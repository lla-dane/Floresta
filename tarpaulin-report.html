<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta","examples","chainstate-builder.rs"],"content":"// SPDX-License-Identifier: MIT\n\n//! In node.rs we created a node that connects to the Bitcoin network and downloads the blockchain.\n//! We use the default chainstate, which starts at genesis and validates all blocks. This is\n//! the simplest way to create a node, but you can also create a node that starts at a given\n//! block, or that doesn't validate all signatures. All customizations are done through the\n//! ChainStateBuilder struct. This example shows how to use it.\nuse bitcoin::blockdata::constants::genesis_block;\nuse bitcoin::hashes::Hash;\nuse bitcoin::BlockHash;\nuse floresta::chain::ChainState;\nuse floresta::chain::KvChainStore;\nuse floresta::chain::Network;\nuse floresta_chain::pruned_utreexo::chain_state_builder::ChainStateBuilder;\nuse floresta_chain::ChainParams;\nuse rustreexo::accumulator::stump::Stump;\n\nconst DATA_DIR: \u0026str = \"./data\";\n\n#[async_std::main]\nasync fn main() {\n    // Create a new chain state, which will store the accumulator and the headers chain.\n    // It will be stored in the DATA_DIR directory. With this chain state, we don't keep\n    // the block data after we validated it. This saves a lot of space, but it means that\n    // we can't serve blocks to other nodes or rescan the blockchain without downloading\n    // it again.\n    let chain_store =\n        KvChainStore::new(DATA_DIR.into()).expect(\"failed to open the blockchain database\");\n\n    // Create a new chain state builder. We can use it to customize the chain state.\n    // Assume valid is the same as in node.rs, it's the block that we assume that all\n    // blocks before it have valid signatures.\n    //\n    // Tip is the block that we consider to be the tip of the chain. If you want to\n    // start the chainstate at a given block, you can use this. If you don't set it,\n    // it will start at genesis.\n    //\n    // We also set the chain params, which are the parameters of the network that we\n    // are connecting to. We use the Bitcoin network here, but you can also use\n    // Testnet, Signet or Regtest.\n    //\n    // Finally, we set the utreexo accumulator. This is the accumulator that we use\n    // to validate the blockchain. If you set the chain height, you should update\n    // the accumulator to the state of the blockchain at that height too.\n    let _chain: ChainState\u003cKvChainStore\u003e = ChainStateBuilder::new()\n        .with_assume_valid(BlockHash::all_zeros())\n        .with_chain_params(ChainParams::from(Network::Bitcoin))\n        .with_tip(\n            (genesis_block(bitcoin::Network::Bitcoin).block_hash(), 0),\n            genesis_block(bitcoin::Network::Bitcoin).header,\n        )\n        .assume_utreexo(Stump::new())\n        .with_chainstore(chain_store)\n        .build()\n        .unwrap();\n\n    // ... If you want to drive the chainstate, you can use the BlockchainInterface trait.\n    // See node.rs for an example on how to do it ...\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta","examples","node.rs"],"content":"// SPDX-License-Identifier: MIT\n\n//! A simple example of a Bitcoin node using the floresta crates. It connects to the Bitcoin\n//! network, downloads the blockchain, and prints the current state of the accumulator.\n//! This will validate all blocks from genesis to the current tip, so it will take a while\n//! to sync.\n\nuse std::str::FromStr;\nuse std::sync::Arc;\n\nuse async_std::sync::RwLock;\nuse bitcoin::BlockHash;\nuse floresta::chain::pruned_utreexo::BlockchainInterface;\nuse floresta::chain::ChainState;\nuse floresta::chain::KvChainStore;\nuse floresta::chain::Network;\nuse floresta::wire::mempool::Mempool;\nuse floresta::wire::node::UtreexoNode;\nuse floresta_chain::AssumeValidArg;\nuse floresta_wire::node_interface::NodeMethods;\nuse floresta_wire::running_node::RunningNode;\nuse floresta_wire::UtreexoNodeConfig;\n\nconst DATA_DIR: \u0026str = \"./data\";\n\n#[async_std::main]\nasync fn main() {\n    // Create a new chain state, which will store the accumulator and the headers chain.\n    // It will be stored in the DATA_DIR directory. With this chain state, we don't keep\n    // the block data after we validated it. This saves a lot of space, but it means that\n    // we can't serve blocks to other nodes or rescan the blockchain without downloading\n    // it again.\n    let chain_store =\n        KvChainStore::new(DATA_DIR.into()).expect(\"failed to open the blockchain database\");\n\n    // The actual chainstate. It will keep track of the current state of the accumulator\n    // and the headers chain. It will also validate new blocks and headers as we receive them.\n    // The last parameter is the assume valid block. We assume that all blocks before this\n    // one have valid signatures. This is a performance optimization, as we don't need to validate all\n    // signatures in the blockchain, just the ones after the assume valid block. We are giving a Disabled\n    // value, so we will validate all signatures regardless.\n    // We place the chain state in an Arc, so we can share it with other components.\n    let chain = Arc::new(ChainState::\u003cKvChainStore\u003e::new(\n        chain_store,\n        Network::Bitcoin,\n        AssumeValidArg::Disabled,\n    ));\n\n    // Create a new node. It will connect to the Bitcoin network and start downloading the blockchain.\n    // It will also start a mempool, which will keep track of the current mempool state, this\n    // particular mempool doesn't store other's transactions, it just keeps track of our own, to\n    // perform broadcast. We always rebroadcast our own transactions every hour.\n    // Note that we are using the RunningNode context, which is a state optimized for a node that\n    // already has the blockchain synced. You don't need to worry about this, because internally\n    // the node will automatically switch to the IBD context and back once it's finished.\n    // If you want a node to IBD only, you can use the IBDNode context.\n    // Finally, we are using the chain state created above, the node will use it to determine\n    // what blocks and headers to download, and hand them to it to validate.\n    let config = UtreexoNodeConfig::default();\n    let p2p: UtreexoNode\u003cRunningNode, Arc\u003cChainState\u003cKvChainStore\u003e\u003e\u003e = UtreexoNode::new(\n        config,\n        chain.clone(),\n        Arc::new(RwLock::new(Mempool::new())),\n        None,\n    );\n    // A handle is a simple way to interact with the node. It implements a queue of requests\n    // that will be processed by the node.\n    let handle = p2p.get_handle();\n\n    let (sender, _receiver) = futures::channel::oneshot::channel();\n\n    // Start the node. This will start the IBD process, and will return once the node is synced.\n    // It will also start the mempool, which will start rebroadcasting our transactions every hour.\n    // The node will keep running until the process is killed, by setting kill_signal to true. In\n    // this example, we don't kill the node, so it will keep running forever.\n    p2p.run(Arc::new(RwLock::new(false)), sender).await;\n\n    // That's it! The node is now running, and will keep running until the process is killed.\n    // You can now use the chain state to query the current state of the accumulator, or the\n    // mempool to query the current state of the mempool. You may also ask the node to grab some\n    // blocks or headers for you, or to send a transaction to the network, rescan the blockchain,\n    // etc. Check the documentation of the node for more information.\n\n    // You can't request blocks or headers from the node until it's synced. You can check if it's\n    // synced by calling the is_in_ibd method.\n    loop {\n        // Wait till the node is synced\n        if !chain.is_in_idb() {\n            break;\n        }\n        // Sleep for 10 seconds, and check again\n        std::thread::sleep(std::time::Duration::from_secs(10));\n    }\n\n    // Here we ask the node to grab the block with the given hash.\n    let block = handle\n        .get_block(\n            BlockHash::from_str(\"000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\")\n                .unwrap(),\n        )\n        .unwrap();\n    println!(\"Block: {:?}\", block);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta","examples","watch-only.rs"],"content":"// SPDX-License-Identifier: MIT\n\n//! This example shows how to create a watch-only wallet, and drive it.\n\nuse bitcoin::consensus::deserialize;\nuse bitcoin::hashes::hex::FromHex;\nuse bitcoin::ScriptBuf;\nuse floresta_common::get_spk_hash;\nuse floresta_watch_only::memory_database::MemoryDatabase;\nuse floresta_watch_only::AddressCache;\nuse miniscript::bitcoin::secp256k1::Secp256k1;\nuse miniscript::Descriptor;\n\nfn main() {\n    // First, we need some place to store the wallet data. Here, we use an in-memory database,\n    // that will be destroyed when the program exits. You can use any database that implements\n    // the `AddressCacheDatabase` trait.\n    let wallet_data = MemoryDatabase::new();\n    // Then, we create the wallet itself.\n    let mut wallet = AddressCache::new(wallet_data);\n    // Now, we need to add the addresses we want to watch. We can add them one by one, or\n    // we can add a descriptor that will generate the addresses for us. Here, we use a\n    // descriptor that generates P2WPKH addresses. The descriptor is parsed using the\n    // `miniscript` library. You can use any descriptor that `miniscript` supports.\n\n    // To parse a descriptor, we need a `Secp256k1` context. This is a wrapper around the\n    // secp256k1 library, that provides some additional functionality. We need it to parse\n    // the descriptor, and to derive the addresses.\n    let secp = Secp256k1::new();\n\n    // We can now parse the descriptor. The `parse_descriptor` function returns a tuple\n    // containing the parsed descriptor, and the map of the keys used in the descriptor.\n    // The keys are indexed by their fingerprint, and the index of the key in the descriptor.\n    let (descriptor, _) = Descriptor::parse_descriptor(\u0026secp, \"wpkh([18940c85/84'/1'/0']tpubDDgpGUUjzTqLqQL9WzPvMDTKyD95AUcwWohMWWoj5kqGU7VLSZ3ju9ZtHRN4ofK6KNaZsTSpB6yGrFuV1V4yVgcwksueuFW3YnKxwoNqb3V/0/*)#0vfhw5fe\").unwrap();\n\n    // We can now add the descriptor to the wallet. This will generate the first 100 addresses\n    // for us, and add them to the wallet.\n    for i in 0..100 {\n        wallet.cache_address(bitcoin::ScriptBuf::from(\n            descriptor\n                .at_derivation_index(i)\n                .unwrap()\n                .explicit_script()\n                .unwrap()\n                .as_bytes()\n                .to_vec(),\n        ));\n    }\n    // We can now process some blocks. Here, we process the first 11 blocks of a custom\n    // regtest network. Each coinbase some of the addresses derived above.\n    for block in BLOCKS.iter() {\n        let block = Vec::from_hex(block).unwrap();\n        let _ = wallet.block_process(\u0026deserialize(\u0026block).unwrap(), 1);\n    }\n    // We can now query the wallet for information about the addresses we added. For example,\n    // we can get the history of the second address, the balance, and the UTXOs. To fetch the\n    // history, we need to know the hash of the address. We can get it using the `get_spk_hash`\n    // function from the `floresta_common` crate. This hash is defined by the Electrum protocol.\n    let hash =\n        get_spk_hash(\u0026ScriptBuf::from_hex(\"00148dae58668d0c15f7ed4f430925634c9a2c666b84\").unwrap());\n\n    // We can now query the wallet for the information we want.\n\n    // Fetch all txids that involve the address.\n    let history = wallet\n        .get_address_history(\u0026hash)\n        .unwrap()\n        .iter()\n        .map(|tx| tx.hash)\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    // Fetch the balance of the address.\n    let balance = wallet.get_address_balance(\u0026hash);\n    // Fetch the UTXOs of the address.\n    let utxos = wallet.get_address_utxos(\u0026hash);\n\n    // We can now print the information we fetched.\n    println!(\"************** Wallet Summary *****************\\n\");\n    println!(\"Descriptor: {}\\n\", descriptor);\n    println!(\"Address #1 hash: {}\\n\", hash);\n    println!(\"History: {:#?}\\n\", history);\n    println!(\"Balance: {:?}\\n\", balance);\n    println!(\"UTXOs: {:#?}\", utxos);\n}\n\nconst BLOCKS: [\u0026str; 11] = [\n    \"0000002006226e46111a0b59caaf126043eb5bbf28c34f3a5e332a1fc7b2b73cf188910f05b917cfbd9c40358ff9a0e64f9da95fd676b8a02a42a32c1c192bd76db60eef20249364ffff7f200300000001020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff03510101ffffffff0200f2052a01000000160014b4ad0d1d8978f3680fa3fc2dfb81b1143a27d4a30000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000\",\n    \"000000201b0abeb75b806f29ee13248bf9c7892672cf80ded985f27fb2f5eb41108bca061e0d3a1c401b2cb5abdc7d1b45da6fa6eb23c7b2ceb82b3c501e15e33d8f30089b309364ffff7f200000000001020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff03520101ffffffff0200f2052a010000001600148dae58668d0c15f7ed4f430925634c9a2c666b840000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000\",\n    \"000000203ed220606ae32337ff45816054bb01a39bfd943ca84daa61c50ad173285f414df345b7d00a902077ef29be75ea0f7b6a4b816d6ad61112865273576fcd3e4b109b309364ffff7f200000000001020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff03530101ffffffff0200f2052a010000001600148dae58668d0c15f7ed4f430925634c9a2c666b840000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000\",\n    \"00000020ba4b379335f3896b025293e6ceeceb865a22093e8550adcca844adfd2afdb00c7482b91566cb4f5c26f917e121699d61bba1926b9dbf43e0fa85fae80649f6889c309364ffff7f200000000001020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff03540101ffffffff0200f2052a010000001600148dae58668d0c15f7ed4f430925634c9a2c666b840000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000\",\n    \"000000208297ce55eed31f7d3fb2cb5b1a5aaeddbc8b4b3133b5623502603a7c1b807477075cf1bb8f9e2f58c63c8ed8b3a085a52a5c982adc6a020994dd59cbe227832d9c309364ffff7f200000000001020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff03550101ffffffff0200f2052a010000001600148dae58668d0c15f7ed4f430925634c9a2c666b840000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000\",\n    \"00000020936b5320b7b346069715fd6ab491b8a29241b5c990b39f50a793c6329b7005671bf190dc397e976064eccff3eca995df63c3f49948fd2889355b935ff42c91de9c309364ffff7f200000000001020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff03560101ffffffff0200f2052a010000001600148dae58668d0c15f7ed4f430925634c9a2c666b840000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000\",\n    \"0000002058217e2ee8e6074c8b26d67b96c9130f0cb52adcced5ba67a30e53a7eacee37caaa4812183e293e93428161f6f89179066124152ca8b1658d66ace5b76aa61849c309364ffff7f200200000001020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff03570101ffffffff0200f2052a010000001600148dae58668d0c15f7ed4f430925634c9a2c666b840000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000\",\n    \"00000020e48e8d22a54e78018591d386fbe5b09d3588756cc541e514074f82aa2596a76400b239f668cb9c5c5809e206754c96a0215a5d7013405ac1b4ad37536400c3649d309364ffff7f200000000001020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff03580101ffffffff0200f2052a010000001600148dae58668d0c15f7ed4f430925634c9a2c666b840000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000\",\n    \"00000020c007dbdee745169560c57367725b69be705b2e2728c6da6313c722309d4a456bce0d0e66ddf0ad519cb91384f1e5038ee3765f31b57781f6eda08678e83e1fcc9f309364ffff7f200100000001020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff03590101ffffffff0200f2052a010000001600148dae58668d0c15f7ed4f430925634c9a2c666b840000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000\",\n    \"000000201096d0268755a324b6b9a1df531877b3f8e161c21261063ba1f1d79d5ba22e5bb386dd8071a9d2a62a2763cc64ceebe85535d4665d7a4f02f18408579874852e9f309364ffff7f200000000001020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff035a0101ffffffff0200f2052a010000001600148dae58668d0c15f7ed4f430925634c9a2c666b840000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000\",\n    \"00000020d0a457ae192831a9dcc1245ed7387c1efc3423bd09d5a306a02772f3ac16827c021a6dbe6981c7e57307533026dc972dd29e5b04d899ba13df355c87cd2797ed9f309364ffff7f200100000001020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff035b0101ffffffff0200f2052a010000001600148dae58668d0c15f7ed4f430925634c9a2c666b840000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000\",\n];\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta","src","lib.rs"],"content":"// SPDX-License-Identifier: MIT\n\n//! Floresta, a collection of crates to build lightweight, fast, and reliable\n//! Bitcoin nodes and wallets, powered by Utreexo, a novel accumulator to represent\n//! the Bitcoin UTXO set.\n//!\n//! This project is layed out as a collection of crates, each implementing one functionality.\n//! They are all named floresta-*. The main crate is floresta, which is a meta-crate\n//! that depends on all the others. It is meant to be used as a dependency in other projects.\n//!\n//! A Bitcoin node is composed of several components. You need some way to express the current\n//! network state, some way to communicate with other nodes, some way to store the blockchain,\n//! validate data you receive and interact with the user.\n//! The current network state (including the accumulator) is tracked by the floresta-chain crate.\n//! It doesn't know where data comes from, it just tracks the state, exposing a simple API to\n//! update it. The chain is reactive, meaning that it will only update when new data is received.\n//!\n//! The floresta-wire crate is responsible for communicating with other nodes. It is a simple\n//! node implementation that can connect to other nodes, send and receive messages, and\n//! handle the peer-to-peer protocol. It is not a full node, it doesn't store the blockchain\n//! or validate data, it just sends and receives messages.\n//!\n//! Floresta also provides a simple watch-only wallet and an electrum server implementation.\n//! They are meant to be used in `florestad`, a full node implementation that uses all the\n//! crates in this project.\n//!\n//! You can find examples of how to use the crates in the examples directory.\n//! # Name\n//! Floresta is the Portuguese word for forest. It is a reference to the Utreexo accumulator,\n//! which is a forest of Merkle trees. It's pronounced /floˈɾɛstɐ/.\n/// Components to build an utreexo-aware, consensus enforcing Bitcoin node.\npub use floresta_chain as chain;\n/// Useful data structures and traits used by the other crates.\npub use floresta_common as common;\n#[cfg(feature = \"electrum-server\")]\n/// An electrum server implementation\npub use floresta_electrum as electrum;\n#[cfg(feature = \"watch-only-wallet\")]\n/// A watch-only wallet implementation, optimized for electrum servers.\npub use floresta_watch_only as wallet;\n/// The transport used to fetch network data.\npub use floresta_wire as wire;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-chain","src","lib.rs"],"content":"// SPDX-License-Identifier: MIT\n//! # Floresta Chain\n//! This crate provides the core validation logic for a full node using libfloresta.\n//! It is maintained as a separate crate to allow other projects to build on it,\n//! independent of the libfloresta P2P network or libfloresta wallet.\n//! The main entry point is the [ChainState] struct, that keeps track of the current\n//! blockchain state, like headers and utreexo accumulator.\n//!\n//! All data is stored in a `ChainStore` implementation, which is generic over the\n//! underlying database. See the ChainStore trait for more information. For a\n//! ready-to-use implementation, see the [KvChainStore] struct.\n#![cfg_attr(any(feature = \"no-std\", not(test)), no_std)]\n\npub mod pruned_utreexo;\npub(crate) use floresta_common::prelude;\npub use pruned_utreexo::chain_state::*;\npub use pruned_utreexo::chainparams::*;\npub use pruned_utreexo::chainstore::*;\npub use pruned_utreexo::error::*;\npub use pruned_utreexo::udata::*;\npub use pruned_utreexo::Notification;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum Network {\n    Bitcoin,\n    Testnet,\n    Regtest,\n    Signet,\n}\nimpl From\u003cbitcoin::network::Network\u003e for Network {\n    fn from(network: bitcoin::network::Network) -\u003e Self {\n        match network {\n            bitcoin::network::Network::Bitcoin =\u003e Network::Bitcoin,\n            bitcoin::network::Network::Testnet =\u003e Network::Testnet,\n            bitcoin::network::Network::Regtest =\u003e Network::Regtest,\n            bitcoin::network::Network::Signet =\u003e Network::Signet,\n            _ =\u003e panic!(\"Unknown network\"),\n        }\n    }\n}\nimpl From\u003cNetwork\u003e for bitcoin::network::Network {\n    fn from(network: Network) -\u003e Self {\n        match network {\n            Network::Bitcoin =\u003e bitcoin::network::Network::Bitcoin,\n            Network::Testnet =\u003e bitcoin::network::Network::Testnet,\n            Network::Regtest =\u003e bitcoin::network::Network::Regtest,\n            Network::Signet =\u003e bitcoin::network::Network::Signet,\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use bitcoin::network::Network as BNetwork;\n\n    use super::*;\n    #[test]\n    fn test_network() {\n        assert_eq!(Network::Bitcoin, BNetwork::Bitcoin.into());\n        assert_eq!(Network::Testnet, BNetwork::Testnet.into());\n        assert_eq!(Network::Regtest, BNetwork::Regtest.into());\n        assert_eq!(Network::Signet, BNetwork::Signet.into());\n    }\n}\n","traces":[{"line":31,"address":[1188816],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":32,"address":[1188823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[22845592],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[1188863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[22845613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[22845606],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[22845590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[1032848],"length":1,"stats":{"Line":4},"fn_name":"from"},{"line":43,"address":[22988055],"length":1,"stats":{"Line":4},"fn_name":null},{"line":44,"address":[1471032],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[1032895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[1032902],"length":1,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[1032909],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":11,"coverable":13},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-chain","src","pruned_utreexo","chain_state.rs"],"content":"extern crate alloc;\n#[cfg(not(feature = \"no-std\"))]\nextern crate std;\n\nuse alloc::borrow::ToOwned;\nuse alloc::fmt::format;\nuse alloc::string::ToString;\nuse alloc::sync::Arc;\nuse alloc::vec::Vec;\nuse core::cell::UnsafeCell;\n#[cfg(feature = \"bitcoinconsensus\")]\nuse core::ffi::c_uint;\n\n#[cfg(feature = \"bitcoinconsensus\")]\nuse bitcoin::bitcoinconsensus;\nuse bitcoin::block::Header as BlockHeader;\nuse bitcoin::blockdata::constants::genesis_block;\nuse bitcoin::consensus::deserialize_partial;\nuse bitcoin::consensus::Decodable;\nuse bitcoin::consensus::Encodable;\nuse bitcoin::hashes::sha256;\nuse bitcoin::hashes::Hash;\nuse bitcoin::p2p::utreexo::UtreexoBlock;\nuse bitcoin::Block;\nuse bitcoin::BlockHash;\nuse bitcoin::OutPoint;\nuse bitcoin::Target;\nuse bitcoin::Transaction;\nuse bitcoin::TxOut;\nuse bitcoin::Work;\nuse floresta_common::Channel;\nuse log::info;\nuse log::trace;\nuse log::warn;\nuse rustreexo::accumulator::node_hash::NodeHash;\nuse rustreexo::accumulator::proof::Proof;\nuse rustreexo::accumulator::stump::Stump;\nuse spin::RwLock;\n\nuse super::chain_state_builder::ChainStateBuilder;\nuse super::chainparams::ChainParams;\nuse super::chainstore::DiskBlockHeader;\nuse super::chainstore::KvChainStore;\nuse super::consensus::Consensus;\nuse super::error::BlockValidationErrors;\nuse super::error::BlockchainError;\nuse super::partial_chain::PartialChainState;\nuse super::partial_chain::PartialChainStateInner;\nuse super::BlockchainInterface;\nuse super::ChainStore;\nuse super::UpdatableChainstate;\nuse crate::prelude::*;\nuse crate::read_lock;\nuse crate::write_lock;\nuse crate::Network;\n\npub trait BlockConsumer: Sync + Send + 'static {\n    fn consume_block(\u0026self, block: \u0026Block, height: u32);\n}\n\nimpl BlockConsumer for Channel\u003c(Block, u32)\u003e {\n    fn consume_block(\u0026self, block: \u0026Block, height: u32) {\n        self.send((block.to_owned(), height));\n    }\n}\n\npub struct ChainStateInner\u003cPersistedState: ChainStore\u003e {\n    /// The acc we use for validation.\n    acc: Stump,\n    /// All data is persisted here.\n    chainstore: PersistedState,\n    /// Best known block, cached in a specific field to faster access.\n    best_block: BestChain,\n    /// When one of our consumers tries to broadcast a transaction, this transaction gets\n    /// writen to broadcast_queue, and the ChainStateBackend can use it's own logic to actually\n    /// broadcast the tx.\n    broadcast_queue: Vec\u003cTransaction\u003e,\n    /// We may have multiple mudules that needs to receive and process blocks as they come, to\n    /// be notified of new blocks, a module should implement the [BlockConsumer] trait, and\n    /// subscribe by passing an [Arc] of itself to chainstate.\n    /// When a new block is accepted (as valid) we call `consume_block` from [BlockConsumer].\n    /// If a mudule just wants pass in a channel, [Sender] implements [BlockConsumer], and can\n    /// be used during subscription (just keep the [Receiver] side.\n    subscribers: Vec\u003cArc\u003cdyn BlockConsumer\u003e\u003e,\n    /// Fee estimation for 1, 10 and 20 blocks\n    fee_estimation: (f64, f64, f64),\n    /// Are we in Initial Block Download?\n    ibd: bool,\n    /// Parameters for the chain and functions that verify the chain.\n    consensus: Consensus,\n    /// Assume valid is a Core-specific config that tells the node to not validate signatures\n    /// in blocks before this one. Note that we only skip signature validation, everything else\n    /// is still validated.\n    assume_valid: Option\u003cBlockHash\u003e,\n}\npub struct ChainState\u003cPersistedState: ChainStore\u003e {\n    inner: RwLock\u003cChainStateInner\u003cPersistedState\u003e\u003e,\n}\n#[derive(Debug, Copy, Clone)]\npub enum AssumeValidArg {\n    Disabled,\n    Hardcoded,\n    UserInput(BlockHash),\n}\n\nimpl\u003cPersistedState: ChainStore\u003e ChainState\u003cPersistedState\u003e {\n    fn maybe_reindex(\u0026self, potential_tip: \u0026DiskBlockHeader) {\n        match potential_tip {\n            DiskBlockHeader::HeadersOnly(_, height) =\u003e {\n                if *height \u003e self.get_best_block().unwrap().0 {\n                    let best_chain = self.reindex_chain();\n                    write_lock!(self).best_block = best_chain;\n                }\n            }\n            DiskBlockHeader::FullyValid(header, _) =\u003e {\n                self.inner.write().best_block.validation_index = header.block_hash();\n            }\n            _ =\u003e {}\n        }\n    }\n\n    /// Just adds headers to the chainstate, without validating them.\n    pub fn push_headers(\n        \u0026self,\n        headers: Vec\u003cBlockHeader\u003e,\n        height: u32,\n    ) -\u003e Result\u003c(), BlockchainError\u003e {\n        let chainstore = \u0026read_lock!(self).chainstore;\n        for (offset, \u0026header) in headers.iter().enumerate() {\n            let block_hash = header.block_hash();\n            let disk_header = DiskBlockHeader::FullyValid(header, height + offset as u32);\n            chainstore.save_header(\u0026disk_header)?;\n            chainstore.update_block_index(height + offset as u32, block_hash)?;\n        }\n        Ok(())\n    }\n    #[cfg(feature = \"bitcoinconsensus\")]\n    /// Returns the validation flags, given the current block height\n    fn get_validation_flags(\u0026self, height: u32) -\u003e c_uint {\n        let chains_params = \u0026read_lock!(self).consensus.parameters;\n        let hash = read_lock!(self)\n            .chainstore\n            .get_block_hash(height)\n            .unwrap()\n            .unwrap();\n        if let Some(flag) = chains_params.exceptions.get(\u0026hash) {\n            return *flag;\n        }\n        // From Bitcoin Core:\n        // BIP16 didn't become active until Apr 1 2012 (on mainnet, and\n        // retroactively applied to testnet)\n        // However, only one historical block violated the P2SH rules (on both\n        // mainnet and testnet).\n        // Similarly, only one historical block violated the TAPROOT rules on\n        // mainnet.\n        // For simplicity, always leave P2SH+WITNESS+TAPROOT on except for the two\n        // violating blocks.\n        let mut flags = bitcoinconsensus::VERIFY_P2SH | bitcoinconsensus::VERIFY_WITNESS;\n\n        if height \u003e= chains_params.bip65_activation_height {\n            flags |= bitcoinconsensus::VERIFY_CHECKLOCKTIMEVERIFY;\n        }\n        if height \u003e= chains_params.bip66_activation_height {\n            flags |= bitcoinconsensus::VERIFY_DERSIG;\n        }\n        if height \u003e= chains_params.csv_activation_height {\n            flags |= bitcoinconsensus::VERIFY_CHECKSEQUENCEVERIFY;\n        }\n        if height \u003e= chains_params.segwit_activation_height {\n            flags |= bitcoinconsensus::VERIFY_NULLDUMMY;\n        }\n        flags\n    }\n\n    fn update_header(\u0026self, header: \u0026DiskBlockHeader) -\u003e Result\u003c(), BlockchainError\u003e {\n        Ok(read_lock!(self).chainstore.save_header(header)?)\n    }\n    fn validate_header(\u0026self, block_header: \u0026BlockHeader) -\u003e Result\u003cBlockHash, BlockchainError\u003e {\n        let prev_block = self.get_disk_block_header(\u0026block_header.prev_blockhash)?;\n        let prev_block_height = prev_block.height();\n        if prev_block_height.is_none() {\n            return Err(BlockValidationErrors::BlockExtendsAnOrphanChain.into());\n        }\n        let height = prev_block_height.unwrap() + 1;\n\n        // Check pow\n        let expected_target = self.get_next_required_work(\u0026prev_block, height, block_header);\n\n        let actual_target = block_header.target();\n        if actual_target \u003e expected_target {\n            return Err(BlockValidationErrors::NotEnoughPow.into());\n        }\n\n        let block_hash = block_header\n            .validate_pow(actual_target)\n            .map_err(|_| BlockchainError::BlockValidation(BlockValidationErrors::NotEnoughPow))?;\n        Ok(block_hash)\n    }\n\n    #[inline]\n    /// Whether a node is the genesis block for this net\n    fn is_genesis(\u0026self, header: \u0026BlockHeader) -\u003e bool {\n        header.block_hash() == self.chain_params().genesis.block_hash()\n    }\n    #[inline]\n    /// Returns the ancestor of a given block\n    fn get_ancestor(\u0026self, header: \u0026BlockHeader) -\u003e Result\u003cDiskBlockHeader, BlockchainError\u003e {\n        self.get_disk_block_header(\u0026header.prev_blockhash)\n    }\n    /// Returns the cumulative work in this branch\n    fn get_branch_work(\u0026self, header: \u0026BlockHeader) -\u003e Result\u003cWork, BlockchainError\u003e {\n        let mut header = *header;\n        let mut work = Work::from_be_bytes([0; 32]);\n        while !self.is_genesis(\u0026header) {\n            work = work + header.work();\n            header = *self.get_ancestor(\u0026header)?;\n        }\n\n        Ok(work)\n    }\n    /// Checks if a branch is valid (i.e. all ancestors are known)\n    fn check_branch(\u0026self, branch_tip: \u0026BlockHeader) -\u003e Result\u003c(), BlockchainError\u003e {\n        let mut header = *branch_tip;\n\n        while !self.is_genesis(\u0026header) {\n            let _header = self.get_ancestor(\u0026header)?;\n            if let DiskBlockHeader::Orphan(block) = _header {\n                return Err(BlockchainError::InvalidTip(format(format_args!(\n                    \"Block {} doesn't have a known ancestor (i.e an orphan block)\",\n                    block.block_hash()\n                ))));\n            }\n            header = *_header;\n        }\n\n        Ok(())\n    }\n    /// Returns the depth of a branch (i.e. how many blocks are in the branch)\n    fn get_chain_depth(\u0026self, branch_tip: \u0026BlockHeader) -\u003e Result\u003cu32, BlockchainError\u003e {\n        let mut header = *branch_tip;\n\n        let mut counter = 0;\n        while !self.is_genesis(\u0026header) {\n            header = *self.get_ancestor(\u0026header)?;\n            counter += 1;\n        }\n\n        Ok(counter)\n    }\n    /// Mark the current index as active, because we are in the middle of a reorg\n    fn mark_chain_as_active(\n        \u0026self,\n        new_tip: \u0026BlockHeader,\n        fork_point: BlockHash,\n    ) -\u003e Result\u003c(), BlockchainError\u003e {\n        let mut height = self.get_chain_depth(new_tip)?;\n        let mut header = DiskBlockHeader::HeadersOnly(*new_tip, height);\n\n        let inner = read_lock!(self);\n\n        while !self.is_genesis(\u0026header) || header.block_hash() == fork_point {\n            inner\n                .chainstore\n                .update_block_index(height, header.block_hash())?;\n            let new_header = DiskBlockHeader::HeadersOnly(*header, height);\n            inner.chainstore.save_header(\u0026new_header)?;\n            header = self.get_ancestor(\u0026header)?;\n            height -= 1;\n        }\n        Ok(())\n    }\n    /// Mark the current index as inactive, either because we found an invalid ancestor,\n    /// or we are in the middle of reorg\n    fn mark_chain_as_inactive(\n        \u0026self,\n        old_tip: \u0026BlockHeader,\n        fork_point: BlockHash,\n    ) -\u003e Result\u003c(), BlockchainError\u003e {\n        let mut header = *old_tip;\n        let mut height = self.get_chain_depth(old_tip)?;\n\n        let inner = read_lock!(self);\n        while !self.is_genesis(\u0026header) || header.block_hash() == fork_point {\n            let new_header = DiskBlockHeader::InFork(header, height);\n            inner.chainstore.save_header(\u0026new_header)?;\n            header = *self.get_ancestor(\u0026header)?;\n            height -= 1;\n        }\n\n        Ok(())\n    }\n    /// Finds where in the current index, a given branch forks out.\n    fn find_fork_point(\u0026self, header: \u0026BlockHeader) -\u003e Result\u003cBlockHeader, BlockchainError\u003e {\n        let mut header = *self.get_ancestor(header)?;\n        let inner = read_lock!(self);\n        while !self.is_genesis(\u0026header) {\n            match inner.chainstore.get_header(\u0026header.block_hash())? {\n                Some(DiskBlockHeader::HeadersOnly(block, _)) =\u003e {\n                    return Ok(block);\n                }\n                Some(DiskBlockHeader::FullyValid(block, _)) =\u003e {\n                    return Ok(block);\n                }\n                Some(DiskBlockHeader::InFork(block, _)) =\u003e {\n                    header = *self.get_ancestor(\u0026block)?;\n                    continue;\n                }\n                Some(DiskBlockHeader::AssumedValid(block, _)) =\u003e {\n                    return Ok(block);\n                }\n                Some(DiskBlockHeader::Orphan(header)) =\u003e {\n                    return Err(BlockchainError::InvalidTip(format(format_args!(\n                        \"Block {} doesn't have a known ancestor (i.e an orphan block)\",\n                        header.block_hash()\n                    ))));\n                }\n                Some(DiskBlockHeader::InvalidChain(header)) =\u003e {\n                    return Err(BlockchainError::InvalidTip(format(format_args!(\n                        \"Block {} is invalid\",\n                        header.block_hash()\n                    ))));\n                }\n                None =\u003e {\n                    return Err(BlockchainError::InvalidTip(format(format_args!(\n                        \"Block {} isn't in our storage\",\n                        header.block_hash()\n                    ))));\n                }\n            }\n        }\n        Err(BlockchainError::InvalidTip(\n            \"Couldn't find a fork point\".to_string(),\n        ))\n    }\n    // This method should only be called after we validate the new branch\n    fn reorg(\u0026self, new_tip: BlockHeader) -\u003e Result\u003c(), BlockchainError\u003e {\n        let current_best_block = self.get_best_block().unwrap().1;\n        let current_best_block = self.get_block_header(\u0026current_best_block)?;\n        let fork_point = self.find_fork_point(\u0026new_tip)?;\n\n        self.mark_chain_as_inactive(\u0026current_best_block, fork_point.block_hash())?;\n        self.mark_chain_as_active(\u0026new_tip, fork_point.block_hash())?;\n\n        let validation_index = self.get_last_valid_block(\u0026new_tip)?;\n        let depth = self.get_chain_depth(\u0026new_tip)?;\n        self.change_active_chain(\u0026new_tip, validation_index, depth);\n\n        Ok(())\n    }\n    /// Changes the active chain to the new branch during a reorg\n    fn change_active_chain(\u0026self, new_tip: \u0026BlockHeader, last_valid: BlockHash, depth: u32) {\n        let mut inner = self.inner.write();\n        inner.best_block.best_block = new_tip.block_hash();\n        inner.best_block.validation_index = last_valid;\n        inner.best_block.depth = depth;\n        inner.acc = Stump::new();\n    }\n    /// Grabs the last block we validated in this branch. We don't validate a fork, unless it\n    /// becomes the best chain. This function technically finds out what is the last common block\n    /// between two branches.\n    fn get_last_valid_block(\u0026self, header: \u0026BlockHeader) -\u003e Result\u003cBlockHash, BlockchainError\u003e {\n        let mut header = *header;\n\n        while !self.is_genesis(\u0026header) {\n            let _header = self.get_ancestor(\u0026header)?;\n            match _header {\n                DiskBlockHeader::FullyValid(_, _) | DiskBlockHeader::AssumedValid(_, _) =\u003e {\n                    return Ok(header.block_hash())\n                }\n                DiskBlockHeader::Orphan(_) =\u003e {\n                    return Err(BlockchainError::InvalidTip(format(format_args!(\n                        \"Block {} doesn't have a known ancestor (i.e an orphan block)\",\n                        header.block_hash()\n                    ))))\n                }\n                DiskBlockHeader::HeadersOnly(_, _) | DiskBlockHeader::InFork(_, _) =\u003e {}\n                DiskBlockHeader::InvalidChain(_) =\u003e {\n                    return Err(BlockchainError::InvalidTip(format(format_args!(\n                        \"Block {} is in an invalid chain\",\n                        header.block_hash()\n                    ))))\n                }\n            }\n\n            header = *_header;\n        }\n        Ok(header.block_hash())\n    }\n    /// If we get a header that doesn't build on top of our best chain, it may cause a reorganization.\n    /// We check this here.\n    fn maybe_reorg(\u0026self, branch_tip: BlockHeader) -\u003e Result\u003c(), BlockchainError\u003e {\n        let current_tip = self.get_block_header(\u0026self.get_best_block().unwrap().1)?;\n        self.check_branch(\u0026branch_tip)?;\n\n        let current_work = self.get_branch_work(\u0026current_tip)?;\n        let new_work = self.get_branch_work(\u0026branch_tip)?;\n        // If the new branch has more work, it becomes the new best chain\n        if new_work \u003e current_work {\n            self.reorg(branch_tip)?;\n            return Ok(());\n        }\n        // If the new branch has less work, we just store it as an alternative branch\n        // that might become the best chain in the future.\n        self.push_alt_tip(\u0026branch_tip)?;\n        let parent_height = self.get_ancestor(\u0026branch_tip)?.height().unwrap();\n        read_lock!(self)\n            .chainstore\n            .save_header(\u0026super::chainstore::DiskBlockHeader::InFork(\n                branch_tip,\n                parent_height + 1,\n            ))?;\n        Ok(())\n    }\n    /// Stores a new tip for a branch that is not the best one\n    fn push_alt_tip(\u0026self, branch_tip: \u0026BlockHeader) -\u003e Result\u003c(), BlockchainError\u003e {\n        let ancestor = self.get_ancestor(branch_tip);\n        let ancestor = match ancestor {\n            Ok(ancestor) =\u003e Some(ancestor),\n            Err(BlockchainError::BlockNotPresent) =\u003e None,\n            Err(e) =\u003e return Err(e),\n        };\n        let mut inner = write_lock!(self);\n        if let Some(ancestor) = ancestor {\n            let ancestor_hash = ancestor.block_hash();\n            if let Some(idx) = inner\n                .best_block\n                .alternative_tips\n                .iter()\n                .position(|hash| ancestor_hash == *hash)\n            {\n                inner.best_block.alternative_tips.remove(idx);\n            }\n        }\n        inner\n            .best_block\n            .alternative_tips\n            .push(branch_tip.block_hash());\n        Ok(())\n    }\n\n    /// Returns the chain_params struct for the current network\n    fn chain_params(\u0026self) -\u003e ChainParams {\n        let inner = read_lock!(self);\n        // We clone the parameters here, because we don't want to hold the lock for too long\n        inner.consensus.parameters.clone()\n    }\n    // This function should be only called if a block is guaranteed to be on chain\n    fn get_block_header_by_height(\u0026self, height: u32) -\u003e BlockHeader {\n        let block = self\n            .get_block_hash(height)\n            .expect(\"This block should be present\");\n        self.get_block_header(\u0026block)\n            .expect(\"This block should also be present\")\n    }\n    fn save_acc(\u0026self) -\u003e Result\u003c(), bitcoin::consensus::encode::Error\u003e {\n        let inner = read_lock!(self);\n        let mut ser_acc: Vec\u003cu8\u003e = Vec::new();\n        inner.acc.leaves.consensus_encode(\u0026mut ser_acc)?;\n        #[allow(clippy::significant_drop_in_scrutinee)]\n        for root in inner.acc.roots.iter() {\n            ser_acc\n                .write_all(\u0026**root)\n                .expect(\"String formatting should not err\");\n        }\n\n        inner\n            .chainstore\n            .save_roots(ser_acc)\n            .expect(\"Chain store is not working\");\n        Ok(())\n    }\n    #[allow(clippy::await_holding_lock)]\n    fn notify(\u0026self, block: \u0026Block, height: u32) {\n        let inner = self.inner.read();\n        let subs = inner.subscribers.iter();\n        for client in subs {\n            client.consume_block(block, height);\n        }\n    }\n\n    pub fn new(\n        chainstore: PersistedState,\n        network: Network,\n        assume_valid: AssumeValidArg,\n    ) -\u003e ChainState\u003cPersistedState\u003e {\n        let genesis = genesis_block(network.into());\n        chainstore\n            .save_header(\u0026super::chainstore::DiskBlockHeader::FullyValid(\n                genesis.header,\n                0,\n            ))\n            .expect(\"Error while saving genesis\");\n        chainstore\n            .update_block_index(0, genesis.block_hash())\n            .expect(\"Error updating index\");\n\n        let assume_valid = Self::get_assume_valid_value(network, assume_valid);\n        ChainState {\n            inner: RwLock::new(ChainStateInner {\n                chainstore,\n                acc: Stump::new(),\n                best_block: BestChain {\n                    best_block: genesis.block_hash(),\n                    depth: 0,\n                    validation_index: genesis.block_hash(),\n                    rescan_index: None,\n                    alternative_tips: Vec::new(),\n                    assume_valid_index: 0,\n                },\n                broadcast_queue: Vec::new(),\n                subscribers: Vec::new(),\n                fee_estimation: (1_f64, 1_f64, 1_f64),\n                ibd: true,\n                consensus: Consensus {\n                    parameters: network.into(),\n                },\n                assume_valid,\n            }),\n        }\n    }\n    fn get_assume_valid_value(network: Network, arg: AssumeValidArg) -\u003e Option\u003cBlockHash\u003e {\n        fn get_hash(hash: \u0026str) -\u003e BlockHash {\n            BlockHash::from_str(hash).expect(\"hardcoded hash should not fail\")\n        }\n        match arg {\n            AssumeValidArg::Disabled =\u003e None,\n            AssumeValidArg::UserInput(hash) =\u003e Some(hash),\n            AssumeValidArg::Hardcoded =\u003e match network {\n                Network::Bitcoin =\u003e {\n                    get_hash(\"00000000000000000009c97098b5295f7e5f183ac811fb5d1534040adb93cabd\")\n                        .into()\n                }\n                Network::Testnet =\u003e {\n                    get_hash(\"0000000000000004877fa2d36316398528de4f347df2f8a96f76613a298ce060\")\n                        .into()\n                }\n                Network::Signet =\u003e {\n                    get_hash(\"0000004f401bac79fe6cb3a10ef367b071e0fb51a1c9f4b3e8484e4dd03e1863\")\n                        .into()\n                }\n                Network::Regtest =\u003e {\n                    get_hash(\"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\")\n                        .into()\n                }\n            },\n        }\n    }\n    fn get_disk_block_header(\u0026self, hash: \u0026BlockHash) -\u003e Result\u003cDiskBlockHeader, BlockchainError\u003e {\n        let inner = read_lock!(self);\n        if let Some(header) = inner.chainstore.get_header(hash)? {\n            return Ok(header);\n        }\n        Err(BlockchainError::BlockNotPresent)\n    }\n    /// If we ever find ourselves in an undefined state, with one of our chain pointers\n    /// pointing to an invalid block, we'll find out what blocks do we have, and start from this\n    /// point.\n    fn reindex_chain(\u0026self) -\u003e BestChain {\n        let get_disk_block_hash =\n            |height: u32| -\u003e Result\u003cOption\u003cBlockHash\u003e, PersistedState::Error\u003e {\n                read_lock!(self).chainstore.get_block_hash(height)\n            };\n\n        warn!(\"reindexing our chain\");\n        let mut best_block = get_disk_block_hash(0).expect(\"No genesis block\").unwrap();\n        let mut depth = 0;\n        let mut validation_index = best_block;\n        let mut next_height = depth + 1;\n\n        // Iteratively fetch the disk header given the next height\n        while let Ok(Some(block_hash)) = get_disk_block_hash(next_height) {\n            match self.get_disk_block_header(\u0026block_hash) {\n                Ok(DiskBlockHeader::FullyValid(_, height)) =\u003e {\n                    assert_eq!(height, next_height);\n                    validation_index = block_hash;\n                }\n                Ok(DiskBlockHeader::HeadersOnly(_, height)) =\u003e {\n                    assert_eq!(height, next_height);\n                }\n                _ =\u003e break,\n            }\n            best_block = block_hash;\n            depth = next_height;\n            next_height += 1;\n        }\n        BestChain {\n            best_block,\n            depth,\n            validation_index,\n            rescan_index: None,\n            alternative_tips: Vec::new(),\n            assume_valid_index: 0,\n        }\n    }\n    pub fn load_chain_state(\n        chainstore: KvChainStore,\n        network: Network,\n        assume_valid: AssumeValidArg,\n    ) -\u003e Result\u003cChainState\u003cKvChainStore\u003e, BlockchainError\u003e {\n        let acc = Self::load_acc(\u0026chainstore);\n\n        let best_chain = chainstore.load_height()?;\n        if best_chain.is_none() {\n            return Err(BlockchainError::ChainNotInitialized);\n        }\n        let inner = ChainStateInner {\n            acc,\n            best_block: best_chain.unwrap(),\n            broadcast_queue: Vec::new(),\n            chainstore,\n            fee_estimation: (1_f64, 1_f64, 1_f64),\n            subscribers: Vec::new(),\n            ibd: true,\n            consensus: Consensus {\n                parameters: network.into(),\n            },\n            assume_valid: Self::get_assume_valid_value(network, assume_valid),\n        };\n        info!(\n            \"Chainstate loaded at height: {}, checking if we have all blocks\",\n            inner.best_block.best_block\n        );\n        let chainstate = ChainState {\n            inner: RwLock::new(inner),\n        };\n        // Check the integrity of our chain\n        chainstate.check_chain_integrity();\n        Ok(chainstate)\n    }\n\n    fn check_chain_integrity(\u0026self) {\n        let best_height = self.get_best_block().expect(\"should have this loaded\").0;\n        for height in 0..=best_height {\n            let Ok(hash) = self.get_block_hash(height) else {\n                self.reindex_chain();\n                return;\n            };\n            match self.get_disk_block_header(\u0026hash) {\n                Ok(DiskBlockHeader::FullyValid(_, _)) =\u003e continue,\n                Ok(DiskBlockHeader::HeadersOnly(_, _)) =\u003e continue,\n\n                _ =\u003e {\n                    warn!(\"our chain is corrupted, reindexing\");\n                    self.reindex_chain();\n                }\n            }\n        }\n    }\n    fn load_acc\u003cStorage: ChainStore\u003e(data_storage: \u0026Storage) -\u003e Stump {\n        let acc = data_storage\n            .load_roots()\n            .expect(\"load_acc: Could not read roots\");\n        if acc.is_none() {\n            return Stump::new();\n        }\n        let mut acc = acc.unwrap();\n        let leaves = acc.drain(0..8).collect::\u003cVec\u003cu8\u003e\u003e();\n        let (leaves, _) =\n            deserialize_partial::\u003cu64\u003e(\u0026leaves).expect(\"load_acc: Invalid num_leaves\");\n        let mut roots = Vec::new();\n        while acc.len() \u003e= 32 {\n            // Since we only expect hashes after the num_leaves, it should always align with 32 bytes\n            assert_eq!(acc.len() % 32, 0);\n            let root = acc.drain(0..32).collect::\u003cVec\u003cu8\u003e\u003e();\n            let root = NodeHash::from(\u0026*root);\n            roots.push(root);\n        }\n        Stump { leaves, roots }\n    }\n    fn update_view(\n        \u0026self,\n        height: u32,\n        block: \u0026BlockHeader,\n        acc: Stump,\n    ) -\u003e Result\u003c(), BlockchainError\u003e {\n        let mut inner = write_lock!(self);\n        inner\n            .chainstore\n            .save_header(\u0026super::chainstore::DiskBlockHeader::FullyValid(\n                *block, height,\n            ))?;\n        inner\n            .chainstore\n            .update_block_index(height, block.block_hash())?;\n        // Updates our local view of the network\n        inner.acc = acc;\n        inner.best_block.valid_block(block.block_hash());\n        Ok(())\n    }\n    fn update_tip(\u0026self, best_block: BlockHash, height: u32) {\n        let mut inner = write_lock!(self);\n        inner.best_block.best_block = best_block;\n        inner.best_block.depth = height;\n    }\n    fn verify_script(\u0026self, height: u32) -\u003e bool {\n        let inner = self.inner.read();\n\n        inner.assume_valid.map_or(true, |hash| {\n            match inner.chainstore.get_header(\u0026hash).unwrap() {\n                // If the assume-valid block is in the best chain, only verify scripts if we are higher\n                Some(DiskBlockHeader::HeadersOnly(_, assume_h))\n                | Some(DiskBlockHeader::FullyValid(_, assume_h)) =\u003e height \u003e assume_h,\n                // Assume-valid is not in the best chain, so verify all the scripts\n                _ =\u003e true,\n            }\n        })\n    }\n    pub fn acc(\u0026self) -\u003e Stump {\n        read_lock!(self).acc.to_owned()\n    }\n    /// Returns the next required work for the next block, usually it's just the last block's target\n    /// but if we are in a retarget period, it's calculated from the last 2016 blocks.\n    fn get_next_required_work(\n        \u0026self,\n        last_block: \u0026BlockHeader,\n        next_height: u32,\n        next_header: \u0026BlockHeader,\n    ) -\u003e Target {\n        let params: ChainParams = self.chain_params();\n        // Special testnet rule, if a block takes more than 20 minutes to mine, we can\n        // mine a block with diff 1\n        if params.pow_allow_min_diff\n            \u0026\u0026 last_block.time + params.pow_target_spacing as u32 * 2 \u003c next_header.time\n        {\n            return params.max_target;\n        }\n        // Regtest don't have retarget\n        if !params.pow_allow_no_retarget \u0026\u0026 (next_height) % 2016 == 0 {\n            // First block in this epoch\n            let first_block = self.get_block_header_by_height(next_height - 2016);\n            let last_block = self.get_block_header_by_height(next_height - 1);\n\n            let target =\n                Consensus::calc_next_work_required(\u0026last_block, \u0026first_block, self.chain_params());\n            if target \u003c params.max_target {\n                return target;\n            }\n            return params.max_target;\n        }\n        last_block.target()\n    }\n    fn validate_block(\n        \u0026self,\n        block: \u0026Block,\n        height: u32,\n        inputs: HashMap\u003cOutPoint, TxOut\u003e,\n    ) -\u003e Result\u003c(), BlockchainError\u003e {\n        if !block.check_merkle_root() {\n            return Err(BlockchainError::BlockValidation(\n                BlockValidationErrors::BadMerkleRoot,\n            ));\n        }\n        if height \u003e= self.chain_params().bip34_activation_height\n            \u0026\u0026 block.bip34_block_height() != Ok(height as u64)\n        {\n            return Err(BlockchainError::BlockValidation(\n                BlockValidationErrors::BadBip34,\n            ));\n        }\n        if !block.check_witness_commitment() {\n            return Err(BlockchainError::BlockValidation(\n                BlockValidationErrors::BadWitnessCommitment,\n            ));\n        }\n\n        // Validate block transactions\n        let subsidy = read_lock!(self).consensus.get_subsidy(height);\n        let verify_script = self.verify_script(height);\n        #[cfg(feature = \"bitcoinconsensus\")]\n        let flags = self.get_validation_flags(height);\n        #[cfg(not(feature = \"bitcoinconsensus\"))]\n        let flags = 0;\n        Consensus::verify_block_transactions(inputs, \u0026block.txdata, subsidy, verify_script, flags)?;\n        Ok(())\n    }\n}\n\nimpl\u003cPersistedState: ChainStore\u003e BlockchainInterface for ChainState\u003cPersistedState\u003e {\n    type Error = BlockchainError;\n\n    fn get_fork_point(\u0026self, block: BlockHash) -\u003e Result\u003cBlockHash, Self::Error\u003e {\n        let fork_point = self.find_fork_point(\u0026self.get_block_header(\u0026block)?)?;\n        Ok(fork_point.block_hash())\n    }\n\n    fn update_acc(\n        \u0026self,\n        acc: Stump,\n        block: UtreexoBlock,\n        height: u32,\n        proof: Proof,\n        del_hashes: Vec\u003csha256::Hash\u003e,\n    ) -\u003e Result\u003cStump, Self::Error\u003e {\n        Consensus::update_acc(\u0026acc, \u0026block.block, height, proof, del_hashes)\n    }\n\n    fn get_chain_tips(\u0026self) -\u003e Result\u003cVec\u003cBlockHash\u003e, Self::Error\u003e {\n        let inner = read_lock!(self);\n        let mut tips = Vec::new();\n\n        tips.push(inner.best_block.best_block);\n        tips.extend(inner.best_block.alternative_tips.iter());\n\n        Ok(tips)\n    }\n\n    fn validate_block(\n        \u0026self,\n        block: \u0026Block,\n        proof: Proof,\n        inputs: HashMap\u003cOutPoint, TxOut\u003e,\n        del_hashes: Vec\u003csha256::Hash\u003e,\n        acc: Stump,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        // verify the proof\n        let del_hashes = del_hashes\n            .iter()\n            .map(|hash| NodeHash::from(hash.as_byte_array()))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        if !acc.verify(\u0026proof, \u0026del_hashes)? {\n            return Err(BlockValidationErrors::InvalidProof.into());\n        }\n\n        let height = self\n            .get_block_height(\u0026block.block_hash())?\n            .ok_or(BlockchainError::BlockNotPresent)?;\n\n        self.validate_block(block, height, inputs)\n    }\n\n    fn get_block_locator_for_tip(\u0026self, tip: BlockHash) -\u003e Result\u003cVec\u003cBlockHash\u003e, BlockchainError\u003e {\n        let mut hashes = Vec::new();\n        let height = self\n            .get_disk_block_header(\u0026tip)?\n            .height()\n            .ok_or(BlockchainError::BlockNotPresent)?;\n\n        let mut index = height;\n        let mut current_height = height;\n        let mut current_header = self.get_disk_block_header(\u0026tip)?;\n        let mut step = 1;\n\n        while index \u003e 0 {\n            while current_height \u003e index {\n                current_header = self.get_ancestor(\u0026current_header)?;\n                current_height -= 1;\n            }\n\n            if hashes.len() \u003e= 10 {\n                step *= 2;\n            }\n\n            hashes.push(current_header.block_hash());\n\n            if index \u003e step {\n                index -= step;\n            } else {\n                break;\n            }\n        }\n\n        // genesis\n        hashes.push(self.get_block_hash(0).unwrap());\n        Ok(hashes)\n    }\n\n    fn is_in_idb(\u0026self) -\u003e bool {\n        self.inner.read().ibd\n    }\n\n    fn get_block_height(\u0026self, hash: \u0026BlockHash) -\u003e Result\u003cOption\u003cu32\u003e, Self::Error\u003e {\n        self.get_disk_block_header(hash)\n            .map(|header| header.height())\n    }\n\n    fn get_block_hash(\u0026self, height: u32) -\u003e Result\u003cbitcoin::BlockHash, Self::Error\u003e {\n        let inner = self.inner.read();\n        if let Some(hash) = inner.chainstore.get_block_hash(height)? {\n            return Ok(hash);\n        }\n        Err(BlockchainError::BlockNotPresent)\n    }\n\n    fn get_tx(\u0026self, _txid: \u0026bitcoin::Txid) -\u003e Result\u003cOption\u003cbitcoin::Transaction\u003e, Self::Error\u003e {\n        unimplemented!(\"This chainstate doesn't hold any tx\")\n    }\n\n    fn get_height(\u0026self) -\u003e Result\u003cu32, Self::Error\u003e {\n        let inner = read_lock!(self);\n        Ok(inner.best_block.depth)\n    }\n\n    fn broadcast(\u0026self, tx: \u0026bitcoin::Transaction) -\u003e Result\u003c(), Self::Error\u003e {\n        let mut inner = write_lock!(self);\n        inner.broadcast_queue.push(tx.clone());\n        Ok(())\n    }\n\n    fn estimate_fee(\u0026self, target: usize) -\u003e Result\u003cf64, Self::Error\u003e {\n        let inner = read_lock!(self);\n        if target == 1 {\n            Ok(inner.fee_estimation.0)\n        } else if target == 10 {\n            Ok(inner.fee_estimation.1)\n        } else {\n            Ok(inner.fee_estimation.2)\n        }\n    }\n\n    fn get_block(\u0026self, _hash: \u0026BlockHash) -\u003e Result\u003cbitcoin::Block, Self::Error\u003e {\n        unimplemented!(\"This chainstate doesn't hold full blocks\")\n    }\n\n    fn get_best_block(\u0026self) -\u003e Result\u003c(u32, BlockHash), Self::Error\u003e {\n        let inner = read_lock!(self);\n        Ok((inner.best_block.depth, inner.best_block.best_block))\n    }\n\n    fn get_block_header(\u0026self, hash: \u0026BlockHash) -\u003e Result\u003cbitcoin::block::Header, Self::Error\u003e {\n        let inner = read_lock!(self);\n        if let Some(header) = inner.chainstore.get_header(hash)? {\n            return Ok(*header);\n        }\n        Err(BlockchainError::BlockNotPresent)\n    }\n    fn get_rescan_index(\u0026self) -\u003e Option\u003cu32\u003e {\n        read_lock!(self).best_block.rescan_index\n    }\n    fn rescan(\u0026self, start_height: u32) -\u003e Result\u003c(), Self::Error\u003e {\n        let mut inner = write_lock!(self);\n        info!(\"Rescanning from block {start_height}\");\n        inner.best_block.rescan_index = Some(start_height);\n        Ok(())\n    }\n    fn subscribe(\u0026self, tx: Arc\u003cdyn BlockConsumer\u003e) {\n        let mut inner = self.inner.write();\n        inner.subscribers.push(tx);\n    }\n    fn get_block_locator(\u0026self) -\u003e Result\u003cVec\u003cBlockHash\u003e, BlockchainError\u003e {\n        let top_height = self.get_height()?;\n        let mut indexes = Vec::new();\n        let mut step = 1;\n        let mut index = top_height;\n        while index \u003e 0 {\n            if indexes.len() \u003e= 10 {\n                step *= 2;\n            }\n            indexes.push(index);\n            if index \u003e step {\n                index -= step;\n            } else {\n                break;\n            }\n        }\n        indexes.push(0);\n        let hashes = indexes\n            .iter()\n            .flat_map(|idx| self.get_block_hash(*idx))\n            .collect();\n\n        Ok(hashes)\n    }\n    fn get_validation_index(\u0026self) -\u003e Result\u003cu32, Self::Error\u003e {\n        let inner = self.inner.read();\n        let validation = inner.best_block.validation_index;\n        let header = self.get_disk_block_header(\u0026validation)?;\n        // The last validated disk header can only be FullyValid\n        if let DiskBlockHeader::FullyValid(_, height) = header {\n            Ok(height)\n        } else {\n            unreachable!(\"Validation index is in an invalid state, you should re-index your node\")\n        }\n    }\n\n    fn is_coinbase_mature(\u0026self, height: u32, block: BlockHash) -\u003e Result\u003cbool, Self::Error\u003e {\n        let chain_params = self.chain_params();\n        let current_height = self.get_disk_block_header(\u0026block)?.height().unwrap_or(0);\n\n        Ok(height + chain_params.coinbase_maturity \u003c= current_height)\n    }\n\n    fn get_unbroadcasted(\u0026self) -\u003e Vec\u003cTransaction\u003e {\n        let mut inner = write_lock!(self);\n        inner.broadcast_queue.drain(..).collect()\n    }\n}\nimpl\u003cPersistedState: ChainStore\u003e UpdatableChainstate for ChainState\u003cPersistedState\u003e {\n    fn switch_chain(\u0026self, new_tip: BlockHash) -\u003e Result\u003c(), BlockchainError\u003e {\n        let new_tip = self.get_block_header(\u0026new_tip)?;\n        self.reorg(new_tip)\n    }\n\n    fn mark_block_as_valid(\u0026self, block: BlockHash) -\u003e Result\u003c(), BlockchainError\u003e {\n        let header = self.get_disk_block_header(\u0026block)?;\n        let height = header.height().unwrap();\n        let new_header = DiskBlockHeader::FullyValid(*header, height);\n        self.update_header(\u0026new_header)\n    }\n\n    fn mark_chain_as_assumed(\u0026self, acc: Stump) -\u003e Result\u003cbool, BlockchainError\u003e {\n        let assumed_hash = self.get_best_block()?.1;\n\n        let mut curr_header = self.get_block_header(\u0026assumed_hash)?;\n\n        // The assumeutreexo value passed is inside our main chain, start from that point\n        while let Ok(header) = self.get_disk_block_header(\u0026curr_header.block_hash()) {\n            // We've reached genesis and didn't our block\n            if self.is_genesis(\u0026header) {\n                break;\n            }\n            self.update_header(\u0026DiskBlockHeader::FullyValid(\n                *header,\n                header.height().unwrap(),\n            ))?;\n            curr_header = *self.get_ancestor(\u0026header)?;\n        }\n\n        let mut guard = write_lock!(self);\n        guard.best_block.validation_index = assumed_hash;\n        guard.best_block.rescan_index = None;\n        info!(\"assuming chain with hash={assumed_hash}\");\n        guard.acc = acc;\n\n        Ok(true)\n    }\n\n    fn invalidate_block(\u0026self, block: BlockHash) -\u003e Result\u003c(), BlockchainError\u003e {\n        let height = self.get_disk_block_header(\u0026block)?.height();\n        if height.is_none() {\n            return Err(BlockchainError::BlockNotPresent);\n        }\n        let height = height.unwrap();\n        let current_height = self.get_height()?;\n        // Mark all blocks after this one as invalid\n        for h in height..=current_height {\n            let hash = self.get_block_hash(h)?;\n            let header = self.get_block_header(\u0026hash)?;\n            let new_header = DiskBlockHeader::InvalidChain(header);\n            self.update_header(\u0026new_header)?;\n        }\n        // Row back to our previous state. Note that acc doesn't actually change in this case\n        // only the currently best known block.\n        self.update_tip(\n            self.get_ancestor(\u0026self.get_block_header(\u0026block)?)?\n                .block_hash(),\n            height - 1,\n        );\n        Ok(())\n    }\n\n    fn toggle_ibd(\u0026self, is_ibd: bool) {\n        let mut inner = write_lock!(self);\n        inner.ibd = is_ibd;\n    }\n\n    fn process_rescan_block(\u0026self, block: \u0026Block) -\u003e Result\u003c(), BlockchainError\u003e {\n        let header = self.get_disk_block_header(\u0026block.block_hash())?;\n        let height = header.height().expect(\"Recaning in an invalid tip\");\n        self.notify(block, height);\n        if self.get_height().unwrap() == height {\n            info!(\"Rescan completed\");\n            write_lock!(self).best_block.rescan_index = None;\n            self.flush()?;\n            return Ok(());\n        }\n        if height % 10_000 == 0 {\n            info!(\"Rescanning at block height={height}\");\n            write_lock!(self).best_block.rescan_index = Some(height);\n            self.flush()?;\n        }\n        Ok(())\n    }\n\n    fn connect_block(\n        \u0026self,\n        block: \u0026Block,\n        proof: Proof,\n        inputs: HashMap\u003cOutPoint, TxOut\u003e,\n        del_hashes: Vec\u003csha256::Hash\u003e,\n    ) -\u003e Result\u003cu32, BlockchainError\u003e {\n        let header = self.get_disk_block_header(\u0026block.block_hash())?;\n        let height = match header {\n            DiskBlockHeader::FullyValid(_, height) =\u003e {\n                self.maybe_reindex(\u0026header);\n                return Ok(height);\n            }\n            // If it's valid or orphan, we don't validate\n            DiskBlockHeader::Orphan(_)\n            | DiskBlockHeader::AssumedValid(_, _) // this will be validated by a partial chain\n            | DiskBlockHeader::InFork(_, _)\n            | DiskBlockHeader::InvalidChain(_) =\u003e return Ok(0),\n            DiskBlockHeader::HeadersOnly(_, height) =\u003e height,\n        };\n\n        // Check if this block is the next one in our chain, if we try\n        // to add them out-of-order, we'll have consensus issues with our\n        // accumulator\n        let expected_height = self.get_validation_index()? + 1;\n        if height != expected_height {\n            return Ok(height);\n        }\n\n        self.validate_block(block, height, inputs)?;\n        let acc = Consensus::update_acc(\u0026self.acc(), block, height, proof, del_hashes)?;\n        let ibd = self.is_in_idb();\n        // ... If we came this far, we consider this block valid ...\n        if ibd \u0026\u0026 height % 10_000 == 0 {\n            info!(\n                \"Downloading blocks: height={height} hash={}\",\n                block.block_hash()\n            );\n            self.flush()?;\n        }\n\n        match ibd {\n            false =\u003e {\n                info!(\n                    \"New tip! hash={} height={height} tx_count={}\",\n                    block.block_hash(),\n                    block.txdata.len()\n                );\n                self.flush()?;\n            }\n            true =\u003e {\n                if block.block_hash() == self.get_best_block()?.1 {\n                    info!(\"Tip reached, toggle IBD off\");\n                    self.toggle_ibd(false);\n                }\n            }\n        }\n\n        self.update_view(height, \u0026block.header, acc)?;\n\n        // Notify others we have a new block\n        self.notify(block, height);\n        Ok(height)\n    }\n\n    fn handle_transaction(\u0026self) -\u003e Result\u003c(), BlockchainError\u003e {\n        unimplemented!(\"This chain_state has no mempool\")\n    }\n\n    fn flush(\u0026self) -\u003e Result\u003c(), BlockchainError\u003e {\n        self.save_acc()?;\n        let inner = read_lock!(self);\n        inner.chainstore.save_height(\u0026inner.best_block)?;\n        inner.chainstore.flush()?;\n        Ok(())\n    }\n\n    fn accept_header(\u0026self, header: BlockHeader) -\u003e Result\u003c(), BlockchainError\u003e {\n        trace!(\"Accepting header {header:?}\");\n        let disk_header = self.get_disk_block_header(\u0026header.block_hash());\n\n        match disk_header {\n            Err(BlockchainError::Database(_)) =\u003e {\n                // If there's a database error we don't know if we already\n                // have the header or not\n                return Err(disk_header.unwrap_err());\n            }\n            Ok(found) =\u003e {\n                // Possibly reindex to recompute the best_block field\n                self.maybe_reindex(\u0026found);\n                // We already have this header\n                return Ok(());\n            }\n            _ =\u003e (),\n        }\n        // The best block we know of\n        let best_block = self.get_best_block()?;\n\n        // Do validation in this header\n        let block_hash = self.validate_header(\u0026header)?;\n\n        // Update our current tip\n        if header.prev_blockhash == best_block.1 {\n            let height = best_block.0 + 1;\n            trace!(\"Header builds on top of our best chain\");\n\n            let mut inner = write_lock!(self);\n            inner.best_block.new_block(block_hash, height);\n            inner\n                .chainstore\n                .save_header(\u0026super::chainstore::DiskBlockHeader::HeadersOnly(\n                    header, height,\n                ))?;\n\n            inner.chainstore.update_block_index(height, block_hash)?;\n        } else {\n            trace!(\"Header not in the best chain\");\n            self.maybe_reorg(header)?;\n        }\n\n        Ok(())\n    }\n\n    fn get_root_hashes(\u0026self) -\u003e Vec\u003cNodeHash\u003e {\n        let inner = read_lock!(self);\n        inner.acc.roots.clone()\n    }\n\n    fn get_partial_chain(\n        \u0026self,\n        initial_height: u32,\n        final_height: u32,\n        acc: Stump,\n    ) -\u003e Result\u003csuper::partial_chain::PartialChainState, BlockchainError\u003e {\n        let blocks = (initial_height..=final_height)\n            .flat_map(|height| {\n                let hash = self\n                    .get_block_hash(height)\n                    .expect(\"Block should be present\");\n                self.get_disk_block_header(\u0026hash)\n            })\n            .filter_map(|header| match header {\n                DiskBlockHeader::FullyValid(header, _) =\u003e Some(header),\n                _ =\u003e None,\n            })\n            .collect();\n\n        let inner = PartialChainStateInner {\n            error: None,\n            blocks,\n            consensus: Consensus {\n                parameters: self.chain_params(),\n            },\n            current_acc: acc,\n            final_height,\n            assume_valid: false,\n            initial_height,\n            current_height: initial_height,\n        };\n\n        Ok(PartialChainState(UnsafeCell::new(inner)))\n    }\n}\n\nimpl\u003cT: ChainStore\u003e From\u003cChainStateBuilder\u003cT\u003e\u003e for ChainState\u003cT\u003e {\n    fn from(mut builder: ChainStateBuilder\u003cT\u003e) -\u003e Self {\n        let inner = ChainStateInner {\n            acc: builder.acc(),\n            chainstore: builder.chainstore(),\n            best_block: builder.best_block(),\n            assume_valid: builder.assume_valid(),\n            ibd: builder.ibd(),\n            broadcast_queue: Vec::new(),\n            subscribers: Vec::new(),\n            fee_estimation: (1_f64, 1_f64, 1_f64),\n            consensus: Consensus {\n                parameters: builder.chain_params(),\n            },\n        };\n\n        let inner = RwLock::new(inner);\n        Self { inner }\n    }\n}\n\n#[macro_export]\n/// Grabs a RwLock for reading\nmacro_rules! read_lock {\n    ($obj:ident) =\u003e {\n        $obj.inner.read()\n    };\n}\n#[macro_export]\n/// Grabs a RwLock for writing\nmacro_rules! write_lock {\n    ($obj:ident) =\u003e {\n        $obj.inner.write()\n    };\n}\n\n#[derive(Clone, Debug)]\n/// Internal representation of the chain we are in\npub struct BestChain {\n    /// Hash of the last block in the chain we believe has more work on\n    best_block: BlockHash,\n    /// How many blocks are pilled on this chain?\n    depth: u32,\n    /// We actually validated blocks up to this point\n    validation_index: BlockHash,\n    /// We may rescan even after we validate all blocks, this index saves the position\n    /// we are while re-scanning\n    rescan_index: Option\u003cu32\u003e,\n    /// Blockchains are not fast-forward only, they might have \"forks\", sometimes it's useful\n    /// to keep track of them, in case they become the best one. This keeps track of some\n    /// tips we know about, but are not the best one. We don't keep tips that are too deep\n    /// or has too little work if compared to our best one\n    alternative_tips: Vec\u003cBlockHash\u003e,\n    /// Saves the height occupied by the assume valid block\n    assume_valid_index: u32,\n}\nimpl BestChain {\n    fn new_block(\u0026mut self, block_hash: BlockHash, height: u32) {\n        self.best_block = block_hash;\n        self.depth = height;\n    }\n    fn valid_block(\u0026mut self, block_hash: BlockHash) {\n        self.validation_index = block_hash;\n    }\n}\nimpl Encodable for BestChain {\n    fn consensus_encode\u003cW: Write + ?Sized\u003e(\u0026self, writer: \u0026mut W) -\u003e Result\u003cusize, ioError\u003e {\n        let mut len = 0;\n        len += self.best_block.consensus_encode(writer)?;\n        len += self.depth.consensus_encode(writer)?;\n        len += self.validation_index.consensus_encode(writer)?;\n        len += self.assume_valid_index.consensus_encode(writer)?;\n\n        match self.rescan_index {\n            Some(height) =\u003e len += height.consensus_encode(writer)?,\n            None =\u003e len += 0_u32.consensus_encode(writer)?,\n        }\n        len += self.alternative_tips.consensus_encode(writer)?;\n        Ok(len)\n    }\n}\nimpl From\u003c(BlockHash, u32)\u003e for BestChain {\n    fn from((best_block, depth): (BlockHash, u32)) -\u003e Self {\n        Self {\n            best_block,\n            depth,\n            validation_index: best_block,\n            rescan_index: None,\n            assume_valid_index: 0,\n            alternative_tips: Vec::new(),\n        }\n    }\n}\nimpl Decodable for BestChain {\n    fn consensus_decode\u003cR: Read + ?Sized\u003e(\n        reader: \u0026mut R,\n    ) -\u003e Result\u003cSelf, bitcoin::consensus::encode::Error\u003e {\n        let best_block = BlockHash::consensus_decode(reader)?;\n        let depth = u32::consensus_decode(reader)?;\n        let validation_index = BlockHash::consensus_decode(reader)?;\n        let rescan_index = u32::consensus_decode(reader)?;\n        let assume_valid_index = u32::consensus_decode(reader)?;\n\n        let rescan_index = if rescan_index == 0 {\n            None\n        } else {\n            Some(rescan_index)\n        };\n        let alternative_tips = \u003cVec\u003cBlockHash\u003e\u003e::consensus_decode(reader)?;\n        Ok(Self {\n            alternative_tips,\n            best_block,\n            depth,\n            rescan_index,\n            validation_index,\n            assume_valid_index,\n        })\n    }\n}\n\n#[cfg(test)]\nmod test {\n    extern crate std;\n    use core::str::FromStr;\n    use std::format;\n    use std::io::Cursor;\n    use std::vec::Vec;\n\n    use bitcoin::block::Header as BlockHeader;\n    use bitcoin::consensus::deserialize;\n    use bitcoin::consensus::Decodable;\n    use bitcoin::hashes::hex::FromHex;\n    use bitcoin::Block;\n    use bitcoin::BlockHash;\n    use rand::Rng;\n    use rustreexo::accumulator::proof::Proof;\n\n    use super::BlockchainInterface;\n    use super::ChainParams;\n    use super::ChainState;\n    use super::DiskBlockHeader;\n    use super::UpdatableChainstate;\n    use crate::prelude::HashMap;\n    use crate::pruned_utreexo::consensus::Consensus;\n    use crate::AssumeValidArg;\n    use crate::KvChainStore;\n    use crate::Network;\n    #[test]\n    fn accept_mainnet_headers() {\n        // Accepts the first 10235 mainnet headers\n        let file = include_bytes!(\"./testdata/headers.zst\");\n        let uncompressed: Vec\u003cu8\u003e = zstd::decode_all(std::io::Cursor::new(file)).unwrap();\n        let mut cursor = Cursor::new(uncompressed);\n\n        let test_id = rand::random::\u003cu64\u003e();\n        let chainstore = KvChainStore::new(format!(\"./data/{test_id}/\")).unwrap();\n        let chain = ChainState::\u003cKvChainStore\u003e::new(\n            chainstore,\n            Network::Bitcoin,\n            AssumeValidArg::Hardcoded,\n        );\n        while let Ok(header) = BlockHeader::consensus_decode(\u0026mut cursor) {\n            chain.accept_header(header).unwrap();\n        }\n    }\n    #[test]\n    fn accept_first_signet_headers() {\n        // Accepts the first 2016 signet headers\n        let file = include_bytes!(\"./testdata/signet_headers.zst\");\n        let uncompressed: Vec\u003cu8\u003e = zstd::decode_all(std::io::Cursor::new(file)).unwrap();\n        let mut cursor = Cursor::new(uncompressed);\n\n        let test_id = rand::random::\u003cu64\u003e();\n        let chainstore = KvChainStore::new(format!(\"./data/{test_id}/\")).unwrap();\n        let chain =\n            ChainState::\u003cKvChainStore\u003e::new(chainstore, Network::Signet, AssumeValidArg::Hardcoded);\n        while let Ok(header) = BlockHeader::consensus_decode(\u0026mut cursor) {\n            chain.accept_header(header).unwrap();\n        }\n    }\n    #[test]\n    fn test_calc_next_work_required() {\n        let first_block = Vec::from_hex(\"0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a008f4d5fae77031e8ad22203\").unwrap();\n        let first_block: BlockHeader = deserialize(\u0026first_block).unwrap();\n\n        let last_block = Vec::from_hex(\"00000020dec6741f7dc5df6661bcb2d3ec2fceb14bd0e6def3db80da904ed1eeb8000000d1f308132e6a72852c04b059e92928ea891ae6d513cd3e67436f908c804ec7be51df535fae77031e4d00f800\").unwrap();\n        let last_block = deserialize(\u0026last_block).unwrap();\n\n        let next_target = Consensus::calc_next_work_required(\n            \u0026last_block,\n            \u0026first_block,\n            ChainParams::from(Network::Bitcoin),\n        );\n\n        assert_eq!(0x1e012fa7, next_target.to_compact_lossy().to_consensus());\n    }\n    #[test]\n    fn test_reorg() {\n        let test_id = rand::random::\u003cu64\u003e();\n        let chainstore = KvChainStore::new(format!(\"./data/{test_id}/\")).unwrap();\n        let chain = ChainState::\u003cKvChainStore\u003e::new(\n            chainstore,\n            Network::Regtest,\n            AssumeValidArg::Hardcoded,\n        );\n        let blocks = include_str!(\"./testdata/test_reorg.json\");\n        let blocks: Vec\u003cVec\u003c\u0026str\u003e\u003e = serde_json::from_str(blocks).unwrap();\n\n        for block in blocks[0].iter() {\n            let block = Vec::from_hex(block).unwrap();\n            let block: Block = deserialize(\u0026block).unwrap();\n            chain.accept_header(block.header).unwrap();\n            chain\n                .connect_block(\u0026block, Proof::default(), HashMap::new(), Vec::new())\n                .unwrap();\n        }\n        assert_eq!(\n            chain.get_best_block().unwrap(),\n            (\n                10,\n                BlockHash::from_str(\n                    \"6e9c49a19038f7db8d13f6c2e70566385536ea11975528b557799e08a014e784\"\n                )\n                .unwrap()\n            )\n        );\n\n        for fork in blocks[1].iter() {\n            let block = Vec::from_hex(fork).unwrap();\n            let block: Block = deserialize(\u0026block).unwrap();\n            chain.accept_header(block.header).unwrap();\n        }\n        let best_block = chain.get_best_block().unwrap();\n        assert_eq!(\n            best_block,\n            (\n                16,\n                BlockHash::from_str(\n                    \"4572ac401b94915dde6c4957b706abdb13b5824b000cad7f6065ebd9aea6dad1\"\n                )\n                .unwrap()\n            )\n        );\n        for i in 1..=chain.get_height().unwrap() {\n            if let Ok(DiskBlockHeader::HeadersOnly(_, _)) =\n                chain.get_disk_block_header(\u0026chain.get_block_hash(i).unwrap())\n            {\n                continue;\n            }\n            panic!(\"Block {} is not in the store\", i);\n        }\n    }\n    #[test]\n    fn test_get_block_header_by_height() {\n        let file = include_bytes!(\"./testdata/signet_headers.zst\");\n        let uncompressed: Vec\u003cu8\u003e = zstd::decode_all(std::io::Cursor::new(file)).unwrap();\n        let mut cursor = Cursor::new(uncompressed);\n\n        let test_id = rand::random::\u003cu64\u003e();\n        let chainstore = KvChainStore::new(format!(\"./data/{test_id}/\")).unwrap();\n        let chain =\n            ChainState::\u003cKvChainStore\u003e::new(chainstore, Network::Signet, AssumeValidArg::Hardcoded);\n        let mut headers: Vec\u003cBlockHeader\u003e = Vec::new();\n        while let Ok(header) = BlockHeader::consensus_decode(\u0026mut cursor) {\n            headers.push(header);\n        }\n        headers.remove(0);\n\n        assert!(chain.push_headers(headers.clone(), 1).is_ok());\n        assert_eq!(chain.get_block_header_by_height(1), headers[0]);\n    }\n    #[test]\n    fn test_reindex_chain() {\n        let file = include_bytes!(\"./testdata/signet_headers.zst\");\n        let uncompressed: Vec\u003cu8\u003e = zstd::decode_all(std::io::Cursor::new(file)).unwrap();\n        let mut cursor = Cursor::new(uncompressed);\n\n        let test_id = rand::random::\u003cu64\u003e();\n        let chainstore = KvChainStore::new(format!(\"./data/{test_id}/\")).unwrap();\n        let chain =\n            ChainState::\u003cKvChainStore\u003e::new(chainstore, Network::Signet, AssumeValidArg::Hardcoded);\n        let mut headers: Vec\u003cBlockHeader\u003e = Vec::new();\n        while let Ok(header) = BlockHeader::consensus_decode(\u0026mut cursor) {\n            headers.push(header);\n        }\n        headers.remove(0);\n        chain.push_headers(headers, 1).unwrap();\n\n        assert_eq!(chain.reindex_chain().depth, 2015);\n    }\n    #[test]\n    fn test_load_acc() {\n        let file = include_bytes!(\"./testdata/signet_headers.zst\");\n        let uncompressed: Vec\u003cu8\u003e = zstd::decode_all(std::io::Cursor::new(file)).unwrap();\n        let mut cursor = Cursor::new(uncompressed);\n\n        let test_id = rand::random::\u003cu64\u003e();\n        let chainstore = KvChainStore::new(format!(\"./data/{test_id}/\")).unwrap();\n        let chain =\n            ChainState::\u003cKvChainStore\u003e::new(chainstore, Network::Signet, AssumeValidArg::Hardcoded);\n        let mut headers: Vec\u003cBlockHeader\u003e = Vec::new();\n        while let Ok(header) = BlockHeader::consensus_decode(\u0026mut cursor) {\n            headers.push(header);\n        }\n        headers.remove(0);\n\n        chain.push_headers(headers, 1).unwrap();\n\n        write_lock!(chain).best_block = chain.reindex_chain();\n\n        assert_eq!(chain.get_validation_index().unwrap(), 2015);\n        let _ = ChainState::\u003cKvChainStore\u003e::load_acc(\u0026read_lock!(chain).chainstore);\n    }\n    #[test]\n    fn test_update_tip() {\n        let file = include_bytes!(\"./testdata/signet_headers.zst\");\n        let uncompressed: Vec\u003cu8\u003e = zstd::decode_all(std::io::Cursor::new(file)).unwrap();\n        let mut cursor = Cursor::new(uncompressed);\n\n        let test_id = rand::random::\u003cu64\u003e();\n        let chainstore = KvChainStore::new(format!(\"./data/{test_id}/\")).unwrap();\n        let chain =\n            ChainState::\u003cKvChainStore\u003e::new(chainstore, Network::Signet, AssumeValidArg::Hardcoded);\n        let mut headers: Vec\u003cBlockHeader\u003e = Vec::new();\n        while let Ok(header) = BlockHeader::consensus_decode(\u0026mut cursor) {\n            headers.push(header);\n        }\n        headers.remove(0);\n\n        chain.update_tip(headers[1].prev_blockhash, 1);\n        assert_eq!(\n            read_lock!(chain).best_block.best_block,\n            headers[1].prev_blockhash\n        );\n    }\n    #[test]\n    fn test_get_block_locator() {\n        let file = include_bytes!(\"./testdata/signet_headers.zst\");\n        let uncompressed: Vec\u003cu8\u003e = zstd::decode_all(std::io::Cursor::new(file)).unwrap();\n        let mut cursor = Cursor::new(uncompressed);\n\n        let test_id = rand::random::\u003cu64\u003e();\n        let chainstore = KvChainStore::new(format!(\"./data/{test_id}/\")).unwrap();\n        let chain =\n            ChainState::\u003cKvChainStore\u003e::new(chainstore, Network::Signet, AssumeValidArg::Hardcoded);\n        let mut headers: Vec\u003cBlockHeader\u003e = Vec::new();\n        while let Ok(header) = BlockHeader::consensus_decode(\u0026mut cursor) {\n            headers.push(header);\n        }\n        headers.remove(0);\n        chain.push_headers(headers, 1).unwrap();\n        write_lock!(chain).best_block = chain.reindex_chain();\n\n        assert!(chain.get_validation_index().is_ok());\n\n        assert!(!chain\n            .get_block_locator_for_tip(read_lock!(chain).best_block.best_block)\n            .unwrap()\n            .is_empty());\n\n        assert!(!chain.get_block_locator().unwrap().is_empty())\n    }\n\n    #[test]\n    fn test_invalidate_block() {\n        let file = include_bytes!(\"./testdata/signet_headers.zst\");\n        let uncompressed: Vec\u003cu8\u003e = zstd::decode_all(std::io::Cursor::new(file)).unwrap();\n        let mut cursor = Cursor::new(uncompressed);\n\n        let test_id = rand::random::\u003cu64\u003e();\n        let chainstore = KvChainStore::new(format!(\"./data/{test_id}/\")).unwrap();\n        let chain =\n            ChainState::\u003cKvChainStore\u003e::new(chainstore, Network::Signet, AssumeValidArg::Hardcoded);\n        let mut headers: Vec\u003cBlockHeader\u003e = Vec::new();\n        while let Ok(header) = BlockHeader::consensus_decode(\u0026mut cursor) {\n            headers.push(header);\n        }\n        headers.remove(0);\n        chain.push_headers(headers.clone(), 1).unwrap();\n        write_lock!(chain).best_block = chain.reindex_chain();\n\n        let random_height = rand::thread_rng().gen_range(1..=2014);\n\n        chain\n            .invalidate_block(headers[random_height].prev_blockhash)\n            .unwrap();\n\n        assert_eq!(chain.get_height().unwrap() as usize, random_height - 1);\n    }\n}\n","traces":[{"line":62,"address":[1165360],"length":1,"stats":{"Line":0},"fn_name":"consume_block"},{"line":63,"address":[1165399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[1247247,1245952],"length":1,"stats":{"Line":5},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[1251680,1253179],"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[1254523,1253216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[1267002,1265184],"length":1,"stats":{"Line":9},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":558,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":564,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":582,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":595,"address":[5099744,5102284,5102422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":612,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":614,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":617,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":619,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":620,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":627,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":628,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":631,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":632,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":635,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":636,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":643,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":650,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":653,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":656,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":657,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":659,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":660,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":661,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":665,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":670,"address":[1272506,1271248,1272466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":676,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":677,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":678,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":679,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":680,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":682,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":683,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":684,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":686,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":690,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":691,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":695,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":698,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":709,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":713,"address":[1273328,1274458],"length":1,"stats":{"Line":3},"fn_name":null},{"line":719,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":722,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":723,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":728,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":730,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":731,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":734,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":735,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":736,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":738,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":740,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":742,"address":[1275970,1274496,1275814],"length":1,"stats":{"Line":1},"fn_name":null},{"line":748,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":749,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":753,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":754,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":756,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":757,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":761,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":762,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":767,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":768,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":770,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":772,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":773,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":774,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":781,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":782,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":783,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":786,"address":[5058208,5058394],"length":1,"stats":{"Line":0},"fn_name":"update_acc\u003cfloresta_chain::pruned_utreexo::chainstore::KvChainStore\u003e"},{"line":794,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":797,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":798,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":802,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":804,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":807,"address":[5060256,5061572,5061599],"length":1,"stats":{"Line":0},"fn_name":"validate_block\u003cfloresta_chain::pruned_utreexo::chainstore::KvChainStore\u003e"},{"line":816,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":818,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":821,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":822,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":825,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":826,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":827,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":829,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":832,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":833,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":834,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":835,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":837,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":839,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":840,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":841,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":842,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":844,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":845,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":846,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":847,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":850,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":851,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":854,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":856,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":857,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":859,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":864,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":865,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":868,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":869,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":872,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":873,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":874,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":877,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":878,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":879,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":880,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":882,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":885,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":889,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":890,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":891,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":894,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":895,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":896,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":897,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":900,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":901,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":902,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":903,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":904,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":905,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":907,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":911,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":915,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":916,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":917,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":920,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":921,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":922,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":923,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":925,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":927,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":928,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":930,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":931,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":932,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":933,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":934,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":936,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":937,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":938,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":940,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":941,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":942,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":943,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":944,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":945,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":946,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":947,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":949,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":950,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":951,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":953,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":956,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":957,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":959,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":962,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":976,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":977,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":978,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":980,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":983,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":984,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":985,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":989,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":990,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":991,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":994,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":995,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":996,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":997,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":998,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1001,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1002,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1004,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1007,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1009,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1010,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1012,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1013,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1014,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1016,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1019,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1020,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1021,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1022,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1023,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1025,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1028,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1029,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1030,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1031,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1033,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1034,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1036,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1037,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1038,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1039,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1040,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1044,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1045,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1046,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1047,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1049,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1052,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1053,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1054,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1057,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1058,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1059,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1060,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1061,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1062,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1063,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1064,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1065,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1067,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1068,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1069,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1070,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1072,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1075,"address":[1287320,1287086,1282752],"length":1,"stats":{"Line":1},"fn_name":"connect_block\u003cfloresta_chain::pruned_utreexo::chainstore::KvChainStore\u003e"},{"line":1082,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1083,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1084,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1085,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1086,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1089,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1091,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1092,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1093,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1099,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1104,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1105,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1106,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1108,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1123,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1126,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1127,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1128,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1133,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1136,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1137,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1144,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1145,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1146,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1147,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1148,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1149,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1152,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1153,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1154,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1156,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1162,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1164,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1166,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1171,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1174,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1177,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1178,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1179,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1181,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1182,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1183,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1185,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1186,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1189,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1191,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1192,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1195,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1203,"address":[5076912,5077672,5077705],"length":1,"stats":{"Line":0},"fn_name":"get_partial_chain\u003cfloresta_chain::pruned_utreexo::chainstore::KvChainStore\u003e"},{"line":1209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1296,"address":[1187712],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1297,"address":[1187721],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1298,"address":[1187752],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1300,"address":[1187760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1301,"address":[1187765],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1305,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1306,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1307,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1308,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1309,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1310,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1312,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1314,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1316,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1317,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1321,"address":[1187822,1187808],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":1328,"address":[1187876],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1333,"address":[1292432],"length":1,"stats":{"Line":0},"fn_name":"consensus_decode\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":1336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":376,"coverable":666},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-chain","src","pruned_utreexo","chain_state_builder.rs"],"content":"use bitcoin::block::Header as BlockHeader;\nuse bitcoin::hashes::Hash;\nuse bitcoin::BlockHash;\nuse rustreexo::accumulator::stump::Stump;\n\nuse super::chain_state::BestChain;\nuse super::chain_state::ChainState;\nuse super::chainparams::ChainParams;\nuse super::ChainStore;\n\n#[derive(Clone, Debug)]\npub enum BlockchainBuilderError {\n    MissingChainstore,\n    MissingChainParams,\n}\n#[derive(Clone, Debug, Default)]\npub struct ChainStateBuilder\u003cPersistedState: ChainStore\u003e {\n    acc: Option\u003cStump\u003e,\n    chainstore: Option\u003cPersistedState\u003e,\n    ibd: bool,\n    chain_params: Option\u003cChainParams\u003e,\n    assume_valid: Option\u003cBlockHash\u003e,\n    tip: Option\u003c(BlockHash, u32)\u003e,\n    first: Option\u003cBlockHeader\u003e,\n}\n\nimpl\u003cT: ChainStore\u003e ChainStateBuilder\u003cT\u003e {\n    pub fn new() -\u003e Self {\n        ChainStateBuilder {\n            acc: None,\n            chainstore: None,\n            ibd: true,\n            chain_params: None,\n            assume_valid: None,\n            tip: None,\n            first: None,\n        }\n    }\n    pub fn build(self) -\u003e Result\u003cChainState\u003cT\u003e, BlockchainBuilderError\u003e {\n        if self.chainstore.is_none() {\n            return Err(BlockchainBuilderError::MissingChainstore);\n        }\n        if self.chain_params.is_none() {\n            return Err(BlockchainBuilderError::MissingChainParams);\n        }\n        if let Some(first) = self.first {\n            self.chainstore\n                .as_ref()\n                .unwrap()\n                .save_header(\u0026crate::DiskBlockHeader::FullyValid(\n                    first,\n                    self.tip.unwrap().1,\n                ))\n                .unwrap();\n            self.chainstore\n                .as_ref()\n                .unwrap()\n                .update_block_index(self.tip.unwrap().1, self.tip.unwrap().0)\n                .unwrap();\n        }\n        Ok(ChainState::from(self))\n    }\n    pub fn with_chainstore(mut self, chainstore: T) -\u003e Self {\n        self.chainstore = Some(chainstore);\n        self\n    }\n\n    pub fn toggle_ibd(mut self, ibd: bool) -\u003e Self {\n        self.ibd = ibd;\n        self\n    }\n    pub fn with_chain_params(mut self, chain_params: ChainParams) -\u003e Self {\n        self.chain_params = Some(chain_params);\n        self\n    }\n    pub fn with_assume_valid(mut self, assume_valid: BlockHash) -\u003e Self {\n        self.assume_valid = Some(assume_valid);\n        self\n    }\n    pub fn assume_utreexo(mut self, acc: Stump) -\u003e Self {\n        self.acc = Some(acc);\n        self\n    }\n    pub fn with_tip(mut self, tip: (BlockHash, u32), header: BlockHeader) -\u003e Self {\n        self.tip = Some(tip);\n        self.first = Some(header);\n        self\n    }\n    pub fn acc(\u0026self) -\u003e Stump {\n        self.acc.clone().unwrap_or_default()\n    }\n    pub fn chainstore(\u0026mut self) -\u003e T {\n        self.chainstore.take().unwrap()\n    }\n    pub fn ibd(\u0026self) -\u003e bool {\n        self.ibd\n    }\n    pub fn chain_params(\u0026self) -\u003e ChainParams {\n        self.chain_params.clone().unwrap()\n    }\n    pub fn best_block(\u0026self) -\u003e BestChain {\n        let block = self.tip.unwrap_or((BlockHash::all_zeros(), 0));\n        BestChain::from(block)\n    }\n    pub fn assume_valid(\u0026self) -\u003e Option\u003cBlockHash\u003e {\n        self.assume_valid\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":46},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-chain","src","pruned_utreexo","chainparams.rs"],"content":"extern crate alloc;\nuse alloc::vec::Vec;\nuse core::ffi::c_uint;\n\n#[cfg(feature = \"bitcoinconsensus\")]\nuse bitcoin::bitcoinconsensus::VERIFY_NONE;\n#[cfg(feature = \"bitcoinconsensus\")]\nuse bitcoin::bitcoinconsensus::VERIFY_P2SH;\n#[cfg(feature = \"bitcoinconsensus\")]\nuse bitcoin::bitcoinconsensus::VERIFY_WITNESS;\nuse bitcoin::blockdata::constants::genesis_block;\nuse bitcoin::Block;\nuse bitcoin::BlockHash;\nuse bitcoin::Target;\nuse rustreexo::accumulator::node_hash::NodeHash;\nuse rustreexo::accumulator::stump::Stump;\n\nuse crate::prelude::*;\nuse crate::Network;\n#[derive(Clone, Debug)]\npub struct ChainParams {\n    /// The network's first block, also called genesis block.\n    pub genesis: Block,\n    /// Whether or not we are allowed to mine blocks with the network's smallest diff, this\n    /// is used in testnet, if a block takes more than 20 minutes to be mined\n    pub pow_allow_min_diff: bool,\n    /// Whether or not we are allowed to mine without retargets, this is used in regtests\n    pub pow_allow_no_retarget: bool,\n    /// This is the maximum possible target (i.e, minimum possible difficulty), and in mainnet\n    /// it's defined as ~((uint256)0 \u003e\u003e 32).\n    pub max_target: Target,\n    /// Interval of blocks until the block reward halves\n    pub subsidy_halving_interval: u64,\n    /// We expect blocks to take this many seconds to be found, on average\n    pub pow_target_spacing: u64,\n    /// When we retarget we expect this many seconds to be elapsed since last time. If\n    /// it's more, we decrease difficulty, if it's less we increase difficulty\n    pub pow_target_timespan: u64,\n    /// We wait this many blocks before a coinbase output can be spent\n    pub coinbase_maturity: u32,\n    /// The height at which bip32 is activated\n    pub bip34_activation_height: u32,\n    /// The height at which bip65 is activated\n    pub bip65_activation_height: u32,\n    /// The height at which bip66 is activated\n    pub bip66_activation_height: u32,\n    /// The height at which segwit is activated\n    pub segwit_activation_height: u32,\n    /// The height at which csv(CHECK_SEQUENCE_VERIFY) is activated\n    pub csv_activation_height: u32,\n    /// A list of exceptions to the rules, where the key is the block hash and the value is the\n    /// verification flags\n    pub exceptions: HashMap\u003cBlockHash, c_uint\u003e,\n    pub network_roots: Stump,\n    pub assumeutreexo_index: (BlockHash, u32),\n}\n\nimpl ChainParams {\n    fn max_target(net: Network) -\u003e Target {\n        match net {\n            Network::Bitcoin =\u003e Target::MAX_ATTAINABLE_MAINNET,\n            Network::Testnet =\u003e Target::MAX_ATTAINABLE_TESTNET,\n            Network::Signet =\u003e Target::MAX_ATTAINABLE_SIGNET,\n            Network::Regtest =\u003e Target::MAX_ATTAINABLE_REGTEST,\n        }\n    }\n}\n\nfn get_signet_roots() -\u003e Stump {\n    let roots: Vec\u003cNodeHash\u003e = [\n        \"8e6fcdcf05020fa1f7131a59a7050b33ca74852f5e82a5fbe236402bc4c8a928\",\n        \"f4c92949c71be7613699977eebf6d3bd5c8fd3e538a01380583e5aba14273425\",\n        \"d73ceb2748d342b14a269d7c0feb34aca1341a6367cc75cff6db8422eb01916d\",\n        \"a012e516784ccb7af26d7b356bf645e6a167cce5b48b9368c58c523acd25f6bf\",\n        \"e6e74ebc1d01ac47541c90afaac208c9b0f16226d2d046742032374e925a79ae\",\n        \"235b255558e994e6c5b6011469e891436cbf18107a939847e6e5df4cb939a96b\",\n        \"a9f45482564f0cb103067636c39fe30df1fa04b6b04d438c655530d991432761\",\n        \"d46716b7ccaf8d9eff11557527056f6100e016126df369eef95b9c9874467d40\",\n        \"7039b9053ef819d35c079eb4dcdd37029653a325bf416768e7de16bacf2c90af\",\n        \"f7a626339303030fc1b71d228e74aebdc2126cb7a2c5e01eb036225ea9dd41c2\",\n        \"b21123705cb4cef5a104705037ccd80ae7281789aa07cd468d5949c7e62df37b\",\n        \"ca931559f3ad9c91b9510f5dbfa42467e40ad8a0069d8f273de6079e9b115232\",\n        \"954ca698b58b6e6cdcc89948c841059d892578b7d67a249965fff83de5aaa7e3\",\n    ]\n    .iter()\n    .map(|hash| NodeHash::from_str(hash).unwrap())\n    .collect();\n\n    Stump {\n        roots,\n        leaves: 1477499,\n    }\n}\n\n#[cfg(feature = \"bitcoinconsensus\")]\nfn get_exceptions() -\u003e HashMap\u003cBlockHash, c_uint\u003e {\n    // For some reason, some blocks in the mainnet and testnet have different rules than it should\n    // be, so we need to keep a list of exceptions and treat them differently\n    let mut exceptions = HashMap::new();\n    exceptions.insert(\n        BlockHash::from_str(\"00000000000002dc756eebf4f49723ed8d30cc28a5f108eb94b1ba88ac4f9c22\")\n            .unwrap(),\n        VERIFY_NONE,\n    ); // BIP16 exception on main net\n    exceptions.insert(\n        BlockHash::from_str(\"0000000000000000000f14c35b2d841e986ab5441de8c585d5ffe55ea1e395ad\")\n            .unwrap(),\n        VERIFY_P2SH | VERIFY_WITNESS,\n    ); // Taproot exception on main net\n    exceptions.insert(\n        BlockHash::from_str(\"00000000dd30457c001f4095d208cc1296b0eed002427aa599874af7a432b105\")\n            .unwrap(),\n        VERIFY_NONE,\n    ); // BIP16 exception on test net\n    exceptions\n}\n\n#[cfg(not(feature = \"bitcoinconsensus\"))]\nfn get_exceptions() -\u003e HashMap\u003cBlockHash, c_uint\u003e {\n    HashMap::new()\n}\n\nimpl From\u003cNetwork\u003e for ChainParams {\n    fn from(net: Network) -\u003e Self {\n        let genesis = genesis_block(net.into());\n        let max_target = ChainParams::max_target(net);\n        let exceptions = get_exceptions();\n        match net {\n            Network::Bitcoin =\u003e ChainParams {\n                assumeutreexo_index: (genesis.block_hash(), 0),\n                genesis,\n                max_target,\n                pow_allow_min_diff: false,\n                pow_allow_no_retarget: false,\n                pow_target_spacing: 10 * 60, // One block every 600 seconds (10 minutes)\n                pow_target_timespan: 14 * 24 * 60 * 60, // two weeks\n                subsidy_halving_interval: 210_000,\n                coinbase_maturity: 100,\n                bip34_activation_height: 227931,\n                bip65_activation_height: 388381,\n                bip66_activation_height: 363725,\n                segwit_activation_height: 481824,\n                csv_activation_height: 419328,\n                exceptions,\n                network_roots: Stump::default(),\n            },\n            Network::Testnet =\u003e ChainParams {\n                assumeutreexo_index: (genesis.block_hash(), 0),\n                genesis,\n                max_target,\n                pow_allow_min_diff: true,\n                pow_allow_no_retarget: false,\n                pow_target_spacing: 10 * 60, // One block every 600 seconds (10 minutes)\n                pow_target_timespan: 14 * 24 * 60 * 60, // two weeks\n                subsidy_halving_interval: 210_000,\n                coinbase_maturity: 100,\n                bip34_activation_height: 211_111,\n                bip65_activation_height: 581_885,\n                bip66_activation_height: 330_776,\n                segwit_activation_height: 834_624,\n                csv_activation_height: 770_112,\n                exceptions,\n                network_roots: Stump::default(),\n            },\n            Network::Signet =\u003e ChainParams {\n                genesis,\n                max_target,\n                pow_allow_min_diff: false,\n                pow_allow_no_retarget: false,\n                pow_target_spacing: 10 * 60, // One block every 600 seconds (10 minutes)\n                pow_target_timespan: 14 * 24 * 60 * 60, // two weeks\n                subsidy_halving_interval: 210_000,\n                coinbase_maturity: 100,\n                bip34_activation_height: 500,\n                csv_activation_height: 1,\n                bip65_activation_height: 1,\n                bip66_activation_height: 1,\n                segwit_activation_height: 1,\n                exceptions,\n                network_roots: get_signet_roots(),\n                assumeutreexo_index: (\n                    BlockHash::from_str(\n                        \"0000001321625245a27e0be82a640106d019e35e48a024a17df1ceeb9b1f2131\",\n                    )\n                    .unwrap(),\n                    74551,\n                ),\n            },\n            Network::Regtest =\u003e ChainParams {\n                assumeutreexo_index: (genesis.block_hash(), 0),\n                genesis,\n                max_target,\n                pow_allow_min_diff: false,\n                pow_allow_no_retarget: true,\n                pow_target_spacing: 10 * 60, // One block every 600 seconds (10 minutes)\n                pow_target_timespan: 14 * 24 * 60 * 60, // two weeks\n                subsidy_halving_interval: 150,\n                coinbase_maturity: 100,\n                bip34_activation_height: 500,\n                csv_activation_height: 0,\n                bip65_activation_height: 0,\n                bip66_activation_height: 0,\n                segwit_activation_height: 0,\n                exceptions,\n                network_roots: Stump::default(),\n            },\n        }\n    }\n}\n\npub fn get_chain_dns_seeds(network: Network) -\u003e Vec\u003c\u0026'static str\u003e {\n    let mut seeds = Vec::new();\n    // DNS seeds taken from Bitcoin Core at commit 382b692a503355df7347efd9c128aff465b5583e\n    match network {\n        Network::Bitcoin =\u003e {\n            seeds.push(\"seed.bitcoin.sipa.be.\"); // Pieter Wuille\n            seeds.push(\"dnsseed.bluematt.me.\"); // Matt Corallo\n            seeds.push(\"dnsseed.bitcoin.dashjr.org.\"); // Luke Dashjr\n            seeds.push(\"seed.bitcoinstats.com.\"); // Christian Decker\n            seeds.push(\"seed.bitcoin.jonasschnelli.ch.\"); // Jonas Schnelli\n            seeds.push(\"seed.btc.petertodd.org.\"); // Peter Todd\n            seeds.push(\"seed.bitcoin.sprovoost.nl.\"); // Sjors Provoost\n            seeds.push(\"dnsseed.emzy.de.\"); // Stephan Oeste\n            seeds.push(\"seed.bitcoin.wiz.biz.\"); // Jason Maurice\n        }\n        Network::Testnet =\u003e {\n            seeds.push(\"testnet-seed.bitcoin.jonasschnelli.ch.\");\n            seeds.push(\"seed.tbtc.petertodd.org.\");\n            seeds.push(\"seed.testnet.bitcoin.sprovoost.nl.\");\n            seeds.push(\"testnet-seed.bluematt.me.\");\n        }\n        Network::Signet =\u003e {\n            seeds.push(\"seed.signet.bitcoin.sprovoost.nl.\");\n            seeds.push(\"x1000000.seed.dlsouza.lol.\"); // Davidson Souza, returns utreexo peers\n        }\n        Network::Regtest =\u003e {\n            // no seeds for regtest\n        }\n    }\n    seeds\n}\n","traces":[{"line":59,"address":[1034928],"length":1,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[1034948],"length":1,"stats":{"Line":4},"fn_name":null},{"line":61,"address":[1034986],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[1035025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[1035113],"length":1,"stats":{"Line":7},"fn_name":null},{"line":64,"address":[1035069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[1035200],"length":1,"stats":{"Line":7},"fn_name":"get_signet_roots"},{"line":70,"address":[1035214],"length":1,"stats":{"Line":7},"fn_name":null},{"line":86,"address":[1185431,1185408],"length":1,"stats":{"Line":14},"fn_name":"{closure#0}"},{"line":96,"address":[1035679,1035344],"length":1,"stats":{"Line":2},"fn_name":"get_exceptions"},{"line":99,"address":[1035365],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[1035471],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[1035435,1035370],"length":1,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[1035557],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[1035478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[1035640],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[1035564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[1035651],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[1035712,1039860,1037198],"length":1,"stats":{"Line":4},"fn_name":"from"},{"line":125,"address":[1035745],"length":1,"stats":{"Line":4},"fn_name":null},{"line":126,"address":[1035802,1035962],"length":1,"stats":{"Line":6},"fn_name":null},{"line":127,"address":[1036046],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[1036053],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[1036305,1036103],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[1036414,1036466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[1036439,1036547,1036727],"length":1,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[1036720],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[1037209,1036133],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[1037318,1037370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[1037638,1037452,1037343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[1037631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[1036227,1038982],"length":1,"stats":{"Line":7},"fn_name":null},{"line":171,"address":[1039064,1039250,1038955],"length":1,"stats":{"Line":14},"fn_name":null},{"line":180,"address":[1039243],"length":1,"stats":{"Line":7},"fn_name":null},{"line":181,"address":[1039478],"length":1,"stats":{"Line":7},"fn_name":null},{"line":190,"address":[1036163,1038082],"length":1,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[1038191,1038243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[1038325,1038511,1038216],"length":1,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[1038504],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[1040419,1039904],"length":1,"stats":{"Line":1},"fn_name":"get_chain_dns_seeds"},{"line":212,"address":[1039929],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[1039934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[1039967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[1040116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[1040140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[1040164],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[1040188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[1040212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[1040236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[1040260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[1040284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[1039991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[1040313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[1040337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[1040361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[1040058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[1040390],"length":1,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[1040027],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":40,"coverable":58},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-chain","src","pruned_utreexo","chainstore.rs"],"content":"// Written in 2022 by Davidson Souza\n\n//! This is a basic kv database that stores all metadata about our blockchain and utreexo\n//! state.\nuse bitcoin::block::Header as BlockHeader;\nuse bitcoin::consensus::deserialize;\nuse bitcoin::consensus::serialize;\nuse bitcoin::consensus::Decodable;\nuse bitcoin::consensus::Encodable;\nuse bitcoin::BlockHash;\n\nuse crate::prelude::*;\n#[derive(Debug)]\npub enum DiskBlockHeader {\n    FullyValid(BlockHeader, u32),\n    AssumedValid(BlockHeader, u32),\n    Orphan(BlockHeader),\n    HeadersOnly(BlockHeader, u32),\n    InFork(BlockHeader, u32),\n    InvalidChain(BlockHeader),\n}\nimpl DiskBlockHeader {\n    pub fn block_hash(\u0026self) -\u003e BlockHash {\n        self.deref().block_hash()\n    }\n    pub fn height(\u0026self) -\u003e Option\u003cu32\u003e {\n        match self {\n            DiskBlockHeader::FullyValid(_, height) =\u003e Some(*height),\n            DiskBlockHeader::Orphan(_) =\u003e None,\n            DiskBlockHeader::HeadersOnly(_, height) =\u003e Some(*height),\n            DiskBlockHeader::InFork(_, height) =\u003e Some(*height),\n            DiskBlockHeader::InvalidChain(_) =\u003e None,\n            DiskBlockHeader::AssumedValid(_, height) =\u003e Some(*height),\n        }\n    }\n}\nimpl Deref for DiskBlockHeader {\n    type Target = BlockHeader;\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        match self {\n            DiskBlockHeader::FullyValid(header, _) =\u003e header,\n            DiskBlockHeader::Orphan(header) =\u003e header,\n            DiskBlockHeader::HeadersOnly(header, _) =\u003e header,\n            DiskBlockHeader::InFork(header, _) =\u003e header,\n            DiskBlockHeader::InvalidChain(header) =\u003e header,\n            DiskBlockHeader::AssumedValid(header, _) =\u003e header,\n        }\n    }\n}\nimpl Decodable for DiskBlockHeader {\n    fn consensus_decode\u003cR: Read + ?Sized\u003e(\n        reader: \u0026mut R,\n    ) -\u003e core::result::Result\u003cSelf, bitcoin::consensus::encode::Error\u003e {\n        let tag = u8::consensus_decode(reader)?;\n        let header = BlockHeader::consensus_decode(reader)?;\n\n        match tag {\n            0x00 =\u003e {\n                let height = u32::consensus_decode(reader)?;\n                Ok(Self::FullyValid(header, height))\n            }\n            0x01 =\u003e Ok(Self::Orphan(header)),\n            0x02 =\u003e {\n                let height = u32::consensus_decode(reader)?;\n                Ok(Self::HeadersOnly(header, height))\n            }\n            0x03 =\u003e {\n                let height = u32::consensus_decode(reader)?;\n\n                Ok(Self::InFork(header, height))\n            }\n            0x04 =\u003e Ok(Self::InvalidChain(header)),\n            0x05 =\u003e {\n                let height = u32::consensus_decode(reader)?;\n                Ok(Self::AssumedValid(header, height))\n            }\n            _ =\u003e unreachable!(),\n        }\n    }\n}\nimpl Encodable for DiskBlockHeader {\n    fn consensus_encode\u003cW: Write + ?Sized\u003e(\n        \u0026self,\n        writer: \u0026mut W,\n    ) -\u003e core::result::Result\u003cusize, ioError\u003e {\n        let mut len = 80 + 1; // Header + tag\n        match self {\n            DiskBlockHeader::FullyValid(header, height) =\u003e {\n                0x00_u8.consensus_encode(writer)?;\n                header.consensus_encode(writer)?;\n                height.consensus_encode(writer)?;\n                len += 4;\n            }\n            DiskBlockHeader::Orphan(header) =\u003e {\n                0x01_u8.consensus_encode(writer)?;\n                header.consensus_encode(writer)?;\n            }\n            DiskBlockHeader::HeadersOnly(header, height) =\u003e {\n                0x02_u8.consensus_encode(writer)?;\n                header.consensus_encode(writer)?;\n                height.consensus_encode(writer)?;\n                len += 4;\n            }\n            DiskBlockHeader::InFork(header, height) =\u003e {\n                0x03_u8.consensus_encode(writer)?;\n                header.consensus_encode(writer)?;\n                height.consensus_encode(writer)?;\n                len += 4;\n            }\n            DiskBlockHeader::InvalidChain(header) =\u003e {\n                0x04_u8.consensus_encode(writer)?;\n                header.consensus_encode(writer)?;\n            }\n            DiskBlockHeader::AssumedValid(header, height) =\u003e {\n                0x05_u8.consensus_encode(writer)?;\n                header.consensus_encode(writer)?;\n                height.consensus_encode(writer)?;\n                len += 4;\n            }\n        };\n        Ok(len)\n    }\n}\nuse kv::Config;\nuse kv::Integer;\nuse kv::Store;\n\nuse super::chain_state::BestChain;\nuse super::ChainStore;\npub struct KvChainStore(Store);\nimpl KvChainStore {\n    pub fn new(datadir: String) -\u003e Result\u003cKvChainStore, kv::Error\u003e {\n        // Configure the database\n        let cfg = Config::new(datadir + \"/chain_data\").cache_capacity(100_000_000);\n\n        // Open the key/value store\n        let store = Store::new(cfg)?;\n\n        Ok(KvChainStore(store))\n    }\n}\nimpl ChainStore for KvChainStore {\n    type Error = kv::Error;\n    fn load_roots(\u0026self) -\u003e Result\u003cOption\u003cVec\u003cu8\u003e\u003e, Self::Error\u003e {\n        let bucket = self.0.bucket::\u003c\u0026str, Vec\u003cu8\u003e\u003e(None)?;\n        bucket.get(\u0026\"roots\")\n    }\n    fn save_roots(\u0026self, roots: Vec\u003cu8\u003e) -\u003e Result\u003c(), Self::Error\u003e {\n        let bucket = self.0.bucket::\u003c\u0026str, Vec\u003cu8\u003e\u003e(None)?;\n\n        bucket.set(\u0026\"roots\", \u0026roots)?;\n        Ok(())\n    }\n\n    fn load_height(\u0026self) -\u003e Result\u003cOption\u003cBestChain\u003e, Self::Error\u003e {\n        let bucket = self.0.bucket::\u003c\u0026str, Vec\u003cu8\u003e\u003e(None)?;\n        let height = bucket.get(\u0026\"height\")?;\n\n        if let Some(height) = height {\n            return Ok(Some(deserialize(\u0026height).unwrap()));\n        }\n        Ok(None)\n    }\n\n    fn save_height(\u0026self, height: \u0026BestChain) -\u003e Result\u003c(), Self::Error\u003e {\n        let bucket = self.0.bucket::\u003c\u0026str, Vec\u003cu8\u003e\u003e(None)?;\n        let height = serialize(height);\n        bucket.set(\u0026\"height\", \u0026height)?;\n        Ok(())\n    }\n    fn get_header(\u0026self, block_hash: \u0026BlockHash) -\u003e Result\u003cOption\u003cDiskBlockHeader\u003e, Self::Error\u003e {\n        let bucket = self.0.bucket::\u003c\u0026[u8], Vec\u003cu8\u003e\u003e(Some(\"header\"))?;\n        let block_hash = serialize(\u0026block_hash);\n\n        let header = bucket.get(\u0026\u0026*block_hash)?;\n        if let Some(header) = header {\n            return Ok(Some(deserialize(\u0026header).unwrap()));\n        }\n        Ok(None)\n    }\n    fn flush(\u0026self) -\u003e Result\u003c(), Self::Error\u003e {\n        // Flush the header bucket\n        let bucket = self.0.bucket::\u003c\u0026[u8], Vec\u003cu8\u003e\u003e(Some(\"header\"))?;\n        bucket.flush()?;\n        // Flush the block index\n        let bucket = self.0.bucket::\u003c\u0026[u8], Vec\u003cu8\u003e\u003e(Some(\"index\"))?;\n        bucket.flush()?;\n        // Flush the default bucket with meta-info\n        let bucket = self.0.bucket::\u003c\u0026[u8], Vec\u003cu8\u003e\u003e(None)?;\n        bucket.flush()?;\n        Ok(())\n    }\n    fn save_header(\u0026self, header: \u0026DiskBlockHeader) -\u003e Result\u003c(), Self::Error\u003e {\n        let ser_header = serialize(header);\n        let block_hash = serialize(\u0026header.block_hash());\n        let bucket = self.0.bucket::\u003c\u0026[u8], Vec\u003cu8\u003e\u003e(Some(\"header\"))?;\n        bucket.set(\u0026\u0026*block_hash, \u0026ser_header)?;\n        Ok(())\n    }\n\n    fn get_block_hash(\u0026self, height: u32) -\u003e Result\u003cOption\u003cBlockHash\u003e, Self::Error\u003e {\n        let bucket = self.0.bucket::\u003cInteger, Vec\u003cu8\u003e\u003e(Some(\"index\"))?;\n        let block = bucket.get(\u0026Integer::from(height))?;\n        if let Some(block) = block {\n            return Ok(Some(deserialize(\u0026block).unwrap()));\n        }\n        Ok(None)\n    }\n\n    fn update_block_index(\u0026self, height: u32, hash: BlockHash) -\u003e Result\u003c(), Self::Error\u003e {\n        let bucket = self.0.bucket::\u003cInteger, Vec\u003cu8\u003e\u003e(Some(\"index\"))?;\n        let block_hash = serialize(\u0026hash);\n\n        bucket.set(\u0026Integer::from(height), \u0026block_hash)?;\n        Ok(())\n    }\n}\n","traces":[{"line":23,"address":[1313872],"length":1,"stats":{"Line":9},"fn_name":null},{"line":24,"address":[1313904],"length":1,"stats":{"Line":9},"fn_name":null},{"line":26,"address":[1313936],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[1313946],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[1313981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[1314044],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[1314059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[1314093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[1314122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[1314015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[1314144],"length":1,"stats":{"Line":9},"fn_name":"deref"},{"line":40,"address":[1314154,1314308],"length":1,"stats":{"Line":18},"fn_name":null},{"line":41,"address":[1314189],"length":1,"stats":{"Line":9},"fn_name":null},{"line":42,"address":[1314231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[1314252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[1314273],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[1314294],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[1314210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[1141136],"length":1,"stats":{"Line":2},"fn_name":"consensus_decode\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[1142720],"length":1,"stats":{"Line":9},"fn_name":"consensus_encode\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":86,"address":[1142772,1142848],"length":1,"stats":{"Line":9},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":132,"address":[1314320],"length":1,"stats":{"Line":8},"fn_name":null},{"line":134,"address":[1314336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[1314568,1314400],"length":1,"stats":{"Line":8},"fn_name":null},{"line":139,"address":[1314518],"length":1,"stats":{"Line":9},"fn_name":null},{"line":144,"address":[1314886,1314640],"length":1,"stats":{"Line":1},"fn_name":"load_roots"},{"line":145,"address":[1314664,1314780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[1314761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[1314912,1315562,1315549],"length":1,"stats":{"Line":1},"fn_name":"save_roots"},{"line":149,"address":[1314941,1315031,1315117,1315560],"length":1,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[1315082,1315260],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[1315487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[1316712,1315584,1316792],"length":1,"stats":{"Line":0},"fn_name":"load_height"},{"line":156,"address":[1315737,1315609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[1316022,1316790,1315710,1315843],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[1316127,1315983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[1316380,1316167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[1316203],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[1316816,1317452],"length":1,"stats":{"Line":1},"fn_name":"save_height"},{"line":166,"address":[1316967,1316854],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[1316960],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[1317149,1317057],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[1317376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[1317488,1318726,1318837],"length":1,"stats":{"Line":3},"fn_name":"get_header"},{"line":172,"address":[1317660,1317518],"length":1,"stats":{"Line":3},"fn_name":null},{"line":173,"address":[1317653],"length":1,"stats":{"Line":3},"fn_name":null},{"line":175,"address":[1317750,1317830,1318069,1318823],"length":1,"stats":{"Line":6},"fn_name":null},{"line":176,"address":[1318030,1318174],"length":1,"stats":{"Line":5},"fn_name":null},{"line":177,"address":[1318214,1318415],"length":1,"stats":{"Line":4},"fn_name":null},{"line":179,"address":[1318250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[1318864,1320357,1320326],"length":1,"stats":{"Line":1},"fn_name":"flush"},{"line":183,"address":[1318893,1319021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[1319127,1320355,1319242,1319014],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[1319179,1319450,1320353,1319363],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[1319711,1320339,1319611,1319435],"length":1,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[1319663,1320337,1319832,1319919],"length":1,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[1320080,1320156,1319904],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[1320133],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[1321269,1321295,1320384],"length":1,"stats":{"Line":9},"fn_name":"save_header"},{"line":194,"address":[1320440],"length":1,"stats":{"Line":9},"fn_name":null},{"line":195,"address":[1320455,1320513],"length":1,"stats":{"Line":18},"fn_name":null},{"line":196,"address":[1320640,1320525,1320730,1321280],"length":1,"stats":{"Line":18},"fn_name":null},{"line":197,"address":[1320885,1320696],"length":1,"stats":{"Line":18},"fn_name":null},{"line":198,"address":[1321180],"length":1,"stats":{"Line":9},"fn_name":null},{"line":201,"address":[1322408,1321312,1322328],"length":1,"stats":{"Line":1},"fn_name":"get_block_hash"},{"line":202,"address":[1321493,1321348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[1322406,1321474,1321806,1321604],"length":1,"stats":{"Line":2},"fn_name":null},{"line":204,"address":[1321911,1321767],"length":1,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[1322114,1321951],"length":1,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[1321985],"length":1,"stats":{"Line":2},"fn_name":null},{"line":210,"address":[1322432,1323108],"length":1,"stats":{"Line":9},"fn_name":"update_block_index"},{"line":211,"address":[1322472,1322599],"length":1,"stats":{"Line":9},"fn_name":null},{"line":212,"address":[1322592],"length":1,"stats":{"Line":9},"fn_name":null},{"line":214,"address":[1322782,1322693],"length":1,"stats":{"Line":18},"fn_name":null},{"line":215,"address":[1323032],"length":1,"stats":{"Line":9},"fn_name":null}],"covered":94,"coverable":120},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-chain","src","pruned_utreexo","consensus.rs"],"content":"//! A collection of functions that implement the consensus rules for the Bitcoin Network.\n//! This module contains functions that are used to verify blocks and transactions, and doesn't\n//! assume anything about the chainstate, so it can be used in any context.\n//! We use this to avoid code reuse among the different implementations of the chainstate.\n\nextern crate alloc;\n\nuse core::ffi::c_uint;\nuse core::ops::Mul;\n\nuse bitcoin::block::Header as BlockHeader;\nuse bitcoin::consensus::Encodable;\nuse bitcoin::hashes::sha256;\nuse bitcoin::hashes::Hash;\nuse bitcoin::pow::U256;\nuse bitcoin::Block;\nuse bitcoin::BlockHash;\nuse bitcoin::OutPoint;\nuse bitcoin::Target;\nuse bitcoin::Transaction;\nuse bitcoin::TxOut;\nuse floresta_common::prelude::*;\nuse rustreexo::accumulator::node_hash::NodeHash;\nuse rustreexo::accumulator::proof::Proof;\nuse rustreexo::accumulator::stump::Stump;\nuse sha2::Digest;\nuse sha2::Sha512_256;\n\nuse super::chainparams::ChainParams;\nuse super::error::BlockValidationErrors;\nuse super::error::BlockchainError;\n\n/// The value of a single coin in satoshis.\npub const COIN_VALUE: u64 = 100_000_000;\n\n/// The version tag to be prepended to the leafhash. It's just the sha512 hash of the string\n/// `UtreexoV1` represented as a vector of [u8] ([85 116 114 101 101 120 111 86 49]).\n/// The same tag is \"5574726565786f5631\" as a hex string.\npub const UTREEXO_TAG_V1: [u8; 64] = [\n    0x5b, 0x83, 0x2d, 0xb8, 0xca, 0x26, 0xc2, 0x5b, 0xe1, 0xc5, 0x42, 0xd6, 0xcc, 0xed, 0xdd, 0xa8,\n    0xc1, 0x45, 0x61, 0x5c, 0xff, 0x5c, 0x35, 0x72, 0x7f, 0xb3, 0x46, 0x26, 0x10, 0x80, 0x7e, 0x20,\n    0xae, 0x53, 0x4d, 0xc3, 0xf6, 0x42, 0x99, 0x19, 0x99, 0x31, 0x77, 0x2e, 0x03, 0x78, 0x7d, 0x18,\n    0x15, 0x6e, 0xb3, 0x15, 0x1e, 0x0e, 0xd1, 0xb3, 0x09, 0x8b, 0xdc, 0x84, 0x45, 0x86, 0x18, 0x85,\n];\n\n/// This struct contains all the information and methods needed to validate a block,\n/// it is used by the [ChainState] to validate blocks and transactions.\n#[derive(Debug, Clone)]\npub struct Consensus {\n    /// The parameters of the chain we are validating, it is usually hardcoded\n    /// constants. See [ChainParams] for more information.\n    pub parameters: ChainParams,\n}\n\nimpl Consensus {\n    /// Returns the amount of block subsidy to be paid in a block, given it's height.\n    /// Bitcoin Core source: https://github.com/bitcoin/bitcoin/blob/2b211b41e36f914b8d0487e698b619039cc3c8e2/src/validation.cpp#L1501-L1512\n    pub fn get_subsidy(\u0026self, height: u32) -\u003e u64 {\n        let halvings = height / self.parameters.subsidy_halving_interval as u32;\n        // Force block reward to zero when right shift is undefined.\n        if halvings \u003e= 64 {\n            return 0;\n        }\n        let mut subsidy = 50 * COIN_VALUE;\n        // Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years.\n        subsidy \u003e\u003e= halvings;\n        subsidy\n    }\n\n    /// Returns the hash of a leaf node in the utreexo accumulator.\n    #[inline]\n    fn get_leaf_hashes(\n        transaction: \u0026Transaction,\n        vout: u32,\n        height: u32,\n        block_hash: BlockHash,\n    ) -\u003e sha256::Hash {\n        let header_code = height \u003c\u003c 1;\n\n        let mut ser_utxo = Vec::new();\n        let utxo = transaction.output.get(vout as usize).unwrap();\n        utxo.consensus_encode(\u0026mut ser_utxo).unwrap();\n        let header_code = if transaction.is_coinbase() {\n            header_code | 1\n        } else {\n            header_code\n        };\n\n        let leaf_hash = Sha512_256::new()\n            .chain_update(UTREEXO_TAG_V1)\n            .chain_update(UTREEXO_TAG_V1)\n            .chain_update(block_hash)\n            .chain_update(transaction.txid())\n            .chain_update(vout.to_le_bytes())\n            .chain_update(header_code.to_le_bytes())\n            .chain_update(ser_utxo)\n            .finalize();\n        sha256::Hash::from_slice(leaf_hash.as_slice())\n            .expect(\"parent_hash: Engines shouldn't be Err\")\n    }\n    /// Verify if all transactions in a block are valid. Here we check the following:\n    /// - The block must contain at least one transaction, and this transaction must be coinbase\n    /// - The first transaction in the block must be coinbase\n    /// - The coinbase transaction must have the correct value (subsidy + fees)\n    /// - The block must not create more coins than allowed\n    /// - All transactions must be valid:\n    ///     - The transaction must not be coinbase (already checked)\n    ///     - The transaction must not have duplicate inputs\n    ///     - The transaction must not spend more coins than it claims in the inputs\n    ///     - The transaction must have valid scripts\n    #[allow(unused)]\n    pub fn verify_block_transactions(\n        mut utxos: HashMap\u003cOutPoint, TxOut\u003e,\n        transactions: \u0026[Transaction],\n        subsidy: u64,\n        verify_script: bool,\n        flags: c_uint,\n    ) -\u003e Result\u003c(), BlockchainError\u003e {\n        // Blocks must contain at least one transaction\n        if transactions.is_empty() {\n            return Err(BlockValidationErrors::EmptyBlock.into());\n        }\n        let mut fee = 0;\n        // Skip the coinbase tx\n        for (n, transaction) in transactions.iter().enumerate() {\n            // We don't need to verify the coinbase inputs, as it spends newly generated coins\n            if transaction.is_coinbase() {\n                if n == 0 {\n                    continue;\n                }\n                // A block must contain only one coinbase, and it should be the fist thing inside it\n                return Err(BlockValidationErrors::FirstTxIsnNotCoinbase.into());\n            }\n            // Amount of all outputs\n            let output_value = transaction\n                .output\n                .iter()\n                .fold(0, |acc, tx| acc + tx.value.to_sat());\n            // Amount of all inputs\n            let in_value = transaction.input.iter().fold(0, |acc, input| {\n                acc + utxos\n                    .get(\u0026input.previous_output)\n                    .expect(\"We have all prevouts here\")\n                    .value\n                    .to_sat()\n            });\n            // Value in should be greater or equal to value out. Otherwise, inflation.\n            if output_value \u003e in_value {\n                return Err(BlockValidationErrors::NotEnoughMoney.into());\n            }\n            // Fee is the difference between inputs and outputs\n            fee += in_value - output_value;\n            // Verify the tx script\n            #[cfg(feature = \"bitcoinconsensus\")]\n            if verify_script {\n                transaction\n                    .verify_with_flags(|outpoint| utxos.remove(outpoint), flags)\n                    .map_err(|err| BlockValidationErrors::InvalidTx(alloc::format!(\"{:?}\", err)))?;\n            }\n        }\n        // In each block, the first transaction, and only the first, should be coinbase\n        if !transactions[0].is_coinbase() {\n            return Err(BlockValidationErrors::FirstTxIsnNotCoinbase.into());\n        }\n        // Checks if the miner isn't trying to create inflation\n        if fee + subsidy\n            \u003c transactions[0]\n                .output\n                .iter()\n                .fold(0, |acc, out| acc + out.value.to_sat())\n        {\n            return Err(BlockValidationErrors::BadCoinbaseOutValue.into());\n        }\n        Ok(())\n    }\n    /// Calculates the next target for the proof of work algorithm, given the\n    /// current target and the time it took to mine the last 2016 blocks.\n    pub fn calc_next_work_required(\n        last_block: \u0026BlockHeader,\n        first_block: \u0026BlockHeader,\n        params: ChainParams,\n    ) -\u003e Target {\n        let cur_target = last_block.target().0;\n\n        let expected_timespan = U256::from(params.pow_target_timespan);\n        let mut actual_timespan = last_block.time - first_block.time;\n\n        // Difficulty adjustments are limited, to prevent large swings in difficulty\n        // caused by malicious miners.\n        if actual_timespan \u003c params.pow_target_timespan as u32 / 4 {\n            actual_timespan = params.pow_target_timespan as u32 / 4;\n        }\n        if actual_timespan \u003e params.pow_target_timespan as u32 * 4 {\n            actual_timespan = params.pow_target_timespan as u32 * 4;\n        }\n\n        let new_target = cur_target.mul(actual_timespan.into());\n        let new_target = new_target / expected_timespan;\n        Target(new_target)\n    }\n    /// Updates our accumulator with the new block. This is done by calculating the new\n    /// root hash of the accumulator, and then verifying the proof of inclusion of the\n    /// deleted nodes. If the proof is valid, we return the new accumulator. Otherwise,\n    /// we return an error.\n    /// This function is pure, it doesn't modify the accumulator, but returns a new one.\n    pub fn update_acc(\n        acc: \u0026Stump,\n        block: \u0026Block,\n        height: u32,\n        proof: Proof,\n        del_hashes: Vec\u003csha256::Hash\u003e,\n    ) -\u003e Result\u003cStump, BlockchainError\u003e {\n        let block_hash = block.block_hash();\n        let mut leaf_hashes = Vec::new();\n        let del_hashes = del_hashes\n            .iter()\n            .map(|hash| NodeHash::from(hash.as_byte_array()))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        // Verify the proof of inclusion of the deleted nodes\n        if !acc.verify(\u0026proof, \u0026del_hashes)? {\n            return Err(BlockValidationErrors::InvalidProof.into());\n        }\n        // Get inputs from the block, we'll need this HashSet to check if an output is spent\n        // in the same block. If it is, we don't need to add it to the accumulator.\n        let mut block_inputs = HashSet::new();\n        for transaction in block.txdata.iter() {\n            for input in transaction.input.iter() {\n                block_inputs.insert((input.previous_output.txid, input.previous_output.vout));\n            }\n        }\n        // Get all leaf hashes that will be added to the accumulator\n        for transaction in block.txdata.iter() {\n            for (i, output) in transaction.output.iter().enumerate() {\n                if !output.script_pubkey.is_provably_unspendable()\n                    \u0026\u0026 !block_inputs.contains(\u0026(transaction.txid(), i as u32))\n                {\n                    leaf_hashes.push(Self::get_leaf_hashes(\n                        transaction,\n                        i as u32,\n                        height,\n                        block_hash,\n                    ))\n                }\n            }\n        }\n        // Convert the leaf hashes to NodeHashes used in Rustreexo\n        let hashes: Vec\u003cNodeHash\u003e = leaf_hashes\n            .iter()\n            .map(|\u0026hash| NodeHash::from(hash.as_byte_array()))\n            .collect();\n        // Update the accumulator\n        let acc = acc.modify(\u0026hashes, \u0026del_hashes, \u0026proof)?.0;\n        Ok(acc)\n    }\n}\n","traces":[{"line":58,"address":[1067760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[1067777,1067822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[1067815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[1067878],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[1067852,1067897,1067914],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[1067948,1067979,1067902],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[1067967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[1068032,1069075,1069044],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[1068085],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[1068106],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[1069088,1070967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[1069283,1069222],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[1069344,1070944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[1069305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[1069398,1069317,1069610],"length":1,"stats":{"Line":3},"fn_name":null},{"line":127,"address":[1069658,1070182],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[1070229],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[1070870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[1070196,1070254],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[1189648,1189671],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":140,"address":[1070322],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[1189781,1189788,1189860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[1189784],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[1070446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[1070484,1070847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[1070461,1070609,1070527],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[1070600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[1069189,1070673,1070812],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[1070665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[1070780],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[1069596,1069687],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[1069826,1069750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[1069793,1069884,1070059],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[1069870,1069925],"length":1,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[1190183,1190160],"length":1,"stats":{"Line":2},"fn_name":"{closure#4}"},{"line":172,"address":[1070152,1070093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[1070080],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[1072433,1071008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[1071237,1071074],"length":1,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[1071313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[1071601,1071523],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[1071647,1071745,1071571],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[1071714],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[1071662,1071761,1071921],"length":1,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[1071885,1071923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[1071800,1072011],"length":1,"stats":{"Line":2},"fn_name":null},{"line":198,"address":[1072180],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[1072325],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[1074813,1075728,1072464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[1072560],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[1072631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[1072646,1072726],"length":1,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[1190291,1190256],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":220,"address":[1072819,1072930,1075666],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[1073095,1073153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[1073138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[1073493,1073201,1073284],"length":1,"stats":{"Line":3},"fn_name":null},{"line":227,"address":[1073509,1075408],"length":1,"stats":{"Line":2},"fn_name":null},{"line":228,"address":[1075572],"length":1,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[1073764,1073466,1073559],"length":1,"stats":{"Line":3},"fn_name":null},{"line":233,"address":[1073788,1074877],"length":1,"stats":{"Line":2},"fn_name":null},{"line":234,"address":[1075119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":235,"address":[1075183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[1075357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[1075307],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[1075309],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[1073838,1073741],"length":1,"stats":{"Line":2},"fn_name":null},{"line":249,"address":[1190360,1190336],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":252,"address":[1074036,1073931],"length":1,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[1074586],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":60,"coverable":84},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-chain","src","pruned_utreexo","error.rs"],"content":"use core::fmt::Debug;\n\nuse bitcoin::blockdata::script;\n#[cfg(feature = \"cli-blockchain\")]\nuse btcd_rpc::error::UtreexodError;\nuse floresta_common::impl_error_from;\n\nuse crate::prelude::*;\npub trait DatabaseError: Debug + Send + Sync + 'static {}\n#[derive(Debug)]\npub enum BlockchainError {\n    BlockNotPresent,\n    #[cfg(feature = \"cli-blockchain\")]\n    #[error(\"Json-Rpc error\")]\n    JsonRpcError(#[from] UtreexodError),\n    Parsing(String),\n    BlockValidation(BlockValidationErrors),\n    InvalidProof,\n    UtreexoError(String),\n    Database(Box\u003cdyn DatabaseError\u003e),\n    ConsensusDecode(bitcoin::consensus::encode::Error),\n    ChainNotInitialized,\n    InvalidTip(String),\n    ScriptValidationFailed(script::Error),\n    Io(ioError),\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum BlockValidationErrors {\n    InvalidTx(String),\n    NotEnoughPow,\n    BadMerkleRoot,\n    BadWitnessCommitment,\n    NotEnoughMoney,\n    FirstTxIsnNotCoinbase,\n    BadCoinbaseOutValue,\n    EmptyBlock,\n    BlockExtendsAnOrphanChain,\n    BadBip34,\n    InvalidProof,\n    CoinbaseNotMatured,\n}\n\nimpl Display for BlockValidationErrors {\n    fn fmt(\u0026self, f: \u0026mut core::fmt::Formatter\u003c'_\u003e) -\u003e core::fmt::Result {\n        match self {\n            BlockValidationErrors::InvalidTx(e) =\u003e {\n                write!(f, \"This block contains an invalid transaction {}\", e)\n            }\n            BlockValidationErrors::NotEnoughPow =\u003e {\n                write!(f, \"This block doesn't have enough proof-of-work\")\n            }\n            BlockValidationErrors::BadMerkleRoot =\u003e write!(f, \"Wrong merkle root\"),\n            BlockValidationErrors::BadWitnessCommitment =\u003e write!(f, \"Wrong witness commitment\"),\n            BlockValidationErrors::NotEnoughMoney =\u003e {\n                write!(f, \"A transaction spends more than it should\")\n            }\n            BlockValidationErrors::FirstTxIsnNotCoinbase =\u003e {\n                write!(f, \"The first transaction in a block isn't a coinbase\")\n            }\n            BlockValidationErrors::BadCoinbaseOutValue =\u003e {\n                write!(f, \"Coinbase claims more bitcoins than it should\")\n            }\n            BlockValidationErrors::EmptyBlock =\u003e {\n                write!(f, \"This block is empty (doesn't have a coinbase tx)\")\n            }\n            BlockValidationErrors::BlockExtendsAnOrphanChain =\u003e {\n                write!(f, \"This block extends a chain we don't have the ancestors\")\n            }\n            BlockValidationErrors::BadBip34 =\u003e write!(f, \"BIP34 commitment mismatch\"),\n            BlockValidationErrors::InvalidProof =\u003e write!(f, \"Invalid proof\"),\n            BlockValidationErrors::CoinbaseNotMatured =\u003e {\n                write!(f, \"Coinbase not matured yet\")\n            }\n        }\n    }\n}\n\nimpl\u003cT: DatabaseError\u003e From\u003cT\u003e for BlockchainError {\n    fn from(value: T) -\u003e Self {\n        BlockchainError::Database(Box::new(value))\n    }\n}\n\nimpl_error_from!(BlockchainError, ioError, Io);\nimpl_error_from!(\n    BlockchainError,\n    bitcoin::consensus::encode::Error,\n    ConsensusDecode\n);\nimpl_error_from!(BlockchainError, BlockValidationErrors, BlockValidation);\nimpl_error_from!(BlockchainError, String, UtreexoError);\nimpl_error_from!(BlockchainError, script::Error, ScriptValidationFailed);\n\nimpl Display for BlockchainError {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{:?}\", self)\n    }\n}\n\nimpl DatabaseError for kv::Error {}\nimpl core2::error::Error for BlockchainError {}\n","traces":[{"line":45,"address":[3276992],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":46,"address":[1363952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[1363987],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[1304744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[3277196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[1364173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[3277300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[1304971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[3277410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[3277465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[1305136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[1305191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[1305246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[1305298],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[1305350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[1305424],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":97,"address":[1305484],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":19},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-chain","src","pruned_utreexo","mod.rs"],"content":"extern crate alloc;\n\npub mod chain_state;\npub mod chain_state_builder;\npub mod chainparams;\npub mod chainstore;\npub mod consensus;\npub mod error;\npub mod partial_chain;\npub mod udata;\n\nuse alloc::sync::Arc;\n\nuse bitcoin::block::Header as BlockHeader;\nuse bitcoin::hashes::sha256;\nuse bitcoin::p2p::utreexo::UtreexoBlock;\nuse bitcoin::Block;\nuse bitcoin::BlockHash;\nuse bitcoin::OutPoint;\nuse bitcoin::Transaction;\nuse bitcoin::TxOut;\nuse rustreexo::accumulator::node_hash::NodeHash;\nuse rustreexo::accumulator::proof::Proof;\nuse rustreexo::accumulator::stump::Stump;\n\nuse self::partial_chain::PartialChainState;\nuse crate::prelude::*;\nuse crate::BestChain;\nuse crate::BlockConsumer;\nuse crate::BlockchainError;\nuse crate::DatabaseError;\nuse crate::DiskBlockHeader;\n\n/// This trait is the main interface between our blockchain backend and other services.\n/// It'll be useful for transitioning from rpc to a p2p based node\npub trait BlockchainInterface {\n    type Error: core2::error::Error + Send + Sync + 'static;\n    /// Returns the block with a given height in our current tip.\n    fn get_block_hash(\u0026self, height: u32) -\u003e Result\u003cbitcoin::BlockHash, Self::Error\u003e;\n    /// Returns a bitcoin [Transaction] given it's txid.\n    fn get_tx(\u0026self, txid: \u0026bitcoin::Txid) -\u003e Result\u003cOption\u003cbitcoin::Transaction\u003e, Self::Error\u003e;\n    /// Get the height of our best know chain.\n    fn get_height(\u0026self) -\u003e Result\u003cu32, Self::Error\u003e;\n    /// Broadcasts a transaction to the network.\n    fn broadcast(\u0026self, tx: \u0026bitcoin::Transaction) -\u003e Result\u003c(), Self::Error\u003e;\n    /// Returns fee estimation for inclusion in `target` blocks.\n    fn estimate_fee(\u0026self, target: usize) -\u003e Result\u003cf64, Self::Error\u003e;\n    /// Returns a block with a given `hash` if any.\n    fn get_block(\u0026self, hash: \u0026BlockHash) -\u003e Result\u003cBlock, Self::Error\u003e;\n    /// Returns the best known block\n    fn get_best_block(\u0026self) -\u003e Result\u003c(u32, BlockHash), Self::Error\u003e;\n    /// Returns associated header for block with `hash`\n    fn get_block_header(\u0026self, hash: \u0026BlockHash) -\u003e Result\u003cBlockHeader, Self::Error\u003e;\n    /// Register for receiving notifications for some event. Right now it only works for\n    /// new blocks, but may work with transactions in the future too.\n    /// if a module performs some heavy-lifting on the block's data, it should pass in a\n    /// vector or a channel where data can be  transfered to the atual worker, otherwise\n    /// chainstate will be stuck for as long as you have work to do.\n    fn subscribe(\u0026self, tx: Arc\u003cdyn BlockConsumer\u003e);\n    /// Tells whether or not we are on ibd\n    fn is_in_idb(\u0026self) -\u003e bool;\n    /// Returns the list of unbroadcasted transactions.\n    fn get_unbroadcasted(\u0026self) -\u003e Vec\u003cTransaction\u003e;\n    /// Checks if a coinbase is mature\n    fn is_coinbase_mature(\u0026self, height: u32, block: BlockHash) -\u003e Result\u003cbool, Self::Error\u003e;\n    /// Returns a block locator\n    fn get_block_locator(\u0026self) -\u003e Result\u003cVec\u003cBlockHash\u003e, Self::Error\u003e;\n    /// Returns a block locator from a given tip\n    ///\n    /// This method may be used to get the locator from a tip that's not the best one\n    fn get_block_locator_for_tip(\u0026self, tip: BlockHash) -\u003e Result\u003cVec\u003cBlockHash\u003e, BlockchainError\u003e;\n    /// Returns the last block we validated\n    fn get_validation_index(\u0026self) -\u003e Result\u003cu32, Self::Error\u003e;\n    /// Triggers a rescan, downloading (but not validating) all blocks in [start_height:tip]\n    fn rescan(\u0026self, start_height: u32) -\u003e Result\u003c(), Self::Error\u003e;\n    /// Returns where we are in the rescan\n    fn get_rescan_index(\u0026self) -\u003e Option\u003cu32\u003e;\n    /// Returns the height of a block, given it's hash\n    fn get_block_height(\u0026self, hash: \u0026BlockHash) -\u003e Result\u003cOption\u003cu32\u003e, Self::Error\u003e;\n    fn update_acc(\n        \u0026self,\n        acc: Stump,\n        block: UtreexoBlock,\n        height: u32,\n        proof: Proof,\n        del_hashes: Vec\u003csha256::Hash\u003e,\n    ) -\u003e Result\u003cStump, Self::Error\u003e;\n\n    fn get_chain_tips(\u0026self) -\u003e Result\u003cVec\u003cBlockHash\u003e, Self::Error\u003e;\n\n    fn validate_block(\n        \u0026self,\n        block: \u0026Block,\n        proof: Proof,\n        inputs: HashMap\u003cOutPoint, TxOut\u003e,\n        del_hashes: Vec\u003csha256::Hash\u003e,\n        acc: Stump,\n    ) -\u003e Result\u003c(), Self::Error\u003e;\n\n    fn get_fork_point(\u0026self, block: BlockHash) -\u003e Result\u003cBlockHash, Self::Error\u003e;\n}\n/// [UpdatableChainstate] is a contract that a is expected from a chainstate\n/// implementation, that wishes to be updated. Using those methods, a backend like the p2p-node,\n/// can notify new blocks and transactions to a chainstate, allowing it to update it's state.\npub trait UpdatableChainstate {\n    /// This is one of the most important methods for a ChainState,\n    /// it gets a block and some utreexo data, validates this block and\n    /// connects to our chain of blocks. This function is meant to be atomic\n    /// and prone of running in parallel.\n    fn connect_block(\n        \u0026self,\n        block: \u0026Block,\n        proof: Proof,\n        inputs: HashMap\u003cOutPoint, TxOut\u003e,\n        del_hashes: Vec\u003csha256::Hash\u003e,\n    ) -\u003e Result\u003cu32, BlockchainError\u003e;\n\n    fn switch_chain(\u0026self, new_tip: BlockHash) -\u003e Result\u003c(), BlockchainError\u003e;\n    /// Accepts a new header to our chain. This method is called before connect_block, and\n    /// makes some basic checks on a header and saves it on disk. We only accept a block as\n    /// valid after calling connect_block.\n    ///\n    /// This function returns whether this block is on our best-known chain, or in a fork\n    fn accept_header(\u0026self, header: BlockHeader) -\u003e Result\u003c(), BlockchainError\u003e;\n    /// Not used for now, but in a future blockchain with mempool, we can process transactions\n    /// that are not in a block yet.\n    fn handle_transaction(\u0026self) -\u003e Result\u003c(), BlockchainError\u003e;\n    /// Persists our data. Should be invoked periodically.\n    fn flush(\u0026self) -\u003e Result\u003c(), BlockchainError\u003e;\n    /// Toggle ibd on/off\n    fn toggle_ibd(\u0026self, is_ibd: bool);\n    /// Tells this blockchain to consider this block invalid, and not build on top of it\n    fn invalidate_block(\u0026self, block: BlockHash) -\u003e Result\u003c(), BlockchainError\u003e;\n    /// Marks one block as being fully validated, this overrides a block that was explicitly\n    /// marked as invalid.\n    fn mark_block_as_valid(\u0026self, block: BlockHash) -\u003e Result\u003c(), BlockchainError\u003e;\n    /// Gives a requested block for rescan\n    fn process_rescan_block(\u0026self, block: \u0026Block) -\u003e Result\u003c(), BlockchainError\u003e;\n    /// Returns the root hashes of our utreexo forest\n    fn get_root_hashes(\u0026self) -\u003e Vec\u003cNodeHash\u003e;\n    /// Returns a partial chainstate from a range of blocks.\n    ///\n    /// [PartialChainState] is a simplified version of `ChainState` that is used during IBD.\n    /// It doesn't suport reorgs, only hold headers for a subset of blocks and isn't [Sync].\n    /// The idea here is that you take a OS thread or some async task that will drive one\n    /// [PartialChainState] to completion by downloading blocks inside that chainstate's range.\n    /// If all goes right, it'll end without error, and you should mark blocks in this range as\n    /// valid.\n    ///\n    /// Since this chainstate may start from a height with an existing UTXO set, you need to\n    /// provide a [Stump] for that block.\n    fn get_partial_chain(\n        \u0026self,\n        initial_height: u32,\n        final_height: u32,\n        acc: Stump,\n    ) -\u003e Result\u003cPartialChainState, BlockchainError\u003e;\n    /// Marks a chain as fully-valid\n    ///\n    /// This mimics the behavour of checking every block before this block, and continues\n    /// from this point\n    fn mark_chain_as_assumed(\u0026self, acc: Stump) -\u003e Result\u003cbool, BlockchainError\u003e;\n}\n\n/// [ChainStore] is a trait defining how we interact with our chain database. This definitions\n/// will be used by the [ChainState] to save and retrieve data about the blockchain, likely\n/// on disk.\n/// Right now, you can use the [KvChainStore] in your code, it implements this trait and\n/// uses a key-value store to save data.\n/// The [DatabaseError] is a simple trait that can be implemented by any error type that\n/// implements [std::error::Error] and [std::fmt::Display]. This is useful to abstract\n/// the database implementation from the blockchain.\n/// See the documentation of [DatabaseError] for more info.\npub trait ChainStore {\n    type Error: DatabaseError;\n    /// Saves the current state of our accumulator.\n    fn save_roots(\u0026self, roots: Vec\u003cu8\u003e) -\u003e Result\u003c(), Self::Error\u003e;\n    /// Loads the state of our accumulator.\n    fn load_roots(\u0026self) -\u003e Result\u003cOption\u003cVec\u003cu8\u003e\u003e, Self::Error\u003e;\n    /// Loads the blockchain height\n    fn load_height(\u0026self) -\u003e Result\u003cOption\u003cBestChain\u003e, Self::Error\u003e;\n    /// Saves the blockchain height.\n    fn save_height(\u0026self, height: \u0026BestChain) -\u003e Result\u003c(), Self::Error\u003e;\n    /// Get a block header from our database. See [DiskBlockHeader] for more info about\n    /// the data we save.\n    fn get_header(\u0026self, block_hash: \u0026BlockHash) -\u003e Result\u003cOption\u003cDiskBlockHeader\u003e, Self::Error\u003e;\n    /// Saves a block header to our database. See [DiskBlockHeader] for more info about\n    /// the data we save.\n    fn save_header(\u0026self, header: \u0026DiskBlockHeader) -\u003e Result\u003c(), Self::Error\u003e;\n    /// Returns the block hash for a given height.\n    fn get_block_hash(\u0026self, height: u32) -\u003e Result\u003cOption\u003cBlockHash\u003e, Self::Error\u003e;\n    /// Flushes write buffers to disk, this is called periodically by the [ChainState],\n    /// so in case of a crash, we don't lose too much data. If the database doesn't support\n    /// write buffers, this method can be a no-op.\n    fn flush(\u0026self) -\u003e Result\u003c(), Self::Error\u003e;\n    /// Associates a block hash with a given height, so we can retrieve it later.\n    fn update_block_index(\u0026self, height: u32, hash: BlockHash) -\u003e Result\u003c(), Self::Error\u003e;\n}\n\n#[derive(Debug, Clone)]\n/// A notification is a hook that a type implementing [BlockchainInterface] sends each\n/// time the given event happens. This is use to notify new blocks to the Electrum server.\n/// In the future, it can be expanded to send more data, like transactions.\npub enum Notification {\n    NewBlock((Block, u32)),\n}\n\nimpl\u003cT: UpdatableChainstate\u003e UpdatableChainstate for Arc\u003cT\u003e {\n    fn flush(\u0026self) -\u003e Result\u003c(), BlockchainError\u003e {\n        T::flush(self)\n    }\n\n    fn toggle_ibd(\u0026self, is_ibd: bool) {\n        T::toggle_ibd(self, is_ibd)\n    }\n\n    fn connect_block(\n        \u0026self,\n        block: \u0026Block,\n        proof: Proof,\n        inputs: HashMap\u003cOutPoint, TxOut\u003e,\n        del_hashes: Vec\u003csha256::Hash\u003e,\n    ) -\u003e Result\u003cu32, BlockchainError\u003e {\n        T::connect_block(self, block, proof, inputs, del_hashes)\n    }\n\n    fn accept_header(\u0026self, header: BlockHeader) -\u003e Result\u003c(), BlockchainError\u003e {\n        T::accept_header(self, header)\n    }\n\n    fn get_root_hashes(\u0026self) -\u003e Vec\u003cNodeHash\u003e {\n        T::get_root_hashes(self)\n    }\n\n    fn invalidate_block(\u0026self, block: BlockHash) -\u003e Result\u003c(), BlockchainError\u003e {\n        T::invalidate_block(self, block)\n    }\n\n    fn get_partial_chain(\n        \u0026self,\n        initial_height: u32,\n        final_height: u32,\n        acc: Stump,\n    ) -\u003e Result\u003cPartialChainState, BlockchainError\u003e {\n        T::get_partial_chain(self, initial_height, final_height, acc)\n    }\n\n    fn handle_transaction(\u0026self) -\u003e Result\u003c(), BlockchainError\u003e {\n        T::handle_transaction(self)\n    }\n\n    fn switch_chain(\u0026self, new_tip: BlockHash) -\u003e Result\u003c(), BlockchainError\u003e {\n        T::switch_chain(self, new_tip)\n    }\n\n    fn process_rescan_block(\u0026self, block: \u0026Block) -\u003e Result\u003c(), BlockchainError\u003e {\n        T::process_rescan_block(self, block)\n    }\n\n    fn mark_block_as_valid(\u0026self, block: BlockHash) -\u003e Result\u003c(), BlockchainError\u003e {\n        T::mark_block_as_valid(self, block)\n    }\n\n    fn mark_chain_as_assumed(\u0026self, acc: Stump) -\u003e Result\u003cbool, BlockchainError\u003e {\n        T::mark_chain_as_assumed(self, acc)\n    }\n}\n\nimpl\u003cT: BlockchainInterface\u003e BlockchainInterface for Arc\u003cT\u003e {\n    type Error = \u003cT as BlockchainInterface\u003e::Error;\n\n    fn get_tx(\u0026self, txid: \u0026bitcoin::Txid) -\u003e Result\u003cOption\u003cbitcoin::Transaction\u003e, Self::Error\u003e {\n        T::get_tx(self, txid)\n    }\n\n    fn rescan(\u0026self, start_height: u32) -\u003e Result\u003c(), Self::Error\u003e {\n        T::rescan(self, start_height)\n    }\n\n    fn broadcast(\u0026self, tx: \u0026bitcoin::Transaction) -\u003e Result\u003c(), Self::Error\u003e {\n        T::broadcast(self, tx)\n    }\n\n    fn get_block(\u0026self, hash: \u0026BlockHash) -\u003e Result\u003cBlock, Self::Error\u003e {\n        T::get_block(self, hash)\n    }\n\n    fn subscribe(\u0026self, tx: Arc\u003cdyn BlockConsumer\u003e) {\n        T::subscribe(self, tx)\n    }\n\n    fn is_in_idb(\u0026self) -\u003e bool {\n        T::is_in_idb(self)\n    }\n\n    fn get_height(\u0026self) -\u003e Result\u003cu32, Self::Error\u003e {\n        T::get_height(self)\n    }\n\n    fn estimate_fee(\u0026self, target: usize) -\u003e Result\u003cf64, Self::Error\u003e {\n        T::estimate_fee(self, target)\n    }\n\n    fn get_block_hash(\u0026self, height: u32) -\u003e Result\u003cbitcoin::BlockHash, Self::Error\u003e {\n        T::get_block_hash(self, height)\n    }\n\n    fn get_best_block(\u0026self) -\u003e Result\u003c(u32, BlockHash), Self::Error\u003e {\n        T::get_best_block(self)\n    }\n\n    fn get_block_header(\u0026self, hash: \u0026BlockHash) -\u003e Result\u003cBlockHeader, Self::Error\u003e {\n        T::get_block_header(self, hash)\n    }\n\n    fn get_rescan_index(\u0026self) -\u003e Option\u003cu32\u003e {\n        T::get_rescan_index(self)\n    }\n\n    fn get_block_height(\u0026self, hash: \u0026BlockHash) -\u003e Result\u003cOption\u003cu32\u003e, Self::Error\u003e {\n        T::get_block_height(self, hash)\n    }\n\n    fn get_unbroadcasted(\u0026self) -\u003e Vec\u003cTransaction\u003e {\n        T::get_unbroadcasted(self)\n    }\n\n    fn get_block_locator(\u0026self) -\u003e Result\u003cVec\u003cBlockHash\u003e, Self::Error\u003e {\n        T::get_block_locator(self)\n    }\n\n    fn is_coinbase_mature(\u0026self, height: u32, block: BlockHash) -\u003e Result\u003cbool, Self::Error\u003e {\n        T::is_coinbase_mature(self, height, block)\n    }\n\n    fn get_validation_index(\u0026self) -\u003e Result\u003cu32, Self::Error\u003e {\n        T::get_validation_index(self)\n    }\n\n    fn get_block_locator_for_tip(\u0026self, tip: BlockHash) -\u003e Result\u003cVec\u003cBlockHash\u003e, BlockchainError\u003e {\n        T::get_block_locator_for_tip(self, tip)\n    }\n\n    fn update_acc(\n        \u0026self,\n        acc: Stump,\n        block: UtreexoBlock,\n        height: u32,\n        proof: Proof,\n        del_hashes: Vec\u003csha256::Hash\u003e,\n    ) -\u003e Result\u003cStump, Self::Error\u003e {\n        T::update_acc(self, acc, block, height, proof, del_hashes)\n    }\n\n    fn get_chain_tips(\u0026self) -\u003e Result\u003cVec\u003cBlockHash\u003e, Self::Error\u003e {\n        T::get_chain_tips(self)\n    }\n\n    fn validate_block(\n        \u0026self,\n        block: \u0026Block,\n        proof: Proof,\n        inputs: HashMap\u003cOutPoint, TxOut\u003e,\n        del_hashes: Vec\u003csha256::Hash\u003e,\n        acc: Stump,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        T::validate_block(self, block, proof, inputs, del_hashes, acc)\n    }\n\n    fn get_fork_point(\u0026self, block: BlockHash) -\u003e Result\u003cBlockHash, Self::Error\u003e {\n        T::get_fork_point(self, block)\n    }\n}\n","traces":[{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[4726432,4726800,4726839],"length":1,"stats":{"Line":0},"fn_name":"connect_block\u003cfloresta_chain::pruned_utreexo::chain_state::ChainState\u003cfloresta_chain::pruned_utreexo::chainstore::KvChainStore\u003e\u003e"},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[4727248,4727221,4727056],"length":1,"stats":{"Line":0},"fn_name":"get_partial_chain\u003cfloresta_chain::pruned_utreexo::chain_state::ChainState\u003cfloresta_chain::pruned_utreexo::chainstore::KvChainStore\u003e\u003e"},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[4724400,4724333,4723888],"length":1,"stats":{"Line":0},"fn_name":"update_acc\u003cfloresta_chain::pruned_utreexo::chain_state::ChainState\u003cfloresta_chain::pruned_utreexo::chainstore::KvChainStore\u003e\u003e"},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[4724752,4725211,4725278],"length":1,"stats":{"Line":0},"fn_name":"validate_block\u003cfloresta_chain::pruned_utreexo::chain_state::ChainState\u003cfloresta_chain::pruned_utreexo::chainstore::KvChainStore\u003e\u003e"},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":68},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-chain","src","pruned_utreexo","partial_chain.rs"],"content":"//! A partial chain is a chain that only contains a subset of the blocks in the\n//! full chain. We use multiple partial chains to sync up with the full chain,\n//! and then merge them together to get the full chain. This allows us to make\n//! Initial Block Download in parallel.\n//!\n//! We use a [PartialChainState] insted of the useal ChainState, mainly for\n//! performance. Because we assume that only one worker will hold a [PartialChainState]\n//! at a given time, we can drop all syncronization primitives and make a really performatic\n//! ChainState that will consume and validate blocks as fast as we possibly can.\n//!\n//! This choice removes the use of costly atomic operations, but opens space for design flaws\n//! and memory unsoundness, so here are some tips about this module and how people looking for\n//! extend or use this code should proceed:\n//!   \n//!   - Shared ownership is forbidden: if you have two threads or tasks owning this, you'll have\n//!     data race. If you want to hold shared ownership for this module, you need to place a\n//!     [PartialChainState] inside an `Arc\u003cMutex\u003e` yourself. Don't just Arc this and expect it to\n//!     work, as you are garanteed to have data races.\n//!   - The interior is toxic, so no peeking: no references, mutable or not, to any field should\n//!     leak through the API, as we are not enforcing lifetime or borrowing rules at compile time.\n//!   - Sending is fine: There's nothing in this module that makes it not sendable to between\n//!     threads, as long as the origin thread gives away the ownership.\nuse bitcoin::BlockHash;\nuse floresta_common::prelude::*;\nextern crate alloc;\n\nuse core::cell::UnsafeCell;\n#[cfg(feature = \"bitcoinconsensus\")]\nuse core::ffi::c_uint;\n\n#[cfg(feature = \"bitcoinconsensus\")]\nuse bitcoin::bitcoinconsensus;\nuse bitcoin::block::Header as BlockHeader;\nuse log::info;\nuse rustreexo::accumulator::stump::Stump;\n\nuse super::chainparams::ChainParams;\nuse super::consensus::Consensus;\nuse super::error::BlockValidationErrors;\nuse super::error::BlockchainError;\nuse super::BlockchainInterface;\nuse super::UpdatableChainstate;\n\n#[doc(hidden)]\n#[derive(Debug)]\npub(crate) struct PartialChainStateInner {\n    /// The current accumulator state, it starts with a hardcoded value and\n    /// gets checked against the result of the previous partial chainstate.\n    pub(crate) current_acc: Stump,\n    /// The block headers in this interval, we need this to verify the blocks\n    /// and to build the accumulator. We assume this is sorted by height, and\n    /// should contains all blocks in this interval.\n    pub(crate) blocks: Vec\u003cBlockHeader\u003e,\n    /// The height this interval starts at. This [initial_height, final_height), so\n    /// if we break the interval at height 100, the first interval will be [0, 100)\n    /// and the second interval will be [100, 200). And the initial height of the\n    /// second interval will be 99.\n    pub(crate) initial_height: u32,\n    /// The height we are on right now, this is used to keep track of the progress\n    /// of the sync.\n    pub(crate) current_height: u32,\n    /// The height we are syncing up to, trying to push more blocks than this will\n    /// result in an error.\n    pub(crate) final_height: u32,\n    /// The error that occurred during validation, if any. It is here so we can\n    /// pull that afterwords.\n    pub(crate) error: Option\u003cBlockValidationErrors\u003e,\n    /// The consensus parameters, we need this to validate the blocks.\n    pub(crate) consensus: Consensus,\n    /// Whether we assume the signatures in this interval as valid, this is used to\n    /// speed up syncing, by assuming signatures in old blocks are valid.\n    pub(crate) assume_valid: bool,\n}\n\n/// A partial chain is a chain that only contains a subset of the blocks in the\n/// full chain. We use multiple partial chains to sync up with the full chain,\n/// and then merge them together to get the full chain. This allows us to conduct\n/// the sync in parallel. To build one, we need to know the initial\n/// height, the final height, and the block headers in between.\n///\n/// We need to modify our current state as-we-go, but we also need to use the main\n/// traits that define a chainstate. Most cruccially, both crates don't take a mutable\n/// reference in any method, so we need some form of interior mutability.\n/// We could just use a mutex, but this is not required and very wateful. Partial chains\n/// differ from the normal chain because they only have one owner, the worker responsible\n/// for driving this chain to it's completion. Because of that, we can simply use a UnsafeCell\n/// and forbit shared access between threads by not implementing [Clone].\npub struct PartialChainState(pub(crate) UnsafeCell\u003cPartialChainStateInner\u003e);\n\n/// We need to send [PartialChainState] between threads/tasks, because the worker thread, once it\n/// finishes, needs to notify the main task and pass the final partial chain.\n/// # Safety\n///\n/// All itens inside the [UnsafeCell] are [Send], most importantly, there are no references or\n/// smart pointers inside it, so sending shouldn't be a problem.\nunsafe impl Send for PartialChainState {}\nunsafe impl Sync for PartialChainState {}\n\nimpl PartialChainStateInner {\n    /// Returns the height we have synced up to so far\n    pub fn current_height(\u0026self) -\u003e u32 {\n        self.current_height\n    }\n\n    /// Whether or not we have synced up to the final height\n    pub fn is_sync(\u0026self) -\u003e bool {\n        self.current_height == self.final_height\n    }\n\n    pub fn get_block(\u0026self, height: u32) -\u003e Option\u003c\u0026BlockHeader\u003e {\n        let index = height - self.initial_height;\n        self.blocks.get(index as usize)\n    }\n\n    #[cfg(feature = \"bitcoinconsensus\")]\n    /// Returns the validation flags, given the current block height\n    fn get_validation_flags(\u0026self, height: u32) -\u003e c_uint {\n        let chains_params = \u0026self.consensus.parameters;\n        let hash = self.get_block(height).unwrap().block_hash();\n        if let Some(flag) = chains_params.exceptions.get(\u0026hash) {\n            return *flag;\n        }\n        // From Bitcoin Core:\n        // BIP16 didn't become active until Apr 1 2012 (on mainnet, and\n        // retroactively applied to testnet)\n        // However, only one historical block violated the P2SH rules (on both\n        // mainnet and testnet).\n        // Similarly, only one historical block violated the TAPROOT rules on\n        // mainnet.\n        // For simplicity, always leave P2SH+WITNESS+TAPROOT on except for the two\n        // violating blocks.\n        let mut flags = bitcoinconsensus::VERIFY_P2SH | bitcoinconsensus::VERIFY_WITNESS;\n\n        if height \u003e= chains_params.bip65_activation_height {\n            flags |= bitcoinconsensus::VERIFY_CHECKLOCKTIMEVERIFY;\n        }\n        if height \u003e= chains_params.bip66_activation_height {\n            flags |= bitcoinconsensus::VERIFY_DERSIG;\n        }\n        if height \u003e= chains_params.csv_activation_height {\n            flags |= bitcoinconsensus::VERIFY_CHECKSEQUENCEVERIFY;\n        }\n        if height \u003e= chains_params.segwit_activation_height {\n            flags |= bitcoinconsensus::VERIFY_NULLDUMMY;\n        }\n        flags\n    }\n\n    #[inline]\n    /// Update our internal state, given a new height and accumulator\n    fn update_state(\u0026mut self, height: u32, acc: Stump) {\n        self.current_height = height;\n        self.current_acc = acc;\n    }\n\n    #[inline]\n    /// Returns the parameters for this chain\n    fn chain_params(\u0026self) -\u003e ChainParams {\n        self.consensus.parameters.clone()\n    }\n\n    #[inline]\n    /// Returns the ancestor for a given block header\n    fn get_ancestor(\u0026self, height: u32) -\u003e Result\u003cBlockHeader, BlockchainError\u003e {\n        let prev = self.get_block(height - 1).unwrap();\n        Ok(*prev)\n    }\n\n    /// Process a block, given the proof, inputs, and deleted hashes. If we find an error,\n    /// we save it.\n    pub fn process_block(\n        \u0026mut self,\n        block: \u0026bitcoin::Block,\n        proof: rustreexo::accumulator::proof::Proof,\n        inputs: HashMap\u003cbitcoin::OutPoint, bitcoin::TxOut\u003e,\n        del_hashes: Vec\u003cbitcoin::hashes::sha256::Hash\u003e,\n    ) -\u003e Result\u003cu32, BlockchainError\u003e {\n        let height = self.current_height + 1;\n\n        if let Err(BlockchainError::BlockValidation(e)) = self.validate_block(block, height, inputs)\n        {\n            self.error = Some(e.clone());\n            return Err(BlockchainError::BlockValidation(e));\n        }\n\n        let acc = match Consensus::update_acc(\u0026self.current_acc, block, height, proof, del_hashes) {\n            Ok(acc) =\u003e acc,\n            Err(_) =\u003e {\n                self.error = Some(BlockValidationErrors::InvalidProof);\n                return Err(BlockchainError::InvalidProof);\n            }\n        };\n\n        // ... If we came this far, we consider this block valid ...\n\n        if height % 10_000 == 0 {\n            info!(\n                \"Downloading blocks: height={height} hash={}\",\n                block.block_hash()\n            );\n        }\n        self.update_state(height, acc);\n\n        Ok(height)\n    }\n\n    /// Check whether a block is valid\n    fn validate_block(\n        \u0026self,\n        block: \u0026bitcoin::Block,\n        height: u32,\n        inputs: HashMap\u003cbitcoin::OutPoint, bitcoin::TxOut\u003e,\n    ) -\u003e Result\u003c(), BlockchainError\u003e {\n        if !block.check_merkle_root() {\n            return Err(BlockchainError::BlockValidation(\n                BlockValidationErrors::BadMerkleRoot,\n            ));\n        }\n        if height \u003e= self.chain_params().bip34_activation_height\n            \u0026\u0026 block.bip34_block_height() != Ok(height as u64)\n        {\n            return Err(BlockchainError::BlockValidation(\n                BlockValidationErrors::BadBip34,\n            ));\n        }\n        if !block.check_witness_commitment() {\n            return Err(BlockchainError::BlockValidation(\n                BlockValidationErrors::BadWitnessCommitment,\n            ));\n        }\n        let prev_block = self.get_ancestor(height)?;\n        if block.header.prev_blockhash != prev_block.block_hash() {\n            return Err(BlockchainError::BlockValidation(\n                BlockValidationErrors::BlockExtendsAnOrphanChain,\n            ));\n        }\n        // Validate block transactions\n        let subsidy = self.consensus.get_subsidy(height);\n        let verify_script = self.assume_valid;\n        #[cfg(feature = \"bitcoinconsensus\")]\n        let flags = self.get_validation_flags(height);\n        #[cfg(not(feature = \"bitcoinconsensus\"))]\n        let flags = 0;\n        Consensus::verify_block_transactions(inputs, \u0026block.txdata, subsidy, verify_script, flags)?;\n        Ok(())\n    }\n}\n\nimpl PartialChainState {\n    /// Borrows the inner content as immutable referece.\n    ///\n    /// # Safety\n    /// We can assume this [UnsafeCell] is initialized because the only way to get a\n    /// [PartialChainState] is through our APIs, and we make sure this [UnsafeCell] is\n    /// always valid.\n    /// The reference returned here **should not** leak through the API, as there's no\n    /// syncronization mechanims for it.\n    #[inline(always)]\n    #[must_use]\n    #[doc(hidden)]\n    fn inner(\u0026self) -\u003e \u0026PartialChainStateInner {\n        unsafe { self.0.get().as_ref().expect(\"this pointer is valid\") }\n    }\n\n    /// Borrows the inner content as a mutable referece.\n    ///\n    /// # Safety\n    /// We can assume this [UnsafeCell] is initialized because the only way to get a\n    /// [PartialChainState] is through our APIs, and we make sure this [UnsafeCell] is\n    /// always valid.\n    /// The reference returned here **should not** leak through the API, as there's no\n    /// syncronization mechanims for it.\n    #[inline(always)]\n    #[allow(clippy::mut_from_ref)]\n    #[must_use]\n    #[doc(hidden)]\n    fn inner_mut(\u0026self) -\u003e \u0026mut PartialChainStateInner {\n        unsafe { self.0.get().as_mut().expect(\"this pointer is valid\") }\n    }\n\n    /// Returns all blocks in this partial chain\n    pub fn list_blocks(\u0026self) -\u003e \u0026[BlockHeader] {\n        \u0026self.inner().blocks\n    }\n\n    /// Returns all block we have validated so far in this chain\n    pub fn list_valid_blocks(\u0026self) -\u003e Vec\u003c\u0026BlockHeader\u003e {\n        self.inner()\n            .blocks\n            .iter()\n            .take(self.inner().current_height as usize)\n            .collect()\n    }\n\n    /// Returns whether any block inside this interval is invalid\n    pub fn has_invalid_blocks(\u0026self) -\u003e bool {\n        self.inner().error.is_some()\n    }\n}\n\nimpl UpdatableChainstate for PartialChainState {\n    fn connect_block(\n        \u0026self,\n        block: \u0026bitcoin::Block,\n        proof: rustreexo::accumulator::proof::Proof,\n        inputs: HashMap\u003cbitcoin::OutPoint, bitcoin::TxOut\u003e,\n        del_hashes: Vec\u003cbitcoin::hashes::sha256::Hash\u003e,\n    ) -\u003e Result\u003cu32, BlockchainError\u003e {\n        self.inner_mut()\n            .process_block(block, proof, inputs, del_hashes)\n    }\n\n    fn get_root_hashes(\u0026self) -\u003e Vec\u003crustreexo::accumulator::node_hash::NodeHash\u003e {\n        self.inner().current_acc.roots.clone()\n    }\n\n    //these are no-ops, you can call them, but they won't do anything\n\n    fn flush(\u0026self) -\u003e Result\u003c(), BlockchainError\u003e {\n        // no-op: we keep everything on memory\n        Ok(())\n    }\n\n    fn toggle_ibd(\u0026self, _is_ibd: bool) {\n        // no-op: we know if we finished by looking at our current and end height\n    }\n\n    // these are unimplemented, and will panic if called\n\n    fn accept_header(\u0026self, _header: BlockHeader) -\u003e Result\u003c(), BlockchainError\u003e {\n        unimplemented!(\"partialChainState shouldn't be used to accept new headers\")\n    }\n\n    fn switch_chain(\u0026self, _new_tip: BlockHash) -\u003e Result\u003c(), BlockchainError\u003e {\n        unimplemented!(\"partialChainState shouldn't be used to switch chains\")\n    }\n\n    fn get_partial_chain(\n        \u0026self,\n        _initial_height: u32,\n        _final_height: u32,\n        _acc: Stump,\n    ) -\u003e Result\u003cPartialChainState, BlockchainError\u003e {\n        unimplemented!(\"We are a partial chain\")\n    }\n\n    fn invalidate_block(\u0026self, _block: BlockHash) -\u003e Result\u003c(), BlockchainError\u003e {\n        unimplemented!(\"we know if a block is invalid, just break out of your loop and use the is_valid() method\")\n    }\n\n    fn handle_transaction(\u0026self) -\u003e Result\u003c(), BlockchainError\u003e {\n        unimplemented!(\"we don't do transactions\")\n    }\n\n    fn process_rescan_block(\u0026self, _block: \u0026bitcoin::Block) -\u003e Result\u003c(), BlockchainError\u003e {\n        unimplemented!(\"we don't do rescan\")\n    }\n\n    fn mark_chain_as_assumed(\u0026self, _acc: Stump) -\u003e Result\u003cbool, BlockchainError\u003e {\n        unimplemented!(\"no need to mark as valid\")\n    }\n\n    fn mark_block_as_valid(\u0026self, _block: BlockHash) -\u003e Result\u003c(), BlockchainError\u003e {\n        unimplemented!(\"no need to mark as valid\")\n    }\n}\n\nimpl BlockchainInterface for PartialChainState {\n    type Error = BlockchainError;\n\n    fn get_height(\u0026self) -\u003e Result\u003cu32, Self::Error\u003e {\n        Ok(self.inner().current_height)\n    }\n\n    fn get_block_hash(\u0026self, height: u32) -\u003e Result\u003cbitcoin::BlockHash, BlockchainError\u003e {\n        let height = height - self.inner().initial_height;\n        self.inner()\n            .blocks\n            .get(height as usize)\n            .map(|b| b.block_hash())\n            .ok_or(BlockchainError::BlockNotPresent)\n    }\n\n    fn get_best_block(\u0026self) -\u003e Result\u003c(u32, bitcoin::BlockHash), Self::Error\u003e {\n        Ok((\n            self.inner().current_height(),\n            self.get_block_hash(self.inner().current_height())?,\n        ))\n    }\n\n    fn is_coinbase_mature(\n        \u0026self,\n        height: u32,\n        _block: bitcoin::BlockHash,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        let current_height = self.inner().current_height;\n        let coinbase_maturity = self.inner().chain_params().coinbase_maturity;\n\n        Ok(height + coinbase_maturity \u003e current_height)\n    }\n\n    fn get_validation_index(\u0026self) -\u003e Result\u003cu32, Self::Error\u003e {\n        Ok(self.inner().current_height)\n    }\n\n    fn is_in_idb(\u0026self) -\u003e bool {\n        !self.inner().is_sync()\n    }\n\n    // partial chain states are only used for IBD, so we don't need to implement these\n\n    fn get_block_header(\u0026self, _height: \u0026BlockHash) -\u003e Result\u003cBlockHeader, Self::Error\u003e {\n        unimplemented!(\"PartialChainState::get_block_header\")\n    }\n\n    fn get_chain_tips(\u0026self) -\u003e Result\u003cVec\u003cBlockHash\u003e, Self::Error\u003e {\n        unimplemented!(\"PartialChainState::get_chain_tips\")\n    }\n\n    fn validate_block(\n        \u0026self,\n        _block: \u0026bitcoin::Block,\n        _proof: rustreexo::accumulator::proof::Proof,\n        _inputs: HashMap\u003cbitcoin::OutPoint, bitcoin::TxOut\u003e,\n        _del_hashes: Vec\u003cbitcoin::hashes::sha256::Hash\u003e,\n        _acc: Stump,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        unimplemented!(\"PartialChainState::validate_block\")\n    }\n\n    fn get_fork_point(\u0026self, _block: BlockHash) -\u003e Result\u003cBlockHash, Self::Error\u003e {\n        unimplemented!(\"PartialChainState::get_fork_point\")\n    }\n\n    fn update_acc(\n        \u0026self,\n        _acc: Stump,\n        _block: bitcoin::p2p::utreexo::UtreexoBlock,\n        _height: u32,\n        _proof: rustreexo::accumulator::proof::Proof,\n        _del_hashes: Vec\u003cbitcoin::hashes::sha256::Hash\u003e,\n    ) -\u003e Result\u003cStump, Self::Error\u003e {\n        unimplemented!(\"PartialChainState::update_acc\")\n    }\n\n    fn get_block_locator_for_tip(\n        \u0026self,\n        _tip: BlockHash,\n    ) -\u003e Result\u003cVec\u003cBlockHash\u003e, BlockchainError\u003e {\n        unimplemented!(\"PartialChainState::get_block_locator_for_tip\")\n    }\n\n    fn get_block(\u0026self, _hash: \u0026bitcoin::BlockHash) -\u003e Result\u003cbitcoin::Block, Self::Error\u003e {\n        unimplemented!(\"PartialChainState::get_block\")\n    }\n\n    fn get_tx(\u0026self, _txid: \u0026bitcoin::Txid) -\u003e Result\u003cOption\u003cbitcoin::Transaction\u003e, Self::Error\u003e {\n        unimplemented!(\"partialChainState::get_tx\")\n    }\n\n    fn rescan(\u0026self, _start_height: u32) -\u003e Result\u003c(), Self::Error\u003e {\n        unimplemented!(\"partialChainState::rescan\")\n    }\n\n    fn broadcast(\u0026self, _tx: \u0026bitcoin::Transaction) -\u003e Result\u003c(), Self::Error\u003e {\n        unimplemented!(\"partialChainState::broadcast\")\n    }\n\n    fn subscribe(\u0026self, _tx: sync::Arc\u003cdyn crate::BlockConsumer\u003e) {\n        unimplemented!(\"partialChainState::subscibe\")\n    }\n\n    fn estimate_fee(\u0026self, _target: usize) -\u003e Result\u003cf64, Self::Error\u003e {\n        unimplemented!(\"partialChainState::estimate_fee\")\n    }\n\n    fn get_rescan_index(\u0026self) -\u003e Option\u003cu32\u003e {\n        unimplemented!(\"partialChainState::get_rescan_index\")\n    }\n\n    fn get_block_height(\u0026self, _hash: \u0026bitcoin::BlockHash) -\u003e Result\u003cOption\u003cu32\u003e, Self::Error\u003e {\n        unimplemented!(\"partialChainState::get_block_height\")\n    }\n\n    fn get_unbroadcasted(\u0026self) -\u003e Vec\u003cbitcoin::Transaction\u003e {\n        unimplemented!(\"partialChainState::get_unbroadcasted\")\n    }\n\n    fn get_block_locator(\u0026self) -\u003e Result\u003cVec\u003cbitcoin::BlockHash\u003e, Self::Error\u003e {\n        unimplemented!(\"partialChainState::get_block_locator\")\n    }\n}\n\n// mainly for tests\nimpl From\u003cPartialChainStateInner\u003e for PartialChainState {\n    fn from(value: PartialChainStateInner) -\u003e Self {\n        PartialChainState(UnsafeCell::new(value))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use core::str::FromStr;\n    use std::collections::HashMap;\n\n    use bitcoin::block::Header;\n    use bitcoin::consensus::deserialize;\n    use bitcoin::Block;\n    use rustreexo::accumulator::node_hash::NodeHash;\n    use rustreexo::accumulator::proof::Proof;\n    use rustreexo::accumulator::stump::Stump;\n\n    use super::PartialChainState;\n    use crate::pruned_utreexo::chainparams::ChainParams;\n    use crate::pruned_utreexo::consensus::Consensus;\n    use crate::pruned_utreexo::error::BlockValidationErrors;\n    use crate::pruned_utreexo::partial_chain::PartialChainStateInner;\n    use crate::pruned_utreexo::UpdatableChainstate;\n    use crate::BlockchainError;\n    use crate::Network;\n\n    #[test]\n    fn test_with_invalid_block() {\n        fn run(block: \u0026str, reason: BlockValidationErrors) {\n            let genesis = parse_block(\"0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4adae5494dffff7f20020000000101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000\");\n            let block = parse_block(block);\n\n            let chainstate = get_empty_pchain(vec![genesis.header, block.header]);\n            let res = chainstate.connect_block(\u0026block, Proof::default(), HashMap::new(), vec![]);\n\n            match res {\n                Err(BlockchainError::BlockValidation(_e)) if matches!(reason, _e) =\u003e {}\n                _ =\u003e panic!(\"unexpected {res:?}\"),\n            };\n        }\n        run(\"0000002000226e46111a0b59caaf126043eb5bbf28c34f3a5e332a1fc7b2b73cf188910f39adbcd7823048d34357bdca86cd47172afe2a4af8366b5b34db36df89386d49b23ec964ffff7f20000000000101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff165108feddb99c6b8435060b2f503253482f627463642fffffffff0100f2052a01000000160014806cef41295922d32ddfca09c26cc4acd36c3ed000000000\",super::BlockValidationErrors::BlockExtendsAnOrphanChain);\n        run(\"0000002000226e46111a0b59caaf126043eb5bbf28c34f3a5e332a1fc7b2b73cf188910f40adbcd7823048d34357bdca86cd47172afe2a4af8366b5b34db36df89386d49b23ec964ffff7f20000000000101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff165108feddb99c6b8435060b2f503253482f627463642fffffffff0100f2052a01000000160014806cef41295922d32ddfca09c26cc4acd36c3ed000000000\", BlockValidationErrors::BadMerkleRoot);\n    }\n    fn parse_block(hex: \u0026str) -\u003e Block {\n        let block = hex::decode(hex).unwrap();\n        deserialize(\u0026block).unwrap()\n    }\n    fn get_empty_pchain(blocks: Vec\u003cHeader\u003e) -\u003e PartialChainState {\n        PartialChainStateInner {\n            assume_valid: true,\n            consensus: Consensus {\n                parameters: ChainParams::from(Network::Regtest),\n            },\n            current_height: 0,\n            current_acc: Stump::default(),\n            final_height: 1,\n            blocks,\n            error: None,\n            initial_height: 0,\n        }\n        .into()\n    }\n\n    #[test]\n    fn test_updating_single_chain() {\n        let blocks = include_str!(\"./testdata/blocks.txt\");\n        let mut parsed_blocks = vec![];\n        for (i, block) in blocks.lines().enumerate() {\n            if i \u003e 100 {\n                break;\n            }\n            let block: Block = deserialize(\u0026hex::decode(block).unwrap()).unwrap();\n            parsed_blocks.push(block);\n        }\n        let chainstate: PartialChainState = PartialChainStateInner {\n            assume_valid: true,\n            consensus: Consensus {\n                parameters: ChainParams::from(Network::Regtest),\n            },\n            current_height: 0,\n            current_acc: Stump::default(),\n            final_height: 100,\n            blocks: parsed_blocks.iter().map(|block| block.header).collect(),\n            error: None,\n            initial_height: 0,\n        }\n        .into();\n        parsed_blocks.remove(0);\n        for block in parsed_blocks {\n            let proof = Proof::default();\n            let inputs = HashMap::new();\n            let del_hashes = vec![];\n            chainstate\n                .connect_block(\u0026block, proof, inputs, del_hashes)\n                .unwrap();\n        }\n        assert_eq!(chainstate.inner().current_height, 100);\n    }\n\n    #[test]\n    fn test_updating_multiple_chains() {\n        // We have two chains, one with 100 blocks, one with 50 blocks. We expect the\n        // accumulator to be what we expect after 100 blocks and after 150 blocks.\n        let blocks = include_str!(\"./testdata/blocks.txt\");\n        let mut parsed_blocks = vec![];\n        for block in blocks.lines() {\n            let block: Block = deserialize(\u0026hex::decode(block).unwrap()).unwrap();\n            parsed_blocks.push(block);\n        }\n        // The file contains 150 blocks, we split them into two chains.\n        let (blocks1, blocks2) = parsed_blocks.split_at(101);\n        let mut chainstate1 = PartialChainStateInner {\n            assume_valid: true,\n            consensus: Consensus {\n                parameters: ChainParams::from(Network::Regtest),\n            },\n            current_height: 0,\n            current_acc: Stump::default(),\n            final_height: 100,\n            blocks: blocks1.iter().map(|block| block.header).collect(),\n            error: None,\n            initial_height: 0,\n        };\n        // We need to add the last block of the first chain to the second chain, so that\n        // the second chain can validate all its blocks.\n        let mut blocks2_headers = vec![blocks1.last().unwrap()];\n        blocks2_headers.extend(blocks2);\n\n        let blocks2_headers = blocks2_headers.iter().map(|block| block.header).collect();\n\n        let mut blocks1 = blocks1.iter();\n        blocks1.next();\n\n        for block in blocks1 {\n            let proof = Proof::default();\n            let inputs = HashMap::new();\n            let del_hashes = vec![];\n            chainstate1\n                .process_block(block, proof, inputs, del_hashes)\n                .unwrap();\n        }\n        // The state after 100 blocks, computed ahead of time.\n        let roots = [\n            \"a2f1e6db842e13c7480c8d80f29ca2db5f9b96e1b428ebfdbd389676d7619081\",\n            \"b21aae30bc74e9aef600a5d507ef27d799b9b6ba08e514656d34d717bdb569d2\",\n            \"bedb648c9a3c5741660f926c1552d83ebb4cb1842cca6855b6d1089bb4951ce1\",\n        ]\n        .iter()\n        .map(|hash| NodeHash::from_str(hash).unwrap())\n        .collect();\n\n        let acc2 = Stump { roots, leaves: 100 };\n\n        // acc2 is hard-coded, while chainstate1.current_acc is calculated.\n        // after catching up in the first half, the accumulator should be the same.\n        // We can have the speedup of doing it in parallel, without needing to trust\n        // the hard-coded values.\n        assert_eq!(chainstate1.current_acc, acc2);\n\n        let chainstate2: PartialChainState = PartialChainStateInner {\n            assume_valid: true,\n            consensus: Consensus {\n                parameters: ChainParams::from(Network::Regtest),\n            },\n            current_height: 100,\n            current_acc: acc2,\n            final_height: 150,\n            blocks: blocks2_headers,\n            error: None,\n            initial_height: 100,\n        }\n        .into();\n\n        for block in blocks2 {\n            let proof = Proof::default();\n            let inputs = HashMap::new();\n            let del_hashes = vec![];\n            chainstate2\n                .connect_block(block, proof, inputs, del_hashes)\n                .unwrap();\n        }\n\n        let roots = [\n            \"e00b4ecc7c30865af0ac3b0c7c1b996015f51d6a6577ee6f52cc04b55933eb91\",\n            \"9bf9659f93e246e0431e228032cd4b3a4d8a13e57f3e08a221e61f3e0bae657f\",\n            \"e329a7ddcc888130bb6e4f82ce9f5cf5a712a7b0ae05a1aaf21b363866a9b05e\",\n            \"1864a4982532447dcb3d9a5d2fea9f8ed4e3b1e759d55b8a427fb599fed0c302\",\n        ]\n        .iter()\n        .map(|x| NodeHash::from(hex::decode(x).unwrap().as_slice()))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let expected_acc: Stump = Stump { leaves: 150, roots };\n\n        assert_eq!(chainstate2.inner().current_height, 150);\n        assert_eq!(chainstate2.inner().current_acc, expected_acc);\n    }\n}\n","traces":[{"line":101,"address":[1293920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[1293925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[1293936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[1293941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[1293968],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[1293986,1294059],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[1294022],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[1294096],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[1294113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[1294130],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[1294169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[1294224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[1294241],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[1294249,1294300],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[1294287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[1294277,1294332],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[1294321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[1294311,1294366],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[1294353],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[1294389,1294343],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[1294378],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[1294368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[1294624],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[1294712],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[1295726,1297318,1294816],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[1295055,1294874],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[1295128,1294982,1295203],"length":1,"stats":{"Line":3},"fn_name":null},{"line":182,"address":[1295251,1295303],"length":1,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[1295478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[1295840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[1295988],"length":1,"stats":{"Line":1},"fn_name":null},{"line":189,"address":[1296156,1296937,1297050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[1297097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[1296283,1296210],"length":1,"stats":{"Line":2},"fn_name":null},{"line":197,"address":[1296661,1296545,1296413,1296297,1296461,1296753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[1296344],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[1296873],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[1299181,1299020,1297360],"length":1,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[1297427,1297511],"length":1,"stats":{"Line":3},"fn_name":null},{"line":215,"address":[1297534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[1297522],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[1297666,1297636],"length":1,"stats":{"Line":3},"fn_name":null},{"line":220,"address":[1299044,1297733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[1299068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[1299056],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[1297710,1297947],"length":1,"stats":{"Line":3},"fn_name":null},{"line":227,"address":[1297970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[1297958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[1298085,1299031,1298338],"length":1,"stats":{"Line":2},"fn_name":null},{"line":232,"address":[1298416,1298297],"length":1,"stats":{"Line":3},"fn_name":null},{"line":233,"address":[1298491],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[1298479],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[1298458,1298603],"length":1,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[1298611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[1298628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[1298997,1298660,1297404,1298914],"length":1,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[1298901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[1299216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[1299269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[1299296],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[1299470,1299371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[1299462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[1299520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[1299573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[1300031,1300066,1299600],"length":1,"stats":{"Line":1},"fn_name":"connect_block"},{"line":309,"address":[1299983,1299666],"length":1,"stats":{"Line":2},"fn_name":null},{"line":310,"address":[1299851],"length":1,"stats":{"Line":1},"fn_name":null},{"line":313,"address":[1300112],"length":1,"stats":{"Line":0},"fn_name":"get_root_hashes"},{"line":314,"address":[1300194],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[1300224],"length":1,"stats":{"Line":0},"fn_name":"flush"},{"line":321,"address":[1300232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[1300240],"length":1,"stats":{"Line":0},"fn_name":"toggle_ibd"},{"line":330,"address":[1300256],"length":1,"stats":{"Line":0},"fn_name":"accept_header"},{"line":334,"address":[1300336],"length":1,"stats":{"Line":0},"fn_name":"switch_chain"},{"line":338,"address":[1300531,1300416],"length":1,"stats":{"Line":0},"fn_name":"get_partial_chain"},{"line":347,"address":[1300560],"length":1,"stats":{"Line":0},"fn_name":"invalidate_block"},{"line":351,"address":[1300640],"length":1,"stats":{"Line":0},"fn_name":"handle_transaction"},{"line":355,"address":[1300720],"length":1,"stats":{"Line":0},"fn_name":"process_rescan_block"},{"line":359,"address":[1300800,1300905],"length":1,"stats":{"Line":0},"fn_name":"mark_chain_as_assumed"},{"line":363,"address":[1300928],"length":1,"stats":{"Line":0},"fn_name":"mark_block_as_valid"},{"line":371,"address":[1301008],"length":1,"stats":{"Line":0},"fn_name":"get_height"},{"line":372,"address":[1301095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[1301120],"length":1,"stats":{"Line":0},"fn_name":"get_block_hash"},{"line":376,"address":[1301218,1301398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[1301370,1301312,1301339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[1301335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[1186016,1186032],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":381,"address":[1301362],"length":1,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[1301440],"length":1,"stats":{"Line":0},"fn_name":"get_best_block"},{"line":385,"address":[1301716],"length":1,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[1301528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[1301803,1301593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[1301872],"length":1,"stats":{"Line":0},"fn_name":"is_coinbase_mature"},{"line":396,"address":[1301974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[1302042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[1302088,1302144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[1302176],"length":1,"stats":{"Line":0},"fn_name":"get_validation_index"},{"line":403,"address":[1302263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[1302288],"length":1,"stats":{"Line":0},"fn_name":"is_in_idb"},{"line":407,"address":[1302341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[1302368],"length":1,"stats":{"Line":0},"fn_name":"get_block_header"},{"line":416,"address":[1302448],"length":1,"stats":{"Line":0},"fn_name":"get_chain_tips"},{"line":420,"address":[1302662,1302716,1302528],"length":1,"stats":{"Line":0},"fn_name":"validate_block"},{"line":431,"address":[1302736],"length":1,"stats":{"Line":0},"fn_name":"get_fork_point"},{"line":435,"address":[1302950,1302816,1303008],"length":1,"stats":{"Line":0},"fn_name":"update_acc"},{"line":446,"address":[1303024],"length":1,"stats":{"Line":0},"fn_name":"get_block_locator_for_tip"},{"line":453,"address":[1303104],"length":1,"stats":{"Line":0},"fn_name":"get_block"},{"line":457,"address":[1303184],"length":1,"stats":{"Line":0},"fn_name":"get_tx"},{"line":461,"address":[1303264],"length":1,"stats":{"Line":0},"fn_name":"rescan"},{"line":465,"address":[1303344],"length":1,"stats":{"Line":0},"fn_name":"broadcast"},{"line":469,"address":[1303424,1303532],"length":1,"stats":{"Line":0},"fn_name":"subscribe"},{"line":473,"address":[1303568],"length":1,"stats":{"Line":0},"fn_name":"estimate_fee"},{"line":477,"address":[1303648],"length":1,"stats":{"Line":0},"fn_name":"get_rescan_index"},{"line":481,"address":[1303728],"length":1,"stats":{"Line":0},"fn_name":"get_block_height"},{"line":485,"address":[1303808],"length":1,"stats":{"Line":0},"fn_name":"get_unbroadcasted"},{"line":489,"address":[1303888],"length":1,"stats":{"Line":0},"fn_name":"get_block_locator"},{"line":496,"address":[1303968],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":497,"address":[1304003],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":57,"coverable":128},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-chain","src","pruned_utreexo","udata.rs"],"content":"//! UData is the serialized data used for proof propagation in utreexo. It contains all\n//! data needed for validating some piece of information, like a transaction and a block.\n\nuse bitcoin::consensus::Decodable;\nuse bitcoin::consensus::Encodable;\nuse bitcoin::hashes::sha256;\nuse bitcoin::hashes::Hash;\nuse bitcoin::BlockHash;\nuse bitcoin::OutPoint;\nuse bitcoin::TxOut;\nuse sha2::Digest;\nuse sha2::Sha512_256;\n\nuse crate::prelude::*;\nuse crate::pruned_utreexo::consensus::UTREEXO_TAG_V1;\n\n/// Leaf data is the data that is hashed when adding to utreexo state. It contains validation\n/// data and some commitments to make it harder to attack an utreexo-only node.\n#[derive(Debug, PartialEq)]\npub struct LeafData {\n    /// A commitment to the block creating this utxo\n    pub block_hash: BlockHash,\n    /// The utxo's outpoint\n    pub prevout: OutPoint,\n    /// Header code is a compact commitment to the block height and whether or not this\n    /// transaction is coinbase. It's defined as\n    ///\n    /// ```ignore\n    /// header_code: u32 = if transaction.is_coinbase() {\n    ///     (block_height \u003c\u003c 1 ) | 1\n    /// } else {\n    ///     block_height \u003c\u003c 1\n    /// };\n    /// ```\n    pub header_code: u32,\n    /// The actual utxo\n    pub utxo: TxOut,\n}\n\nimpl LeafData {\n    pub fn _get_leaf_hashes(\u0026self) -\u003e sha256::Hash {\n        let mut ser_utxo = Vec::new();\n        let _ = self.utxo.consensus_encode(\u0026mut ser_utxo);\n        let leaf_hash = Sha512_256::new()\n            .chain_update(UTREEXO_TAG_V1)\n            .chain_update(UTREEXO_TAG_V1)\n            .chain_update(self.block_hash)\n            .chain_update(self.prevout.txid)\n            .chain_update(self.prevout.vout.to_le_bytes())\n            .chain_update(self.header_code.to_le_bytes())\n            .chain_update(ser_utxo)\n            .finalize();\n        sha256::Hash::from_slice(leaf_hash.as_slice())\n            .expect(\"parent_hash: Engines shouldn't be Err\")\n    }\n}\n\nimpl Decodable for LeafData {\n    fn consensus_decode\u003cR: Read + ?Sized\u003e(\n        reader: \u0026mut R,\n    ) -\u003e Result\u003cSelf, bitcoin::consensus::encode::Error\u003e {\n        Self::consensus_decode_from_finite_reader(reader)\n    }\n    fn consensus_decode_from_finite_reader\u003cR: Read + ?Sized\u003e(\n        reader: \u0026mut R,\n    ) -\u003e Result\u003cSelf, bitcoin::consensus::encode::Error\u003e {\n        let block_hash = BlockHash::consensus_decode(reader)?;\n        let prevout = OutPoint::consensus_decode(reader)?;\n        let header_code = u32::consensus_decode(reader)?;\n        let utxo = TxOut::consensus_decode(reader)?;\n        Ok(LeafData {\n            block_hash,\n            prevout,\n            header_code,\n            utxo,\n        })\n    }\n}\n\npub mod proof_util {\n    use bitcoin::blockdata::script::Instruction;\n    use bitcoin::hashes::sha256;\n    use bitcoin::hashes::Hash;\n    use bitcoin::p2p::utreexo::CompactLeafData;\n    use bitcoin::p2p::utreexo::UData;\n    use bitcoin::Amount;\n    use bitcoin::OutPoint;\n    use bitcoin::PubkeyHash;\n    use bitcoin::ScriptBuf;\n    use bitcoin::ScriptHash;\n    use bitcoin::Transaction;\n    use bitcoin::TxIn;\n    use bitcoin::TxOut;\n    use bitcoin::WPubkeyHash;\n    use bitcoin::WScriptHash;\n    use rustreexo::accumulator::node_hash::NodeHash;\n    use rustreexo::accumulator::proof::Proof;\n\n    use super::LeafData;\n    use crate::prelude::*;\n    use crate::pruned_utreexo::BlockchainInterface;\n\n    #[derive(Debug)]\n    pub enum Error {\n        EmptyStack,\n    }\n\n    pub fn reconstruct_leaf_data(\n        leaf: \u0026CompactLeafData,\n        input: \u0026TxIn,\n        block_hash: bitcoin::BlockHash,\n    ) -\u003e Result\u003cLeafData, Error\u003e {\n        let spk = reconstruct_script_pubkey(leaf, input)?;\n\n        Ok(LeafData {\n            block_hash,\n            header_code: leaf.header_code,\n            prevout: input.previous_output,\n            utxo: TxOut {\n                script_pubkey: spk,\n                value: Amount::from_sat(leaf.amount),\n            },\n        })\n    }\n\n    #[allow(clippy::type_complexity)]\n    pub fn process_proof\u003cChain: BlockchainInterface\u003e(\n        udata: \u0026UData,\n        transactions: \u0026[Transaction],\n        chain: \u0026Chain,\n    ) -\u003e Result\u003c(Proof, Vec\u003csha256::Hash\u003e, HashMap\u003cOutPoint, TxOut\u003e), Chain::Error\u003e {\n        let targets = udata.proof.targets.iter().map(|target| target.0).collect();\n        let hashes = udata\n            .proof\n            .hashes\n            .iter()\n            .map(|hash| NodeHash::Some(*hash.as_byte_array()))\n            .collect();\n        let proof = Proof::new(targets, hashes);\n        let mut hashes = Vec::new();\n        let mut leaves_iter = udata.leaves.iter().cloned();\n        let mut tx_iter = transactions.iter();\n\n        let mut inputs = HashMap::new();\n        tx_iter.next(); // Skip coinbase\n\n        for tx in tx_iter {\n            let txid = tx.txid();\n            for (vout, out) in tx.output.iter().enumerate() {\n                inputs.insert(\n                    OutPoint {\n                        txid,\n                        vout: vout as u32,\n                    },\n                    out.clone(),\n                );\n            }\n\n            for input in tx.input.iter() {\n                if !inputs.contains_key(\u0026input.previous_output) {\n                    if let Some(leaf) = leaves_iter.next() {\n                        let height = leaf.header_code \u003e\u003e 1;\n                        let hash = chain.get_block_hash(height)?;\n                        let leaf =\n                            reconstruct_leaf_data(\u0026leaf, input, hash).expect(\"Invalid proof\");\n                        hashes.push(leaf._get_leaf_hashes());\n                        inputs.insert(leaf.prevout, leaf.utxo);\n                    }\n                }\n            }\n        }\n\n        Ok((proof, hashes, inputs))\n    }\n\n    fn reconstruct_script_pubkey(leaf: \u0026CompactLeafData, input: \u0026TxIn) -\u003e Result\u003cScriptBuf, Error\u003e {\n        match \u0026leaf.spk_ty {\n            bitcoin::p2p::utreexo::ScriptPubkeyType::Other(spk) =\u003e {\n                Ok(ScriptBuf::from(spk.clone().into_vec()))\n            }\n            bitcoin::p2p::utreexo::ScriptPubkeyType::PubKeyHash =\u003e {\n                let pkhash = get_pk_hash(input)?;\n                Ok(ScriptBuf::new_p2pkh(\u0026pkhash))\n            }\n            bitcoin::p2p::utreexo::ScriptPubkeyType::WitnessV0PubKeyHash =\u003e {\n                let pk_hash = get_witness_pk_hash(input)?;\n                Ok(ScriptBuf::new_p2wpkh(\u0026pk_hash))\n            }\n            bitcoin::p2p::utreexo::ScriptPubkeyType::ScriptHash =\u003e {\n                let script_hash = get_script_hash(input)?;\n                Ok(ScriptBuf::new_p2sh(\u0026script_hash))\n            }\n            bitcoin::p2p::utreexo::ScriptPubkeyType::WitnessV0ScriptHash =\u003e {\n                let witness_program_hash = get_witness_script_hash(input)?;\n                Ok(ScriptBuf::new_p2wsh(\u0026witness_program_hash))\n            }\n        }\n    }\n    fn get_pk_hash(input: \u0026TxIn) -\u003e Result\u003cPubkeyHash, Error\u003e {\n        let script_sig = \u0026input.script_sig;\n        let inst = script_sig.instructions().last();\n        if let Some(Ok(bitcoin::blockdata::script::Instruction::PushBytes(bytes))) = inst {\n            return Ok(PubkeyHash::hash(bytes.as_bytes()));\n        }\n        Err(Error::EmptyStack)\n    }\n    fn get_script_hash(input: \u0026TxIn) -\u003e Result\u003cScriptHash, Error\u003e {\n        let script_sig = \u0026input.script_sig;\n        let inst = script_sig.instructions().last();\n        if let Some(Ok(Instruction::PushBytes(bytes))) = inst {\n            return Ok(ScriptBuf::from_bytes(bytes.as_bytes().to_vec()).script_hash());\n        }\n        Err(Error::EmptyStack)\n    }\n    fn get_witness_pk_hash(input: \u0026TxIn) -\u003e Result\u003cWPubkeyHash, Error\u003e {\n        let witness = \u0026input.witness;\n        let pk = witness.last();\n        if let Some(pk) = pk {\n            return Ok(WPubkeyHash::hash(pk));\n        }\n        Err(Error::EmptyStack)\n    }\n    fn get_witness_script_hash(input: \u0026TxIn) -\u003e Result\u003cWScriptHash, Error\u003e {\n        let witness = \u0026input.witness;\n        let script = witness.last();\n        if let Some(script) = script {\n            return Ok(WScriptHash::hash(script));\n        }\n        Err(Error::EmptyStack)\n    }\n}\n#[cfg(test)]\nmod test {\n    extern crate std;\n    use std::str::FromStr;\n    use std::vec::Vec;\n\n    use bitcoin::consensus::deserialize;\n    use bitcoin::hashes::hex::FromHex;\n    use bitcoin::p2p::utreexo::CompactLeafData;\n    use bitcoin::Amount;\n    use bitcoin::BlockHash;\n    use bitcoin::ScriptBuf;\n    use bitcoin::Transaction;\n\n    use super::proof_util::reconstruct_leaf_data;\n    use super::LeafData;\n    macro_rules! test_recover_spk {\n        (\n            $tx_hex:literal,\n            $height:literal,\n            $index:literal,\n            $amount:literal,\n            $block_hash:literal,\n            $spk_type:ident,\n            $expected_spk:literal\n        ) =\u003e {\n            let hex = Vec::from_hex($tx_hex).unwrap();\n            let s: Transaction = deserialize(\u0026hex).unwrap();\n            let leaf = CompactLeafData {\n                amount: Amount::from_btc($amount).unwrap().to_sat(),\n                header_code: $height,\n                spk_ty: bitcoin::p2p::utreexo::ScriptPubkeyType::$spk_type,\n            };\n            let spk = super::proof_util::reconstruct_leaf_data(\n                \u0026leaf,\n                \u0026s.input[0],\n                BlockHash::from_str($block_hash).unwrap(),\n            )\n            .unwrap();\n            assert_eq!(\n                spk.utxo.script_pubkey,\n                ScriptBuf::from_hex($expected_spk).unwrap()\n            )\n        };\n    }\n    #[test]\n    fn test_spk_recovery() {\n        // p2pkh\n        test_recover_spk!(\n            \"010000000114baa734ec1a75e84726af2da3abcd41fe9d96f3f8b7e99bcefdfc040cffc2ba030000006a47304402202f89e2deb17f0c2c5732d6f7791a2731703cb128dc86ae0bf288e55a3d7ce9d6022051c2242ca0885a4a2054391385eda03132616fb0c2daa61d6823eff7a21b5d0c01210395c223fbf96e49e5b9e06a236ca7ef95b10bf18c074bd91a5942fc40360d0b68fdffffff04b400000000000000536a4c5058325bc5b3f7d4e7acf388d63ab92d14d7f8f8bcdff384bddd4668f283df0bfe1c2f7728ec1e550ca841794fa28e16e154c5b92b5a1d1d98db4e89f15726bf75e352fe000bddf10068000bd72600012bc20000000000000017a914352481ec2fecfde0c5cdc635a383c4ac27b9f71e87c20000000000000017a9144890aae025c84cb72a9730b49ca12595d6f6088d8772aa0900000000001976a914bf2646b8ba8b4a143220528bde9c306dac44a01c88ac00000000\",\n            0,\n            777548,\n            0.03956721,\n            \"000000000000000000066caa76847c109010eb58402d7a5bf05cc201a011071d\",\n            PubKeyHash,\n            \"76a914bf2646b8ba8b4a143220528bde9c306dac44a01c88ac\"\n        );\n        // p2sh\n        test_recover_spk!(\n            \"0200000001ff1ba24eb11f1290b293b2c5520e4863ffedcc4a4ed9e4933334639ecbcc946500000000fc00473044022001460e6d06dc44e163ef1f692d275a1e357d086d0361fbe5012dbf18cbf2617202207f9e8fb54e776d7e98a6425da2be15e2ffca2e623b7617234226eafe77c70eaa01473044022076d756a250ad4044e2b4a0049112d87367b2f0ce80253e400f3ba09d620cbbdd022020f67b65f7cb5e109b8ccbc852e30b4e84b0b682136a5e72f679bd581b271ea8014c695221021c04b91bffe90c3e4defd021a4b6da4983b97e13c772bf15009f1661480658832102be11f7f0d9696ef731c13ed8b6e955df43cd4238d694a1698b02fcb3c2d275322102e0ad7274a4e93b3b30793ff7a04a31d2792ed22a563fe5ea0095af844c10c9c453aefdffffff02fd5403000000000017a914351bb17d072fff46336baec11a6a8d13ab6b590e87305837000000000017a9147b8d77369df3d2172b0d56792308d7f2635ca79087f1dd0b00\",\n            0,\n            777548,\n            0.03956721,\n            \"00000000000000000005a784e2b5006b34ff63644408df00bfc1a0b1b9507021\",\n            ScriptHash,\n            \"a914ed9371b30de550c0617cd0c4b2c0c0dc5e88c65487\"\n        );\n        //p2wpkh\n        test_recover_spk!(\n            \"01000000000101a742910d02da84259631288eab229ca2bdd39ed7edc8811ca125dc0bcf2b654c0100000000ffffffff02ba150a000000000016001406a9852b7c9f4ff9993b5d2192ac42a5df54828e34c812000000000016001486bdf86c7cbce4841f95b4d8ef101ce8a306e6ad0247304402202936300c12249c8696bb90addcc9482995429d7be0418260178ddc0c630c10ed02206128cac337841b171d15d9aadc2af77d280da7cd85c049149c8134ddb5adc8a10121038adb3497e025c0ff14521a789af4f10d526ec4c95348e708ebdc4d5ac58228e500000000\",\n            1,\n            777716,\n            0.01893642,\n            \"00000000000000000002264d1e3f90280ededd1587c7af932480dac3e2480048\",\n            WitnessV0PubKeyHash,\n            \"001406a9852b7c9f4ff9993b5d2192ac42a5df54828e\"\n        );\n        //p2wsh\n        test_recover_spk!(\n            \"01000000000101cacacdfdc79620cac8bc463cdac9864f557fdb73b6ef0dea8e0d74297d2e4c1a0100000000ffffffff0280841e000000000017a914cef5ab6252860ada719556abebe952c79c466f86878af74e0c00000000220020701a8d401c84fb13e6baf169d59684e17abd9fa216c8cc5b9fc63d622ff8c58d04004730440220289b2e0b6aec5a8f43d283edef0757206de77e3f3acdb322ade452a0468764db02201c332ec46a2ed3614fe392c4011063f39e77def57d89991ccbb99b6c7de2491901473044022044eaf71bdb4b3f0b0ba2f1eec82cad412729a1a4d5fc3b2fa251fecb73c56c0502201579c9e13b4d7595f9c6036a612828eac4796902c248131a7f25a117a0c68ca8016952210375e00eb72e29da82b89367947f29ef34afb75e8654f6ea368e0acdfd92976b7c2103a1b26313f430c4b15bb1fdce663207659d8cac749a0e53d70eff01874496feff2103c96d495bfdd5ba4145e3e046fee45e84a8a48ad05bd8dbb395c011a32cf9f88053ae00000000\",\n            0,\n            487740,\n            2.08551770,\n            \"0000000000000000004fce5d650f72e8f288e8c81b36377c3c7de3d2bc5b3118\",\n            WitnessV0ScriptHash,\n            \"0020701a8d401c84fb13e6baf169d59684e17abd9fa216c8cc5b9fc63d622ff8c58d\"\n        );\n        test_recover_spk!(\n            \"020000000001018f97e04dd76eec325c149ad417175f01f71b45523d8df79d2745cfee110eabf20000000000ffffffff015cddc71d000000002200204ae81572f06e1b88fd5ced7a1a000945432e83e1551e6f721ee9c00b8cc3326001015100000000\",\n            0,\n            27366,\n            4.99637721,\n            \"000000069585e4b2517a8862d527558ff18df7d4b8c2795b249c116aba9c6c98\",\n            WitnessV0ScriptHash,\n            \"00204ae81572f06e1b88fd5ced7a1a000945432e83e1551e6f721ee9c00b8cc33260\"\n        );\n    }\n    #[test]\n    fn test_reconstruct_leaf_data() {\n        let leaf = Vec::from_hex(\"f99e24b9e96a3c6220449b2bf520d6a9562237e2f4fc6f6b2ba57a71de000000e6f50efb6747f836ca3510df3da120fdb2ae4cf62893cc014e08c25dab70248b01000000cc000400b429653b4f0600001600142b91c8f80b071c5f60e1a512d49a6a544e51165b\").unwrap();\n        let leaf: LeafData = deserialize(\u0026leaf).unwrap();\n        let spending_tx = Vec::from_hex(\"02000000000101e6f50efb6747f836ca3510df3da120fdb2ae4cf62893cc014e08c25dab70248b0100000000feffffff02dbe6553b4f0600001600148d57f8da7fc15371dc14d35e97850ab564a17b1240420f0000000000220020ed59bf193c5197a5b1dbbbc723ddeca82cdfbb188218b3ede50150e1890fc55202473044022024979ec4bda473b71288b2c15390418d7d300551aa5e463cc6b64acd5c3070b50220444c94242aff2ba1bd966308d60f537524b0755931d545d98e1fc45239ff6b08012103de7c420624c009d6a5761871e78b39ff864887f885ed313e27f778b3772e74916a000200\").unwrap();\n        let spending_tx: Transaction = deserialize(\u0026spending_tx).unwrap();\n\n        let compact = CompactLeafData {\n            amount: Amount::from_btc(69373.68668596).unwrap().to_sat(),\n            header_code: 262348,\n            spk_ty: bitcoin::p2p::utreexo::ScriptPubkeyType::WitnessV0PubKeyHash,\n        };\n        let reconstructed = reconstruct_leaf_data(\n            \u0026compact,\n            \u0026spending_tx.input[0],\n            BlockHash::from_str(\"000000de717aa52b6b6ffcf4e2372256a9d620f52b9b4420623c6ae9b9249ef9\")\n                .unwrap(),\n        )\n        .unwrap();\n        assert_eq!(leaf, reconstructed);\n    }\n}\n","traces":[{"line":41,"address":[1378703,1378734,1377888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[1377918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[1377963,1378020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[1378346,1378397,1378286,1378044,1378471,1378559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[1378238],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[1378298],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[1378358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[1378432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[1378501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[1378586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[1201776],"length":1,"stats":{"Line":1},"fn_name":"consensus_decode_from_finite_reader\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[1326841,1326820,1326208],"length":1,"stats":{"Line":1},"fn_name":"reconstruct_leaf_data"},{"line":113,"address":[1326240,1326489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[1326624],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[1326389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[1326396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[1326568],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[1326430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[1326464],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[3336735,3336524,3333512,3330752,3333760,3333723],"length":1,"stats":{"Line":0},"fn_name":"process_proof\u003calloc::sync::Arc\u003cfloresta_chain::pruned_utreexo::chain_state::ChainState\u003cfloresta_chain::pruned_utreexo::chainstore::KvChainStore\u003e, alloc::alloc::Global\u003e\u003e"},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[3334592,3331584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[1326880],"length":1,"stats":{"Line":1},"fn_name":"reconstruct_script_pubkey"},{"line":177,"address":[1326922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[1326958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[1326970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[1327046,1327309,1327458],"length":1,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[1327389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[1327105,1327639,1327475],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[1327567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[1327656,1327170,1327820],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[1327748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[1328037,1327837,1327235,1326906],"length":1,"stats":{"Line":3},"fn_name":null},{"line":195,"address":[1327965],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[1328064],"length":1,"stats":{"Line":1},"fn_name":"get_pk_hash"},{"line":200,"address":[1328099],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[1328107],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[1328142,1328196],"length":1,"stats":{"Line":2},"fn_name":null},{"line":203,"address":[1328248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[1328191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[1328732,1328320],"length":1,"stats":{"Line":1},"fn_name":"get_script_hash"},{"line":208,"address":[1328358],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[1328366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[1328401,1328458],"length":1,"stats":{"Line":2},"fn_name":null},{"line":211,"address":[1328510],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[1328450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[1328768],"length":1,"stats":{"Line":1},"fn_name":"get_witness_pk_hash"},{"line":216,"address":[1328800],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[1328809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[1328828],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[1328874],"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[1328925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[1328944],"length":1,"stats":{"Line":1},"fn_name":"get_witness_script_hash"},{"line":224,"address":[1328974],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[1328983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[1329002],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[1329048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[1329110],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":44,"coverable":95},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-cli","src","lib.rs"],"content":"// SPDX license specifier: MIT\n\n//! # floresta-cli - A command line interface for florestad\n//!\n//! Florestad is a lightweight Bitcoin full node, built with libfloresta. It gives\n//! you complete control over your Bitcoin node with a simple json-rpc interface that\n//! may be used either from command line or programmatically. This crate provides a\n//! ready-to-use library for interacting with florestad's json-rpc interface in your rust\n//! application.\n\n#[cfg(feature = \"with-reqwest\")]\npub mod reqwest_client;\n\npub mod rpc;\npub mod rpc_types;\n\n// Those tests doesn't work on windowns\n// TODO (Davidson): work on windows?\n\n#[cfg(all(test, not(target_os = \"windows\")))]\nmod tests {\n    use std::fs;\n    use std::process::Child;\n    use std::process::Command;\n    use std::process::Stdio;\n    use std::str::FromStr;\n    use std::thread::sleep;\n    use std::time::Duration;\n\n    use bitcoin::BlockHash;\n    use bitcoin::Txid;\n\n    use crate::reqwest_client::ReqwestClient;\n    use crate::rpc::FlorestaRPC;\n\n    struct Florestad {\n        proc: Child,\n    }\n\n    impl Drop for Florestad {\n        fn drop(\u0026mut self) {\n            self.proc.kill().unwrap();\n        }\n    }\n\n    /// A helper function for tests.\n    ///\n    /// This function will start a florestad process and return a client that can be used to\n    /// interact with it through RPC. It also returns a handle to the process itself, so that\n    /// you can poke at the stdin and out for this process. You don't have to kill it though,\n    /// once the handle goes out of scope, the process will be killed.\n    ///\n    /// The process created by this method will run in a random datadir and use random ports\n    /// for both RPC and Electrum. The datadir will be in the current dir, under a `tmp` subdir.\n    /// If you're at $HOME/floresta it will run on $HOME/floresta/tmp/\u003crandom_name\u003e/\n    fn start_florestad() -\u003e (Florestad, ReqwestClient) {\n        let here = env!(\"PWD\");\n        let port = rand::random::\u003cu16\u003e() % 1000 + 18443;\n\n        // makes a temporary directory\n        let test_code = rand::random::\u003cu64\u003e();\n        let dirname = format!(\"{here}/tmp/floresta.{test_code}\");\n        fs::DirBuilder::new()\n            .recursive(true)\n            .create(dirname.clone())\n            .unwrap();\n\n        let fld = Command::new(format!(\"{here}/target/debug/florestad\"))\n            .args([\"-n\", \"regtest\"])\n            .args([\"run\"])\n            .args([\"--data-dir\", \u0026dirname])\n            .args([\"--rpc-address\", \u0026format!(\"127.0.0.1:{}\", port)])\n            .args([\"--electrum-address\", \u0026format!(\"127.0.0.1:{}\", port + 1)])\n            .stdout(Stdio::null())\n            .stderr(Stdio::null())\n            .spawn()\n            .unwrap();\n\n        let client = ReqwestClient::new(format!(\"http://127.0.0.1:{port}\"));\n\n        let mut retries = 10;\n\n        loop {\n            sleep(Duration::from_secs(1));\n            retries -= 1;\n            if retries == 0 {\n                panic!(\"florestad didn't start {:?}\", fld.stdout);\n            }\n            match client.get_blockchain_info() {\n                Ok(_) =\u003e break,\n                Err(_) =\u003e continue,\n            }\n        }\n\n        (Florestad { proc: fld }, client)\n    }\n\n    #[test]\n    #[ignore = \"tarpaulin\"]\n    fn test_rescan() {\n        let (_proc, client) = start_florestad();\n\n        let rescan = client.rescan(0).expect(\"rpc not working\");\n        assert!(rescan);\n    }\n\n    #[test]\n    #[ignore = \"tarpaulin\"]\n    fn test_stop() {\n        let (mut _proc, client) = start_florestad();\n\n        let stop = client.stop().expect(\"rpc not working\");\n        assert!(stop);\n    }\n\n    #[test]\n    #[ignore = \"tarpaulin\"]\n    fn test_get_blockchaininfo() {\n        let (_proc, client) = start_florestad();\n\n        let gbi = client.get_blockchain_info().expect(\"rpc not working\");\n\n        assert_eq!(gbi.height, 0);\n        assert_eq!(gbi.chain, \"regtest\".to_owned());\n        assert!(gbi.ibd);\n        assert_eq!(gbi.leaf_count, 0);\n        assert_eq!(gbi.root_hashes, Vec::\u003cString\u003e::new());\n    }\n\n    #[test]\n    #[ignore = \"tarpaulin\"]\n    fn test_get_roots() {\n        let (_proc, client) = start_florestad();\n\n        let gbi = client.get_blockchain_info().expect(\"rpc not working\");\n\n        assert_eq!(gbi.root_hashes, Vec::\u003cString\u003e::new());\n    }\n\n    #[test]\n    #[ignore = \"tarpaulin\"]\n    fn test_get_block() {\n        let (_proc, client) = start_florestad();\n\n        let block_hash: BlockHash =\n            \"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\"\n                .parse()\n                .unwrap();\n        let block = client.get_block(block_hash).unwrap();\n\n        assert_eq!(\n            block.hash,\n            \"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\".to_owned()\n        );\n    }\n\n    #[test]\n    #[ignore = \"tarpaulin\"]\n    fn test_get_block_hash() {\n        let (_proc, client) = start_florestad();\n\n        let blockhash = client.get_block_hash(0).expect(\"rpc not working\");\n\n        assert_eq!(\n            blockhash,\n            \"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\"\n                .parse()\n                .unwrap()\n        );\n    }\n\n    #[test]\n    #[ignore = \"tarpaulin\"]\n    fn test_get_block_header() {\n        let (_proc, client) = start_florestad();\n\n        let blockhash = client.get_block_hash(0).expect(\"rpc not working\");\n        let block_header = client.get_block_header(blockhash).expect(\"rpc not working\");\n\n        assert_eq!(block_header.block_hash(), blockhash);\n    }\n\n    #[test]\n    #[ignore = \"tarpaulin\"]\n    fn test_get_block_filter() {\n        let (_proc, client) = start_florestad();\n\n        let block_filter = client.get_block_filter(0);\n\n        // this should err, because there is no filter for genesis block\n        assert!(block_filter.is_err());\n    }\n\n    #[test]\n    #[ignore = \"tarpaulin\"]\n    fn test_load_descriptor() {\n        let (_proc, client) = start_florestad();\n\n        let desc = \"\n            wsh(sortedmulti(1,[54ff5a12/48h/1h/0h/2h]tpubDDw6pwZA3hYxcSN32q7a5ynsKmWr4BbkBNHydHPKkM4BZwUfiK7tQ26h7USm8kA1E2FvCy7f7Er7QXKF8RNptATywydARtzgrxuPDwyYv4x/\u003c0;1\u003e/*,[bcf969c0/48h/1h/0h/2h]tpubDEFdgZdCPgQBTNtGj4h6AehK79Jm4LH54JrYBJjAtHMLEAth7LuY87awx9ZMiCURFzFWhxToRJK6xp39aqeJWrG5nuW3eBnXeMJcvDeDxfp/\u003c0;1\u003e/*))#fuw35j0q\";\n\n        let res = client.load_descriptor(desc.to_string(), Some(0)).unwrap();\n\n        assert!(res)\n    }\n\n    #[test]\n    #[ignore = \"tarpaulin\"]\n    fn test_get_height() {\n        let (_proc, client) = start_florestad();\n\n        let height = client.get_height().unwrap();\n        assert_eq!(height, 0);\n    }\n\n    #[test]\n    #[ignore = \"tarpaulin\"]\n    fn test_send_raw_transaction() {\n        let (_proc, client) = start_florestad();\n\n        let tx = \"01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000\".to_string();\n\n        let res = client.send_raw_transaction(tx).unwrap();\n        assert_eq!(\n            res,\n            Txid::from_str(\"4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\")\n                .unwrap()\n        );\n    }\n}\n","traces":[{"line":41,"address":[1516848],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":42,"address":[1516853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[1597397,1594208],"length":1,"stats":{"Line":0},"fn_name":"start_florestad"},{"line":57,"address":[1594231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[1594285,1594633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[1594339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[1594478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[1594810,1594608,1594721],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[1594767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[1595249,1596207,1595147,1595740,1596255,1596163,1594942,1595370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[1595077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[1595214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[1595272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[1595689,1595480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[1596112,1595873,1595755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[1596175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[1596223],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[1596591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[1596724],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[1596805,1596740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[1596859,1596816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[1596847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[1597000,1596892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[1597084,1596983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[1597142],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":25},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-cli","src","main.rs"],"content":"use std::fmt::Debug;\n\nuse anyhow::Ok;\nuse bitcoin::BlockHash;\nuse bitcoin::Network;\nuse bitcoin::Txid;\nuse clap::Parser;\nuse clap::Subcommand;\nuse floresta_cli::reqwest_client::ReqwestClient;\nuse floresta_cli::rpc::FlorestaRPC;\n\nmod reqwest_client;\nmod rpc;\nmod rpc_types;\n\nfn main() -\u003e anyhow::Result\u003c()\u003e {\n    let cli = Cli::parse();\n\n    let client = ReqwestClient::new(get_host(\u0026cli));\n    let res = do_request(\u0026cli, client)?;\n\n    println!(\"{}\", res);\n\n    anyhow::Ok(())\n}\n\nfn get_host(cmd: \u0026Cli) -\u003e String {\n    if let Some(host) = cmd.rpc_host.clone() {\n        return host;\n    }\n\n    match cmd.network {\n        Network::Bitcoin =\u003e \"http://127.0.0.1:8332\".into(),\n        Network::Testnet =\u003e \"http://127.0.0.1:18332\".into(),\n        Network::Signet =\u003e \"http://127.0.0.1:38332\".into(),\n        Network::Regtest =\u003e \"http://127.0.0.1:18442\".into(),\n        _ =\u003e \"http://127.0.0.1:8332\".into(),\n    }\n}\n\nfn do_request(cmd: \u0026Cli, client: ReqwestClient) -\u003e anyhow::Result\u003cString\u003e {\n    Ok(match cmd.methods.clone() {\n        Methods::GetBlockchainInfo =\u003e serde_json::to_string_pretty(\u0026client.get_blockchain_info()?)?,\n        Methods::GetBlockHash { height } =\u003e {\n            serde_json::to_string_pretty(\u0026client.get_block_hash(height)?)?\n        }\n        Methods::GetTxOut { txid, vout } =\u003e {\n            serde_json::to_string_pretty(\u0026client.get_tx_out(txid, vout)?)?\n        }\n        Methods::GetTxProof { txids, .. } =\u003e {\n            serde_json::to_string_pretty(\u0026client.get_tx_proof(txids)?)?\n        }\n        Methods::GetRawTransaction { txid, .. } =\u003e {\n            serde_json::to_string_pretty(\u0026client.get_transaction(txid, Some(true))?)?\n        }\n        Methods::RescanBlockchain { start_height } =\u003e {\n            serde_json::to_string_pretty(\u0026client.rescan(start_height)?)?\n        }\n        Methods::SendRawTransaction { tx } =\u003e {\n            serde_json::to_string_pretty(\u0026client.send_raw_transaction(tx)?)?\n        }\n        Methods::GetBlockHeader { hash } =\u003e {\n            serde_json::to_string_pretty(\u0026client.get_block_header(hash)?)?\n        }\n        Methods::LoadDescriptor { desc, rescan } =\u003e {\n            serde_json::to_string_pretty(\u0026client.load_descriptor(desc, rescan)?)?\n        }\n        Methods::GetRoots =\u003e serde_json::to_string_pretty(\u0026client.get_roots()?)?,\n        Methods::GetBlock { hash, .. } =\u003e serde_json::to_string_pretty(\u0026client.get_block(hash)?)?,\n        Methods::GetPeerInfo =\u003e serde_json::to_string_pretty(\u0026client.get_peer_info()?)?,\n        Methods::Stop =\u003e serde_json::to_string_pretty(\u0026client.stop()?)?,\n        Methods::AddNode { node } =\u003e serde_json::to_string_pretty(\u0026client.add_node(node)?)?,\n        Methods::GetFilters { height } =\u003e {\n            serde_json::to_string_pretty(\u0026client.get_block_filter(height)?)?\n        }\n    })\n}\n\n#[derive(Debug, Parser)]\n#[command(author = \"Davidson Souza\", version = \"0.1.0\", about = r#\"\n    A simple command line interface to the Floresta JSON RPC interface.\n\"#, long_about = None)]\npub struct Cli {\n    /// Sets a custom config file\n    #[arg(short, long, value_name = \"FILE\")]\n    pub config_file: Option\u003cString\u003e,\n    /// Which network should we use\n    #[arg(short, long, default_value_t=Network::Bitcoin)]\n    pub network: Network,\n    /// Turn debugging information on\n    #[arg(short, long, action = clap::ArgAction::Count)]\n    pub debug: u8,\n    /// The RPC host to connect to\n    #[arg(short = 'H', long, value_name = \"URL\")]\n    pub rpc_host: Option\u003cString\u003e,\n    /// The RPC username to use\n    #[arg(short = 'u', long, value_name = \"USERNAME\")]\n    pub rpc_user: Option\u003cString\u003e,\n    /// The RPC password to use\n    #[arg(short = 'P', long, value_name = \"PASSWORD\")]\n    pub rpc_password: Option\u003cString\u003e,\n    /// An actual RPC command to run\n    #[command(subcommand)]\n    pub methods: Methods,\n}\n\n#[derive(Debug, Clone, Subcommand)]\npub enum Methods {\n    /// Returns information about the current state of the blockchain\n    #[command(name = \"getblockchaininfo\")]\n    GetBlockchainInfo,\n    /// Returns the hash of the block associated with height\n    #[command(name = \"getblockhash\")]\n    GetBlockHash { height: u32 },\n    /// Returns the proof that one or more transactions were included in a block\n    #[command(name = \"gettxproof\")]\n    GetTxProof {\n        txids: Txid,\n        blockhash: Option\u003cBlockHash\u003e,\n    },\n    /// Returns the raw transaction, assuming it is cached by our watch only wallet\n    #[command(name = \"getrawtransaction\")]\n    GetRawTransaction { txid: Txid, verbose: Option\u003cbool\u003e },\n    /// Ask the node to rescan the blockchain for transactions\n    #[command(name = \"rescan\")]\n    RescanBlockchain { start_height: u32 },\n    /// Submits a raw transaction to the network\n    #[command(name = \"sendrawtransaction\")]\n    SendRawTransaction { tx: String },\n    /// Returns the block header for the given block hash\n    #[command(name = \"getblockheader\")]\n    GetBlockHeader { hash: BlockHash },\n    /// Loads a new descriptor to the watch only wallet\n    #[command(name = \"loaddescriptor\")]\n    LoadDescriptor { desc: String, rescan: Option\u003cu32\u003e },\n    /// Returns the roots of the current utreexo forest\n    #[command(name = \"getroots\")]\n    GetRoots,\n    /// Returns a block\n    #[command(name = \"getblock\")]\n    GetBlock { hash: BlockHash, verbosity: u32 },\n    /// Returns information about the peers we are connected to\n    #[command(name = \"getpeerinfo\")]\n    GetPeerInfo,\n    /// Returns the value associated with a UTXO, if it's still not spent.\n    /// This function only works properly if we have the compact block filters\n    /// feature enabled\n    #[command(name = \"gettxout\")]\n    GetTxOut { txid: Txid, vout: u32 },\n    /// Stops the node\n    #[command(name = \"stop\")]\n    Stop,\n    /// Connects with a peer, given its address and port\n    /// Usage: addnode \u003cip:[port]\u003e\n    #[command(name = \"addnode\")]\n    AddNode { node: String },\n    /// Returns the filters for a given block\n    #[command(name = \"getfilter\")]\n    GetFilters { height: u32 },\n}\n","traces":[{"line":16,"address":[1990914,1990224,1990881],"length":1,"stats":{"Line":0},"fn_name":"main"},{"line":17,"address":[1990241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[1990259,1990303],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[1990330,1990897,1990649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[1990741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[1990817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[1990944],"length":1,"stats":{"Line":0},"fn_name":"get_host"},{"line":28,"address":[1990968],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[1991044],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[1991091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[1991139],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[1991164],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[1991189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[1991214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[1991132],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[1992784,1991248,1998440],"length":1,"stats":{"Line":0},"fn_name":"do_request"},{"line":42,"address":[1991293,1991353,1992739],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[1992332,1991402,1992749,1992795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[1991417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[1993136,1991439,1992813],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[1992089],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[1992135,1997117,1997238,1997290,1996890],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[1991454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[1993606,1991486,1993192,1993433,1993554],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[1991549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[1993975,1993854,1991581,1994027,1993627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[1991660],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[1991682,1994335,1994048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[1991697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[1991745,1994391,1994714],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[1991760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[1994770,1991792,1995188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[1991855],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[1995244,1995531,1991933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[1995587,1991956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[1996022,1991971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[1996467,1992074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[1997311,1992206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[1992221,1997654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[1992284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[1992306,1997997,1998238,1998359,1998435],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":41},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-cli","src","reqwest_client.rs"],"content":"use std::fmt::Debug;\n\nuse serde::Deserialize;\nuse serde_json::json;\n\nuse crate::rpc::JsonRPCClient;\n\n#[derive(Debug, Default, Clone)]\npub struct ReqwestClient {\n    client: reqwest::blocking::Client,\n    url: String,\n    auth: Option\u003c(String, String)\u003e,\n}\n\npub struct ReqwestConfig {\n    pub url: String,\n    pub proxy: Option\u003creqwest::Proxy\u003e,\n    pub auth: Option\u003c(String, String)\u003e,\n    pub timeout: Option\u003cstd::time::Duration\u003e,\n    pub headers: Option\u003creqwest::header::HeaderMap\u003e,\n}\n\nimpl ReqwestClient {\n    pub fn new(url: String) -\u003e Self {\n        Self {\n            url,\n            ..Default::default()\n        }\n    }\n\n    pub fn new_with_config(config: ReqwestConfig) -\u003e Self {\n        let mut client_builder = reqwest::blocking::Client::builder();\n\n        if let Some(proxy) = config.proxy {\n            client_builder = client_builder.proxy(proxy);\n        }\n\n        if let Some(timeout) = config.timeout {\n            client_builder = client_builder.timeout(timeout);\n        }\n\n        if let Some(headers) = config.headers {\n            client_builder = client_builder.default_headers(headers);\n        }\n\n        let client = client_builder.build().unwrap();\n        Self {\n            url: config.url,\n            auth: config.auth,\n            client,\n        }\n    }\n\n    pub fn rpc_call\u003cResponse\u003e(\n        \u0026self,\n        method: \u0026str,\n        params: \u0026[serde_json::Value],\n    ) -\u003e Result\u003cResponse, crate::rpc_types::Error\u003e\n    where\n        Response: for\u003c'a\u003e serde::de::Deserialize\u003c'a\u003e + Debug,\n    {\n        let mut req = self\n            .client\n            .post(\u0026self.url)\n            .body(\n                json!({\n                    \"jsonrpc\": \"2.0\",\n                    \"id\": 0,\n                    \"method\": method,\n                    \"params\": params,\n                })\n                .to_string(),\n            )\n            .header(\"Content-Type\", \"application/json\");\n\n        if let Some((user, pass)) = \u0026self.auth {\n            req = req.basic_auth(user, Some(pass));\n        }\n\n        let resp = req.send()?;\n        let resp = serde_json::from_str::\u003cJsonRpcResponse\u003cResponse\u003e\u003e(\u0026resp.text()?)?;\n        match resp.result {\n            Some(resp) =\u003e Ok(resp),\n            None if resp.error.is_some() =\u003e Err(crate::rpc_types::Error::Api(resp.error.unwrap())),\n            None =\u003e Err(crate::rpc_types::Error::EmtpyResponse),\n        }\n    }\n}\n\nimpl JsonRPCClient for ReqwestClient {\n    fn call\u003cT: for\u003c'a\u003e serde::de::Deserialize\u003c'a\u003e + Debug\u003e(\n        \u0026self,\n        method: \u0026str,\n        params: \u0026[serde_json::Value],\n    ) -\u003e Result\u003cT, crate::rpc_types::Error\u003e {\n        self.rpc_call(method, params)\n    }\n}\n\n#[derive(Debug, Deserialize)]\npub struct JsonRpcResponse\u003cRes\u003e {\n    pub jsonrpc: String,\n    pub id: u64,\n    pub result: Option\u003cRes\u003e,\n    pub error: Option\u003cserde_json::Value\u003e,\n}\n","traces":[{"line":24,"address":[1723966,1723776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[1725107,1724000,1725138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[1724022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[1724123,1724313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[1724222,1724290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[1724258,1724476,1724320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[1724453,1724387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[2496513,2496291,2496235],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[1792294,1792204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[1792319,1792268],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[1792354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[1792399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[1739587,1712624,1729374,1719122,1733200,1739756,1726160,1715663,1732894,1719312,1722659,1736528,1733056,1715968,1719456,1725823,1722816,1715820,1722473,1726005,1729536,1729680,1736218,1736375],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[1726240,1729760,1726323,1733286,1713861,1720702,1722985,1733369,1729843,1730917,1713908,1719542,1730964,1712704,1724109,1719625,1717205,1722902,1716048,1712787,1737812,1724062,1716131,1727397,1720749,1727444,1737765,1736608,1717252,1734493,1734446,1736691],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[1736687,1733365,1712783,1716127,1719621,1726319,1729839,1722981],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[1719368,1712867,1726403,1729592,1712816,1716160,1719654,1726061,1726352,1729872,1736720,1719705,1722715,1733449,1715876,1723065,1733398,1736431,1739812,1729923,1716211,1723014,1736771,1733112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[1738221,1717417,1717661,1724518,1731373,1714073,1714317,1734658,1724274,1727609,1721158,1734902,1720914,1727853,1737977,1731129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[1727663,1734712,1738031,1721124,1727819,1724484,1714127,1717627,1734868,1720968,1724328,1717471,1731183,1731339,1714283,1738187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[1727752,1727871,1714216,1717679,1724723,1714335,1738426,1735107,1721363,1739754,1724536,1733054,1722657,1721057,1715818,1719310,1717560,1721176,1728058,1714522,1724417,1734920,1738239,1738120,1731391,1731578,1726003,1731272,1729534,1734801,1736373,1717866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[1731526,1715736,1735197,1738516,1725958,1714470,1717814,1719228,1728006,1728148,1733009,1714612,1736291,1731668,1729452,1725921,1729489,1724671,1732972,1715773,1721311,1739709,1724813,1736328,1717956,1719265,1735055,1721453,1722612,1722575,1738374,1739672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[1718549,1732293,1735664,1739077,1728773,1715173,1725280,1721920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[1715210,1739126,1721968,1725324,1735696,1718602,1728818,1732338],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[1739110,1735860,1725465,1718706,1722114,1732542,1739171,1732639,1735785,1725390,1739336,1718871,1735957,1722038,1728799,1715412,1729022,1729119,1732319,1732470,1715186,1715315,1725305,1718586,1715247,1725562,1735685,1739239,1718774,1721957,1728950,1722211],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[1725401,1718717,1715258,1732481,1735796,1728961,1722049,1739182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[1739904,1739968,1740160,1740224,1740096,1740032,1740352,1740288],"length":1,"stats":{"Line":0},"fn_name":"call\u003cfloresta_cli::rpc_types::GetBlockchainInfoRes\u003e"},{"line":96,"address":[1739941,1740005,1740197,1740261,1740133,1740069,1740325,1740389],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":32},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-cli","src","rpc.rs"],"content":"use std::fmt::Debug;\n\nuse bitcoin::block::Header as BlockHeader;\nuse bitcoin::BlockHash;\nuse bitcoin::Txid;\nuse serde_json::Number;\nuse serde_json::Value;\n\nuse crate::rpc_types;\nuse crate::rpc_types::*;\n\ntype Result\u003cT\u003e = std::result::Result\u003cT, rpc_types::Error\u003e;\n\n/// A trait specifying all possible methods for floresta's json-rpc\npub trait FlorestaRPC {\n    /// Get the BIP158 filter for a given block height\n    ///\n    /// BIP158 filters are a compact representation of the set of transactions in a block,\n    /// designed for efficient light client synchronization. This method returns the filter\n    /// for a given block height, encoded as a hexadecimal string.\n    /// You need to have enabled block filters by setting the `blockfilters=1` option\n    fn get_block_filter(\u0026self, heigth: u32) -\u003e Result\u003cString\u003e;\n    /// Returns general information about the chain we are on\n    ///\n    /// This method returns a bunch of information about the chain we are on, including\n    /// the current height, the best block hash, the difficulty, and whether we are\n    /// currently in IBD (Initial Block Download) mode.\n    fn get_blockchain_info(\u0026self) -\u003e Result\u003cGetBlockchainInfoRes\u003e;\n    /// Returns the hash of the block at the given height\n    ///\n    /// This method returns the hash of the block at the given height. If the height is\n    /// invalid, an error is returned.\n    fn get_block_hash(\u0026self, height: u32) -\u003e Result\u003cBlockHash\u003e;\n    /// Returns the block header for the given block hash\n    ///\n    /// This method returns the block header for the given block hash, as defined\n    /// in the Bitcoin protocol specification. A header contains the block's version,\n    /// the previous block hash, the merkle root, the timestamp, the difficulty target,\n    /// and the nonce.\n    fn get_block_header(\u0026self, hash: BlockHash) -\u003e Result\u003cBlockHeader\u003e;\n    /// Gets a transaction from the blockchain\n    ///\n    /// This method returns a transaction that's cached in our wallet. If the verbosity flag is\n    /// set to false, the transaction is returned as a hexadecimal string. If the verbosity\n    /// flag is set to true, the transaction is returned as a json object.\n    fn get_transaction(\u0026self, tx_id: Txid, verbosity: Option\u003cbool\u003e) -\u003e Result\u003cValue\u003e;\n    /// Returns the proof that one or more transactions were included in a block\n    ///\n    /// This method returns the Merkle proof, showing that a transaction was included in a block.\n    /// The pooof is returned as a vector hexadecimal string.\n    fn get_tx_proof(\u0026self, tx_id: Txid) -\u003e Result\u003cVec\u003cString\u003e\u003e;\n    /// Loads up a descriptor into the wallet\n    ///\n    /// This method loads up a descriptor into the wallet. If the rescan option is not None,\n    /// the wallet will be rescanned for transactions matching the descriptor. If you have\n    /// compact block filters enabled, this process will be much faster and use less bandwidth.\n    /// The rescan parameter is the height at which to start the rescan, and should be at least\n    /// as old as the oldest transaction this descriptor could have been used in.\n    fn load_descriptor(\u0026self, descriptor: String, rescan: Option\u003cu32\u003e) -\u003e Result\u003cbool\u003e;\n    /// Trigger a rescan of the wallet\n    ///\n    /// This method triggers a rescan of the wallet. If you have compact block filters enabled,\n    /// this process will be much faster and use less bandwidth. If you don't have compact block\n    /// filters, we'll need to download the entire blockchain again, which will take a while.\n    /// The rescan parameter is the height at which to start the rescan, and should be at least\n    /// as old as the oldest transaction this descriptor could have been used in.\n    fn rescan(\u0026self, rescan: u32) -\u003e Result\u003cbool\u003e;\n    /// Returns the current height of the blockchain\n    fn get_height(\u0026self) -\u003e Result\u003cu32\u003e;\n    /// Sends a hex-encoded transaction to the network\n    ///\n    /// This method sends a transaction to the network. The transaction should be encoded as a\n    /// hexadecimal string. If the transaction is valid, it will be broadcast to the network, and\n    /// return the transaction id. If the transaction is invalid, an error will be returned.\n    fn send_raw_transaction(\u0026self, tx: String) -\u003e Result\u003cTxid\u003e;\n    /// Gets the current accumulator for the chain we're on\n    ///\n    /// This method returns the current accumulator for the chain we're on. The accumulator is\n    /// a set of roots, that let's us prove that a UTXO exists in the chain. This method returns\n    /// a vector of hexadecimal strings, each of which is a root in the accumulator.\n    fn get_roots(\u0026self) -\u003e Result\u003cVec\u003cString\u003e\u003e;\n    /// Gets information about the peers we're connected with\n    ///\n    /// This method returns information about the peers we're connected with. This includes\n    /// the peer's IP address, the peer's version, the peer's user agent, and the peer's\n    /// current height.\n    fn get_peer_info(\u0026self) -\u003e Result\u003cVec\u003cPeerInfo\u003e\u003e;\n    /// Returns a block, given a block hash\n    ///\n    /// This method returns a block, given a block hash. If the verbosity flag is 0, the block\n    /// is returned as a hexadecimal string. If the verbosity flag is 1, the block is returned\n    /// as a json object.\n    fn get_block(\u0026self, hash: BlockHash) -\u003e Result\u003cGetBlockRes\u003e;\n    /// Finds an specific utxo in the chain\n    ///\n    /// You can use this to look for a utxo. If it exists, it will return the amount and\n    /// scriptPubKey of this utxo. It returns an empty object if the utxo doesn't exist.\n    /// You must have enabled block filters by setting the `blockfilters=1` option.\n    fn get_tx_out(\u0026self, tx_id: Txid, outpoint: u32) -\u003e Result\u003cValue\u003e;\n    /// Stops the florestad process\n    ///\n    /// This can be used to gracefully stop the florestad process.\n    fn stop(\u0026self) -\u003e Result\u003cbool\u003e;\n    /// Tells florestad to connect with a peer\n    ///\n    /// You can use this to connect with a given node, providing it's IP address and port.\n    fn add_node(\u0026self, node: String) -\u003e Result\u003cbool\u003e;\n}\n\n/// Since the workflow for jsonrpc is the same for all methods, we can implement a trait\n/// that will let us call any method on the client, and then implement the methods on any\n/// client that implements this trait.\npub trait JsonRPCClient: Sized {\n    /// Calls a method on the client\n    ///\n    /// This should call the appropriated rpc method and return a parsed response or error.\n    fn call\u003cT\u003e(\u0026self, method: \u0026str, params: \u0026[Value]) -\u003e Result\u003cT\u003e\n    where\n        T: for\u003c'a\u003e serde::de::Deserialize\u003c'a\u003e + serde::de::DeserializeOwned + Debug;\n}\n\nimpl\u003cT: JsonRPCClient\u003e FlorestaRPC for T {\n    fn add_node(\u0026self, node: String) -\u003e Result\u003cbool\u003e {\n        self.call(\"addnode\", \u0026[Value::String(node)])\n    }\n\n    fn stop(\u0026self) -\u003e Result\u003cbool\u003e {\n        self.call(\"stop\", \u0026[])\n    }\n\n    fn rescan(\u0026self, rescan: u32) -\u003e Result\u003cbool\u003e {\n        self.call(\"rescan\", \u0026[Value::Number(Number::from(rescan))])\n    }\n\n    fn get_roots(\u0026self) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        self.call(\"getroots\", \u0026[])\n    }\n\n    fn get_block(\u0026self, hash: BlockHash) -\u003e Result\u003cGetBlockRes\u003e {\n        let verbosity = 1; // Return the block in json format\n        self.call(\n            \"getblock\",\n            \u0026[\n                Value::String(hash.to_string()),\n                Value::Number(Number::from(verbosity)),\n            ],\n        )\n    }\n\n    fn get_height(\u0026self) -\u003e Result\u003cu32\u003e {\n        self.call(\"getheight\", \u0026[])\n    }\n\n    fn get_tx_out(\u0026self, tx_id: Txid, outpoint: u32) -\u003e Result\u003cValue\u003e {\n        self.call(\n            \"gettxout\",\n            \u0026[\n                Value::String(tx_id.to_string()),\n                Value::Number(Number::from(outpoint)),\n            ],\n        )\n    }\n\n    fn get_tx_proof(\u0026self, tx_id: Txid) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        self.call(\"gettxoutproof\", \u0026[Value::String(tx_id.to_string())])\n    }\n\n    fn get_peer_info(\u0026self) -\u003e Result\u003cVec\u003cPeerInfo\u003e\u003e {\n        self.call(\"getpeerinfo\", \u0026[])\n    }\n\n    fn get_block_hash(\u0026self, height: u32) -\u003e Result\u003cBlockHash\u003e {\n        self.call(\"getblockhash\", \u0026[Value::Number(Number::from(height))])\n    }\n\n    fn get_transaction(\u0026self, tx_id: Txid, verbosity: Option\u003cbool\u003e) -\u003e Result\u003cValue\u003e {\n        let verbosity = verbosity.unwrap_or(false);\n        self.call(\n            \"getrawtransaction\",\n            \u0026[Value::String(tx_id.to_string()), Value::Bool(verbosity)],\n        )\n    }\n\n    fn load_descriptor(\u0026self, descriptor: String, rescan: Option\u003cu32\u003e) -\u003e Result\u003cbool\u003e {\n        let rescan = rescan.unwrap_or(0);\n        self.call(\n            \"loaddescriptor\",\n            \u0026[\n                Value::String(descriptor),\n                Value::Number(Number::from(rescan)),\n            ],\n        )\n    }\n\n    fn get_block_filter(\u0026self, heigth: u32) -\u003e Result\u003cString\u003e {\n        self.call(\"getblockfilter\", \u0026[Value::Number(Number::from(heigth))])\n    }\n\n    fn get_block_header(\u0026self, hash: BlockHash) -\u003e Result\u003cBlockHeader\u003e {\n        self.call(\"getblockheader\", \u0026[Value::String(hash.to_string())])\n    }\n\n    fn get_blockchain_info(\u0026self) -\u003e Result\u003cGetBlockchainInfoRes\u003e {\n        self.call(\"getblockchaininfo\", \u0026[])\n    }\n\n    fn send_raw_transaction(\u0026self, tx: String) -\u003e Result\u003cTxid\u003e {\n        self.call(\"sendrawtransaction\", \u0026[Value::String(tx)])\n    }\n}\n","traces":[{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[1740416],"length":1,"stats":{"Line":0},"fn_name":"stop\u003cfloresta_cli::reqwest_client::ReqwestClient\u003e"},{"line":128,"address":[1740433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[1740667,1740480],"length":1,"stats":{"Line":0},"fn_name":"rescan\u003cfloresta_cli::reqwest_client::ReqwestClient\u003e"},{"line":132,"address":[1740530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[1740704,1741036],"length":1,"stats":{"Line":0},"fn_name":"get_block\u003cfloresta_cli::reqwest_client::ReqwestClient\u003e"},{"line":140,"address":[1740739],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[1740949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[1740900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[1740763],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[1740876,1740818],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[1741072],"length":1,"stats":{"Line":0},"fn_name":"get_height\u003cfloresta_cli::reqwest_client::ReqwestClient\u003e"},{"line":151,"address":[1741089],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[1741323,1741136],"length":1,"stats":{"Line":0},"fn_name":"get_block_hash\u003cfloresta_cli::reqwest_client::ReqwestClient\u003e"},{"line":173,"address":[1741186],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[1741830,1741360],"length":1,"stats":{"Line":0},"fn_name":"load_descriptor\u003cfloresta_cli::reqwest_client::ReqwestClient\u003e"},{"line":185,"address":[1741432,1741515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[1741738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[1741686],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[1741522],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[1741601,1741662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[1741872,1742059],"length":1,"stats":{"Line":0},"fn_name":"get_block_filter\u003cfloresta_cli::reqwest_client::ReqwestClient\u003e"},{"line":196,"address":[1741922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[1742096,1742289],"length":1,"stats":{"Line":0},"fn_name":"get_block_header\u003cfloresta_cli::reqwest_client::ReqwestClient\u003e"},{"line":200,"address":[1742142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[1742320],"length":1,"stats":{"Line":0},"fn_name":"get_blockchain_info\u003cfloresta_cli::reqwest_client::ReqwestClient\u003e"},{"line":204,"address":[1742337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[1742521,1742384],"length":1,"stats":{"Line":0},"fn_name":"send_raw_transaction\u003cfloresta_cli::reqwest_client::ReqwestClient\u003e"},{"line":208,"address":[1742401],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":45},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-cli","src","rpc_types.rs"],"content":"use std::fmt::Display;\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct GetBlockchainInfoRes {\n    /// The best block we know about\n    ///\n    /// This should be the hash of the latest block in the most PoW chain we know about. We may\n    /// or may not have fully-validated it yet\n    pub best_block: String,\n    /// The depth of the most-PoW chain we know about\n    pub height: u32,\n    /// Whether we are on Initial Block Download\n    pub ibd: bool,\n    /// How many blocks we have fully-validated so far? This number will be smaller than\n    /// height during IBD, and should be equal to height otherwise\n    pub validated: u32,\n    /// The work performed by the last block\n    ///\n    /// This is the estimated amount of hashes the miner of this block had to perform\n    /// before mining that block, on average\n    pub latest_work: String,\n    /// The UNIX timestamp for the latest block, as reported by the block's header\n    pub latest_block_time: u32,\n    /// How many leaves we have in the utreexo accumulator so far\n    ///\n    /// This should be equal to the number of UTXOs returned by core's `gettxoutsetinfo`\n    pub leaf_count: u32,\n    /// How many roots we have in the acc\n    pub root_count: u32,\n    /// The actual hex-encoded roots\n    pub root_hashes: Vec\u003cString\u003e,\n    /// A short string representing the chain we're in\n    pub chain: String,\n    /// The validation progress\n    ///\n    /// 0% means we didn't validate any block. 100% means we've validated all blocks, so\n    /// validated == height\n    pub progress: Option\u003cf32\u003e,\n    /// Current network \"difficulty\"\n    ///\n    /// On average, miners needs to make `difficulty` hashes before finding one that\n    /// solves a block's PoW\n    pub difficulty: u64,\n}\n\n/// The information returned by a get_raw_tx\n#[derive(Deserialize, Serialize)]\npub struct RawTx {\n    /// Whether this tx is in our best known chain\n    pub in_active_chain: bool,\n    /// The hex-encoded tx\n    pub hex: String,\n    /// Tha sha256d of the serialized transaction without witness\n    pub txid: String,\n    /// The sha256d of the serialized transaction including witness\n    pub hash: String,\n    /// The size this transaction occupies on disk\n    pub size: u32,\n    /// The virtual size of this transaction, as define by the segwit soft-fork\n    pub vsize: u32,\n    /// The weight of this transacion, as defined by the segwit soft-fork\n    pub weight: u32,\n    /// This transaction's version. The current bigger version is 2\n    pub version: u32,\n    /// This transaction's locktime\n    pub locktime: u32,\n    /// A list of inputs being spent by this transaction\n    ///\n    /// See [TxIn] for more information about the contents of this\n    pub vin: Vec\u003cTxIn\u003e,\n    /// A list of outputs being created by this tx\n    ///\n    /// Se [TxOut] for more information\n    pub vout: Vec\u003cTxOut\u003e,\n    /// The hash of the block that included this tx, if any\n    pub blockhash: String,\n    /// How many blocks have been mined after this transaction's confirmation\n    /// including the block that confirms it. A zero value means this tx is unconfirmed\n    pub confirmations: u32,\n    /// The timestamp for the block confirming this tx, if confirmed\n    pub blocktime: u32,\n    /// Same as blocktime\n    pub time: u32,\n}\n\n/// A transaction output returned by some RPCs like getrawtransaction and getblock\n#[derive(Deserialize, Serialize)]\npub struct TxOut {\n    /// The amount in sats locked in this UTXO\n    pub value: u64,\n    /// This utxo's index inside the transaction\n    pub n: u32,\n    /// The loking script of this utxo\n    pub script_pub_key: ScriptPubKey,\n}\n\n/// The locking script inside a txout\n#[derive(Deserialize, Serialize)]\npub struct ScriptPubKey {\n    /// A ASM representation for this script\n    ///\n    /// Assembly is a high-level representation of a lower level code. Instructions\n    /// are turned into OP_XXXXX and data is hex-encoded.\n    /// E.g: OP_DUP OP_HASH160 \u003c0000000000000000000000000000000000000000\u003e OP_EQUALVERIFY OP_CHECKSIG\n    pub asm: String,\n    /// The hex-encoded raw script\n    pub hex: String,\n    /// How many signatures are required to spend this UTXO.\n    ///\n    /// This field is deprecated and is here for compatibility with Core\n    pub req_sigs: u32,\n    #[serde(rename = \"type\")]\n    /// The type of this spk. E.g: PKH, SH, WSH, WPKH, TR, non-standard...\n    pub type_: String,\n    /// Encode this script using one of the standard address types, if possible\n    pub address: String,\n}\n\n/// A transaction input returned by some rpcs, like getrawtransaction and getblock\n#[derive(Deserialize, Serialize)]\npub struct TxIn {\n    /// The txid that created this UTXO\n    pub txid: String,\n    /// The index of this UTXO inside the tx that created it\n    pub vout: u32,\n    /// Unlocking script that should solve the challenge and prove ownership over\n    /// that UTXO\n    pub script_sig: ScriptSigJson,\n    /// The nSequence field, used in relative and absolute lock-times\n    pub sequence: u32,\n    /// A vector of witness elements for this input\n    pub witness: Vec\u003cString\u003e,\n}\n\n/// A representation for the transaction ScriptSig, returned by some rpcs\n/// like getrawtransaction and getblock\n#[derive(Deserialize, Serialize)]\npub struct ScriptSigJson {\n    /// A ASM representation for this scriptSig\n    ///\n    /// Assembly is a high-level representation of a lower level code. Instructions\n    /// are turned into OP_XXXXX and data is hex-encoded.\n    /// E.g: OP_PUSHBYTES32 \u003c000000000000000000000000000000000000000000000000000000000000000000\u003e\n    pub asm: String,\n    /// The hex-encoded script sig\n    pub hex: String,\n}\n\n/// General information about our peers. Returned by get_peer_info\n#[derive(Debug, Deserialize, Serialize)]\npub struct PeerInfo {\n    /// The network address for this peer.\n    pub address: String,\n    /// A string with the services this peer advertises. E.g. NODE_NETWORK, UTREEXO, WITNESS...\n    pub services: String,\n    /// User agent is a string that represents the client being used by our peer. E.g.\n    /// /Satoshi-26.0/ for bitcoin core version 26\n    pub user_agent: String,\n    /// This peer's height at the time we've openned a connection with them\n    pub initial_height: u32,\n}\n\n/// A full bitcoin block, returned by get_block\n#[derive(Debug, Deserialize, Serialize)]\npub struct GetBlockRes {\n    /// This block's hash.\n    pub hash: String,\n    /// How many blocks have been added to the chain, after this one have been found. This is\n    /// inclusive, so it starts with one when this block is the latest. If another one is found,\n    /// then it increments to 2 and so on...\n    pub confirmations: u32,\n    /// The size of this block, without the witness\n    pub strippedsize: usize,\n    /// This block's size, with the witness\n    pub size: usize,\n    /// This block's weight.\n    ///\n    /// Data inside a segwit block is counted differently, 'base data' has a weight of 4, while\n    /// witness only counts 1. This is (3 * base_size) + size\n    pub weight: usize,\n    /// How many blocks there are before this block\n    pub height: u32,\n    /// This block's version field\n    ///\n    /// Currently, blocks have version 2 (see BIP34), but it may also flip some of the LSB for\n    /// either consensus reason (see BIPs 8 and 9) or for version rolling mining, usually bits\n    /// after the 24th are not touched. Therefore, the actual version is likelly the result of\n    /// version \u0026 ~(1 \u003c\u003c 24).\n    /// This is encoded as a number, see `version_hex` for a hex-encoded version\n    pub version: i32,\n    #[serde(rename = \"versionHex\")]\n    /// Same as `version` by hex-encoded\n    pub version_hex: String,\n    /// This block's merkle root\n    ///\n    /// A Merkle Tree is a binary tree where every leaf is some data, and the branches are pairwise\n    /// hashes util reaching the root. This allows for compact proof of inclusion in the original\n    /// set. This merkle tree commits to the txid of all transactions in a block, and is used by\n    /// some light clients to determine whether a transaction is in a given block\n    pub merkleroot: String,\n    /// A list of hex-encoded transaction id for the tx's in this block\n    pub tx: Vec\u003cString\u003e,\n    /// The timestamp commited to in this block's header\n    ///\n    /// Since there's no central clock that can tell time precisely in Bitcoin, this value is\n    /// reported by miners and only constrained by a couple of consensus rules. More sensibly, it\n    /// is **not** garanteed to be monotonical. So a block n might have a lower timestamp than\n    /// block `n - 1`.\n    /// If you need it to be monotonical, see `mediantime` insted\n    pub time: u32,\n    /// The meadian of the last 11 blocktimes.\n    ///\n    /// This is a monotonically increasing number that bounds how old a block can be. Blocks may\n    /// not have a timestamp less than the current `mediantime`. This is also used in relative\n    /// timelocks.\n    pub mediantime: u32,\n    /// The nonce used to mine this block.\n    ///\n    /// Blocks are mined by increasing this value until you find a hash that is less than a network\n    /// defined target. This number has no meaning in itself and is just a random u32.\n    pub nonce: u32,\n    /// Bits is a compact representation for the target.\n    ///\n    /// This is a exponential format (with well-define rouding) used by openssl that Satoshi\n    /// decided to make consensus critical :/\n    pub bits: String,\n    /// The difficulty is derived from the current target and is defined as how many hashes, on\n    /// average, one has to make before finding a valid block\n    ///\n    /// This is computed as 1 / (target / 2 ^ 256). In most softwares (this one inclued) the\n    /// difficulty is a multiple of the smallest possible difficulty. So to find the actual\n    /// difficulty you have to multiply this by the min_diff.\n    /// For mainnet, mindiff is 2 ^ 32\n    pub difficulty: u128,\n    /// Commullative work in this network\n    ///\n    /// This is a estimate of how many hashes the network has ever made to produce this chain\n    pub chainwork: String,\n    /// How many transactions in this block\n    pub n_tx: usize,\n    /// The hash of the block comming before this one\n    pub previousblockhash: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    /// The hash of the block comming after this one, if any\n    pub nextblockhash: Option\u003cString\u003e,\n}\n\n#[derive(Debug)]\n/// All possible errors returned by the jsonrpc\npub enum Error {\n    /// An error while deserializing our response\n    Serde(serde_json::Error),\n    #[cfg(feature = \"with-reqwest\")]\n    /// An internal reqwest error\n    Reqwest(reqwest::Error),\n    /// An error internal to our jsonrpc server\n    Api(serde_json::Value),\n    /// The server sent an empty response\n    EmtpyResponse,\n}\n\nimpl From\u003cserde_json::Error\u003e for Error {\n    fn from(value: serde_json::Error) -\u003e Self {\n        Error::Serde(value)\n    }\n}\n\nimpl From\u003creqwest::Error\u003e for Error {\n    fn from(value: reqwest::Error) -\u003e Self {\n        Error::Reqwest(value)\n    }\n}\n\nimpl Display for Error {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Error::Reqwest(e) =\u003e write!(f, \"reqwest returned an error {e}\"),\n            Error::Api(e) =\u003e write!(f, \"general jsonrpc error: {e}\"),\n            Error::Serde(e) =\u003e write!(f, \"error while deserializing the response: {e}\"),\n            Error::EmtpyResponse =\u003e write!(f, \"got an empty response from server\"),\n        }\n    }\n}\n\nimpl std::error::Error for Error {}\n","traces":[{"line":266,"address":[1604704],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":267,"address":[1604712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[1604720],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":273,"address":[1660296],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[2502720],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":279,"address":[1604768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[1604980,1605049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[1605186,1605121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[1604893,1604818],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[1605260],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-common","src","constants.rs"],"content":"//! This module contains some common strings for versioning\n\n/// The default name of our data dir\npub const DIR_NAME: \u0026str = \".floresta\";\n/// Version of rust-bitcoin we are using. If we bump it on Cargo.toml, should change here too\npub const RUST_BITCOIN_VERSION: \u0026str = \"0.29.3\";\n/// Version of rustreexo we use\npub const RUSTREEXO_VERSION: \u0026str = \"0.1.0\";\n/// Our own version\npub const FLORESTA_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-common","src","lib.rs"],"content":"#![no_std]\nuse bitcoin::hashes::sha256;\nuse bitcoin::hashes::Hash;\nuse bitcoin::ScriptBuf;\n#[cfg(feature = \"descriptors\")]\nuse miniscript::Descriptor;\n#[cfg(feature = \"descriptors\")]\nuse miniscript::DescriptorPublicKey;\nuse sha2::Digest;\npub mod constants;\npub mod spsc;\n\nuse prelude::*;\npub use spsc::Channel;\n\npub fn get_hash_from_u8(data: \u0026[u8]) -\u003e sha256::Hash {\n    let hash = sha2::Sha256::new().chain_update(data).finalize();\n    sha256::Hash::from_slice(hash.as_slice()).expect(\"Engines shouldn't be Err\")\n}\n\npub fn get_spk_hash(spk: \u0026ScriptBuf) -\u003e sha256::Hash {\n    let script_hash = spk.as_bytes();\n    let mut hash = sha2::Sha256::new().chain_update(script_hash).finalize();\n    hash.reverse();\n    sha256::Hash::from_slice(hash.as_slice()).expect(\"Engines shouldn't be Err\")\n}\n\n#[cfg(feature = \"descriptors\")]\npub fn parse_descriptors(\n    descriptors: \u0026[String],\n) -\u003e Result\u003cVec\u003cDescriptor\u003cDescriptorPublicKey\u003e\u003e, miniscript::Error\u003e {\n    let descriptors = descriptors\n        .iter()\n        .map(|descriptor| {\n            let descriptor = Descriptor::\u003cDescriptorPublicKey\u003e::from_str(descriptor.as_str())?;\n            descriptor.sanity_check()?;\n            descriptor.into_single_descriptors()\n        })\n        .collect::\u003cResult\u003cVec\u003cVec\u003c_\u003e\u003e, _\u003e\u003e()?\n        .into_iter()\n        .flatten()\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    Ok(descriptors)\n}\n#[cfg(feature = \"no-std\")]\npub mod prelude {\n    extern crate alloc;\n    pub use alloc::borrow::ToOwned;\n    pub use alloc::boxed::Box;\n    pub use alloc::string::String;\n    pub use alloc::string::ToString;\n    pub use alloc::vec;\n    pub use alloc::vec::Vec;\n    pub use core::cmp;\n    pub use core::convert;\n    pub use core::core::str::FromStr;\n    pub use core::fmt;\n    pub use core::fmt::Display;\n    pub use core::iter;\n    pub use core::mem;\n    pub use core::ops;\n    pub use core::ops::Deref;\n    pub use core::ops::DerefMut;\n    pub use core::option;\n    pub use core::result;\n    pub use core::slice;\n    pub use core::str;\n\n    pub use core2::error::Error;\n    pub use core2::io::Error as ioError;\n    pub use core2::io::Read;\n    pub use core2::io::Write;\n    pub use hashbrown::HashMap;\n    pub use hashbrown::HashSet;\n}\n#[cfg(not(feature = \"no-std\"))]\npub mod prelude {\n    extern crate alloc;\n    extern crate std;\n    pub use alloc::string::ToString;\n    pub use std::borrow::ToOwned;\n    pub use std::boxed::Box;\n    pub use std::collections::hash_map::Entry;\n    pub use std::collections::HashMap;\n    pub use std::collections::HashSet;\n    pub use std::error::Error;\n    pub use std::fmt::Display;\n    pub use std::fmt::Formatter;\n    pub use std::fmt::{self};\n    pub use std::io::Error as ioError;\n    pub use std::io::Read;\n    pub use std::io::Write;\n    pub use std::ops::Deref;\n    pub use std::ops::DerefMut;\n    pub use std::result::Result;\n    pub use std::str::FromStr;\n    pub use std::string::String;\n    pub use std::sync;\n    pub use std::vec::Vec;\n    pub use std::vec::{self};\n}\n#[macro_export]\nmacro_rules! impl_error_from {\n    ($thing:ty, $from_thing:ty, $field:ident) =\u003e {\n        impl From\u003c$from_thing\u003e for $thing {\n            fn from(e: $from_thing) -\u003e Self {\n                \u003c$thing\u003e::$field(e)\n            }\n        }\n    };\n}\n","traces":[{"line":16,"address":[5082960],"length":1,"stats":{"Line":0},"fn_name":"get_hash_from_u8"},{"line":17,"address":[914810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[914865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[4976912],"length":1,"stats":{"Line":3},"fn_name":"get_spk_hash"},{"line":22,"address":[5083190],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[915025],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[5083327],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[915122],"length":1,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[5083424],"length":1,"stats":{"Line":0},"fn_name":"parse_descriptors"},{"line":32,"address":[5083483,5083790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[819164,819133,818544],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":35,"address":[818767,818590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[8093921,8094042,8094158,8093742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[818921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[915449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[992832,992800,992784],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":107,"address":[992835,992808,992792],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":5,"coverable":17},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-common","src","spsc.rs"],"content":"//! A no-std Single Producer, Single Consumer channel for unidirectional message exchange between\n//! modules. This module don't use anything from the standard lib and can be easily used in no-std\n//! enviroments. We only use mem::take from [core].\n\nuse core::mem::take;\n\nuse crate::prelude::Vec;\n\n/// A (Send + Sync) single producer, single consumer channel to notify modules about things.\n/// The api is super minimalistic to reduce external dependecies, including from the std-lib\n///\n/// One notable difference from the standard mspc channel is that this channel's ends are't\n/// two different types, while this is possible, there's no reason to do that. Specially\n/// considering that to get a good compile-time asurance that both ends will not be shared, the\n/// channel must not be [Send], but this is one of the main requirements to use this channel in\n/// async code. Moreover, if two worker threads are meant to be identical threads balancing their\n/// work, it might be beneficial to use this same channel as a de-facto single producer, multiple\n/// consumer channel for work distribution.\n/// # Example\n/// ```\n/// use floresta_common::spsc;\n/// let channel = spsc::Channel::new();\n///\n/// // Send something\n/// channel.send(1);\n/// // Read the same thing back\n/// assert_eq!(channel.recv().next(), Some(1));\n/// ```\n#[derive(Debug, Default)]\npub struct Channel\u003cT\u003e {\n    /// The data pending for read\n    content: spin::Mutex\u003cVec\u003cT\u003e\u003e,\n}\n\nimpl\u003cT\u003e Channel\u003cT\u003e {\n    /// Creates a new channel\n    ///\n    /// # Example\n    /// ```\n    /// use floresta_common::spsc;\n    /// let channel = spsc::Channel::new();\n    ///\n    /// channel.send(1);\n    /// assert_eq!(channel.recv().next(), Some(1));\n    /// ```\n    pub fn new() -\u003e Self {\n        Channel {\n            content: spin::Mutex::new(Vec::new()),\n        }\n    }\n    /// Sends some data through a channel\n    ///\n    /// # Example\n    /// ```\n    /// use floresta_common::spsc;\n    /// let channel = spsc::Channel::new();\n    ///\n    /// channel.send(1);\n    /// assert_eq!(channel.recv().next(), Some(1));\n    /// ```\n    pub fn send(\u0026self, data: T) {\n        self.content.lock().push(data);\n    }\n    /// Reads from a channel\n    ///\n    /// This method returns an iterator over all alements inside a [Channel]\n    pub fn recv(\u0026self) -\u003e RecvIter\u003cT\u003e {\n        let inner = take(\u0026mut *self.content.lock());\n        RecvIter { inner }\n    }\n}\n\n/// An iterator issued every time someone calls `recv`.\n///\n/// This iterator takes all itens available for reading in a channel\n/// and lets the consumer iterate over them, without acquiring the lock\n/// every time (the mutex is only locked when `recv` is called).\n///\n/// # Example\n/// ```\n/// use floresta_common::spsc;\n/// let channel = spsc::Channel::new();\n///\n/// channel.send(0);\n/// channel.send(1);\n///\n/// for (i, el) in channel.recv().enumerate() {\n///     assert_eq!(i, el);\n/// }\n/// // A second read should create an empty iterator\n/// assert_eq!(channel.recv().next(), None);\n/// ```\npub struct RecvIter\u003cT\u003e {\n    inner: Vec\u003cT\u003e,\n}\n\nimpl\u003cT\u003e Iterator for RecvIter\u003cT\u003e {\n    type Item = T;\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        if self.inner.is_empty() {\n            return None;\n        }\n        Some(self.inner.remove(0))\n    }\n}\n","traces":[{"line":46,"address":[4814864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[24220908,24220304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[4815248,4815699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-compact-filters","src","bip158.rs"],"content":"// SPDX-License-Identifier: CC0-1.0\n\n// This module was largely copied from https://github.com/rust-bitcoin/murmel/blob/master/src/blockfilter.rs\n// on 11. June 2019 which is licensed under Apache, that file specifically\n// was written entirely by Tamas Blummer, who is re-licensing its contents here as CC0.\n\n//! BIP158 Compact Block Filters for light clients.\n//!\n//! This module implements a structure for compact filters on block data, for\n//! use in the BIP 157 light client protocol. The filter construction proposed\n//! is an alternative to Bloom filters, as used in BIP 37, that minimizes filter\n//! size by using Golomb-Rice coding for compression.\n//!\n//! ## Example\n//!\n//! ```ignore\n//! fn get_script_for_coin(coin: \u0026OutPoint) -\u003e Result\u003cScript, BlockFilterError\u003e {\n//!   // get utxo ...\n//! }\n//!\n//! // create a block filter for a block (server side)\n//! let filter = BlockFilter::new_script_filter(\u0026block, get_script_for_coin)?;\n//!\n//! // or create a filter from known raw data\n//! let filter = BlockFilter::new(content);\n//!\n//! // read and evaluate a filter\n//!\n//! let query: Iterator\u003cItem=Script\u003e = // .. some scripts you care about\n//! if filter.match_any(\u0026block_hash, \u0026mut query.map(|s| s.as_bytes())) {\n//!   // get this block\n//! }\n//!  ```\n\nuse std::cmp::Ordering;\nuse std::cmp::{self};\nuse std::collections::HashSet;\nuse std::fmt::Display;\nuse std::fmt::Formatter;\nuse std::fmt::{self};\nuse std::io::Cursor;\nuse std::io::{self};\n\nuse bitcoin::consensus::Decodable;\nuse bitcoin::consensus::Encodable;\nuse bitcoin::hashes::siphash24;\nuse bitcoin::hashes::Hash;\nuse bitcoin::hex::write_err;\nuse bitcoin::BlockHash;\nuse bitcoin::OutPoint;\nuse bitcoin::VarInt;\n\n/// Golomb encoding parameter as in BIP-158, see also https://gist.github.com/sipa/576d5f09c3b86c3b1b75598d799fc845\nconst P: u8 = 19;\nconst M: u64 = 784931;\n\n/// Errors for blockfilter\n#[derive(Debug)]\npub enum Error {\n    /// missing UTXO, can not calculate script filter\n    UtxoMissing(OutPoint),\n    /// some IO error reading or writing binary serialization of the filter\n    Io(io::Error),\n}\n\nimpl Display for Error {\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e Result\u003c(), fmt::Error\u003e {\n        match *self {\n            Error::UtxoMissing(ref coin) =\u003e write!(f, \"unresolved UTXO {}\", coin),\n            Error::Io(ref e) =\u003e write_err!(f, \"IO error\"; e),\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"std\")))]\nimpl std::error::Error for Error {\n    fn source(\u0026self) -\u003e Option\u003c\u0026(dyn std::error::Error + 'static)\u003e {\n        use self::Error::*;\n\n        match self {\n            UtxoMissing(_) =\u003e None,\n            Io(e) =\u003e Some(e),\n        }\n    }\n}\n\nimpl From\u003cio::Error\u003e for Error {\n    fn from(io: io::Error) -\u003e Self {\n        Error::Io(io)\n    }\n}\n\n/// a computed or read block filter\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct BlockFilter {\n    /// Golomb encoded filter\n    pub content: Vec\u003cu8\u003e,\n}\n\nimpl BlockFilter {\n    /// create a new filter from pre-computed data\n    pub fn new(content: \u0026[u8]) -\u003e BlockFilter {\n        BlockFilter {\n            content: content.to_vec(),\n        }\n    }\n\n    /// match any query pattern\n    pub fn match_any(\n        \u0026self,\n        block_hash: \u0026BlockHash,\n        query: \u0026mut dyn Iterator\u003cItem = \u0026[u8]\u003e,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        let filter_reader = BlockFilterReader::new(block_hash);\n        filter_reader.match_any(\u0026mut Cursor::new(self.content.as_slice()), query)\n    }\n\n    /// match all query pattern\n    pub fn match_all(\n        \u0026self,\n        block_hash: \u0026BlockHash,\n        query: \u0026mut dyn Iterator\u003cItem = \u0026[u8]\u003e,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        let filter_reader = BlockFilterReader::new(block_hash);\n        filter_reader.match_all(\u0026mut Cursor::new(self.content.as_slice()), query)\n    }\n}\n\n/// Reads and interpret a block filter\npub struct BlockFilterReader {\n    reader: GCSFilterReader,\n}\n\nimpl BlockFilterReader {\n    /// Create a block filter reader\n    pub fn new(block_hash: \u0026BlockHash) -\u003e BlockFilterReader {\n        let block_hash_as_int = block_hash.to_byte_array();\n        let mut k0 = [0; 8];\n        let mut k1 = [0; 8];\n\n        k0.clone_from_slice(\u0026block_hash_as_int[0..8]);\n        k1.clone_from_slice(\u0026block_hash_as_int[8..16]);\n\n        let k0 = u64::from_le_bytes(k0);\n        let k1 = u64::from_le_bytes(k1);\n        BlockFilterReader {\n            reader: GCSFilterReader::new(k0, k1, M, P),\n        }\n    }\n\n    /// match any query pattern\n    pub fn match_any(\n        \u0026self,\n        reader: \u0026mut dyn io::Read,\n        query: \u0026mut dyn Iterator\u003cItem = \u0026[u8]\u003e,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        self.reader.match_any(reader, query)\n    }\n\n    /// match all query pattern\n    pub fn match_all(\n        \u0026self,\n        reader: \u0026mut dyn io::Read,\n        query: \u0026mut dyn Iterator\u003cItem = \u0026[u8]\u003e,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        self.reader.match_all(reader, query)\n    }\n}\n\n/// Golomb-Rice encoded filter reader\npub struct GCSFilterReader {\n    filter: GCSFilter,\n    m: u64,\n}\n\nimpl GCSFilterReader {\n    /// Create a new filter reader with specific seed to siphash\n    pub fn new(k0: u64, k1: u64, m: u64, p: u8) -\u003e GCSFilterReader {\n        GCSFilterReader {\n            filter: GCSFilter::new(k0, k1, p),\n            m,\n        }\n    }\n\n    /// match any query pattern\n    pub fn match_any(\n        \u0026self,\n        reader: \u0026mut dyn io::Read,\n        query: \u0026mut dyn Iterator\u003cItem = \u0026[u8]\u003e,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        let mut decoder = reader;\n        let n_elements: VarInt = Decodable::consensus_decode(\u0026mut decoder).unwrap_or(VarInt(0));\n        let reader = \u0026mut decoder;\n        // map hashes to [0, n_elements \u003c\u003c grp]\n        let nm = n_elements.0 * self.m;\n        let mut mapped = query\n            .map(|e| map_to_range(self.filter.hash(e), nm))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        // sort\n        mapped.sort_unstable();\n        if mapped.is_empty() {\n            return Ok(true);\n        }\n        if n_elements.0 == 0 {\n            return Ok(false);\n        }\n\n        // find first match in two sorted arrays in one read pass\n        let mut reader = BitStreamReader::new(reader);\n        let mut data = self.filter.golomb_rice_decode(\u0026mut reader)?;\n        let mut remaining = n_elements.0 - 1;\n        for p in mapped {\n            loop {\n                match data.cmp(\u0026p) {\n                    Ordering::Equal =\u003e return Ok(true),\n                    Ordering::Less =\u003e {\n                        if remaining \u003e 0 {\n                            data += self.filter.golomb_rice_decode(\u0026mut reader)?;\n                            remaining -= 1;\n                        } else {\n                            return Ok(false);\n                        }\n                    }\n                    Ordering::Greater =\u003e break,\n                }\n            }\n        }\n        Ok(false)\n    }\n\n    /// match all query pattern\n    pub fn match_all(\n        \u0026self,\n        reader: \u0026mut dyn io::Read,\n        query: \u0026mut dyn Iterator\u003cItem = \u0026[u8]\u003e,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        let mut decoder = reader;\n        let n_elements: VarInt = Decodable::consensus_decode(\u0026mut decoder).unwrap_or(VarInt(0));\n        let reader = \u0026mut decoder;\n        // map hashes to [0, n_elements \u003c\u003c grp]\n        let nm = n_elements.0 * self.m;\n        let mut mapped = query\n            .map(|e| map_to_range(self.filter.hash(e), nm))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        // sort\n        mapped.sort_unstable();\n        mapped.dedup();\n        if mapped.is_empty() {\n            return Ok(true);\n        }\n        if n_elements.0 == 0 {\n            return Ok(false);\n        }\n\n        // figure if all mapped are there in one read pass\n        let mut reader = BitStreamReader::new(reader);\n        let mut data = self.filter.golomb_rice_decode(\u0026mut reader)?;\n        let mut remaining = n_elements.0 - 1;\n        for p in mapped {\n            loop {\n                match data.cmp(\u0026p) {\n                    Ordering::Equal =\u003e break,\n                    Ordering::Less =\u003e {\n                        if remaining \u003e 0 {\n                            data += self.filter.golomb_rice_decode(\u0026mut reader)?;\n                            remaining -= 1;\n                        } else {\n                            return Ok(false);\n                        }\n                    }\n                    Ordering::Greater =\u003e return Ok(false),\n                }\n            }\n        }\n        Ok(true)\n    }\n}\n\n// fast reduction of hash to [0, nm) range\nfn map_to_range(hash: u64, nm: u64) -\u003e u64 {\n    ((hash as u128 * nm as u128) \u003e\u003e 64) as u64\n}\n\n/// Colomb-Rice encoded filter writer\npub struct GCSFilterWriter\u003c'a\u003e {\n    filter: GCSFilter,\n    writer: \u0026'a mut dyn io::Write,\n    elements: HashSet\u003cVec\u003cu8\u003e\u003e,\n    m: u64,\n}\n\nimpl\u003c'a\u003e GCSFilterWriter\u003c'a\u003e {\n    /// Create a new GCS writer wrapping a generic writer, with specific seed to siphash\n    pub fn new(\n        writer: \u0026'a mut dyn io::Write,\n        k0: u64,\n        k1: u64,\n        m: u64,\n        p: u8,\n    ) -\u003e GCSFilterWriter\u003c'a\u003e {\n        GCSFilterWriter {\n            filter: GCSFilter::new(k0, k1, p),\n            writer,\n            elements: HashSet::new(),\n            m,\n        }\n    }\n\n    /// Add some data to the filter\n    pub fn add_element(\u0026mut self, element: \u0026[u8]) {\n        if !element.is_empty() {\n            self.elements.insert(element.to_vec());\n        }\n    }\n\n    /// write the filter to the wrapped writer\n    pub fn finish(\u0026mut self) -\u003e Result\u003cusize, io::Error\u003e {\n        let nm = self.elements.len() as u64 * self.m;\n\n        // map hashes to [0, n_elements * M)\n        let mut mapped: Vec\u003c_\u003e = self\n            .elements\n            .iter()\n            .map(|e| map_to_range(self.filter.hash(e.as_slice()), nm))\n            .collect();\n        mapped.sort_unstable();\n\n        // write number of elements as varint\n        let mut wrote = VarInt(mapped.len() as u64).consensus_encode(\u0026mut self.writer)?;\n\n        // write out deltas of sorted values into a Golonb-Rice coded bit stream\n        let mut writer = BitStreamWriter::new(self.writer);\n        let mut last = 0;\n        for data in mapped {\n            wrote += self.filter.golomb_rice_encode(\u0026mut writer, data - last)?;\n            last = data;\n        }\n        wrote += writer.flush()?;\n        Ok(wrote)\n    }\n}\n\n/// Golomb Coded Set Filter\nstruct GCSFilter {\n    k0: u64, // sip hash key\n    k1: u64, // sip hash key\n    p: u8,\n}\n\nimpl GCSFilter {\n    /// Create a new filter\n    fn new(k0: u64, k1: u64, p: u8) -\u003e GCSFilter {\n        GCSFilter { k0, k1, p }\n    }\n\n    /// Golomb-Rice encode a number n to a bit stream (Parameter 2^k)\n    fn golomb_rice_encode(\u0026self, writer: \u0026mut BitStreamWriter, n: u64) -\u003e Result\u003cusize, io::Error\u003e {\n        let mut wrote = 0;\n        let mut q = n \u003e\u003e self.p;\n        while q \u003e 0 {\n            let nbits = cmp::min(q, 64);\n            wrote += writer.write(!0u64, nbits as u8)?;\n            q -= nbits;\n        }\n        wrote += writer.write(0, 1)?;\n        wrote += writer.write(n, self.p)?;\n        Ok(wrote)\n    }\n\n    /// Golomb-Rice decode a number from a bit stream (Parameter 2^k)\n    fn golomb_rice_decode(\u0026self, reader: \u0026mut BitStreamReader) -\u003e Result\u003cu64, io::Error\u003e {\n        let mut q = 0u64;\n        while reader.read(1)? == 1 {\n            q += 1;\n        }\n        let r = reader.read(self.p)?;\n        Ok((q \u003c\u003c self.p) + r)\n    }\n\n    /// Hash an arbitrary slice with siphash using parameters of this filter\n    fn hash(\u0026self, element: \u0026[u8]) -\u003e u64 {\n        siphash24::Hash::hash_to_u64_with_keys(self.k0, self.k1, element)\n    }\n}\n\n/// Bitwise stream reader\npub struct BitStreamReader\u003c'a\u003e {\n    buffer: [u8; 1],\n    offset: u8,\n    reader: \u0026'a mut dyn io::Read,\n}\n\nimpl\u003c'a\u003e BitStreamReader\u003c'a\u003e {\n    /// Create a new BitStreamReader that reads bitwise from a given reader\n    pub fn new(reader: \u0026'a mut dyn io::Read) -\u003e BitStreamReader {\n        BitStreamReader {\n            buffer: [0u8],\n            reader,\n            offset: 8,\n        }\n    }\n\n    /// Read nbit bits\n    pub fn read(\u0026mut self, mut nbits: u8) -\u003e Result\u003cu64, io::Error\u003e {\n        if nbits \u003e 64 {\n            return Err(io::Error::new(\n                io::ErrorKind::Other,\n                \"can not read more than 64 bits at once\",\n            ));\n        }\n        let mut data = 0u64;\n        while nbits \u003e 0 {\n            if self.offset == 8 {\n                self.reader.read_exact(\u0026mut self.buffer)?;\n                self.offset = 0;\n            }\n            let bits = cmp::min(8 - self.offset, nbits);\n            data \u003c\u003c= bits;\n            data |= ((self.buffer[0] \u003c\u003c self.offset) \u003e\u003e (8 - bits)) as u64;\n            self.offset += bits;\n            nbits -= bits;\n        }\n        Ok(data)\n    }\n}\n\n/// Bitwise stream writer\npub struct BitStreamWriter\u003c'a\u003e {\n    buffer: [u8; 1],\n    offset: u8,\n    writer: \u0026'a mut dyn io::Write,\n}\n\nimpl\u003c'a\u003e BitStreamWriter\u003c'a\u003e {\n    /// Create a new BitStreamWriter that writes bitwise to a given writer\n    pub fn new(writer: \u0026'a mut dyn io::Write) -\u003e BitStreamWriter {\n        BitStreamWriter {\n            buffer: [0u8],\n            writer,\n            offset: 0,\n        }\n    }\n\n    /// Write nbits bits from data\n    pub fn write(\u0026mut self, data: u64, mut nbits: u8) -\u003e Result\u003cusize, io::Error\u003e {\n        if nbits \u003e 64 {\n            return Err(io::Error::new(\n                io::ErrorKind::Other,\n                \"can not write more than 64 bits at once\",\n            ));\n        }\n        let mut wrote = 0;\n        while nbits \u003e 0 {\n            let bits = cmp::min(8 - self.offset, nbits);\n            self.buffer[0] |= ((data \u003c\u003c (64 - nbits)) \u003e\u003e (64 - 8 + self.offset)) as u8;\n            self.offset += bits;\n            nbits -= bits;\n            if self.offset == 8 {\n                wrote += self.flush()?;\n            }\n        }\n        Ok(wrote)\n    }\n\n    /// flush bits not yet written\n    pub fn flush(\u0026mut self) -\u003e Result\u003cusize, io::Error\u003e {\n        if self.offset \u003e 0 {\n            self.writer.write_all(\u0026self.buffer)?;\n            self.buffer[0] = 0u8;\n            self.offset = 0;\n            Ok(1)\n        } else {\n            Ok(0)\n        }\n    }\n}\n","traces":[{"line":67,"address":[981792],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":68,"address":[981824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[981840,981909],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[981981,982050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[982144],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":90,"address":[982152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[982176],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[982199],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[982256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[982322],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[982337],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[982416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[982482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[982497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[982576],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[982601],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[982646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[982658],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[982670],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[982793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[982885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[982930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[982975],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[983072],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[983109],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[983136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[983173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[983200],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[983241],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[983312,984878,984833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[983379],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[983403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[983473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[983489,983669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[983578],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[983554],"length":1,"stats":{"Line":3},"fn_name":null},{"line":201,"address":[983750,983648],"length":1,"stats":{"Line":2},"fn_name":null},{"line":202,"address":[983757,984482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[983811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[983798],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[983828],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[983840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[984020,983889,984844],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[984133,984058,983990],"length":1,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[984066,984165,984562],"length":1,"stats":{"Line":3},"fn_name":null},{"line":214,"address":[984790,984374],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[984428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[984502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[984484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[984828,984531,984584,984744],"length":1,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[984795,984711,984782],"length":1,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[984519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[984381],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[984912,986449,986494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[984979],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[985003],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[985073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[985089,985269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[985178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[985154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[985248,985350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[985365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[985372,986098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[985426],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[985413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[985443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[985455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[986460,985635,985504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[985605,985673,985748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[985681,986178,985780],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[985989,986406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[986043],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[986100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[986444,986147,986360,986200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[986327,986398,986411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[986135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[986118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[985996],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[986528],"length":1,"stats":{"Line":1},"fn_name":"map_to_range"},{"line":282,"address":[986570,986545],"length":1,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[986608],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":353,"address":[988464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":358,"address":[988496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":359,"address":[988552],"length":1,"stats":{"Line":1},"fn_name":null},{"line":360,"address":[988561,988605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":361,"address":[988603,988635,989266],"length":1,"stats":{"Line":3},"fn_name":null},{"line":362,"address":[988705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":363,"address":[989120,988739,989227],"length":1,"stats":{"Line":2},"fn_name":null},{"line":364,"address":[989261,989271,989200],"length":1,"stats":{"Line":2},"fn_name":null},{"line":366,"address":[988648,988792,988943],"length":1,"stats":{"Line":2},"fn_name":null},{"line":367,"address":[988973,989077,988891],"length":1,"stats":{"Line":2},"fn_name":null},{"line":368,"address":[989059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":372,"address":[989312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[989355],"length":1,"stats":{"Line":1},"fn_name":null},{"line":374,"address":[989553,989369],"length":1,"stats":{"Line":2},"fn_name":null},{"line":375,"address":[989464,989548,989558],"length":1,"stats":{"Line":2},"fn_name":null},{"line":377,"address":[989497,989593,989647],"length":1,"stats":{"Line":2},"fn_name":null},{"line":378,"address":[989614,989686,989771],"length":1,"stats":{"Line":2},"fn_name":null},{"line":382,"address":[989824],"length":1,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[989851],"length":1,"stats":{"Line":1},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":113,"coverable":160},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-compact-filters","src","kv_filter_database.rs"],"content":"use core::fmt;\nuse std::fmt::Debug;\nuse std::fmt::Formatter;\nuse std::path::PathBuf;\n\nuse kv::Bucket;\nuse kv::Config;\nuse kv::Integer;\n\nuse crate::BlockFilter;\nuse crate::BlockFilterStore;\n\n/// Stores the block filters insinde a kv database\n#[derive(Clone)]\npub struct KvFilterStore {\n    bucket: Bucket\u003c'static, Integer, Vec\u003cu8\u003e\u003e,\n}\n\nimpl Debug for KvFilterStore {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.debug_struct(\"KvFilterStore\").finish()\n    }\n}\n\nimpl KvFilterStore {\n    /// Creates a new [KvFilterStore] that stores it's content in `datadir`.\n    ///\n    /// If the path does't exist it'll be created. This store uses compression by default, if you\n    /// want to make more granular configuration over the underlying Kv database, use `with_config`\n    /// instead.\n    pub fn new(datadir: \u0026PathBuf) -\u003e Self {\n        let store = kv::Store::new(kv::Config {\n            path: datadir.to_owned(),\n            temporary: false,\n            use_compression: false,\n            flush_every_ms: None,\n            cache_capacity: None,\n            segment_size: None,\n        })\n        .expect(\"Could not open store\");\n\n        let bucket = store.bucket(Some(\"cfilters\")).unwrap();\n        KvFilterStore { bucket }\n    }\n\n    /// Creates a new [KvFilterStore] that stores it's content with a given config\n    pub fn with_config(config: Config) -\u003e Self {\n        let store = kv::Store::new(config).expect(\"Could not open database\");\n        let bucket = store.bucket(Some(\"cffilters\")).unwrap();\n        KvFilterStore { bucket }\n    }\n}\n\nimpl BlockFilterStore for KvFilterStore {\n    fn get_filter(\u0026self, block_height: u64) -\u003e Option\u003cBlockFilter\u003e {\n        let value = self\n            .bucket\n            .get(\u0026Integer::from(block_height))\n            .ok()\n            .flatten()?;\n        Some(BlockFilter::new(\u0026value))\n    }\n    fn put_filter(\u0026self, block_height: u64, block_filter: BlockFilter) {\n        self.bucket\n            .set(\u0026Integer::from(block_height), \u0026block_filter.content)\n            .expect(\"Bucket should be open\");\n    }\n}\n","traces":[{"line":20,"address":[19488928],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":21,"address":[18256030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[18256544,18256080],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[973571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[19489010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[18256115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[19489039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[973559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[19489385,19489285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[19489488,19489739],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[973994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[974160,974060],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[974256,974646],"length":1,"stats":{"Line":0},"fn_name":"get_filter"},{"line":56,"address":[974326,974512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[974307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[974575,974481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[974672,974857],"length":1,"stats":{"Line":0},"fn_name":"put_filter"},{"line":64,"address":[974766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[974704],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":19},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-compact-filters","src","lib.rs"],"content":"// SPDX-License-Identifier: MIT\n\n//! A library for building and querying BIP-158 compact block filters locally\n//!\n//! This lib implements BIP-158 client-side Galomb-Rice block filters, without\n//! relaying on p2p connections to retrieve them. We use this to speedup wallet\n//! resyncs and allow arbitrary UTXO retrieving for lightning nodes.\n//!\n//! This module should receive blocks as we download them, it'll create a filter\n//! for it. Therefore, you can't use this to speedup wallet sync **before** IBD,\n//! since we wouldn't have the filter for all blocks yet.\nuse core::fmt::Debug;\nuse core::ops::BitAnd;\nuse std::io::Write;\n\nuse bitcoin::hashes::Hash;\nuse bitcoin::Block;\nuse bitcoin::BlockHash;\nuse bitcoin::OutPoint;\nuse bitcoin::Transaction;\nuse bitcoin::Txid;\nuse floresta_chain::BlockConsumer;\nuse log::error;\n\nmod bip158;\npub mod kv_filter_database;\npub mod network_filters;\n\npub use bip158::BlockFilter;\nuse bip158::*;\n\n/// A database that stores our compact filters\npub trait BlockFilterStore: Send + Sync {\n    /// Fetches a block filter\n    fn get_filter(\u0026self, block_height: u64) -\u003e Option\u003cbip158::BlockFilter\u003e;\n    /// Stores a new filter\n    fn put_filter(\u0026self, block_height: u64, block_filter: bip158::BlockFilter);\n}\n\n/// All standard outputs type define in the Bitcoin network\n#[derive(Debug, Hash)]\npub enum OutputTypes {\n    /// public key hash\n    PKH,\n    /// script hash\n    SH,\n    /// witness public key hash\n    WPKH,\n    /// witness script hash\n    WSH,\n    /// Taproot (witness v1)\n    TR,\n}\n\n/// This means we track all suported address types\nconst ALL_OUTPUTS: u8 = 0x1f; // 00011111\n/// The `M` parameter from BIP-158\nconst FILTER_M: u64 = 784931;\n/// The `P` parameter form BIP-158\nconst FILTER_P: u8 = 19;\n\nimpl BitAnd\u003cu8\u003e for OutputTypes {\n    type Output = bool;\n    fn bitand(self, rhs: u8) -\u003e Self::Output {\n        let is_set = match self {\n            Self::PKH =\u003e rhs \u0026 1,\n            Self::SH =\u003e rhs \u0026 2,\n            Self::WPKH =\u003e rhs \u0026 4,\n            Self::WSH =\u003e rhs \u0026 16,\n            Self::TR =\u003e rhs \u0026 32,\n        };\n        is_set != 0\n    }\n}\n\n/// A backend capable of holding multiple BIP158 compact block filters\npub struct BlockFilterBackend {\n    /// Which outputs types we index\n    whitelisted_outputs: u8,\n    /// Whether we index inputs (if true, all outpoints being spent are added to the filter)\n    index_inputs: bool,\n    /// Whether we index txids. If true, all txids are added to the filter. This is useful for\n    /// using floresta as a lightning node backend\n    index_txids: bool,\n    /// A persistence engine for our filters\n    storage: Box\u003cdyn BlockFilterStore\u003e,\n    /// The first half of the siphash key\n    k0: u64,\n    /// The second half of the siphash key\n    k1: u64,\n    /// A block hash used to salt the siphash, we use a random hash instead of\n    /// an actual block hash\n    key: [u8; 32],\n}\n\n/// Keeps track of a unfinnished BIP-158 block filter. We use this to add new elements\n/// to the filter, until there's nothing more to add\nstruct FilterBuilder\u003c'a\u003e {\n    writer: GCSFilterWriter\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e FilterBuilder\u003c'a\u003e {\n    #[allow(non_snake_case)]\n    pub fn new(writer: \u0026'a mut dyn Write, M: u64, P: u8, k0: u64, k1: u64) -\u003e FilterBuilder {\n        let writer = GCSFilterWriter::new(writer, k0, k1, M, P);\n        FilterBuilder { writer }\n    }\n    /// Add a new slice to the filter\n    pub fn put(\u0026mut self, el: \u0026[u8]) {\n        self.writer.add_element(el);\n    }\n    /// Mark a filter as finished, writing the filter content into the internal buffer\n    ///\n    /// This method should be called only once, and no more elements should be added after\n    /// calling this method.\n    pub fn finish(\u0026mut self) -\u003e Result\u003cusize, bip158::Error\u003e {\n        Ok(self.writer.finish()?)\n    }\n}\n\nimpl BlockFilterBackend {\n    /// Creates a new [BlockFilterBackend].\n    ///\n    /// Storage is a database used for storing and retrieving filters. May be anything\n    /// that implements [BlockFilterStore].\n    /// Key is a 256-bytes element that'll be used as key for the siphash iside our filters.\n    /// BIP-158 defines this key as the hash of each block, since they need a public parameter,\n    /// and a fixed one may be exploited by bad actors trying to trick a wallet into having many\n    /// false-positives. Since we don' need a public parameter here, a once-initialized random\n    /// slice is enought.\n    pub fn new(storage: Box\u003cdyn BlockFilterStore\u003e, key: [u8; 32]) -\u003e BlockFilterBackend {\n        let mut k0 = [0_u8; 8];\n        let mut k1 = [0_u8; 8];\n\n        k0.copy_from_slice(\u0026key[0..8]);\n        k1.copy_from_slice(\u0026key[8..16]);\n\n        BlockFilterBackend {\n            whitelisted_outputs: ALL_OUTPUTS,\n            index_inputs: true,\n            index_txids: true,\n            storage,\n            key,\n            k0: u64::from_le_bytes(k0),\n            k1: u64::from_le_bytes(k1),\n        }\n    }\n    /// Returns a given filter\n    pub fn get_filter(\u0026self, block_height: u32) -\u003e Option\u003cbip158::BlockFilter\u003e {\n        self.storage.get_filter(block_height as u64)\n    }\n\n    /// Build and index a given block height\n    pub fn filter_block(\u0026self, block: \u0026Block, block_height: u64) -\u003e Result\u003c(), bip158::Error\u003e {\n        let mut writer = Vec::new();\n        let mut filter = FilterBuilder::new(\u0026mut writer, FILTER_M, FILTER_P, self.k0, self.k1);\n\n        if self.index_inputs {\n            self.write_inputs(\u0026block.txdata, \u0026mut filter);\n        }\n\n        if self.index_txids {\n            self.write_txids(\u0026block.txdata, \u0026mut filter);\n        }\n\n        self.write_outputs(\u0026block.txdata, \u0026mut filter);\n        filter.finish()?;\n\n        let filter = BlockFilter::new(writer.as_slice());\n\n        self.storage.put_filter(block_height, filter);\n        Ok(())\n    }\n\n    /// Maches a set of filters against out current set of filters\n    ///\n    /// This function will run over each filter inside the range `[start, end]` and sees\n    /// if at least one query mathes. It'll return a vector of block heights where it matches.\n    /// you should download those blocks and see what if there's anything interesting.\n    pub fn match_any(\u0026self, start: u64, end: u64, query: \u0026[QueryType]) -\u003e Option\u003cVec\u003cu64\u003e\u003e {\n        let mut blocks = Vec::new();\n        let key = BlockHash::from_byte_array(self.key);\n        let values = query\n            .iter()\n            .map(|filter| filter.as_slice())\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        for i in start..=end {\n            if let Some(result) = self.storage.get_filter(i) {\n                let result = result.match_any(\u0026key, \u0026mut values.iter().copied()).ok()?;\n                if result {\n                    blocks.push(i);\n                }\n            }\n        }\n        Some(blocks)\n    }\n\n    fn write_txids(\u0026self, txs: \u0026Vec\u003cTransaction\u003e, filter: \u0026mut FilterBuilder) {\n        for tx in txs {\n            filter.put(tx.txid().as_byte_array());\n        }\n    }\n\n    fn write_inputs(\u0026self, txs: \u0026Vec\u003cTransaction\u003e, filter: \u0026mut FilterBuilder) {\n        for tx in txs {\n            tx.input.iter().for_each(|input| {\n                let mut ser_input = [0; 36];\n                ser_input[0..32].clone_from_slice(input.previous_output.txid.as_byte_array());\n                ser_input[32..].clone_from_slice(\u0026input.previous_output.vout.to_be_bytes());\n                filter.put(\u0026ser_input);\n            })\n        }\n    }\n\n    fn write_tx_outs(\u0026self, tx: \u0026Transaction, filter: \u0026mut FilterBuilder) {\n        for output in tx.output.iter() {\n            let hash = floresta_common::get_spk_hash(\u0026output.script_pubkey);\n            if OutputTypes::PKH \u0026 self.whitelisted_outputs \u0026\u0026 output.script_pubkey.is_p2pkh() {\n                filter.put(hash.as_byte_array());\n            }\n            if OutputTypes::SH \u0026 self.whitelisted_outputs \u0026\u0026 output.script_pubkey.is_p2sh() {\n                filter.put(hash.as_byte_array());\n            }\n            if OutputTypes::WPKH \u0026 self.whitelisted_outputs \u0026\u0026 output.script_pubkey.is_p2wpkh() {\n                filter.put(hash.as_byte_array());\n            }\n            if OutputTypes::WSH \u0026 self.whitelisted_outputs \u0026\u0026 output.script_pubkey.is_p2wsh() {\n                filter.put(hash.as_byte_array());\n            }\n            if OutputTypes::TR \u0026 self.whitelisted_outputs \u0026\u0026 output.script_pubkey.is_p2tr() {\n                filter.put(hash.as_byte_array());\n            }\n        }\n    }\n\n    fn write_outputs(\u0026self, txs: \u0026Vec\u003cTransaction\u003e, filter: \u0026mut FilterBuilder) {\n        for tx in txs {\n            self.write_tx_outs(tx, filter);\n        }\n    }\n}\n\nimpl BlockConsumer for BlockFilterBackend {\n    fn consume_block(\u0026self, block: \u0026Block, height: u32) {\n        if let Err(e) = self.filter_block(block, height as u64) {\n            error!(\"while creating filter for block {height}: {e}\");\n        }\n    }\n}\n/// Builds a block filter backend with an interactive builder.\n///\n/// The only thing required is a database to save the filters.\n/// Fields have the same meaning as in the backend itself.\n#[derive(Default)]\npub struct FilterBackendBuilder {\n    /// Where we should store our filter.\n    storage: Option\u003cBox\u003cdyn BlockFilterStore\u003e\u003e,\n    /// What types of outputs should we store.\n    whitelisted_outputs: u8,\n    /// Whether we should save outpoints being spent to the filter\n    index_input: bool,\n    /// Whether we should save the id for transactions in this block\n    index_txids: bool,\n    /// The siphash key we should use\n    key: [u8; 32],\n}\n\nimpl FilterBackendBuilder {\n    /// Which storage we should use for our filters\n    ///\n    /// This is the only required field.\n    pub fn use_storage(mut self, s: Box\u003cdyn BlockFilterStore\u003e) -\u003e Self {\n        self.storage.replace(s);\n        self\n    }\n    /// Add one address type to the set of outputs we follow\n    ///\n    /// You can use whatever number of types, including all. But any new type\n    /// makes the filter larger.\n    pub fn add_address_type(mut self, out_type: OutputTypes) -\u003e Self {\n        match out_type {\n            OutputTypes::PKH =\u003e self.whitelisted_outputs |= 1,\n            OutputTypes::SH =\u003e self.whitelisted_outputs |= 2,\n            OutputTypes::WPKH =\u003e self.whitelisted_outputs |= 4,\n            OutputTypes::WSH =\u003e self.whitelisted_outputs |= 16,\n            OutputTypes::TR =\u003e self.whitelisted_outputs |= 32,\n        };\n        self\n    }\n    /// Whether we should index txids\n    ///\n    /// You can use this index to fetch arbitrary outpoints, like a lightning\n    /// channel. In general, this should be used in combination with index_input,\n    /// or you can't be sure whether the outpoint is spent or not.\n    pub fn index_txids(mut self, index: bool) -\u003e Self {\n        self.index_txids = index;\n        self\n    }\n    /// Whether we index inputs\n    ///\n    /// If true, we add the prevout, but not the previous spk or scriptSig\n    pub fn index_input(mut self, index: bool) -\u003e Self {\n        self.index_input = index;\n        self\n    }\n    /// A key used by siphash\n    ///\n    /// BIP-158 uses the block hash, but we use a fixed by here, so we don't\n    /// need to access chaindata on query\n    pub fn key_hash(mut self, key: [u8; 32]) -\u003e Self {\n        self.key = key;\n        self\n    }\n    /// Builds the final backend\n    ///\n    /// # Panics\n    /// Panics if we don't have a storage\n    pub fn build(self) -\u003e BlockFilterBackend {\n        let mut k0 = [0_u8; 8];\n        let mut k1 = [0_u8; 8];\n\n        k0.copy_from_slice(\u0026self.key[0..8]);\n        k1.copy_from_slice(\u0026self.key[8..16]);\n\n        BlockFilterBackend {\n            key: self.key,\n            whitelisted_outputs: self.whitelisted_outputs,\n            index_inputs: self.index_input,\n            index_txids: self.index_txids,\n            storage: self.storage.expect(\"No filter storage specified\"),\n            k0: u64::from_le_bytes(k0),\n            k1: u64::from_le_bytes(k1),\n        }\n    }\n}\n\n/// A serialized output that can be queried against our filter\n#[derive(Debug)]\npub struct QueriableOutpoint(pub(crate) [u8; 36]);\n\nimpl From\u003cOutPoint\u003e for QueriableOutpoint {\n    fn from(value: OutPoint) -\u003e Self {\n        let mut ser_input = [0; 36];\n        ser_input[0..32].clone_from_slice(value.txid.as_byte_array());\n        ser_input[32..].clone_from_slice(\u0026value.vout.to_be_bytes());\n        QueriableOutpoint(ser_input)\n    }\n}\n\n/// The type of value we are looking for in a filter.\n#[derive(Debug)]\npub enum QueryType {\n    /// We are looking for a specific outpoint being spent\n    Input(QueriableOutpoint),\n    /// We're looking for a script hash receiving money (not spending)\n    ScriptHash([u8; 32]),\n    /// A transaction with a specific it\n    Txid(Txid),\n}\n\nimpl QueryType {\n    pub(crate) fn as_slice(\u0026self) -\u003e \u0026[u8] {\n        match self {\n            QueryType::Txid(txid) =\u003e txid.as_byte_array().as_slice(),\n            QueryType::Input(outpoint) =\u003e \u0026outpoint.0,\n            QueryType::ScriptHash(script) =\u003e script,\n        }\n    }\n}\n\n#[doc(hidden)]\n#[cfg(test)]\nuse std::cell::RefCell;\n\n/// A volatile block filters store used for tests\n#[cfg(test)]\n#[doc(hidden)]\n#[derive(Debug, Default)]\npub struct MemoryBlockFilterStorage {\n    filters: RefCell\u003cVec\u003cbip158::BlockFilter\u003e\u003e,\n}\n\n#[cfg(test)]\n#[doc(hidden)]\nunsafe impl Sync for MemoryBlockFilterStorage {}\n\n#[doc(hidden)]\n#[cfg(test)]\nimpl BlockFilterStore for MemoryBlockFilterStorage {\n    fn get_filter(\u0026self, block_height: u64) -\u003e Option\u003cbip158::BlockFilter\u003e {\n        self.filters.borrow().get(block_height as usize).cloned()\n    }\n    fn put_filter(\u0026self, _block_height: u64, block_filter: bip158::BlockFilter) {\n        self.filters.borrow_mut().push(block_filter);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::str::FromStr;\n\n    use bitcoin::consensus::deserialize;\n    use bitcoin::hashes::hex::FromHex;\n    use bitcoin::hashes::Hash;\n    use bitcoin::Block;\n    use bitcoin::BlockHash;\n    use bitcoin::OutPoint;\n    use bitcoin::ScriptBuf;\n    use bitcoin::Txid;\n\n    use super::BlockFilterBackend;\n    use super::FilterBuilder;\n    use super::MemoryBlockFilterStorage;\n    use crate::bip158;\n    use crate::QueryType;\n    #[test]\n    fn test_filter() {\n        let mut writer = Vec::new();\n        let value = [10_u8; 42].as_slice();\n        let mut filters = FilterBuilder::new(\u0026mut writer, 784931, 19, 0, 0);\n\n        filters.put(value);\n        filters.finish().unwrap();\n\n        let filter = bip158::BlockFilter::new(\u0026writer);\n        let res = filter\n            .match_any(\n                \u0026BlockHash::from_byte_array([0; 32]),\n                \u0026mut [value].iter().copied(),\n            )\n            .unwrap();\n        assert!(res);\n\n        let value = [11_u8; 42].as_slice();\n        let res = filter\n            .match_any(\n                \u0026BlockHash::from_byte_array([0; 32]),\n                \u0026mut [value].iter().copied(),\n            )\n            .unwrap();\n        assert!(!res);\n    }\n\n    #[test]\n    fn test_filter_block() {\n        let block = Vec::from_hex(\"000000204cc1f0cc52950600bc94fc482713c1f10174c85f20290168832552c1b900000039d96a9dbab5998c344c092583552e6ed5e2884c8a52a95b482f59413f39e8d55cf03f654454011e7d45dc0003020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff0f030b8d020a2f7369676e65743a332ffeffffff025503062a010000002251207099e4b23427fc40ba4777bbf52cfd0b7444d69a3e21ef281270723f54c0c14b0000000000000000776a24aa21a9edfb6e452f1cccc00da281067a88bed1d9ec6e02361d424dfd46dc46972b6c22284c4fecc7daa249004730440220435eaca92f93497d07825fe4587183272084e257c61cccab15a1dbc37a946699022000c18b0cba4f96ab5f741478da264b361ba95523a486126657b6f9e1045126a20100012000000000000000000000000000000000000000000000000000000000000000000000000002000000000101125b54a68d9a39561dd268e020e3f26dd900ded46a3dfdbae7ea95797022a0a80100000000fdffffff027082030000000000160014fabea557d8541249533fe281aac45c37b2dbf3422dab090000000000220020dfcc1d4c1fef729015420efed6202f7d1fd1a74813f7875fa235413bd36f73d20800483045022100dce01d603f84de4faeacd7bcdf1bc93fdc3cb7a28eff0544d88c1b64fa07f8d602206aefc00419126035222e5138b07b40d77c71feba78c26d4febd51f10f814dff101483045022100bf7c25066c5c4abb2d2733cf04c700b175d5e92d09e5931313adaef05e062758022001cf4bb4437a0a20b6ff9277c29a2b28259c1a6143fd4938920cae7a8a3658350147304402206f3d38a3f4db843a41f22583cfd344b935156fa0e82afe7212f8861fc04d979c0220726324a84cb6906df296416a00032e0c8238df0f4cf8e7204385f2cdd359056301483045022100fb3a30dc1103ba0b865d96bd9097a264c0e18aeffb2a4ee0875c0edea356cb6c022070e47aac3b0ed218a9afbc7f70d42935084a80f47af44941a6712314b3391b50010000fdea016376a914a2c0c43c1cbc4c3d1f5d197000414de73e76456388ac6b76a914bf51072415ece1527ac34d955924be96d07cbde788ac6c936b76a91425fb796fb6194fe09ab2b06344bace2b9320d45c88ac6c936b76a914a6cb8313859649a1b83dc9b77c3afe7671affe0b88ac6c93518803ffff00b2676376a914c209f7a523ffa69a7226c5a5167b2b37ddec58eb88ac6b76a914d61ff559b874d8833b75b7d6939b0df3e68b583d88ac6c936b76a91444b6c96c823cb70c130bd12ee39b5504d6be84cc88ac6c936b76a914f086890b09e618632f45a3511c5983dafb2e714a88ac6c93528854b267542102a31ccbcc7262f1cf9ee85bf04723d28d5cdebdaa98fa0b972fd5210610c6aaba2102a9b90ff89fa8a411c7e8f1af247ba6e32c6d4d4e682d643eb30a02841dae2a962103b8c2b5e5db7603cb0b3a5280941988588af0f71362321442f228fb2b4a38cbd921022da633f9e545cc1029055cafa583b4cd99b7a4bcfb1ea2a388fbefb11e0c8b9054ae736476a91443948748fc4e5a8300ea3eee7feafad9cdd4a3c588ac6b76a91447f5b0296d7b9dd38b64d45b3ef88490847d17ad88ac6c936b76a914f2b7716f6e11b214457c38c501b7a0f7706e06aa88ac6c936b76a91443587cfdb6e2bace0de537152e1ffa8e8d77d91a88ac6c93538852b268686800000000020000000001013b12458f060f8df025c0ab068695384bcc6c846aefed31b0d203122ee09c71100100000000feffffff02ef8b64d04a0600001600147f5eeef1c2a1c5c81ee1545876c8f8fc93d0c1e6a086010000000000160014a9c03ef086c4d0c9fe2d093a4e1f28dff63c0f700247304402205e1935e762a89e99b9185e540ad0a1800d26a9643599d28c4e8619432f04abc802200a3fedf0746f127884b74087561d3190c408afda770bd5aeb3928bb7a4d61832012103b5746579fa0f79ed83dfd6a2142d957156a89690fcb76ed90debdf287b9bc94bb98c0200\").unwrap();\n\n        let block: Block = deserialize(\u0026block).unwrap();\n        let storage = MemoryBlockFilterStorage::default();\n        let backend =\n            BlockFilterBackend::new(Box::new(storage), block.block_hash().to_byte_array());\n\n        backend.filter_block(\u0026block, 0).unwrap();\n\n        // One txid from this block\n        let txid =\n            Txid::from_str(\"7e0ce903920704a79beb99beb05c6d5a01852907dccc0973f96eb295d1ad0557\")\n                .unwrap();\n        let txid = QueryType::Txid(txid);\n\n        // One output being spent in this block\n        let prev_txid =\n            Txid::from_str(\"a8a022707995eae7bafd3d6ad4de00d96df2e320e068d21d56399a8da6545b12\")\n                .unwrap();\n        let prev_vout: u32 = 1;\n\n        let prevout = QueryType::Input(\n            OutPoint {\n                txid: prev_txid,\n                vout: prev_vout,\n            }\n            .into(),\n        );\n        // One spk from this block\n        let spck = ScriptBuf::from_hex(\"0014fabea557d8541249533fe281aac45c37b2dbf342\").unwrap();\n        let spck = QueryType::ScriptHash(floresta_common::get_spk_hash(\u0026spck).to_byte_array());\n\n        let expected = Some(vec![0]);\n\n        assert_eq!(backend.match_any(0, 0, \u0026[txid]), expected);\n        assert_eq!(backend.match_any(0, 0, \u0026[prevout]), expected);\n        assert_eq!(backend.match_any(0, 0, \u0026[spck]), expected);\n    }\n}\n","traces":[{"line":64,"address":[1013872],"length":1,"stats":{"Line":1},"fn_name":"bitand"},{"line":65,"address":[1013890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[1013927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[1013939],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[1013951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[1013963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[1013975],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[1013981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[1014903,1014320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[1014360],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[1014385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[1014394,1014501],"length":1,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[1014534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[1014702],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[1014775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[1014944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[1014967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[1014992,1015641],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[1015048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[1015077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[1015167],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[1015242,1015201],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[1015178],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[1015281],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[1015259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[1015303,1015405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[1015374,1015496],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[1015513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[1015574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[1015680,1016907,1016956],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[1015777],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[1015826],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[1015923],"length":1,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[1030393,1030368],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":188,"address":[1016016,1016298,1016083,1016936],"length":1,"stats":{"Line":4},"fn_name":null},{"line":189,"address":[1016367,1016319],"length":1,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[1016787,1016561,1015737,1016444],"length":1,"stats":{"Line":3},"fn_name":null},{"line":191,"address":[1016773],"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[1016817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[1016208],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[1016992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[1017027,1017089],"length":1,"stats":{"Line":2},"fn_name":null},{"line":201,"address":[1017099],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[1017152],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[1017244,1017182],"length":1,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[1017254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[1030449],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[1030466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[1030566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[1030676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[1017312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[1017451,1017357],"length":1,"stats":{"Line":2},"fn_name":null},{"line":218,"address":[1017469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[1017547,1017485],"length":1,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[1017570],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[1017638,1017515],"length":1,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[1017661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[1017729,1017606],"length":1,"stats":{"Line":2},"fn_name":null},{"line":226,"address":[1017752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[1017697,1017823],"length":1,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[1017846],"length":1,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[1017788,1017882],"length":1,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[1017908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[1017952],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[1017994,1018066],"length":1,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[1018076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[1018745,1018096],"length":1,"stats":{"Line":0},"fn_name":"consume_block"},{"line":246,"address":[1018131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[1018403,1018630,1018229,1018343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[1018988,1018816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[1018877,1018936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[1018968],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[1019024],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[1019048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[1019085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[1019100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[1019115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[1019130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[1019145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[1019163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[1019184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[1019207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[1019212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[1019232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[1019255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[1019260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[1019280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[1019288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[1019302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[1019328,1019987],"length":1,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[1019358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[1019383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[1019499,1019392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[1019532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[1019643],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[1019666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[1019673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[1019680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[1019687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[1019765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[1019838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[1020032],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":344,"address":[1020054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":345,"address":[1020071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":346,"address":[1020165],"length":1,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[1020270],"length":1,"stats":{"Line":1},"fn_name":null},{"line":363,"address":[1020336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":364,"address":[1020479,1020350],"length":1,"stats":{"Line":2},"fn_name":null},{"line":365,"address":[1020447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[1020387],"length":1,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[1020417],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":77,"coverable":117},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-compact-filters","src","network_filters.rs"],"content":"use std::sync::PoisonError;\nuse std::sync::RwLock;\nuse std::sync::RwLockWriteGuard;\n\nuse bitcoin::BlockHash;\nuse floresta_chain::pruned_utreexo::BlockchainInterface;\n\nuse crate::BlockFilterStore;\n\n#[derive(Debug)]\npub struct NetworkFilters\u003cStorage: BlockFilterStore + Send + Sync\u003e {\n    filters: Storage,\n    height: RwLock\u003cu32\u003e,\n}\n\nimpl\u003cStorage: BlockFilterStore + Send + Sync\u003e NetworkFilters\u003cStorage\u003e {\n    pub fn new(filters: Storage, height: u32) -\u003e Self {\n        Self {\n            filters,\n            height: RwLock::new(height),\n        }\n    }\n\n    pub fn get_filter(\u0026self, height: u32) -\u003e Option\u003ccrate::BlockFilter\u003e {\n        self.filters.get_filter(height as u64)\n    }\n\n    pub fn match_any(\n        \u0026self,\n        query: Vec\u003c\u0026[u8]\u003e,\n        start_height: u32,\n        end_height: u32,\n        chain: impl BlockchainInterface,\n    ) -\u003e Vec\u003cBlockHash\u003e {\n        let mut blocks = Vec::new();\n        for height in start_height..end_height {\n            let Some(filter) = self.filters.get_filter(height as u64) else {\n                continue;\n            };\n\n            let mut query = query.clone().into_iter();\n            let hash = chain.get_block_hash(height).unwrap();\n\n            if filter.match_any(\u0026hash, \u0026mut query).unwrap() {\n                let block_hash = chain.get_block_hash(height).unwrap();\n                blocks.push(block_hash);\n            }\n        }\n\n        blocks\n    }\n\n    pub fn push_filter(\n        \u0026self,\n        height: u32,\n        filter: crate::BlockFilter,\n    ) -\u003e Result\u003c(), PoisonError\u003cRwLockWriteGuard\u003cu32\u003e\u003e\u003e {\n        self.filters.put_filter(height as u64, filter);\n        self.height.write().map(|mut self_height| {\n            *self_height = height;\n        })\n    }\n\n    pub fn get_height(\u0026self) -\u003e u32 {\n        self.height.read().map(|height| *height).unwrap_or(0)\n    }\n}\n","traces":[{"line":17,"address":[3901488,3901616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[5038380],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[5037888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[5037908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[3901648,3902622,3902668],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[5038560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[3901967,3902617,3901866,3901785],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[3902072,3901982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[5038994,5039076],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[3902324,3902259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[5038112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":21},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-electrum","src","electrum_protocol.rs"],"content":"use std::borrow::Borrow;\nuse std::collections::HashMap;\nuse std::collections::HashSet;\nuse std::sync::Arc;\n\nuse async_std::channel::unbounded;\nuse async_std::channel::Receiver;\nuse async_std::channel::Sender;\nuse async_std::io::BufReader;\nuse async_std::net::TcpListener;\nuse async_std::net::TcpStream;\nuse async_std::prelude::*;\nuse async_std::sync::RwLock;\nuse bitcoin::consensus::deserialize;\nuse bitcoin::consensus::encode::serialize_hex;\nuse bitcoin::hashes::hex::FromHex;\nuse bitcoin::hashes::sha256;\nuse bitcoin::ScriptBuf;\nuse bitcoin::Transaction;\nuse bitcoin::TxOut;\nuse bitcoin::Txid;\nuse floresta_chain::pruned_utreexo::BlockchainInterface;\nuse floresta_common::get_hash_from_u8;\nuse floresta_common::get_spk_hash;\nuse floresta_common::spsc::Channel;\nuse floresta_compact_filters::kv_filter_database::KvFilterStore;\nuse floresta_compact_filters::network_filters::NetworkFilters;\nuse floresta_watch_only::kv_database::KvDatabase;\nuse floresta_watch_only::AddressCache;\nuse floresta_watch_only::CachedTransaction;\nuse floresta_wire::node_interface::NodeInterface;\nuse floresta_wire::node_interface::NodeMethods;\nuse log::error;\nuse log::info;\nuse log::trace;\nuse serde_json::json;\nuse serde_json::Value;\n\nuse crate::get_arg;\nuse crate::json_rpc_res;\nuse crate::request::Request;\n\n/// Type alias for u32 representing a ClientId\ntype ClientId = u32;\n\n/// A client connected to the server\n#[derive(Debug, Clone)]\npub struct Client {\n    client_id: ClientId,\n    _addresses: HashSet\u003cScriptBuf\u003e,\n    stream: Arc\u003cTcpStream\u003e,\n}\n\nimpl Client {\n    /// Send a message to the client, should be a serialized JSON\n    pub async fn write(\u0026self, data: \u0026[u8]) -\u003e Result\u003c(), std::io::Error\u003e {\n        let mut stream = self.stream.as_ref();\n        let _ = stream.write(data).await;\n        let _ = stream.write('\\n'.to_string().as_bytes()).await;\n\n        Ok(())\n    }\n    /// Create a new client from a stream\n    pub fn new(client_id: ClientId, stream: Arc\u003cTcpStream\u003e) -\u003e Self {\n        Client {\n            client_id,\n            _addresses: HashSet::new(),\n            stream,\n        }\n    }\n}\n\npub enum Message {\n    /// A new client just connected to the server\n    NewClient((ClientId, Arc\u003cClient\u003e)),\n    /// Some client just sent a message\n    Message((ClientId, String)),\n    /// A client just disconnected\n    Disconnect(ClientId),\n}\n\npub struct ElectrumServer\u003cBlockchain: BlockchainInterface\u003e {\n    /// The blockchain backend we are using. This will be used to query\n    /// blockchain information and broadcast transactions.\n    pub chain: Arc\u003cBlockchain\u003e,\n    /// The address cache is used to store addresses and transactions, like a\n    /// watch-only wallet, but it is adapted to the electrum protocol.\n    pub address_cache: Arc\u003cRwLock\u003cAddressCache\u003cKvDatabase\u003e\u003e\u003e,\n    /// The TCP listener is used to accept new connections to our server.\n    pub tcp_listener: Arc\u003cTcpListener\u003e,\n    /// The clients are the clients connected to our server, we keep track of them\n    /// using a unique id.\n    pub clients: HashMap\u003cClientId, Arc\u003cClient\u003e\u003e,\n    /// The message_receiver receive messages and handles them.\n    pub message_receiver: Receiver\u003cMessage\u003e,\n    /// The message_transmitter is used to send requests from clients or notifications\n    /// like new or dropped clients\n    pub message_transmitter: Sender\u003cMessage\u003e,\n    /// The client_addresses is used to keep track of the addresses of each client.\n    /// We keep the script_hash and which client has it, so we can notify the\n    /// clients when a new transaction is received.\n    pub client_addresses: HashMap\u003csha256::Hash, Arc\u003cClient\u003e\u003e,\n    /// A Arc-ed copy of the block filters backend that we can use to check if a\n    /// block contains a transaction that we are interested in.\n    pub block_filters: Option\u003cArc\u003cNetworkFilters\u003cKvFilterStore\u003e\u003e\u003e,\n    /// An interface to a running node, used to broadcast transactions and request\n    /// blocks.\n    pub node_interface: Arc\u003cNodeInterface\u003e,\n    /// A list of addresses that we've just learned about and need to rescan for\n    /// transactions.\n    ///\n    /// We accumulate those addresses here and then periodically\n    /// scan, since a wallet will often send multiple addresses, but\n    /// in different requests.\n    pub addresses_to_scan: Vec\u003csha256::Hash\u003e,\n}\n\nimpl\u003cBlockchain: BlockchainInterface\u003e ElectrumServer\u003cBlockchain\u003e {\n    pub async fn new(\n        address: String,\n        address_cache: Arc\u003cRwLock\u003cAddressCache\u003cKvDatabase\u003e\u003e\u003e,\n        chain: Arc\u003cBlockchain\u003e,\n        block_filters: Option\u003cArc\u003cNetworkFilters\u003cKvFilterStore\u003e\u003e\u003e,\n        node_interface: Arc\u003cNodeInterface\u003e,\n    ) -\u003e Result\u003cElectrumServer\u003cBlockchain\u003e, Box\u003cdyn std::error::Error\u003e\u003e {\n        let listener = Arc::new(TcpListener::bind(address).await?);\n        let (tx, rx) = unbounded();\n        let unconfirmed = address_cache.read().await.find_unconfirmed().unwrap();\n        for tx in unconfirmed {\n            chain.broadcast(\u0026tx).expect(\"Invalid chain\");\n        }\n        Ok(ElectrumServer {\n            chain,\n            address_cache,\n            block_filters,\n            node_interface,\n            tcp_listener: listener,\n            clients: HashMap::new(),\n            message_receiver: rx,\n            message_transmitter: tx,\n            client_addresses: HashMap::new(),\n            addresses_to_scan: Vec::new(),\n        })\n    }\n\n    /// Handle a request from a client. All methods are defined in the electrum\n    /// protocol.\n    pub async fn handle_client_request(\n        \u0026mut self,\n        client: Arc\u003cClient\u003e,\n        request: Request,\n    ) -\u003e Result\u003cValue, super::error::Error\u003e {\n        // Methods are in alphabetical order\n        match request.method.as_str() {\n            \"blockchain.block.header\" =\u003e {\n                let height = get_arg!(request, u64, 0);\n                let hash = self\n                    .chain\n                    .get_block_hash(height as u32)\n                    .map_err(|_| super::error::Error::InvalidParams)?;\n                let header = self\n                    .chain\n                    .get_block_header(\u0026hash)\n                    .map_err(|e| super::error::Error::Blockchain(Box::new(e)))?;\n                let header = serialize_hex(\u0026header);\n                json_rpc_res!(request, header)\n            }\n            \"blockchain.block.headers\" =\u003e {\n                let start_height = get_arg!(request, u64, 0);\n                let count = get_arg!(request, u64, 1);\n                let mut headers = String::new();\n                let count = if count \u003c 2016 { count } else { 2016 };\n                for height in start_height..(start_height + count) {\n                    let hash = self\n                        .chain\n                        .get_block_hash(height as u32)\n                        .map_err(|_| super::error::Error::InvalidParams)?;\n\n                    let header = self\n                        .chain\n                        .get_block_header(\u0026hash)\n                        .map_err(|e| super::error::Error::Blockchain(Box::new(e)))?;\n                    let header = serialize_hex(\u0026header);\n                    headers.push_str(\u0026header);\n                }\n                json_rpc_res!(request, {\n                    \"count\": count,\n                    \"hex\": headers,\n                    \"max\": 2016\n                })\n            }\n            \"blockchain.estimatefee\" =\u003e json_rpc_res!(request, 0.0001),\n            \"blockchain.headers.subscribe\" =\u003e {\n                let (height, hash) = self\n                    .chain\n                    .get_best_block()\n                    .map_err(|e| super::error::Error::Blockchain(Box::new(e)))?;\n                let header = self\n                    .chain\n                    .get_block_header(\u0026hash)\n                    .map_err(|e| super::error::Error::Blockchain(Box::new(e)))?;\n                let result = json!({\n                    \"height\": height,\n                    \"hex\": serialize_hex(\u0026header)\n                });\n                json_rpc_res!(request, result)\n            }\n            // TODO: Ask Backend for fees\n            \"blockchain.relayfee\" =\u003e json_rpc_res!(request, 0.00001),\n            \"blockchain.scripthash.get_balance\" =\u003e {\n                let script_hash = get_arg!(request, sha256::Hash, 0);\n                let balance = self\n                    .address_cache\n                    .read()\n                    .await\n                    .get_address_balance(\u0026script_hash);\n                let result = json!({\n                    \"confirmed\": balance,\n                    \"unconfirmed\": 0\n                });\n                json_rpc_res!(request, result)\n            }\n            \"blockchain.scripthash.get_history\" =\u003e {\n                let script_hash = get_arg!(request, sha256::Hash, 0);\n                self.address_cache\n                    .read()\n                    .await\n                    .get_address_history(\u0026script_hash)\n                    .map(|transactions| {\n                        let res = Self::process_history(\u0026transactions);\n                        json_rpc_res!(request, res)\n                    })\n                    .unwrap_or_else(|| {\n                        Ok(json!({\n                            \"jsonrpc\": \"2.0\",\n                            \"result\": null,\n                            \"id\": request.id\n                        }))\n                    })\n            }\n            \"blockchain.scripthash.get_mempool\" =\u003e json_rpc_res!(request, []),\n            \"blockchain.scripthash.listunspent\" =\u003e {\n                let hash = get_arg!(request, sha256::Hash, 0);\n                let utxos = self.address_cache.read().await.get_address_utxos(\u0026hash);\n                if utxos.is_none() {\n                    return json_rpc_res!(request, []);\n                }\n                let mut final_utxos = Vec::new();\n                for (utxo, prevout) in utxos.unwrap().into_iter() {\n                    let height = self\n                        .address_cache\n                        .read()\n                        .await\n                        .get_height(\u0026prevout.txid)\n                        .unwrap();\n\n                    let position = self\n                        .address_cache\n                        .read()\n                        .await\n                        .get_position(\u0026prevout.txid)\n                        .unwrap();\n\n                    final_utxos.push(json!({\n                        \"height\": height,\n                        \"tx_pos\": position,\n                        \"tx_hash\": prevout.txid,\n                        \"value\": utxo.value\n                    }));\n                }\n\n                json_rpc_res!(request, final_utxos)\n            }\n            \"blockchain.scripthash.subscribe\" =\u003e {\n                let hash = get_arg!(request, sha256::Hash, 0);\n                self.client_addresses.insert(hash, client);\n\n                let history = self.address_cache.read().await.get_address_history(\u0026hash);\n                match history {\n                    Some(transactions) if !transactions.is_empty() =\u003e {\n                        let res = get_status(transactions);\n                        json_rpc_res!(request, res)\n                    }\n                    Some(_) =\u003e {\n                        json_rpc_res!(request, null)\n                    }\n                    None =\u003e {\n                        self.addresses_to_scan.push(hash);\n                        json_rpc_res!(request, null)\n                    }\n                }\n            }\n            \"blockchain.scripthash.unsubscribe\" =\u003e {\n                let address = get_arg!(request, sha256::Hash, 0);\n                self.client_addresses.remove(\u0026address);\n                json_rpc_res!(request, true)\n            }\n            \"blockchain.transaction.broadcast\" =\u003e {\n                let tx = get_arg!(request, String, 0);\n                let hex: Vec\u003c_\u003e =\n                    Vec::from_hex(\u0026tx).map_err(|_| super::error::Error::InvalidParams)?;\n                let tx: Transaction =\n                    deserialize(\u0026hex).map_err(|_| super::error::Error::InvalidParams)?;\n                self.chain\n                    .broadcast(\u0026tx)\n                    .map_err(|e| super::error::Error::Blockchain(Box::new(e)))?;\n                let id = tx.txid();\n                let updated = self\n                    .address_cache\n                    .write()\n                    .await\n                    .cache_mempool_transaction(\u0026tx)\n                    .into_iter()\n                    .map(|spend| (tx.clone(), spend))\n                    .collect::\u003cVec\u003c_\u003e\u003e();\n                self.wallet_notify(\u0026updated).await;\n                json_rpc_res!(request, id)\n            }\n            \"blockchain.transaction.get\" =\u003e {\n                let tx_id = get_arg!(request, Txid, 0);\n                let tx = self\n                    .address_cache\n                    .read()\n                    .await\n                    .get_cached_transaction(\u0026tx_id);\n                if let Some(tx) = tx {\n                    return json_rpc_res!(request, tx);\n                }\n\n                Err(super::error::Error::InvalidParams)\n            }\n            \"blockchain.transaction.get_merkle\" =\u003e {\n                let tx_id = get_arg!(request, Txid, 0);\n                let proof = self.address_cache.read().await.get_merkle_proof(\u0026tx_id);\n                let height = self.address_cache.read().await.get_height(\u0026tx_id);\n                if let Some((proof, position)) = proof {\n                    let result = json!({\n                        \"merkle\": proof,\n                        \"block_height\": height.unwrap_or(0),\n                        \"pos\": position\n                    });\n                    return json_rpc_res!(request, result);\n                }\n\n                Err(super::error::Error::InvalidParams)\n            }\n            //blockchain.transaction.id_from_pos\n            // TODO: Create an actual histogram\n            \"mempool.get_fee_histogram\" =\u003e json_rpc_res!(request, []),\n            \"server.add_peer\" =\u003e json_rpc_res!(request, true),\n            \"server.banner\" =\u003e json_rpc_res!(request, \"Welcome to Floresta's Electrum Server.\"),\n            \"server.donation_address\" =\u003e {\n                json_rpc_res!(request, \"\")\n            }\n            \"server.features\" =\u003e {\n                let genesis_hash = self\n                    .chain\n                    .get_block_hash(0)\n                    .expect(\"Genesis block should be present\");\n                let res = json!(\n                    {\n                        \"genesis_hash\": genesis_hash,\n                        \"hosts\": {\"127.0.0.1\": {\"tcp_port\": 50001}},\n                        \"protocol_max\": \"1.4\",\n                        \"protocol_min\": \"1.0\",\n                        \"pruning\": null,\n                        \"server_version\": format!(\"Floresta {}\", env!(\"CARGO_PKG_VERSION\")),\n                        \"hash_function\": \"sha256\"\n                    }\n                );\n                json_rpc_res!(request, res)\n            }\n            \"server.peers.subscribe\" =\u003e json_rpc_res!(request, []),\n            \"server.ping\" =\u003e json_rpc_res!(request, null),\n            \"server.version\" =\u003e json_rpc_res!(\n                request,\n                [format!(\"Floresta {}\", env!(\"CARGO_PKG_VERSION\")), \"1.4\"]\n            ),\n\n            _ =\u003e Err(super::error::Error::InvalidParams),\n        }\n    }\n\n    pub async fn main_loop(mut self) -\u003e Result\u003c(), crate::error::Error\u003e {\n        let blocks = Channel::new();\n        let blocks = Arc::new(blocks);\n\n        self.chain.subscribe(blocks.clone());\n\n        loop {\n            for (block, height) in blocks.recv() {\n                self.handle_block(block, height).await;\n            }\n\n            // handles client requests\n            while let Ok(request) = async_std::future::timeout(\n                std::time::Duration::from_secs(1),\n                self.message_receiver.recv(),\n            )\n            .await\n            {\n                if let Ok(message) = request {\n                    self.handle_message(message).await?;\n                }\n            }\n\n            // rescan for new addresses, if any\n            if !self.addresses_to_scan.is_empty() {\n                info!(\"Catching up with addresses {:?}\", self.addresses_to_scan);\n                let addresses: Vec\u003csha256::Hash\u003e = self.addresses_to_scan.drain(..).collect();\n                for address in addresses.iter().copied() {\n                    self.address_cache.write().await.cache_address_hash(address);\n                }\n                self.rescan_for_addresses(addresses).await?;\n            }\n        }\n    }\n\n    /// If a user adds a new address that we didn't have cached, this method\n    /// will look for historical transactions for it.\n    ///\n    /// Usually, we'll relly on compact block filters to speed things up. If\n    /// we don't have compact block filters, we may rescan using the older,\n    /// more bandwidth-intensive method of actually downloading blocks.\n    async fn rescan_for_addresses(\n        \u0026mut self,\n        addresses: Vec\u003csha256::Hash\u003e,\n    ) -\u003e Result\u003c(), super::error::Error\u003e {\n        // If compact block filters are enabled, use them. Otherwise, fallback\n        // to the \"old-school\" rescaning.\n        match \u0026self.block_filters {\n            Some(cfilters) =\u003e self.rescan_with_block_filters(cfilters, addresses).await,\n            None =\u003e self\n                .chain\n                .rescan(1)\n                .map_err(|e| super::error::Error::Blockchain(Box::new(e))),\n        }\n    }\n\n    /// If we have compact block filters enabled, this method will use them to\n    /// find blocks of interest and download for our wallet to learn about new\n    /// transactions, once a new address is added by subscription.\n    async fn rescan_with_block_filters(\n        \u0026self,\n        cfilters: \u0026Arc\u003cNetworkFilters\u003cKvFilterStore\u003e\u003e,\n        addresses: Vec\u003csha256::Hash\u003e,\n    ) -\u003e Result\u003c(), super::error::Error\u003e {\n        // By default, we look from 1..tip\n        let height = self.chain.get_height().unwrap_or(0) as u64;\n        let mut _addresses = addresses\n            .iter()\n            .map(|hash| hash.borrow())\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        // TODO (Davidson): Let users select what the starting and end height is\n        let blocks: Vec\u003c_\u003e = cfilters\n            .match_any(_addresses, 1, height as u32, self.chain.clone())\n            .into_iter()\n            .flat_map(|hash| self.node_interface.get_block(hash).ok().flatten())\n            .collect();\n\n        // Tells users about the transactions we found\n        for block in blocks {\n            let height = self\n                .chain\n                .get_block_height(\u0026block.block_hash())\n                .ok()\n                .flatten()\n                .unwrap();\n            self.handle_block(block, height).await;\n        }\n\n        Ok(())\n    }\n\n    fn process_history(transactions: \u0026[CachedTransaction]) -\u003e Vec\u003cValue\u003e {\n        let mut res = Vec::new();\n        for transaction in transactions {\n            let entry = if transaction.height == 0 {\n                json!({\n                    \"tx_hash\": transaction.hash,\n                    \"height\": transaction.height,\n                    \"fee\": 2000\n                })\n            } else {\n                json!({\n                    \"tx_hash\": transaction.hash,\n                    \"height\": transaction.height,\n                })\n            };\n\n            res.push(entry);\n        }\n        res\n    }\n\n    async fn handle_block(\u0026self, block: bitcoin::Block, height: u32) {\n        let result = json!({\n            \"jsonrpc\": \"2.0\",\n            \"method\": \"blockchain.headers.subscribe\",\n            \"params\": [{\n                \"height\": height,\n                \"hex\": serialize_hex(\u0026block.header)\n            }]\n        });\n\n        let current_height = self.address_cache.read().await.get_cache_height();\n\n        if (!self.chain.is_in_idb() || height % 1000 == 0) \u0026\u0026 (height \u003e current_height) {\n            let lock = self.address_cache.write().await;\n            lock.bump_height(height);\n        }\n\n        if self.chain.get_height().unwrap() == height {\n            for client in \u0026mut self.clients.values() {\n                let res = client\n                    .write(serde_json::to_string(\u0026result).unwrap().as_bytes())\n                    .await;\n                if res.is_err() {\n                    info!(\"Could not write to client {:?}\", client);\n                }\n            }\n        }\n\n        let transactions = self\n            .address_cache\n            .write()\n            .await\n            .block_process(\u0026block, height);\n\n        self.wallet_notify(\u0026transactions).await;\n    }\n\n    /// Handles each kind of Message\n    async fn handle_message(\u0026mut self, message: Message) -\u003e Result\u003c(), crate::error::Error\u003e {\n        match message {\n            Message::NewClient((id, client)) =\u003e {\n                self.clients.insert(id, client);\n            }\n\n            Message::Message((client, msg)) =\u003e {\n                trace!(\"Message: {msg}\");\n                if let Ok(req) = serde_json::from_str::\u003cRequest\u003e(msg.as_str()) {\n                    let client = self.clients.get(\u0026client);\n                    if client.is_none() {\n                        error!(\"Client sent a message but is not listed as client\");\n                        return Ok(());\n                    }\n                    let client = client.unwrap().to_owned();\n                    let id = req.id.to_owned();\n                    let res = self.handle_client_request(client.clone(), req).await;\n\n                    if let Ok(res) = res {\n                        client\n                            .write(serde_json::to_string(\u0026res).unwrap().as_bytes())\n                            .await?;\n                    } else {\n                        let res = json!({\n                            \"jsonrpc\": \"2.0\",\n                            \"error\": {\n                                \"code\": -32000,\n                                \"message\": \"Internal JSON-RPC error.\",\n                                \"data\": null\n                            },\n                            \"id\": id\n                        });\n                        client\n                            .write(serde_json::to_string(\u0026res).unwrap().as_bytes())\n                            .await?;\n                    }\n                } else if let Ok(requests) = serde_json::from_str::\u003cVec\u003cRequest\u003e\u003e(\u0026msg) {\n                    let mut results = Vec::new();\n                    for req in requests {\n                        let client = self.clients.get(\u0026client);\n                        if client.is_none() {\n                            error!(\"Client sent a message but is not listed as client\");\n                            return Ok(());\n                        }\n                        let client = client.unwrap().to_owned();\n                        let id = req.id.to_owned();\n                        let res = self.handle_client_request(client.clone(), req).await;\n\n                        if let Ok(res) = res {\n                            results.push(res);\n                        } else {\n                            let res = json!({\n                                \"jsonrpc\": \"2.0\",\n                                \"error\": {\n                                    \"code\": -32000,\n                                    \"message\": \"Internal JSON-RPC error.\",\n                                    \"data\": null\n                                },\n                                \"id\": id\n                            });\n                            results.push(res);\n                        }\n                    }\n                    if let Some(client) = self.clients.get(\u0026client) {\n                        client\n                            .write(serde_json::to_string(\u0026results).unwrap().as_bytes())\n                            .await?;\n                    }\n                } else {\n                    let res = json!({\n                        \"jsonrpc\": \"2.0\",\n                        \"error\": {\n                            \"code\": -32700,\n                            \"message\": \"Parse error. Invalid JSON was received by the server.\",\n                            \"data\": null\n                        },\n                        \"id\": null\n                    });\n                    if let Some(client) = self.clients.get(\u0026client) {\n                        client\n                            .write(serde_json::to_string(\u0026res).unwrap().as_bytes())\n                            .await?;\n                    }\n                }\n            }\n\n            Message::Disconnect(id) =\u003e {\n                self.clients.remove(\u0026id);\n            }\n        }\n\n        Ok(())\n    }\n\n    async fn wallet_notify(\u0026self, transactions: \u0026[(Transaction, TxOut)]) {\n        for (_, out) in transactions {\n            let hash = get_spk_hash(\u0026out.script_pubkey);\n            if let Some(client) = self.client_addresses.get(\u0026hash) {\n                let history = self.address_cache.read().await.get_address_history(\u0026hash);\n\n                let status_hash = get_status(history.unwrap());\n                let notify = json!({\n                    \"jsonrpc\": \"2.0\",\n                    \"method\": \"blockchain.scripthash.subscribe\",\n                    \"params\": [hash, status_hash]\n                });\n                if let Err(err) = client\n                    .write(serde_json::to_string(\u0026notify).unwrap().as_bytes())\n                    .await\n                {\n                    error!(\"{err}\");\n                }\n            }\n        }\n    }\n}\n\n/// Each client gets one loop to deal with their requests\nasync fn client_broker_loop(\n    client: Arc\u003cClient\u003e,\n    message_transmitter: Sender\u003cMessage\u003e,\n) -\u003e Result\u003c(), std::io::Error\u003e {\n    let mut _stream = \u0026*client.stream;\n    let mut lines = BufReader::new(_stream).lines();\n\n    while let Some(Ok(line)) = lines.next().await {\n        message_transmitter\n            .send(Message::Message((client.client_id, line)))\n            .await\n            .expect(\"Main loop is broken\");\n    }\n\n    info!(\"Lost client with ID: {}\", client.client_id);\n\n    message_transmitter\n        .send(Message::Disconnect(client.client_id))\n        .await\n        .expect(\"Main loop is broken\");\n\n    Ok(())\n}\n\n/// Listens to new TCP connections in a loop\npub async fn client_accept_loop(listener: Arc\u003cTcpListener\u003e, message_transmitter: Sender\u003cMessage\u003e) {\n    let mut id_count = 0;\n    loop {\n        if let Ok((stream, _addr)) = listener.accept().await {\n            info!(\"New client connection\");\n            let stream = Arc::new(stream);\n            let client = Arc::new(Client::new(id_count, stream));\n            async_std::task::spawn(client_broker_loop(\n                client.clone(),\n                message_transmitter.clone(),\n            ));\n\n            message_transmitter\n                .send(Message::NewClient((client.client_id, client)))\n                .await\n                .expect(\"Main loop is broken\");\n            id_count += 1;\n        }\n    }\n}\n\n/// As per electrum documentation:\n/// ### To calculate the status of a script hash (or address):\n///\n/// 1. order confirmed transactions to the script hash by increasing height (and position in the block if there are more than one in a block)\n///\n/// 2. form a string that is the concatenation of strings \"tx_hash:height:\" for each\n/// transaction in order, where:\n///\n///  tx_hash is the transaction hash in hexadecimal\n///  height is the height of the block it is in.\n///\n/// 3. Next, with mempool transactions in any order, append a similar string for those\n/// transactions, but where height is -1 if the transaction has at least one unconfirmed\n/// input, and 0 if all inputs are confirmed.\n///\n/// 4. The status of the script hash is the sha256() hash of the full string expressed\n/// as a hexadecimal string, or null if the string is empty because there are no\n/// transactions.\nfn get_status(transactions: Vec\u003cCachedTransaction\u003e) -\u003e sha256::Hash {\n    let mut status_preimage = String::new();\n    for transaction in transactions {\n        status_preimage.extend(format!(\"{}:{}:\", transaction.hash, transaction.height).chars());\n    }\n    get_hash_from_u8(status_preimage.as_bytes())\n}\n\n#[macro_export]\n/// Builds the response as defined by jsonrpc v2.0. Request should have type [Request] and the\n/// response is always a [Json]\nmacro_rules! json_rpc_res {\n    ($request: ident, $result: ident) =\u003e (\n        Ok(json!({\n            \"jsonrpc\": \"2.0\",\n            \"result\": $result,\n            \"id\": $request.id\n        }))\n    );\n    ($request: ident, $result: literal) =\u003e (\n        Ok(json!({\n            \"jsonrpc\": \"2.0\",\n            \"result\": $result,\n            \"id\": $request.id\n        }))\n    );\n    ($request: ident, $result: tt) =\u003e {\n        Ok(json!({\n            \"jsonrpc\": \"2.0\",\n            \"result\": $result,\n            \"id\": $request.id\n        }))\n    }\n}\n\n#[macro_export]\n/// Returns and parses a value from the request json or fails with [super::error::Error::InvalidParams].\nmacro_rules! get_arg {\n    ($request:ident, $arg_type:ty, $idx:literal) =\u003e {\n        if let Some(arg) = $request.params.get($idx) {\n            serde_json::from_value::\u003c$arg_type\u003e(arg.clone())?\n        } else {\n            return Err(super::error::Error::InvalidParams);\n        }\n    };\n}\n","traces":[{"line":56,"address":[1450752,1450770],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[5998354,5998508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[5998704,5998284,5998411,5998511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[3774271],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[5999231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[1450928,1450800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[1450832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[5989840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[5932880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[5931664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[5987248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":558,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":562,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":598,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":601,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":607,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":613,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":614,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":626,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":631,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":632,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":635,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":636,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":641,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":643,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":645,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":653,"address":[1450960],"length":1,"stats":{"Line":0},"fn_name":"client_broker_loop"},{"line":657,"address":[5901195,5901365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[5901408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":660,"address":[3777060,3776946,3777035,3776896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":661,"address":[5901885,5902646,5902450,5901716],"length":1,"stats":{"Line":0},"fn_name":null},{"line":662,"address":[5902472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":663,"address":[3776724],"length":1,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[5903009,5902714,5902849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[5903155,5902766,5903494,5903615],"length":1,"stats":{"Line":0},"fn_name":null},{"line":670,"address":[5903118,5902788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":671,"address":[3776746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":674,"address":[5903649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":678,"address":[1451021,1451008],"length":1,"stats":{"Line":0},"fn_name":"client_accept_loop"},{"line":679,"address":[5898913],"length":1,"stats":{"Line":0},"fn_name":null},{"line":680,"address":[5899520,5898925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":681,"address":[3776162],"length":1,"stats":{"Line":0},"fn_name":null},{"line":682,"address":[5900103,5900015,5900183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":683,"address":[5900109,5900308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":684,"address":[5900316,5900379],"length":1,"stats":{"Line":0},"fn_name":null},{"line":685,"address":[5900576,5900635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[5900435,5900496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[5900512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":690,"address":[5900791,5900657,5899192,5899335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":691,"address":[5900673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":692,"address":[3776180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":694,"address":[5899423,5899369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":717,"address":[1451040,1452023],"length":1,"stats":{"Line":0},"fn_name":"get_status"},{"line":718,"address":[1451062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":719,"address":[1451136,1451228],"length":1,"stats":{"Line":0},"fn_name":null},{"line":720,"address":[1451425,1451641,1451734],"length":1,"stats":{"Line":0},"fn_name":null},{"line":722,"address":[1451505],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":379},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-electrum","src","error.rs"],"content":"#[cfg(feature = \"cli-blockchain\")]\nuse btcd_rpc::error::UtreexodError;\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum Error {\n    #[error(\"Utreexod error\")]\n    #[cfg(feature = \"cli-blockchain\")]\n    BackendError(#[from] UtreexodError),\n    #[error(\"Invalid params passed in\")]\n    InvalidParams,\n    #[error(\"Invalid json string {0}\")]\n    Parsing(#[from] serde_json::Error),\n    #[error(\"Blockchain error\")]\n    Blockchain(Box\u003cdyn core2::error::Error + Send + 'static\u003e),\n    #[error(\"IO error\")]\n    Io(#[from] std::io::Error),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-electrum","src","lib.rs"],"content":"use serde::Deserialize;\nuse serde::Serialize;\n\npub mod electrum_protocol;\npub mod error;\npub mod request;\n#[derive(Debug, Deserialize, Serialize)]\nstruct TransactionHistoryEntry {\n    height: u32,\n    tx_hash: String,\n}\n#[derive(Debug, Deserialize, Serialize)]\nstruct MempoolTransaction {\n    height: u32,\n    tx_hash: String,\n    fee: u32,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-electrum","src","request.rs"],"content":"use serde::Deserialize;\nuse serde_json::Value;\n\n#[derive(Clone, Debug, Deserialize)]\npub struct Request {\n    pub id: Value,\n    pub method: String,\n    pub jsonrpc: String,\n\n    #[serde(default)]\n    pub params: Vec\u003cValue\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-watch-only","src","kv_database.rs"],"content":"use bitcoin::consensus::deserialize;\nuse bitcoin::consensus::encode::Error;\nuse bitcoin::consensus::serialize;\nuse bitcoin::hashes::Hash;\nuse bitcoin::Txid;\nuse floresta_common::impl_error_from;\nuse floresta_common::prelude::*;\nuse kv::Bucket;\nuse kv::Config;\nuse kv::Store;\n\nuse super::AddressCacheDatabase;\nuse super::Stats;\n\npub struct KvDatabase(Store, Bucket\u003c'static, String, Vec\u003cu8\u003e\u003e);\nimpl KvDatabase {\n    pub fn new(datadir: String) -\u003e Result\u003cKvDatabase\u003e {\n        // Configure the database\n        let cfg = Config::new(datadir);\n\n        // Open the key/value store\n        let store = Store::new(cfg)?;\n        let bucket = store.bucket::\u003cString, Vec\u003cu8\u003e\u003e(Some(\"addresses\"))?;\n        Ok(KvDatabase(store, bucket))\n    }\n}\n#[derive(Debug)]\npub enum KvDatabaseError {\n    KvError(kv::Error),\n    SerdeJsonError(serde_json::Error),\n    WalletNotInitialized,\n    DeserializeError(Error),\n    TransactionNotFound,\n}\nimpl_error_from!(KvDatabaseError, serde_json::Error, SerdeJsonError);\nimpl_error_from!(KvDatabaseError, kv::Error, KvError);\nimpl_error_from!(KvDatabaseError, Error, DeserializeError);\n\nimpl Display for KvDatabaseError {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            KvDatabaseError::KvError(e) =\u003e write!(f, \"KvError: {}\", e),\n            KvDatabaseError::SerdeJsonError(e) =\u003e write!(f, \"SerdeJsonError: {}\", e),\n            KvDatabaseError::WalletNotInitialized =\u003e write!(f, \"WalletNotInitialized\"),\n            KvDatabaseError::DeserializeError(e) =\u003e write!(f, \"DeserializeError: {}\", e),\n            KvDatabaseError::TransactionNotFound =\u003e write!(f, \"TransactionNotFound\"),\n        }\n    }\n}\n\nimpl floresta_common::prelude::Error for KvDatabaseError {}\n\ntype Result\u003cT\u003e = floresta_common::prelude::Result\u003cT, KvDatabaseError\u003e;\n\nimpl AddressCacheDatabase for KvDatabase {\n    type Error = KvDatabaseError;\n    fn load(\u0026self) -\u003e Result\u003cVec\u003csuper::CachedAddress\u003e\u003e {\n        let mut addresses = Vec::new();\n        for item in self.1.iter() {\n            let item = item?;\n            let key = item.key::\u003cString\u003e()?;\n            if *\"height\" == key || *\"desc\" == key {\n                continue;\n            }\n            let value: Vec\u003cu8\u003e = item.value().unwrap();\n            let value = serde_json::from_slice(\u0026value)?;\n            addresses.push(value);\n        }\n        Ok(addresses)\n    }\n    fn save(\u0026self, address: \u0026super::CachedAddress) {\n        let key = address.script_hash.to_string();\n        let value = serde_json::to_vec(\u0026address).expect(\"Invalid object serialization\");\n\n        self.1\n            .set(\u0026key, \u0026value)\n            .expect(\"Fatal: Database isn't working\");\n        self.1.flush().expect(\"Could not write to disk\");\n    }\n    fn update(\u0026self, address: \u0026super::CachedAddress) {\n        self.save(address);\n    }\n    fn get_cache_height(\u0026self) -\u003e Result\u003cu32\u003e {\n        let height = self.1.get(\u0026String::from(\"height\"))?;\n        if let Some(height) = height {\n            return Ok(deserialize(\u0026height)?);\n        }\n        Err(KvDatabaseError::WalletNotInitialized)\n    }\n    fn set_cache_height(\u0026self, height: u32) -\u003e Result\u003c()\u003e {\n        self.1.set(\u0026String::from(\"height\"), \u0026serialize(\u0026height))?;\n        self.1.flush()?;\n        Ok(())\n    }\n\n    fn desc_save(\u0026self, descriptor: \u0026str) -\u003e Result\u003c()\u003e {\n        let mut descs = self.descs_get()?;\n        descs.push(String::from(descriptor));\n        self.1\n            .set(\u0026String::from(\"desc\"), \u0026serde_json::to_vec(\u0026descs).unwrap())?;\n        self.1.flush()?;\n\n        Ok(())\n    }\n\n    fn descs_get(\u0026self) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        let res = self.1.get(\u0026String::from(\"desc\"))?;\n        if let Some(res) = res {\n            return Ok(serde_json::de::from_slice(\u0026res)?);\n        }\n        Ok(Vec::new())\n    }\n\n    fn get_transaction(\u0026self, txid: \u0026bitcoin::Txid) -\u003e Result\u003csuper::CachedTransaction\u003e {\n        let store = self.0.bucket::\u003c\u0026[u8], Vec\u003cu8\u003e\u003e(Some(\"transactions\"))?;\n        let res = store.get(\u0026txid.as_byte_array().to_vec().as_slice())?;\n        if let Some(res) = res {\n            return Ok(serde_json::de::from_slice(\u0026res)?);\n        }\n        Err(KvDatabaseError::TransactionNotFound)\n    }\n\n    fn save_transaction(\u0026self, tx: \u0026super::CachedTransaction) -\u003e Result\u003c()\u003e {\n        let store = self.0.bucket::\u003c\u0026[u8], Vec\u003cu8\u003e\u003e(Some(\"transactions\"))?;\n        let ser_tx = serde_json::to_vec(\u0026tx)?;\n        store.set(\u0026tx.tx.txid().as_byte_array().to_vec().as_slice(), \u0026ser_tx)?;\n        self.1.flush()?;\n\n        Ok(())\n    }\n\n    fn get_stats(\u0026self) -\u003e Result\u003csuper::Stats\u003e {\n        let store = self.0.bucket::\u003c\u0026[u8], Vec\u003cu8\u003e\u003e(Some(\"stats\"))?;\n        let res = store.get(\u0026String::from(\"stats\").as_bytes())?;\n        if let Some(res) = res {\n            return Ok(serde_json::de::from_slice(\u0026res)?);\n        }\n        Err(KvDatabaseError::TransactionNotFound)\n    }\n\n    fn save_stats(\u0026self, stats: \u0026Stats) -\u003e Result\u003c()\u003e {\n        let store = self.0.bucket::\u003c\u0026[u8], Vec\u003cu8\u003e\u003e(Some(\"stats\"))?;\n        let ser_stats = serde_json::to_vec(\u0026stats)?;\n        store.set(\u0026String::from(\"stats\").as_bytes(), \u0026ser_stats)?;\n        self.1.flush()?;\n\n        Ok(())\n    }\n\n    fn list_transactions(\u0026self) -\u003e Result\u003cVec\u003cbitcoin::Txid\u003e\u003e {\n        let mut transactions = Vec::new();\n        let store = self.0.bucket::\u003c\u0026[u8], Vec\u003cu8\u003e\u003e(Some(\"transactions\"))?;\n\n        for item in store.iter() {\n            let item = item?;\n            let key = item.key::\u003c\u0026[u8]\u003e()?;\n            transactions.push(Txid::from_slice(key).unwrap());\n        }\n        Ok(transactions)\n    }\n}\n","traces":[{"line":17,"address":[979181,978352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[978369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[978379,978791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[979053,978908,978728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[978961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[979216],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":41,"address":[979248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[979367,979302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[979439,979508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[979585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[979644,979719],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[979799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[979872,981752,981876],"length":1,"stats":{"Line":0},"fn_name":"load"},{"line":58,"address":[979902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[979994,979925,981852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[980237,980340,980546,981859],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[980531,980707,980842,981842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[981058,980803,980995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[981080],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[981600,981208,981117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[981471],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[980249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[982257,981904],"length":1,"stats":{"Line":0},"fn_name":"save"},{"line":72,"address":[981928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[982009,981961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[982049,982113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[982169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[982288],"length":1,"stats":{"Line":0},"fn_name":"update"},{"line":81,"address":[982302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[983124,982320,983158],"length":1,"stats":{"Line":0},"fn_name":"get_cache_height"},{"line":84,"address":[983189,982345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[982740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[982936,983112,982800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[982833],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[983216,983869],"length":1,"stats":{"Line":0},"fn_name":"set_cache_height"},{"line":91,"address":[983834,983250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[983678,983770],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[983765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[983904,984975],"length":1,"stats":{"Line":0},"fn_name":"desc_save"},{"line":97,"address":[983960,984090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[984083,984197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[984209,984366,984430,984630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[984373,984217,984655,984937,984526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[984698,984807,984922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[984786],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[985008,985915,985818],"length":1,"stats":{"Line":0},"fn_name":"descs_get"},{"line":107,"address":[985033,985946],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[985428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[985599,985488,985806],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[985516,985834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[987146,987243,985968],"length":1,"stats":{"Line":0},"fn_name":"get_transaction"},{"line":115,"address":[986145,986006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[986133,986240,987224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[986700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[986964,987124,986769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[986806],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[988497,987264,988484],"length":1,"stats":{"Line":0},"fn_name":"save_transaction"},{"line":124,"address":[987433,987299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[987668,987426,987539,988495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[987753,988453,987639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[988307,988432,988192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[988280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[988512,989746,989649],"length":1,"stats":{"Line":0},"fn_name":"get_stats"},{"line":133,"address":[988686,988537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[988659,988784,989727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[989208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[989277,989465,989627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[989314],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[990958,989776,990945],"length":1,"stats":{"Line":0},"fn_name":"save_stats"},{"line":142,"address":[989945,989811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[989938,990956,990051,990183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[990151,990268,990914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[990768,990893,990653],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[990741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[990976,992427,992377],"length":1,"stats":{"Line":0},"fn_name":"list_transactions"},{"line":151,"address":[991006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[991037,991224,992425,991149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[992370,991370,991209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[991616,992388,991722,991928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[991913,992089,992173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[992161,992275],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[991628],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":82},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-watch-only","src","lib.rs"],"content":"#![cfg_attr(feature = \"no-std\", no_std)]\nuse core::cmp::Ordering;\nuse core::fmt::Debug;\n\nuse bitcoin::hashes::sha256;\nuse bitcoin::ScriptBuf;\nuse floresta_common::get_spk_hash;\nuse floresta_common::parse_descriptors;\nuse floresta_common::prelude::ToString;\n\npub mod kv_database;\n#[cfg(any(test, feature = \"memory-database\"))]\npub mod memory_database;\npub mod merkle;\n\nuse bitcoin::consensus::deserialize;\nuse bitcoin::consensus::encode::serialize_hex;\nuse bitcoin::hash_types::Txid;\nuse bitcoin::hashes::hex::FromHex;\nuse bitcoin::hashes::sha256::Hash;\nuse bitcoin::hashes::Hash as HashTrait;\nuse bitcoin::Block;\nuse bitcoin::OutPoint;\nuse bitcoin::Transaction;\nuse bitcoin::TxOut;\nuse floresta_common::prelude::*;\nuse merkle::MerkleProof;\nuse serde::Deserialize;\nuse serde::Serialize;\n\n#[derive(Debug)]\npub enum WatchOnlyError\u003cDatabaseError: fmt::Debug\u003e {\n    WalletNotInitialized,\n    TransactionNotFound,\n    DatabaseError(DatabaseError),\n}\nimpl\u003cDatabaseError: fmt::Debug\u003e Display for WatchOnlyError\u003cDatabaseError\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            WatchOnlyError::WalletNotInitialized =\u003e {\n                write!(f, \"Wallet isn't initialized\")\n            }\n            WatchOnlyError::TransactionNotFound =\u003e {\n                write!(f, \"Transaction not found\")\n            }\n            WatchOnlyError::DatabaseError(e) =\u003e {\n                write!(f, \"Database error: {:?}\", e)\n            }\n        }\n    }\n}\nimpl\u003cDatabaseError: fmt::Debug\u003e From\u003cDatabaseError\u003e for WatchOnlyError\u003cDatabaseError\u003e {\n    fn from(e: DatabaseError) -\u003e Self {\n        WatchOnlyError::DatabaseError(e)\n    }\n}\nimpl\u003cT: Debug\u003e floresta_common::prelude::Error for WatchOnlyError\u003cT\u003e {}\n\n/// Every address contains zero or more associated transactions, this struct defines what\n/// data we store for those.\n#[derive(Debug, Clone, Eq, Serialize, Deserialize)]\npub struct CachedTransaction {\n    pub tx: Transaction,\n    pub height: u32,\n    pub merkle_block: Option\u003cMerkleProof\u003e,\n    pub hash: Txid,\n    pub position: u32,\n}\n\nimpl Ord for CachedTransaction {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e Ordering {\n        self.height.cmp(\u0026other.height)\n    }\n}\n\nimpl PartialOrd for CachedTransaction {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n        Some(self.cmp(other))\n    }\n}\n\nimpl PartialEq for CachedTransaction {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.height == other.height\n    }\n}\nimpl Default for CachedTransaction {\n    fn default() -\u003e Self {\n        CachedTransaction {\n            // A placeholder transaction with no input and no outputs, the bare-minimum to be\n            // serializable\n            tx: deserialize(\u0026Vec::from_hex(\"010000000000ffffffff\").unwrap()).unwrap(),\n            height: 0,\n            merkle_block: None,\n            hash: Txid::all_zeros(),\n            position: 0,\n        }\n    }\n}\n\n/// An address inside our cache, contains all information we need to satisfy electrum's requests\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CachedAddress {\n    script_hash: Hash,\n    balance: u64,\n    transactions: Vec\u003cTxid\u003e,\n    utxos: Vec\u003cOutPoint\u003e,\n}\n\n/// Holds some useful data about our wallet, like how many addresses we have, how many\n/// transactions we have, etc.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct Stats {\n    pub address_count: usize,\n    pub transaction_count: usize,\n    pub utxo_count: usize,\n    pub cache_height: u32,\n    pub txo_count: usize,\n    pub balance: u64,\n    pub derivation_index: u32,\n}\n/// Public trait defining a common interface for databases to be used with our cache\npub trait AddressCacheDatabase {\n    type Error: fmt::Debug + Send + Sync + 'static;\n    /// Saves a new address to the database. If the address already exists, `update` should\n    /// be used instead\n    fn save(\u0026self, address: \u0026CachedAddress);\n    /// Loads all addresses we have cached so far\n    fn load(\u0026self) -\u003e Result\u003cVec\u003cCachedAddress\u003e, Self::Error\u003e;\n    /// Loads the data associated with our watch-only wallet.\n    fn get_stats(\u0026self) -\u003e Result\u003cStats, Self::Error\u003e;\n    /// Saves the data associated with our watch-only wallet.\n    fn save_stats(\u0026self, stats: \u0026Stats) -\u003e Result\u003c(), Self::Error\u003e;\n    /// Updates an address, probably because a new transaction arrived\n    fn update(\u0026self, address: \u0026CachedAddress);\n    /// TODO: Maybe turn this into another db\n    /// Returns the height of the last block we filtered\n    fn get_cache_height(\u0026self) -\u003e Result\u003cu32, Self::Error\u003e;\n    /// Saves the height of the last block we filtered\n    fn set_cache_height(\u0026self, height: u32) -\u003e Result\u003c(), Self::Error\u003e;\n    /// Saves the descriptor of associated cache\n    fn desc_save(\u0026self, descriptor: \u0026str) -\u003e Result\u003c(), Self::Error\u003e;\n    /// Get associated descriptors\n    fn descs_get(\u0026self) -\u003e Result\u003cVec\u003cString\u003e, Self::Error\u003e;\n    /// Get a transaction from the database\n    fn get_transaction(\u0026self, txid: \u0026Txid) -\u003e Result\u003cCachedTransaction, Self::Error\u003e;\n    /// Saves a transaction to the database\n    fn save_transaction(\u0026self, tx: \u0026CachedTransaction) -\u003e Result\u003c(), Self::Error\u003e;\n    /// Returns all transaction we have cached so far\n    fn list_transactions(\u0026self) -\u003e Result\u003cVec\u003cTxid\u003e, Self::Error\u003e;\n}\n/// Holds all addresses and associated transactions. We need a database with some basic\n/// methods, to store all data\npub struct AddressCache\u003cD: AddressCacheDatabase\u003e {\n    /// A database that will be used to persist all needed to get our address history\n    database: D,\n    /// Maps a hash to a cached address struct, this is basically an in-memory version\n    /// of our database, used for speeding up processing a block. This hash is the electrum's\n    /// script hash\n    address_map: HashMap\u003cHash, CachedAddress\u003e,\n    /// Holds all scripts we are interested in\n    script_set: HashSet\u003csha256::Hash\u003e,\n    /// Keeps track of all utxos we own, and the script hash they belong to\n    utxo_index: HashMap\u003cOutPoint, Hash\u003e,\n}\n\nimpl\u003cD: AddressCacheDatabase\u003e AddressCache\u003cD\u003e {\n    /// Iterates through a block, finds transactions destined to ourselves.\n    /// Returns all transactions we found.\n    pub fn block_process(\u0026mut self, block: \u0026Block, height: u32) -\u003e Vec\u003c(Transaction, TxOut)\u003e {\n        let mut my_transactions = Vec::new();\n        // Check if this transaction spends from one of our utxos\n        for (position, transaction) in block.txdata.iter().enumerate() {\n            for (vin, txin) in transaction.input.iter().enumerate() {\n                if let Some(script) = self.utxo_index.get(\u0026txin.previous_output) {\n                    let script = self\n                        .address_map\n                        .get(script)\n                        .expect(\"Can't cache a utxo for a address we don't have\")\n                        .to_owned();\n                    let tx = self\n                        .get_transaction(\u0026txin.previous_output.txid)\n                        .expect(\"We cached a utxo for a transaction we don't have\");\n\n                    let utxo = tx\n                        .tx\n                        .output\n                        .get(txin.previous_output.vout as usize)\n                        .expect(\"Did we cache an invalid utxo?\");\n                    let merkle_block = MerkleProof::from_block(block, position as u64);\n\n                    self.cache_transaction(\n                        transaction,\n                        height,\n                        utxo.value.to_sat(),\n                        merkle_block,\n                        position as u32,\n                        vin,\n                        true,\n                        script.script_hash,\n                    )\n                }\n            }\n            // Checks if one of our addresses is the recipient of this transaction\n            for (vout, output) in transaction.output.iter().enumerate() {\n                let hash = get_spk_hash(\u0026output.script_pubkey);\n                if self.script_set.contains(\u0026hash) {\n                    my_transactions.push((transaction.clone(), output.clone()));\n\n                    let merkle_block = MerkleProof::from_block(block, position as u64);\n\n                    self.cache_transaction(\n                        transaction,\n                        height,\n                        output.value.to_sat(),\n                        merkle_block,\n                        position as u32,\n                        vout,\n                        false,\n                        hash,\n                    );\n                }\n            }\n        }\n        my_transactions\n    }\n\n    fn get_stats(\u0026self) -\u003e Stats {\n        self.database\n            .get_stats()\n            .expect(\"Could not get stats from database\")\n    }\n\n    pub fn bump_height(\u0026self, height: u32) {\n        self.database\n            .set_cache_height(height)\n            .expect(\"Database is not working\");\n    }\n\n    pub fn get_cache_height(\u0026self) -\u003e u32 {\n        self.database.get_cache_height().unwrap_or(0)\n    }\n\n    pub fn new(database: D) -\u003e AddressCache\u003cD\u003e {\n        let scripts = database.load().expect(\"Could not load database\");\n        if database.get_stats().is_err() {\n            database\n                .save_stats(\u0026Stats::default())\n                .expect(\"Could not save stats\");\n        }\n        let mut address_map = HashMap::new();\n        let mut script_set = HashSet::new();\n        let mut utxo_index = HashMap::new();\n        for address in scripts {\n            for utxo in address.utxos.iter() {\n                utxo_index.insert(*utxo, address.script_hash);\n            }\n            script_set.insert(address.script_hash);\n            address_map.insert(address.script_hash, address);\n        }\n        AddressCache {\n            database,\n            address_map,\n            script_set,\n            utxo_index,\n        }\n    }\n    pub fn get_address_utxos(\u0026self, script_hash: \u0026Hash) -\u003e Option\u003cVec\u003c(TxOut, OutPoint)\u003e\u003e {\n        let address = self.address_map.get(script_hash)?;\n        let utxos = \u0026address.utxos;\n        let mut address_utxos = Vec::new();\n        for utxo in utxos {\n            let tx = self.get_transaction(\u0026utxo.txid)?;\n            let txout = tx.tx.output.get(utxo.vout as usize)?;\n            address_utxos.push((txout.clone(), *utxo));\n        }\n\n        Some(address_utxos)\n    }\n    pub fn get_transaction(\u0026self, txid: \u0026Txid) -\u003e Option\u003cCachedTransaction\u003e {\n        self.database.get_transaction(txid).ok()\n    }\n    /// Returns all transactions this address has, both input and outputs\n    pub fn get_address_history(\u0026self, script_hash: \u0026Hash) -\u003e Option\u003cVec\u003cCachedTransaction\u003e\u003e {\n        let cached_script = self.address_map.get(script_hash)?;\n        let mut transactions: Vec\u003c_\u003e = cached_script\n            .transactions\n            .iter()\n            .filter_map(|txid| self.get_transaction(txid))\n            .collect();\n        let mut unconfirmed = transactions.clone();\n\n        transactions.retain(|tx| tx.height != 0);\n        transactions.sort();\n        unconfirmed.retain(|tx| tx.height == 0);\n        transactions.extend(unconfirmed);\n        Some(transactions)\n    }\n    /// Returns the balance of this address, debts (spends) are taken in account\n    pub fn get_address_balance(\u0026self, script_hash: \u0026Hash) -\u003e u64 {\n        if let Some(cached_script) = self.address_map.get(script_hash) {\n            return cached_script.balance;\n        }\n\n        0\n    }\n    /// Returns the Merkle Proof for a given address\n    pub fn get_merkle_proof(\u0026self, txid: \u0026Txid) -\u003e Option\u003c(Vec\u003cString\u003e, u32)\u003e {\n        let mut hashes = Vec::new();\n        let tx = self.get_transaction(txid)?;\n        // If a given transaction is cached, but the merkle tree doesn't exist, that means\n        // an unconfirmed transaction.\n        tx.merkle_block.as_ref()?;\n        for hash in tx.merkle_block?.hashes() {\n            hashes.push(hash.to_string());\n        }\n        Some((hashes, tx.position))\n    }\n    pub fn get_position(\u0026self, txid: \u0026Txid) -\u003e Option\u003cu32\u003e {\n        Some(self.get_transaction(txid)?.position)\n    }\n    pub fn get_height(\u0026self, txid: \u0026Txid) -\u003e Option\u003cu32\u003e {\n        Some(self.get_transaction(txid)?.height)\n    }\n    pub fn get_cached_transaction(\u0026self, txid: \u0026Txid) -\u003e Option\u003cString\u003e {\n        let tx = self.get_transaction(txid)?;\n        Some(serialize_hex(\u0026tx.tx))\n    }\n    /// Adds a new address to track, should be called at wallet setup and every once in a while\n    /// to cache new addresses, as we use the first ones. Only requires a script to cache.\n    pub fn cache_address(\u0026mut self, script_pk: ScriptBuf) {\n        let hash = get_spk_hash(\u0026script_pk);\n        if self.address_map.contains_key(\u0026hash) {\n            return;\n        }\n        let new_address = CachedAddress {\n            balance: 0,\n            script_hash: hash,\n            transactions: Vec::new(),\n            utxos: Vec::new(),\n        };\n        self.database.save(\u0026new_address);\n\n        self.address_map.insert(hash, new_address);\n        self.script_set.insert(hash);\n    }\n    pub fn cache_address_hash(\u0026mut self, script_hash: Hash) {\n        if self.address_map.contains_key(\u0026script_hash) {\n            return;\n        }\n        let new_address = CachedAddress {\n            balance: 0,\n            script_hash,\n            transactions: Vec::new(),\n            utxos: Vec::new(),\n        };\n        self.database.save(\u0026new_address);\n\n        self.address_map.insert(script_hash, new_address);\n        self.script_set.insert(script_hash);\n    }\n    /// Setup is the first command that should be executed. In a new cache. It sets our wallet's\n    /// state, like the height we should start scanning and the wallet's descriptor.\n    pub fn setup(\u0026self) -\u003e Result\u003c(), WatchOnlyError\u003cD::Error\u003e\u003e {\n        if self.database.descs_get().is_err() {\n            self.database.set_cache_height(0)?;\n        }\n        Ok(())\n    }\n    /// Tells whether or not a descriptor is already cached\n    pub fn is_cached(\u0026self, desc: \u0026String) -\u003e Result\u003cbool, WatchOnlyError\u003cD::Error\u003e\u003e {\n        let known_descs = self.database.descs_get()?;\n        Ok(known_descs.contains(desc))\n    }\n    pub fn push_descriptor(\u0026self, descriptor: \u0026str) -\u003e Result\u003c(), WatchOnlyError\u003cD::Error\u003e\u003e {\n        Ok(self.database.desc_save(descriptor)?)\n    }\n    fn derive_addresses(\u0026mut self) -\u003e Result\u003c(), WatchOnlyError\u003cD::Error\u003e\u003e {\n        let mut stats = self.get_stats();\n        let descriptors = self.database.descs_get()?;\n        let descriptors = parse_descriptors(\u0026descriptors).expect(\"We validate those descriptors\");\n        for desc in descriptors {\n            let index = stats.derivation_index;\n            for idx in index..(index + 100) {\n                let script = desc\n                    .at_derivation_index(idx)\n                    .expect(\"We validate those descriptors before saving\")\n                    .script_pubkey();\n                self.cache_address(script);\n            }\n        }\n        stats.derivation_index += 100;\n        Ok(self.database.save_stats(\u0026stats)?)\n    }\n    fn maybe_derive_addresses(\u0026mut self) {\n        let stats = self.get_stats();\n        if stats.transaction_count \u003e (stats.derivation_index as usize * 100) {\n            let res = self.derive_addresses();\n            if res.is_err() {\n                log::error!(\"Error deriving addresses: {:?}\", res);\n            }\n        }\n    }\n    pub fn find_unconfirmed(\u0026self) -\u003e Result\u003cVec\u003cTransaction\u003e, WatchOnlyError\u003cD::Error\u003e\u003e {\n        let transactions = self.database.list_transactions()?;\n        let mut unconfirmed = Vec::new();\n\n        for tx in transactions {\n            let tx = self.database.get_transaction(\u0026tx)?;\n            if tx.height == 0 {\n                unconfirmed.push(tx.tx);\n            }\n        }\n        Ok(unconfirmed)\n    }\n    fn find_spend(\u0026self, transaction: \u0026Transaction) -\u003e Vec\u003c(usize, TxOut)\u003e {\n        let mut spends = Vec::new();\n        for (idx, input) in transaction.input.iter().enumerate() {\n            if self.utxo_index.contains_key(\u0026input.previous_output) {\n                let prev_tx = self.get_transaction(\u0026input.previous_output.txid).unwrap();\n                spends.push((\n                    idx,\n                    prev_tx.tx.output[input.previous_output.vout as usize].clone(),\n                ));\n            }\n        }\n        spends\n    }\n    pub fn cache_mempool_transaction(\u0026mut self, transaction: \u0026Transaction) -\u003e Vec\u003cTxOut\u003e {\n        let mut coins = self.find_spend(transaction);\n        for (idx, spend) in coins.iter() {\n            let script = self\n                .address_map\n                .get(\u0026get_spk_hash(\u0026spend.script_pubkey))\n                .unwrap()\n                .to_owned();\n            self.cache_transaction(\n                transaction,\n                0,\n                spend.value.to_sat(),\n                MerkleProof::default(),\n                0,\n                *idx,\n                true,\n                script.script_hash,\n            )\n        }\n        for (idx, out) in transaction.output.iter().enumerate() {\n            let spk_hash = get_spk_hash(\u0026out.script_pubkey);\n            if self.script_set.contains(\u0026spk_hash) {\n                let script = self.address_map.get(\u0026spk_hash).unwrap().to_owned();\n                coins.push((idx, out.clone()));\n                self.cache_transaction(\n                    transaction,\n                    0,\n                    out.value.to_sat(),\n                    MerkleProof::default(),\n                    0,\n                    idx,\n                    true,\n                    script.script_hash,\n                )\n            }\n        }\n        coins\n            .iter()\n            .cloned()\n            .unzip::\u003cusize, TxOut, Vec\u003cusize\u003e, Vec\u003cTxOut\u003e\u003e()\n            .1\n    }\n    fn save_mempool_tx(\u0026mut self, hash: Hash, transaction_to_cache: CachedTransaction) {\n        if let Some(address) = self.address_map.get_mut(\u0026hash) {\n            if !address.transactions.contains(\u0026transaction_to_cache.hash) {\n                address.transactions.push(transaction_to_cache.hash);\n                self.database.update(address);\n            }\n        }\n    }\n    fn save_non_mempool_tx(\n        \u0026mut self,\n        transaction: \u0026Transaction,\n        is_spend: bool,\n        value: u64,\n        index: usize,\n        hash: Hash,\n        transaction_to_cache: CachedTransaction,\n    ) {\n        if let Some(address) = self.address_map.get_mut(\u0026hash) {\n            // This transaction is spending from this address, so we should remove the UTXO\n            if is_spend {\n                assert!(value \u003c= address.balance);\n                address.balance -= value;\n                let input = transaction\n                    .input\n                    .get(index)\n                    .expect(\"Malformed call, index is bigger than the output vector\");\n                let idx = address\n                    .utxos\n                    .iter()\n                    .position(|utxo| *utxo == input.previous_output);\n                if let Some(idx) = idx {\n                    let utxo = address.utxos.remove(idx);\n                    self.utxo_index.remove(\u0026utxo);\n                }\n            } else {\n                // This transaction is creating a new utxo for this address\n                let utxo = OutPoint {\n                    txid: transaction.txid(),\n                    vout: index as u32,\n                };\n                address.utxos.push(utxo);\n                self.utxo_index.insert(utxo, hash);\n                address.balance += value;\n            }\n\n            if !address.transactions.contains(\u0026transaction_to_cache.hash) {\n                address.transactions.push(transaction_to_cache.hash);\n                self.database.update(address);\n            }\n        }\n    }\n    /// Caches a new transaction. This method may be called for addresses we don't follow yet,\n    /// this automatically makes we follow this address.\n    #[allow(clippy::too_many_arguments)]\n    pub fn cache_transaction(\n        \u0026mut self,\n        transaction: \u0026Transaction,\n        height: u32,\n        value: u64,\n        merkle_block: MerkleProof,\n        position: u32,\n        index: usize,\n        is_spend: bool,\n        hash: sha256::Hash,\n    ) {\n        let transaction_to_cache = CachedTransaction {\n            height,\n            merkle_block: Some(merkle_block),\n            tx: transaction.clone(),\n            hash: transaction.txid(),\n            position,\n        };\n        self.database\n            .save_transaction(\u0026transaction_to_cache)\n            .expect(\"Database not working\");\n\n        if let Entry::Vacant(e) = self.address_map.entry(hash) {\n            // This means `cache_transaction` have been called with an address we don't\n            // follow. This may be useful for caching new addresses without re-scanning.\n            // We can track this address from now onwards, but the past history is only\n            // available with full rescan\n            let new_address = CachedAddress {\n                balance: transaction.output[index].value.to_sat(),\n                script_hash: hash,\n                transactions: Vec::from([transaction_to_cache.hash]),\n                utxos: Vec::from([OutPoint {\n                    txid: transaction.txid(),\n                    vout: index as u32,\n                }]),\n            };\n            self.database.save(\u0026new_address);\n\n            e.insert(new_address);\n            self.script_set.insert(hash);\n        }\n        self.maybe_derive_addresses();\n        // Confirmed transaction\n        if height \u003e 0 {\n            return self.save_non_mempool_tx(\n                transaction,\n                is_spend,\n                value,\n                index,\n                hash,\n                transaction_to_cache,\n            );\n        }\n        // Unconfirmed transaction\n        self.save_mempool_tx(hash, transaction_to_cache);\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use bitcoin::address::NetworkUnchecked;\n    use bitcoin::consensus::deserialize;\n    use bitcoin::consensus::Decodable;\n    use bitcoin::hashes::hex::FromHex;\n    use bitcoin::hashes::sha256;\n    use bitcoin::Address;\n    use bitcoin::ScriptBuf;\n    use bitcoin::Txid;\n    use floresta_common::get_spk_hash;\n    use floresta_common::prelude::*;\n\n    const BLOCK_FIRST_UTXO: \u0026str = \"00000020b4f594a390823c53557c5a449fa12413cbbae02be529c11c4eb320ff8e000000dd1211eb35ca09dc0ee519b0f79319fae6ed32c66f8bbf353c38513e2132c435474d81633c4b011e195a220002010000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff0403edce01feffffff028df2052a0100000016001481113cad52683679a83e76f76f84a4cfe36f75010000000000000000776a24aa21a9ed67863b4f356b7b9f3aab7a2037615989ef844a0917fb0a1dcd6c23a383ee346b4c4fecc7daa2490047304402203768ff10a948a2dd1825cc5a3b0d336d819ea68b5711add1390b290bf3b1cba202201d15e73791b2df4c0904fc3f7c7b2f22ab77762958e9bc76c625138ad3a04d290100012000000000000000000000000000000000000000000000000000000000000000000000000002000000000101be07b18750559a418d144f1530be380aa5f28a68a0269d6b2d0e6ff3ff25f3200000000000feffffff0240420f00000000001600142b6a2924aa9b1b115d1ac3098b0ba0e6ed510f2a326f55d94c060000160014c2ed86a626ee74d854a12c9bb6a9b72a80c0ddc50247304402204c47f6783800831bd2c75f44d8430bf4d962175349dc04d690a617de6c1eaed502200ffe70188a6e5ad89871b2acb4d0f732c2256c7ed641d2934c6e84069c792abc012103ba174d9c66078cf813d0ac54f5b19b5fe75104596bdd6c1731d9436ad8776f41ecce0100\";\n    const BLOCK_SPEND: \u0026str = \"000000203ea734fa2c8dee7d3194878c9eaf6e83a629f79b3076ec857793995e01010000eb99c679c0305a1ac0f5eb2a07a9f080616105e605b92b8c06129a2451899225ab5481633c4b011e0b26720102020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff0403efce01feffffff026ef2052a01000000225120a1a1b1376d5165617a50a6d2f59abc984ead8a92df2b25f94b53dbc2151824730000000000000000776a24aa21a9ed1b4c48a7220572ff3ab3d2d1c9231854cb62542fbb1e0a4b21ebbbcde8d652bc4c4fecc7daa2490047304402204b37c41fce11918df010cea4151737868111575df07f7f2945d372e32a6d11dd02201658873a8228d7982df6bdbfff5d0cad1d6f07ee400e2179e8eaad8d115b7ed001000120000000000000000000000000000000000000000000000000000000000000000000000000020000000001017ca523c5e6df0c014e837279ab49be1676a9fe7571c3989aeba1e5d534f4054a0000000000fdffffff01d2410f00000000001600142b6a2924aa9b1b115d1ac3098b0ba0e6ed510f2a02473044022071b8583ba1f10531b68cb5bd269fb0e75714c20c5a8bce49d8a2307d27a082df022069a978dac00dd9d5761aa48c7acc881617fa4d2573476b11685596b17d437595012103b193d06bd0533d053f959b50e3132861527e5a7a49ad59c5e80a265ff6a77605eece0100\";\n    fn deserialize_from_str\u003cT: Decodable\u003e(thing: \u0026str) -\u003e T {\n        let hex = Vec::from_hex(thing).unwrap();\n        deserialize(\u0026hex).unwrap()\n    }\n    use super::memory_database::MemoryDatabase;\n    use super::AddressCache;\n    fn get_test_cache() -\u003e AddressCache\u003cMemoryDatabase\u003e {\n        let database = MemoryDatabase::new();\n        AddressCache::new(database)\n    }\n    fn get_test_address() -\u003e (Address\u003cNetworkUnchecked\u003e, sha256::Hash) {\n        let address = Address::from_str(\"tb1q9d4zjf92nvd3zhg6cvyckzaqumk4zre26x02q9\").unwrap();\n        let script_hash = get_spk_hash(\u0026address.payload().script_pubkey());\n        (address, script_hash)\n    }\n    #[test]\n    fn test_create() {\n        let _ = get_test_cache();\n    }\n    #[test]\n    fn test_cache_address() {\n        let (address, script_hash) = get_test_address();\n        let mut cache = get_test_cache();\n        // Should have no address before caching\n        assert_eq!(cache.address_map.len(), 0);\n\n        cache.cache_address(address.payload().script_pubkey());\n        // Assert we indeed have one cached address\n        assert_eq!(cache.address_map.len(), 1);\n        assert_eq!(cache.get_address_balance(\u0026script_hash), 0);\n        assert_eq!(cache.get_address_history(\u0026script_hash), Some(Vec::new()));\n    }\n    #[test]\n    fn test_cache_transaction() {\n        // Signet transaction with id 6bb0665122c7dcecc6e6c45b6384ee2bdce148aea097896e6f3e9e08070353ea\n        // block hash 0000009298f9e75a91fa763c78b66d1555cb059d9ca9d45601eed2b95166a151.\n        let transaction = \"020000000001017ca523c5e6df0c014e837279ab49be1676a9fe7571c3989aeba1e5d534f4054a0000000000fdffffff01d2410f00000000001600142b6a2924aa9b1b115d1ac3098b0ba0e6ed510f2a02473044022071b8583ba1f10531b68cb5bd269fb0e75714c20c5a8bce49d8a2307d27a082df022069a978dac00dd9d5761aa48c7acc881617fa4d2573476b11685596b17d437595012103b193d06bd0533d053f959b50e3132861527e5a7a49ad59c5e80a265ff6a77605eece0100\";\n        let transaction = Vec::from_hex(transaction).unwrap();\n        let transaction = deserialize(\u0026transaction).unwrap();\n\n        let merkle_block = \"0100000000000000ea530307089e3e6f6e8997a0ae48e1dc2bee84635bc4e6c6ecdcc7225166b06b010000000000000034086ef398efcdec47b37241221c8f4613e02bc31026cc74d07ddb3092e6d6e7\";\n        let merkle_block = Vec::from_hex(merkle_block).unwrap();\n        let merkle_block = deserialize(\u0026merkle_block).unwrap();\n\n        let (address, script_hash) = get_test_address();\n        let mut cache = get_test_cache();\n        cache.cache_address(address.payload().script_pubkey());\n\n        cache.cache_transaction(\n            \u0026transaction,\n            118511,\n            transaction.output[0].value.to_sat(),\n            merkle_block,\n            1,\n            0,\n            false,\n            get_spk_hash(\u0026transaction.output[0].script_pubkey),\n        );\n\n        let balance = cache.get_address_balance(\u0026script_hash);\n        let history = cache.get_address_history(\u0026script_hash).unwrap();\n        let cached_merkle_block = cache.get_merkle_proof(\u0026transaction.txid()).unwrap();\n        assert_eq!(balance, 999890);\n        assert_eq!(\n            Ok(history[0].hash),\n            Txid::from_str(\"6bb0665122c7dcecc6e6c45b6384ee2bdce148aea097896e6f3e9e08070353ea\")\n        );\n        let expected_hashes = Vec::from([String::from(\n            \"e7d6e69230db7dd074cc2610c32be013468f1c224172b347eccdef98f36e0834\",\n        )]);\n        assert_eq!(cached_merkle_block, (expected_hashes, 1));\n    }\n    #[test]\n    fn test_process_block() {\n        let (address, script_hash) = get_test_address();\n        let mut cache = get_test_cache();\n        cache.cache_address(address.payload().script_pubkey());\n\n        let block = \"000000203ea734fa2c8dee7d3194878c9eaf6e83a629f79b3076ec857793995e01010000eb99c679c0305a1ac0f5eb2a07a9f080616105e605b92b8c06129a2451899225ab5481633c4b011e0b26720102020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff0403efce01feffffff026ef2052a01000000225120a1a1b1376d5165617a50a6d2f59abc984ead8a92df2b25f94b53dbc2151824730000000000000000776a24aa21a9ed1b4c48a7220572ff3ab3d2d1c9231854cb62542fbb1e0a4b21ebbbcde8d652bc4c4fecc7daa2490047304402204b37c41fce11918df010cea4151737868111575df07f7f2945d372e32a6d11dd02201658873a8228d7982df6bdbfff5d0cad1d6f07ee400e2179e8eaad8d115b7ed001000120000000000000000000000000000000000000000000000000000000000000000000000000020000000001017ca523c5e6df0c014e837279ab49be1676a9fe7571c3989aeba1e5d534f4054a0000000000fdffffff01d2410f00000000001600142b6a2924aa9b1b115d1ac3098b0ba0e6ed510f2a02473044022071b8583ba1f10531b68cb5bd269fb0e75714c20c5a8bce49d8a2307d27a082df022069a978dac00dd9d5761aa48c7acc881617fa4d2573476b11685596b17d437595012103b193d06bd0533d053f959b50e3132861527e5a7a49ad59c5e80a265ff6a77605eece0100\";\n        let block = deserialize(\u0026Vec::from_hex(block).unwrap()).unwrap();\n        cache.block_process(\u0026block, 118511);\n\n        let balance = cache.get_address_balance(\u0026script_hash);\n        let history = cache.get_address_history(\u0026script_hash).unwrap();\n        let transaction_id =\n            Txid::from_str(\"6bb0665122c7dcecc6e6c45b6384ee2bdce148aea097896e6f3e9e08070353ea\")\n                .unwrap();\n        let cached_merkle_block = cache.get_merkle_proof(\u0026transaction_id).unwrap();\n        assert_eq!(balance, 999890);\n        assert_eq!(\n            history[0].hash,\n            Txid::from_str(\"6bb0665122c7dcecc6e6c45b6384ee2bdce148aea097896e6f3e9e08070353ea\")\n                .unwrap()\n        );\n        let expected_hashes = Vec::from([String::from(\n            \"e7d6e69230db7dd074cc2610c32be013468f1c224172b347eccdef98f36e0834\",\n        )]);\n        assert_eq!(cached_merkle_block, (expected_hashes, 1));\n    }\n    #[test]\n    fn test_multiple_transaction() {\n        let block1 = deserialize_from_str(BLOCK_FIRST_UTXO);\n        let block2 = deserialize_from_str(BLOCK_SPEND);\n\n        let spk = ScriptBuf::from_hex(\"00142b6a2924aa9b1b115d1ac3098b0ba0e6ed510f2a\")\n            .expect(\"Valid address\");\n        let script_hash = get_spk_hash(\u0026spk);\n        let mut cache = get_test_cache();\n\n        cache.cache_address(spk);\n\n        cache.block_process(\u0026block1, 118511);\n        cache.block_process(\u0026block2, 118509);\n\n        let address = cache.address_map.get(\u0026script_hash).unwrap();\n\n        assert_eq!(address.transactions.len(), 2);\n        assert_eq!(address.utxos.len(), 1);\n    }\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[1089552],"length":1,"stats":{"Line":0},"fn_name":"cmp"},{"line":72,"address":[1089566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[1089600],"length":1,"stats":{"Line":0},"fn_name":"partial_cmp"},{"line":78,"address":[1089614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[1089632],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":84,"address":[1089642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[1090091,1090121,1089664],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":92,"address":[1089681,1089825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[1089885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[1404976,1406310],"length":1,"stats":{"Line":2},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":525,"address":[1407826,1406384,1408089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":564,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":97,"coverable":255},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-watch-only","src","memory_database.rs"],"content":"//! An in-memory database to store addresses data. Being in-memory means this database is\n//! volatile, and all data is lost after the database is dropped or the process is terminated.\n//! It's not meant to use in production, but for the integrated testing framework\n//!\n//! For actual databases that can be used for production code, see [KvDatabase].\nuse bitcoin::hashes::sha256;\nuse bitcoin::Txid;\nuse floresta_common::prelude::sync::RwLock;\nuse floresta_common::prelude::*;\n\nuse super::AddressCacheDatabase;\nuse super::CachedAddress;\nuse super::CachedTransaction;\nuse super::Stats;\n#[derive(Debug, Default)]\nstruct Inner {\n    addresses: HashMap\u003csha256::Hash, CachedAddress\u003e,\n    transactions: HashMap\u003cTxid, CachedTransaction\u003e,\n    stats: Stats,\n    height: u32,\n    descriptors: Vec\u003cString\u003e,\n}\n\n#[derive(Debug)]\npub enum MemoryDatabaseError {\n    PoisonedLock,\n}\n#[derive(Debug, Default)]\npub struct MemoryDatabase {\n    inner: RwLock\u003cInner\u003e,\n}\n\ntype Result\u003cT\u003e = floresta_common::prelude::Result\u003cT, MemoryDatabaseError\u003e;\n\nimpl MemoryDatabase {\n    fn get_inner(\u0026self) -\u003e Result\u003csync::RwLockReadGuard\u003cInner\u003e\u003e {\n        self.inner\n            .read()\n            .map_err(|_| MemoryDatabaseError::PoisonedLock)\n    }\n    fn get_inner_mut(\u0026self) -\u003e Result\u003csync::RwLockWriteGuard\u003cInner\u003e\u003e {\n        self.inner\n            .write()\n            .map_err(|_| MemoryDatabaseError::PoisonedLock)\n    }\n    pub fn new() -\u003e MemoryDatabase {\n        MemoryDatabase {\n            inner: Default::default(),\n        }\n    }\n}\nimpl AddressCacheDatabase for MemoryDatabase {\n    type Error = MemoryDatabaseError;\n    fn save(\u0026self, address: \u0026CachedAddress) {\n        self.get_inner_mut()\n            .map(|mut inner| {\n                inner\n                    .addresses\n                    .insert(address.script_hash, address.to_owned())\n            })\n            .unwrap();\n    }\n\n    fn load(\u0026self) -\u003e Result\u003cVec\u003cCachedAddress\u003e\u003e {\n        Ok(self.get_inner()?.addresses.values().cloned().collect())\n    }\n\n    fn get_stats(\u0026self) -\u003e Result\u003csuper::Stats\u003e {\n        Ok(self.get_inner()?.stats.to_owned())\n    }\n\n    fn save_stats(\u0026self, stats: \u0026super::Stats) -\u003e Result\u003c()\u003e {\n        self.get_inner_mut().map(|mut inner| {\n            inner.stats.clone_from(stats);\n        })?;\n        Ok(())\n    }\n\n    fn update(\u0026self, address: \u0026super::CachedAddress) {\n        self.get_inner_mut()\n            .map(|mut inner| {\n                inner\n                    .addresses\n                    .entry(address.script_hash)\n                    .and_modify(|addr| addr.clone_from(address));\n            })\n            .unwrap();\n    }\n\n    fn get_cache_height(\u0026self) -\u003e Result\u003cu32\u003e {\n        Ok(self.get_inner()?.height)\n    }\n\n    fn set_cache_height(\u0026self, height: u32) -\u003e Result\u003c()\u003e {\n        self.get_inner_mut()?.height = height;\n        Ok(())\n    }\n\n    fn desc_save(\u0026self, descriptor: \u0026str) -\u003e Result\u003c()\u003e {\n        self.get_inner_mut().map(|mut inner| {\n            inner.descriptors.push(descriptor.into());\n        })\n    }\n\n    fn descs_get(\u0026self) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        Ok(self.get_inner()?.descriptors.to_owned())\n    }\n\n    fn get_transaction(\u0026self, txid: \u0026bitcoin::Txid) -\u003e Result\u003csuper::CachedTransaction\u003e {\n        if let Some(tx) = self.get_inner()?.transactions.get(txid) {\n            return Ok(tx.clone());\n        }\n        Err(MemoryDatabaseError::PoisonedLock)\n    }\n\n    fn save_transaction(\u0026self, tx: \u0026super::CachedTransaction) -\u003e Result\u003c()\u003e {\n        self.get_inner_mut()?\n            .transactions\n            .insert(tx.hash, tx.to_owned());\n        Ok(())\n    }\n\n    fn list_transactions(\u0026self) -\u003e Result\u003cVec\u003cTxid\u003e\u003e {\n        Ok(self.get_inner()?.transactions.keys().copied().collect())\n    }\n}\n","traces":[{"line":36,"address":[1070544],"length":1,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[1070565],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[1012045,1012032],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":41,"address":[1070592],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[1070613],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[1012064,1012081],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":46,"address":[1070640],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[1070657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[1070704],"length":1,"stats":{"Line":1},"fn_name":"save"},{"line":55,"address":[1070731,1070751],"length":1,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[1012096,1012270],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":57,"address":[1012240,1012135],"length":1,"stats":{"Line":4},"fn_name":null},{"line":59,"address":[1012181],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[1070816,1071151],"length":1,"stats":{"Line":3},"fn_name":"load"},{"line":65,"address":[1071053,1070846],"length":1,"stats":{"Line":4},"fn_name":null},{"line":68,"address":[1071184,1071460],"length":1,"stats":{"Line":1},"fn_name":"get_stats"},{"line":69,"address":[1071214,1071385],"length":1,"stats":{"Line":4},"fn_name":null},{"line":72,"address":[1071488],"length":1,"stats":{"Line":0},"fn_name":"save_stats"},{"line":73,"address":[1012407,1012304],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":74,"address":[1012376,1012331],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[1071570],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[1071616],"length":1,"stats":{"Line":1},"fn_name":"update"},{"line":80,"address":[1071635,1071655],"length":1,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[1012619,1012432],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":82,"address":[1012556,1012576,1012462],"length":1,"stats":{"Line":6},"fn_name":null},{"line":84,"address":[1012514],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[1012656,1012563,1012681],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":90,"address":[1071696,1071900],"length":1,"stats":{"Line":0},"fn_name":"get_cache_height"},{"line":91,"address":[1071859,1071700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[1072136,1071936],"length":1,"stats":{"Line":0},"fn_name":"set_cache_height"},{"line":95,"address":[1071944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[1072117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[1072160],"length":1,"stats":{"Line":0},"fn_name":"desc_save"},{"line":100,"address":[1012704,1012846],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":101,"address":[1012736,1012781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[1072256,1072513],"length":1,"stats":{"Line":0},"fn_name":"descs_get"},{"line":106,"address":[1072286,1072443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[1072544,1072912],"length":1,"stats":{"Line":1},"fn_name":"get_transaction"},{"line":110,"address":[1072579,1072769],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[1072839,1072874],"length":1,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[1072861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[1072944,1073300],"length":1,"stats":{"Line":1},"fn_name":"save_transaction"},{"line":117,"address":[1073166,1072956,1073246],"length":1,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[1073258,1073175,1073124],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[1073278],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[1073667,1073328],"length":1,"stats":{"Line":0},"fn_name":"list_transactions"},{"line":124,"address":[1073358,1073560],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":28,"coverable":47},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-watch-only","src","merkle.rs"],"content":"use bitcoin::consensus::Decodable;\nuse bitcoin::consensus::Encodable;\nuse bitcoin::hashes::sha256d;\nuse bitcoin::hashes::Hash;\nuse bitcoin::hashes::HashEngine;\nuse bitcoin::Block;\nuse bitcoin::Txid;\nuse floresta_common::prelude::*;\nuse serde::Deserialize;\nuse serde::Serialize;\n#[derive(Clone, Debug, Hash, PartialEq, Eq, Serialize, Deserialize)]\npub struct MerkleProof {\n    target: Txid,\n    pos: u64,\n    hashes: Vec\u003csha256d::Hash\u003e,\n}\nimpl Default for MerkleProof {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\nimpl MerkleProof {\n    /// Creates an empty proof\n    fn new() -\u003e Self {\n        MerkleProof {\n            target: Txid::all_zeros(),\n            hashes: Vec::new(),\n            pos: 0,\n        }\n    }\n    /// Returns the hashes for this proof\n    pub fn hashes(\u0026self) -\u003e Vec\u003csha256d::Hash\u003e {\n        self.hashes.clone()\n    }\n    /// Creates a new proof from a list of hashes and a target. Target is a 64 bits\n    /// unsigned integer indicating the index of a transaction we with to prove. Note that\n    /// this only proves one tx at the time.\n    pub fn from_block_hashes(tx_list: Vec\u003csha256d::Hash\u003e, target: u64) -\u003e Self {\n        let target_hash = tx_list[target as usize];\n        let (_, proof) = Self::transverse(tx_list, Vec::new(), target);\n        Self {\n            target: target_hash.into(),\n            pos: target,\n            hashes: proof,\n        }\n    }\n    /// Same as [MerkleProof::from_block_hashes] but you give a block instead of a list of\n    /// hashes.\n    pub fn from_block(block: \u0026Block, target: u64) -\u003e Self {\n        let tx_list: Vec\u003c_\u003e = block\n            .txdata\n            .iter()\n            .map(|tx| tx.txid().to_raw_hash())\n            .collect();\n        Self::from_block_hashes(tx_list, target)\n    }\n    #[allow(unused)]\n    /// Verifies a proof by hashing up all nodes until reach a root, and compare `root` with\n    /// computed root.\n    pub fn verify(\u0026self, root: sha256d::Hash) -\u003e Result\u003cbool, String\u003e {\n        let mut computed = self.target.to_raw_hash();\n        let mut placement = self.pos;\n        for hash in self.hashes.iter() {\n            if placement \u0026 1 == 0 {\n                computed = Self::parent_hash(computed.as_ref(), hash.as_ref());\n            } else {\n                computed = Self::parent_hash(hash.as_ref(), computed.as_ref());\n            }\n\n            placement \u003e\u003e= 1;\n        }\n        Ok(root == computed)\n    }\n    /// Returns the position of a node's parent\n    fn get_parent(pos: u64) -\u003e u64 {\n        (pos ^ 1) / 2\n    }\n    /// Returns a node's sibling. This is useful because we have to copy a node's sibling\n    /// to proof, so we can compute it's parent.\n    fn get_sibling(pos: u64) -\u003e u64 {\n        pos ^ 1\n    }\n    /// Computes the hash of two node's parent, by taking sha256d(left_child | right_child), where |\n    /// means byte-wise concatenation.\n    fn parent_hash(left: \u0026[u8], right: \u0026[u8]) -\u003e sha256d::Hash {\n        let mut engine = sha256d::Hash::engine();\n        engine.input(left);\n        engine.input(right);\n        sha256d::Hash::from_engine(engine)\n    }\n    /// Iterates over the tree, collecting required nodes for proof, internally we compute\n    /// all intermediate nodes, but don't keep them.\n    fn transverse(\n        nodes: Vec\u003csha256d::Hash\u003e,\n        mut proof: Vec\u003csha256d::Hash\u003e,\n        target: u64,\n    ) -\u003e (Vec\u003csha256d::Hash\u003e, Vec\u003csha256d::Hash\u003e) {\n        // We reached a root. This is the recursion base\n        if nodes.len() == 1 {\n            return (nodes, proof);\n        }\n        // Here we store all nodes for the next row\n        let mut new_nodes = Vec::new();\n        // Grab a node's sibling. In a Merkle Tree, our target nodes are given, and its parent\n        // can be computed using available data. We must only provide a node's sibling, so verifier\n        // can get a parent hash.\n        let sibling = Self::get_sibling(target);\n\n        // This if catches an edge case where we try to get a sibling from the last node\n        // in a non-perfect tree. This yields an out-of-bound read from nodes.\n        if sibling != nodes.len() as u64 {\n            proof.push(nodes[sibling as usize]);\n        } else {\n            proof.push(nodes[target as usize]);\n        }\n        // If the row has a odd number of nodes, we must repeat the last node to force it\n        // even.\n        let node_count = nodes.len();\n\n        let pairs = if node_count % 2 == 0 {\n            node_count / 2\n        } else {\n            (node_count + 1) / 2\n        };\n\n        for idx in 0..pairs {\n            if (2 * idx + 1) \u003e= node_count {\n                new_nodes.push(Self::parent_hash(\n                    nodes[2 * idx].as_ref(),\n                    nodes[2 * idx].as_ref(),\n                ));\n            } else {\n                new_nodes.push(Self::parent_hash(\n                    nodes[2 * idx].as_ref(),\n                    nodes[2 * idx + 1].as_ref(),\n                ));\n            }\n        }\n        Self::transverse(new_nodes, proof, Self::get_parent(target))\n    }\n}\n\nimpl Decodable for MerkleProof {\n    fn consensus_decode\u003cR: Read + ?Sized\u003e(\n        reader: \u0026mut R,\n    ) -\u003e Result\u003cSelf, bitcoin::consensus::encode::Error\u003e {\n        let pos = u64::consensus_decode(reader)?;\n        let target = Txid::consensus_decode(reader)?;\n        let len = u64::consensus_decode(reader)?;\n        let mut hashes = Vec::new();\n        for _ in 0..len {\n            let hash = sha256d::Hash::consensus_decode(reader)?;\n            hashes.push(hash);\n        }\n        Ok(Self {\n            hashes,\n            pos,\n            target,\n        })\n    }\n}\n\nimpl Encodable for MerkleProof {\n    fn consensus_encode\u003cW: Write + ?Sized\u003e(\u0026self, writer: \u0026mut W) -\u003e Result\u003cusize, ioError\u003e {\n        let mut len = 0;\n        len += self.pos.consensus_encode(writer)?;\n        len += self.target.consensus_encode(writer)?;\n\n        let hashes_len = self.hashes.len() as u64;\n        len += hashes_len.consensus_encode(writer)?;\n\n        for hash in self.hashes.iter() {\n            len += hash.consensus_encode(writer)?;\n        }\n        Ok(len)\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use bitcoin::consensus::deserialize;\n    use bitcoin::hashes::hex::FromHex;\n    use bitcoin::hashes::sha256d;\n    use floresta_common::prelude::*;\n\n    use super::MerkleProof;\n    #[test]\n    fn test_merkle_root() {\n        let hashes = Vec::from([\n            \"9fe0683d05e5a8ce867712f0f744a1e9893365307d433ab3b8f65dfc59d561de\",\n            \"9e2804f04a9d52ad4b67e10cba631934915a7d6d083126b338dda680522bb602\",\n            \"01ad659d8d3f17e96d54e4240614fad5813a58cc1ac67a336839b0bf6c56f2d3\",\n            \"8627dad7e4df3cc60d1349aac61cae36436423429a12f3df9a1e54a5ca8ee008\",\n            \"5f82784d819f440ee1766d9802d113c54626bd613009cbf699213f49adf2fbbd\",\n        ]);\n        let root = sha256d::Hash::from_str(\n            \"ff8fa20a8da05e334d59d257c8ba6f76b31856fafe92afdb51151daa2fe0a240\",\n        )\n        .unwrap();\n        let hashes: Vec\u003c_\u003e = hashes\n            .iter()\n            .map(|txid| sha256d::Hash::from_str(txid).unwrap())\n            .collect();\n        let proof = MerkleProof::from_block_hashes(hashes, 2);\n        assert_eq!(Ok(true), proof.verify(root));\n    }\n    #[test]\n    fn test_serialization() {\n        use bitcoin::consensus::serialize;\n        let hashes = Vec::from([\n            \"9fe0683d05e5a8ce867712f0f744a1e9893365307d433ab3b8f65dfc59d561de\",\n            \"9e2804f04a9d52ad4b67e10cba631934915a7d6d083126b338dda680522bb602\",\n            \"01ad659d8d3f17e96d54e4240614fad5813a58cc1ac67a336839b0bf6c56f2d3\",\n            \"8627dad7e4df3cc60d1349aac61cae36436423429a12f3df9a1e54a5ca8ee008\",\n            \"5f82784d819f440ee1766d9802d113c54626bd613009cbf699213f49adf2fbbd\",\n        ]);\n        let root = sha256d::Hash::from_str(\n            \"ff8fa20a8da05e334d59d257c8ba6f76b31856fafe92afdb51151daa2fe0a240\",\n        )\n        .unwrap();\n        let hashes: Vec\u003c_\u003e = hashes\n            .iter()\n            .map(|txid| sha256d::Hash::from_str(txid).unwrap())\n            .collect();\n\n        let proof = MerkleProof::from_block_hashes(hashes, 2);\n        let ser_proof = serialize(\u0026proof);\n        let de_proof = deserialize::\u003cMerkleProof\u003e(\u0026ser_proof);\n\n        assert!(de_proof.is_ok());\n\n        let de_proof = de_proof.unwrap();\n        assert_eq!(de_proof, proof);\n        assert!(de_proof.verify(root).unwrap());\n    }\n    #[test]\n    fn test_from_block() {\n        // Example from signet block 114448. This has a edge case of the target transaction\n        // being the last one in a odd number of elements, this caused this code to break in the past\n        // credit to @jaonoctus for finding it.\n        let block_hex = Vec::from_hex(\"000000200e7a1b4acac9d0fede38780af685f4f2468f379441da88d9333190e9fd000000de17ded487dedf4febfc2062696f726daf82c387c40ac6bf3f730cb6b8078ea6c7cb5c631e52011eafd2850109010000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff040310bf01feffffff02cdf7052a0100000016001481113cad52683679a83e76f76f84a4cfe36f75010000000000000000776a24aa21a9ed1a57f94172436261a598a05fd00f5dc6f0af113118b2ad0fd5ab067cdf14d0844c4fecc7daa2490047304402200188f50f763b594ad2515b5fe7a6ccd0651cb21a57f7c9462517809b0a71056a022073de9d51712ed92333fdf103021ab15f9d7ee438a9f40c4d21a2aae25e30a746010001200000000000000000000000000000000000000000000000000000000000000000000000000200000000010600f477f4573600d59279b8590ad2f393e80e35a4747a6bb980ed435cae516a470100000000fdffffffeeed54083b3a3b3d5fbd2b89dbd584cf9473caecff5307ef6a45d4bf895d3c9f0100000000fdffffff71998948a594919d5f458ca629851af2cddc6a707a46953946fa169785809cc50000000000fdffffff95aff1490be1d5cd7c0147cad2f09e85419661322abe55177e6c37cf74a274da0100000000fdffffff3989e6239f74d9f01863b9cdeb139c911f864e56f42d9a423e2fb56b8acff0e40100000000fdffffffa14095a3c7134dcfe63670990f1aae604e9c75c995bbe4e786d5dad9e210bdfa0100000000fdffffff011e21730200000000160014167905ff5769be1088fba282d5f2fe083eafd24f024730440220524dae54f383a34a3605a0fdd403f5e69e991675d4d631925fd38b16f11d965b02207946cd9a39407d722cb3407913dfd13970b347473e87fdf2dfa3d5ea9dc2e14d012102e62ff0a4b5f94bed13bda49c6f28016a4c462246ca234d91010050d67a766d850247304402206e2410b4b76d09b4c67c84f005d84e46e9d444495734dd3037f1cd8ac938de8602206da11b400e7b02a7ee6a51cb7b42b893db214a2ffff2eac75502429f50b03f8301210215a12de3be0588cc75b0f4c313dae06dbd9ecee933532f4d792bc25fa7a866aa024730440220255e7e199d8dfdc3764e7328b96a26d014f337d27f6629022bc4d6499af832020220703ae4dee6b14a568c877e31af8ead209316891a33eee085dc695ae7fc1cfc84012103dceb3c814a400f39c67d4cd71f926bf1e1dc8944445f712a3ea583ea5f4d1e9b0247304402203a5eb82548dd0ff5f443b66e7f26f5c846315cfbfe488854027dc417c27993090220058ce815c913b0a4b24bd8d9db0a350f5c3bb2b4dcdec2a002a24c440b8496e0012102e8f9662c11aec882442f42dad5d7c19373249793a2a6b630c1971c8e2930ad0f0247304402203411bb65d910def1892d83dba89c6ea6664313eda18af70248884efe4ec6c204022029845c30b2904b60ab5fe6e19cf448f970dfe61cf2e4079482c55f1bb8b8cf4a0121030e8756107674bf33e2392d77f20d2890570c605282e665ec56358b72861219da02473044022075517e3dcfde63549abb19db17fe8a88b2cc643c921b295388c79f78936d3d8802202699e190c42a53856e99211f7b2a702fbc29466bfcac5d7a10e57fd77c109b1801210381477a1e64fda3873c3833c7cbe12cf0a8379a10c57e143be887cf5a53fe46bc0ebf0100020000000001011963991b6c03ca15f9ec0e4ad611e474c3277d0c3655bc9d797de1c14ab7aa7c0100000000feffffff0240420f00000000001600142349b57a01d75c7c858ac751f897239a86bbf04bb873285d5106000016001414bf9b0fe92caa0097b63a1ef3ea275d410fd98d02473044022054b442f21f988a0b97e6d7e8b24e23ccfecfaa12c0eb9eb96775a7765af941de022050d04a2db06e86fe9c9f90fee1169648cf9531e4c3697a744296f6b61324f4830121028bf1e30de43373796a0991b98aa5a4195c86495fba684656a26b0096df3110990fbf010002000000000101344f1ef28a664fe17a4aa50b8d3009ef6c6e49b85d66f8f9b3449bb74582ea350000000000feffffff0240420f0000000000160014e44b51eb316763098c5d18de6ca8b2c0a59c0e17bc9ce6df4f0600001600145fd025abef9e808689076765f4f0c56738c59f39024730440220479115072916500cffc1cc52fd889e5bf832a353125a1bdece97f7563feb5e090220504c4c7dd6a1f6cb0c2ba50c44187f46075dd8b20f94ad6c8b6bafc790dbcc31012102f2bdad8ec4652cb21e7605f26bc81ca66c10ff28e0f3d2a0ea19fc8cd52099b10fbf010002000000000101edd9a6cc38a24a387dc9abe7a1701886fcb2320657b144d0d0316e8ca43ae3d70000000000feffffff0240420f000000000022512010e8ae98031a5708b4bf6569c51f2fff6b000d0237d094bba411b684bb91357aafcb93035206000016001460f37086e9aaae4ddbf4b239482368a10d9c41c70247304402201ee3fdce8f0fb88e23ebdb43fab44044d099f85f506a93feb18b3dd2396b10f002206e82dab913ea09a62509b34b9d1799682af3dc2852a7ca3a851f0d377f8f387001210263bb044157db46c69b30e280e1b012aeeef7e4d2e324bb1badf6b271eea081d50fbf010002000000000101716c42179f6c5c18bb8c648fbb5697e4ada7a3661d6dc41988898b4a3366f00b0000000000feffffff028fbb1b0c000000001600145cb211255a52a72c50ff28125e6d19c3783634246a2b010000000000160014b323d1a6d231f481ec9d0edb4b6628ad7c3013ed02473044022013a5cf7f8b40b66b49d1d3b0da3b045c55eb65da1f0ab5b51925ad1ab74676420220670a2cc57fdd95bec289f3659254683401f550ead6c518ea69b2ac5e154a984d012102638e70a1e4a118a68d0a222d6783bb89308e54c403b44347c140c47d9f3f00290fbf0100020000000001018aece6fc6208c756036d569293b3f309fd753b7e72aef0d57d9d937db72721cf0100000000feffffff02590db89c5006000016001456e2f3da4da33aef14ddfcb6b732a81ff7e8675d40420f00000000002251205e15d348f226d1ea063a79e25aace48990dc473f61ae23f517e07f2917ac721c024730440220545d47834d82f7701cf229d5261f7de206f935ba4b0b58bb89d515add9a900d402207fd29ec10e8e2c935aba34c22d9dc8fc37b32cb0ab4ab4bff91fe6c68456b0c1012103ae5be7da80c63939f16a801363033d52c4e551b55eb1329d09ffa244e0d793290fbf010002000000000101911cf9966a3d8cd2bfb90f6f5d099c1e568a55bdcc55c4e6c041fc600614a3520100000000feffffff020dce63d44e0600001600145cee73b449f3da151659deb159148753c283381140420f0000000000225120b3b15df11fed9bca782f500031c94efc4ed8e4b0521c00295784d7dc5ac8684c02473044022046abbd3a4c279ddd535c3695bb89300f46494411f29c617862ccbb38b923ee740220638ad662b069c9977d4ac51065b493545ff3f4a890c05b42717be6d5ab9b3bd201210254f0f69224472b7f6a0849587a171637916a274d7ddef895dba298e6a1d89dbfadbe0100020000000001013d154c4a311dc630d1b3b403a327f03c07348b6c6cf0557500ef518ca412a2990000000000feffffff026d0833374d060000160014359a35960efb7c6ad62119702edf555163c03ab640420f0000000000225120dd0440d706666db07ae597a02d7af497d8fe1fdf059d1ca0b3c13b6d00a7d24f02473044022038535e6b04102ac866e896a33692e4050339de1f078b375c72d14914133cf9c6022034ad2f08092667cf8e5c60973771bef68315a47dff73f8ad4f0ef1d4a7d863110121032a42df4c108ad44282a75746f52161759aff3adc38bde305be7f5ddf172860120ebf0100\").unwrap();\n        let block = deserialize(\u0026block_hex).unwrap();\n        let merkle = MerkleProof::from_block(\u0026block, 8);\n\n        assert!(merkle\n            .verify(*block.header.merkle_root.as_raw_hash())\n            .unwrap());\n    }\n}\n","traces":[{"line":18,"address":[993152],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":19,"address":[993160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[993184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[993197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[993207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[993312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[993329],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[993344,993931,993964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[993395,993489],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[993942,993506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[993733],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[994000],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[994042],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[1154307,1154272],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":55,"address":[994094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[994144],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[994179],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[994239],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[994251,994393,994677],"length":1,"stats":{"Line":6},"fn_name":null},{"line":64,"address":[994414,994545],"length":1,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[994432],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[994552],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[994658],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[994350],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[994688],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[994696],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[994704],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[994712],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[994720],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[994789],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[994810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[994831],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[994842],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[994912,997205,996313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[994978,995082],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[995116],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[995275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[995386,995306],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[995394],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[995484,995605],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[995446,995522],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[995657,995574],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[995673,995857],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[995722,995683],"length":1,"stats":{"Line":4},"fn_name":null},{"line":123,"address":[995693,995804],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[996087,995875,995733],"length":1,"stats":{"Line":3},"fn_name":null},{"line":127,"address":[996111,996354],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[997106],"length":1,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[996883,996505],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[996969],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[996831],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[996550,996472],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[996636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[996279,995985,996324,996143],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[1154352,1155555],"length":1,"stats":{"Line":1},"fn_name":"consensus_decode\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":147,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":68,"coverable":75},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","cli_wire","mod.rs"],"content":"use std::{\n    collections::HashMap,\n    io::BufReader,\n    net::TcpStream,\n    sync::{atomic::AtomicBool, Arc},\n    time::Duration,\n};\n\nuse bitcoin::{\n    consensus::{deserialize, deserialize_partial, Encodable},\n    hashes::{\n        hex::{FromHex, ToHex},\n        sha256, Hash,\n    },\n    Block, BlockHash, BlockHeader, OutPoint,\n};\nuse btcd_rpc::{\n    client::{BTCDClient, BtcdRpc},\n    json_types::{blockchain::GetUtreexoProofResult, VerbosityOutput},\n};\nuse log::{error, info};\nuse rustreexo::accumulator::proof::Proof;\nuse serde::Deserialize;\n\nuse super::{\n    chain_state::ChainState, chainstore::KvChainStore, error::BlockchainError, udata::LeafData,\n    BlockchainInterface, Result, UpdatableChainstate,\n};\nuse crate::try_and_log;\n\npub struct UtreexodBackend {\n    pub use_batch_sync: bool,\n    pub batch_sync_hostname: String,\n    pub rpc: Arc\u003cBTCDClient\u003e,\n    pub chainstate: Arc\u003cChainState\u003cKvChainStore\u003e\u003e,\n    pub term: Arc\u003cAtomicBool\u003e,\n}\n\nimpl UtreexodBackend {\n    fn _get_block_hash(\u0026self, height: u32) -\u003e Result\u003cbitcoin::BlockHash\u003e {\n        Ok(BlockHash::from_hex(\n            self.rpc.getblockhash(height as usize)?.as_str(),\n        )?)\n    }\n    fn get_height(\u0026self) -\u003e Result\u003cu32\u003e {\n        let block = self.rpc.getbestblock()?;\n        Ok(block.height as u32)\n    }\n\n    fn broadcast(\u0026self, tx: \u0026bitcoin::Transaction) -\u003e Result\u003c()\u003e {\n        let mut writer = Vec::new();\n        let _ = tx\n            .consensus_encode(\u0026mut writer)\n            .expect(\"Should be a valid transaction\");\n        if self.rpc.sendrawtransaction(writer.to_hex()).is_err() {\n            error!(\"Error while broadcasting tx {}\", tx.txid());\n        }\n        Ok(())\n    }\n\n    fn _estimate_fee(\u0026self, target: usize) -\u003e Result\u003cf64\u003e {\n        let feerate = self.rpc.estimatefee(target as u32)?;\n        Ok(feerate)\n    }\n    pub fn get_block(\u0026self, height: u32) -\u003e Result\u003cBlock\u003e {\n        let hash = self.rpc.getblockhash(height as usize)?;\n        let block = self.rpc.getblock(hash, false)?;\n        if let VerbosityOutput::Simple(hex) = block {\n            let block = Vec::from_hex(hex.as_str())?;\n            let (block, _): (Block, usize) = deserialize_partial(\u0026block).unwrap();\n            let validation = block.header.validate_pow(\u0026block.header.target());\n            assert!(validation.is_ok());\n            return Ok(block);\n        }\n        Err(BlockchainError::BlockNotPresent)\n    }\n    pub fn get_proof\u003cT: BtcdRpc\u003e(\n        rpc: \u0026T,\n        hash: \u0026String,\n    ) -\u003e Result\u003c(Proof, Vec\u003csha256::Hash\u003e, Vec\u003cLeafData\u003e)\u003e {\n        let proof = rpc.getutreexoproof(hash.to_string(), true)?.get_verbose();\n        Self::process_proof(proof)\n    }\n    fn process_proof(\n        proof: GetUtreexoProofResult,\n    ) -\u003e Result\u003c(Proof, Vec\u003csha256::Hash\u003e, Vec\u003cLeafData\u003e)\u003e {\n        let preimages: Vec\u003c_\u003e = proof\n            .target_preimages\n            .iter()\n            .map(|preimage| {\n                deserialize_partial::\u003cLeafData\u003e(\u0026Vec::from_hex(preimage).unwrap())\n                    .unwrap()\n                    .0\n            })\n            .collect();\n\n        let proof_hashes: Vec\u003c_\u003e = proof\n            .proofhashes\n            .iter()\n            .map(|hash| sha256::Hash::from_hex(hash).unwrap())\n            .collect();\n        let targets = proof.prooftargets;\n\n        let targethashes: Vec\u003c_\u003e = proof\n            .targethashes\n            .iter()\n            .map(|hash| sha256::Hash::from_hex(hash).unwrap())\n            .collect();\n        let proof = Proof::new(targets, proof_hashes);\n\n        Ok((proof, targethashes, preimages))\n    }\n\n    pub fn handle_broadcast(\u0026self) -\u003e Result\u003c()\u003e {\n        let tx_list = self.chainstate.get_unbroadcasted();\n        for tx in tx_list {\n            self.broadcast(\u0026tx)?;\n        }\n        Ok(())\n    }\n    pub async fn handle_tip_update(\u0026self) -\u003e Result\u003c()\u003e {\n        let height = self.get_height()?;\n        let local_best = self.chainstate.get_best_block().unwrap().0;\n        if height \u003e local_best {\n            self.get_headers()?;\n            self.download_blocks().await?;\n        }\n        Ok(())\n    }\n    fn process_block(\u0026self, block_height: u32) -\u003e Result\u003c()\u003e {\n        let block = self.get_block(block_height)?;\n        let (proof, del_hashes, leaf_data) =\n            Self::get_proof(\u0026*self.rpc, \u0026block.block_hash().to_string())?;\n        let mut inputs = HashMap::new();\n        for tx in block.txdata.iter() {\n            for (vout, out) in tx.output.iter().enumerate() {\n                inputs.insert(\n                    OutPoint {\n                        txid: tx.txid(),\n                        vout: vout as u32,\n                    },\n                    out.clone(),\n                );\n            }\n        }\n        for leaf in leaf_data {\n            inputs.insert(leaf.prevout, leaf.utxo);\n        }\n        self.chainstate\n            .connect_block(\u0026block, proof, inputs, del_hashes)?;\n        Ok(())\n    }\n    async fn download_blocks(\u0026self) -\u003e Result\u003c()\u003e {\n        let height = self.get_height()?;\n        let current = self.chainstate.get_validation_index()?;\n        // We don't download genesis, because utreexod will error out if we try to fetch\n        // proof for it.\n        let current = if current == 0 { 1 } else { current };\n        if self.chainstate.is_in_idb() {\n            info!(\"Start Initial Block Download at height {current} of {height}\");\n        }\n        for block_height in current..=height {\n            if self.is_shutting_down() {\n                return Ok(());\n            }\n\n            if block_height % 10_000 == 0 {\n                info!(\"Sync at block {block_height}\");\n                if block_height % 100_000 == 0 {\n                    self.chainstate.flush()?;\n                }\n            }\n            self.process_block(block_height)?;\n        }\n        if self.chainstate.is_in_idb() {\n            info!(\"Leaving Initial Block Download at height {height}\");\n        } else {\n            info!(\"New tip: {height}\");\n        }\n        self.chainstate.toggle_ibd(false);\n        self.chainstate.flush()?;\n\n        Ok(())\n    }\n    async fn process_batch_block(\u0026self) -\u003e Result\u003c()\u003e {\n        let socket = TcpStream::connect(self.batch_sync_hostname.to_owned().as_str())?;\n\n        let height = self.get_height()?;\n        let current = self.chainstate.get_validation_index()?;\n        let mut reader = BufReader::new(socket);\n        for _ in (current + 1)..=height {\n            if self.is_shutting_down() {\n                return Ok(());\n            }\n            let block_data = rmp_serde::decode::from_read::\u003c_, BlockData\u003e(\u0026mut reader);\n            if block_data.is_err() {\n                error!(\"{:?}\", block_data);\n                break;\n            }\n            let block_data = block_data.unwrap();\n            let (proof, del_hashes, leaf_data) = Self::process_proof(block_data.proof)?;\n            let mut inputs = HashMap::new();\n            for tx in block_data.block.txdata.iter() {\n                for (vout, out) in tx.output.iter().enumerate() {\n                    inputs.insert(\n                        OutPoint {\n                            txid: tx.txid(),\n                            vout: vout as u32,\n                        },\n                        out.clone(),\n                    );\n                }\n            }\n            if block_data.height % 10_000 == 0 {\n                info!(\"Sync at block {}\", block_data.height);\n                self.chainstate.flush()?;\n            }\n            for leaf in leaf_data {\n                inputs.insert(leaf.prevout, leaf.utxo);\n            }\n            self.chainstate\n                .connect_block(\u0026block_data.block, proof, inputs, del_hashes)?;\n        }\n        info!(\"Leaving ibd\");\n        self.chainstate.toggle_ibd(false);\n        self.chainstate.flush()?;\n\n        Ok(())\n    }\n    fn get_headers(\u0026self) -\u003e Result\u003c()\u003e {\n        let tip = self.get_height()?;\n        let current = self.chainstate.get_best_block()?.0;\n        info!(\"Downloading headers\");\n        for i in (current / 2_000)..((tip / 2_000) + 1) {\n            if self.is_shutting_down() {\n                return Ok(());\n            }\n            let locator = self.chainstate.get_block_locator()?;\n            let locator = locator\n                .iter()\n                .map(|hash| hash.to_string())\n                .collect::\u003cVec\u003c_\u003e\u003e();\n\n            let headers = self\n                .rpc\n                .getheaders(locator, BlockHash::all_zeros().to_string())?;\n\n            let headers = headers\n                .iter()\n                .map(|header| {\n                    let header = Vec::from_hex(header).unwrap();\n                    deserialize::\u003cBlockHeader\u003e(\u0026header).unwrap()\n                })\n                .collect::\u003cVec\u003c_\u003e\u003e();\n\n            for header in headers {\n                self.chainstate.accept_header(header)?;\n            }\n            self.chainstate.flush()?;\n            info!(\n                \"Downloading headers...{:02.0}%\",\n                ((i * 2_000) as f64) / (tip as f64) * 100.00\n            );\n        }\n        Ok(())\n    }\n\n    pub async fn run(self) {\n        try_and_log!(self.get_headers());\n        if self.is_shutting_down() {\n            info!(\"Shuting blockchain down\");\n            try_and_log!(self.chainstate.flush());\n            return;\n        }\n        if self.use_batch_sync {\n            try_and_log!(self.process_batch_block().await);\n        } else {\n            try_and_log!(self.download_blocks().await);\n        }\n        self.chainstate.toggle_ibd(false);\n        loop {\n            async_std::task::sleep(Duration::from_secs(1)).await;\n            if self.is_shutting_down() {\n                info!(\"Shuting blockchain down\");\n                try_and_log!(self.chainstate.flush());\n                return;\n            }\n            try_and_log!(self.handle_broadcast());\n            try_and_log!(self.handle_tip_update().await);\n            try_and_log!(self.chainstate.flush());\n        }\n    }\n    fn is_shutting_down(\u0026self) -\u003e bool {\n        self.term\n            .fetch_and(true, std::sync::atomic::Ordering::AcqRel)\n    }\n}\n#[macro_export]\n/// Attempt to execute a function, and logs the error, if any.\nmacro_rules! try_and_log {\n    ($what: expr) =\u003e {\n        let result = $what;\n        if let Err(error) = result {\n            log::error!(\"{:?}\", error);\n        }\n    };\n}\n#[allow(unused)]\n#[derive(Debug, Deserialize)]\nstruct BlockData {\n    height: u32,\n    block: Block,\n    proof: GetUtreexoProofResult,\n}\n","traces":[{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","lib.rs"],"content":"// SPDX-License-Identifier: MIT\n//! # Floresta Wire\n//! This crate provides the core networking logic for a full node using libfloresta,\n//! including the P2P network and the mempool. You can easily integrate it with any\n//! other crate that provides a `BlockchainInterface` and `UpdatableChainstate`\n//! implementation.\n//!\n//! A node also gives you a `handle` that you can use to send messages to the node,\n//! like requesting blocks, mempool transactions or asking to connect with a given\n//! peer.\n\n#[cfg(not(target_arch = \"wasm32\"))]\nmod p2p_wire;\nuse bitcoin::block::Header as BlockHeader;\nuse bitcoin::Block;\nuse bitcoin::Transaction;\n#[cfg(not(target_arch = \"wasm32\"))]\npub use p2p_wire::address_man;\n#[cfg(not(target_arch = \"wasm32\"))]\npub use p2p_wire::mempool;\n#[cfg(not(target_arch = \"wasm32\"))]\npub use p2p_wire::node;\n#[cfg(not(target_arch = \"wasm32\"))]\npub use p2p_wire::node_context;\n#[cfg(not(target_arch = \"wasm32\"))]\npub use p2p_wire::node_interface;\n#[cfg(not(target_arch = \"wasm32\"))]\npub use p2p_wire::running_node;\npub use p2p_wire::UtreexoNodeConfig;\n/// NodeHooks is a trait that defines the hooks that a node can use to interact with the network\n/// and the blockchain. Every time an event happens, the node will call the corresponding hook.\npub trait NodeHooks {\n    /// We've received a new block\n    fn on_block_received(\u0026mut self, block: \u0026Block);\n    /// We've received a new transaction\n    fn on_transaction_received(\u0026mut self, transaction: \u0026Transaction);\n    /// We've received a new peer\n    fn on_peer_connected(\u0026mut self, peer: \u0026u32);\n    /// We've lost a peer\n    fn on_peer_disconnected(\u0026mut self, peer: \u0026u32);\n    /// We've received a new header\n    fn on_header_received(\u0026mut self, header: \u0026BlockHeader);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","address_man.rs"],"content":"//! Address manager is a module that keeps track of known peer addresses and associated\n//! metadata. This module is very important in keeping our node protected against targeted\n//! attacks, like eclipse attacks.\n\nuse std::collections::HashMap;\nuse std::fs::File;\nuse std::io;\nuse std::io::Read;\nuse std::net::IpAddr;\nuse std::net::Ipv4Addr;\nuse std::net::Ipv6Addr;\nuse std::str::FromStr;\nuse std::time::SystemTime;\nuse std::time::UNIX_EPOCH;\n\nuse async_std::fs::DirBuilder;\nuse bitcoin::p2p::address::AddrV2;\nuse bitcoin::p2p::address::AddrV2Message;\nuse bitcoin::p2p::ServiceFlags;\nuse floresta_chain::get_chain_dns_seeds;\nuse floresta_chain::Network;\nuse log::info;\nuse rand::Rng;\nuse serde::Deserialize;\nuse serde::Serialize;\nuse thiserror::Error;\n\nconst RETRY_TIME: u64 = 60 * 60; // 1 hour\ntype AddressToSend = Vec\u003c(AddrV2, u64, ServiceFlags, u16)\u003e;\n\n#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]\npub enum AddressState {\n    /// We never tried this peer before, so we don't know what to expect. This variant\n    /// also applies to peers that we tried to connect, but failed or we didn't connect\n    /// to for a long time.\n    NeverTried,\n    /// We tried this peer before, and had success at least once, so we know what to expect\n    Tried(u64),\n    /// This peer misbehaved and we banned them\n    Banned(u64),\n    /// We are connected to this peer right now\n    Connected,\n    /// We tried connecting, but failed\n    Failed(u64),\n}\n/// How do we store peers locally\n#[derive(Debug, Clone, PartialEq)]\npub struct LocalAddress {\n    /// An actual address\n    address: AddrV2,\n    /// Last time we successfully connected to this peer, only relevant is state == State::Tried\n    last_connected: u64,\n    /// Our local state for this peer, as defined in AddressState\n    state: AddressState,\n    /// Network services announced by this peer\n    services: ServiceFlags,\n    /// Network port this peers listens to\n    port: u16,\n    /// Random id for this peer\n    pub id: usize,\n}\n/// Seed Data for paesing in tests.\n#[derive(Debug, Clone, PartialEq, Deserialize)]\npub struct SeedData {\n    /// An actual address\n    address: SeedAddress,\n    /// Last time we successfully connected to this peer, only relevant is state == State::Tried\n    last_connected: u64,\n    /// Our local state for this peer, as defined in AddressState\n    state: AddressState,\n    /// Network services announced by this peer\n    pub services: u64,\n    /// Network port this peers listens to\n    port: u16,\n}\n#[derive(Debug, Deserialize, Serialize, Clone, PartialEq)]\nstruct SeedAddress {\n    V4: Ipv4Addr,\n}\n#[derive(Debug, Error)]\npub enum AddrManError {}\nimpl From\u003cAddrV2\u003e for LocalAddress {\n    fn from(value: AddrV2) -\u003e Self {\n        LocalAddress {\n            address: value,\n            last_connected: SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            state: AddressState::NeverTried,\n            services: ServiceFlags::NONE,\n            port: 8333,\n            id: rand::random::\u003cusize\u003e(),\n        }\n    }\n}\nimpl From\u003cAddrV2Message\u003e for LocalAddress {\n    fn from(value: AddrV2Message) -\u003e Self {\n        LocalAddress {\n            address: value.addr,\n            last_connected: value.time.into(),\n            state: AddressState::NeverTried,\n            services: value.services,\n            port: value.port,\n            id: rand::random::\u003cusize\u003e(),\n        }\n    }\n}\nimpl FromStr for LocalAddress {\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        LocalAddress::try_from(s)\n    }\n    type Err = std::net::AddrParseError;\n}\nimpl TryFrom\u003c\u0026str\u003e for LocalAddress {\n    fn try_from(value: \u0026str) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let split = value.split(':').collect::\u003cVec\u003c_\u003e\u003e();\n        let address = split[0].parse::\u003cIpv4Addr\u003e()?;\n        let port = if let Some(port) = split.get(1) {\n            port.parse().unwrap_or(8333)\n        } else {\n            8333\n        };\n        Ok(LocalAddress::new(\n            AddrV2::Ipv4(address),\n            SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            super::address_man::AddressState::NeverTried,\n            ServiceFlags::NONE,\n            port,\n            rand::random::\u003cusize\u003e(),\n        ))\n    }\n\n    type Error = std::net::AddrParseError;\n}\n\nimpl LocalAddress {\n    pub fn new(\n        address: AddrV2,\n        last_connected: u64,\n        state: AddressState,\n        services: ServiceFlags,\n        port: u16,\n        id: usize,\n    ) -\u003e LocalAddress {\n        LocalAddress {\n            address,\n            last_connected,\n            state,\n            services,\n            port,\n            id,\n        }\n    }\n    /// Returns this address's port\n    pub fn get_port(\u0026self) -\u003e u16 {\n        self.port\n    }\n    /// Return an IP address associated with this peer address\n    pub fn get_net_address(\u0026self) -\u003e IpAddr {\n        match self.address {\n            // IPV4\n            AddrV2::Ipv4(ipv4) =\u003e IpAddr::V4(ipv4),\n            // IPV6\n            AddrV2::Ipv6(ipv6) =\u003e IpAddr::V6(ipv6),\n            _ =\u003e IpAddr::V4(Ipv4Addr::LOCALHOST),\n        }\n    }\n    /// Returns the actual address, as defined in AddrV2. This is useful\n    /// if we are trying a peer that needs a proxy like Tor.\n    pub fn get_address(\u0026self) -\u003e AddrV2 {\n        self.address.clone()\n    }\n}\n/// A module that keeps track of know addresses and serve them to our node to connect\n#[derive(Default)]\npub struct AddressMan {\n    addresses: HashMap\u003cusize, LocalAddress\u003e,\n    good_addresses: Vec\u003cusize\u003e,\n    utreexo_addresses: Vec\u003cusize\u003e,\n}\nimpl AddressMan {\n    /// Add a new address to our list of known address\n    pub fn push_addresses(\u0026mut self, addresses: \u0026[LocalAddress]) {\n        for address in addresses {\n            let id = address.id;\n            if let std::collections::hash_map::Entry::Vacant(e) = self.addresses.entry(id) {\n                // For now we assume that all addresses are valid, until proven otherwise.\n                self.good_addresses.push(id);\n                if address.services.has(ServiceFlags::from(1 \u003c\u003c 24)) {\n                    self.utreexo_addresses.push(id);\n                }\n                e.insert(address.to_owned());\n            }\n        }\n    }\n    pub fn get_addresses_to_send(\u0026self) -\u003e AddressToSend {\n        let addresses = self\n            .addresses\n            .iter()\n            .flat_map(|(time, v)| match v.state {\n                AddressState::Tried(time) =\u003e {\n                    let timeout = time + RETRY_TIME;\n                    let now_as_sec = SystemTime::now()\n                        .duration_since(UNIX_EPOCH)\n                        .unwrap()\n                        .as_secs();\n                    if timeout \u003c now_as_sec {\n                        return Some((v.address.clone(), time, v.services, v.port));\n                    }\n                    None\n                }\n                AddressState::Connected =\u003e {\n                    Some((v.address.clone(), *time as u64, v.services, v.port))\n                }\n                _ =\u003e None,\n            })\n            .collect();\n        addresses\n    }\n    pub fn get_seeds_from_dns(\n        \u0026mut self,\n        seed: \u0026str,\n        default_port: u16,\n    ) -\u003e Result\u003cusize, std::io::Error\u003e {\n        let mut addresses = Vec::new();\n        let utreexo_seed = seed.contains(\"x1000000.\");\n        for ip in dns_lookup::lookup_host(seed)? {\n            if let Ok(mut ip) = LocalAddress::try_from(format!(\"{}:{}\", ip, default_port).as_str())\n            {\n                // This seed returns utreexo nodes\n                if utreexo_seed {\n                    ip.services |= ServiceFlags::from(1 \u003c\u003c 24);\n                }\n                addresses.push(ip);\n            }\n        }\n        self.push_addresses(\u0026addresses);\n        Ok(addresses.len())\n    }\n    /// Returns a new random address to open a new connection, we try to get addresses with\n    /// a set of features supported for our peers\n    pub fn get_address_to_connect(\n        \u0026mut self,\n        flags: ServiceFlags,\n        feeler: bool,\n    ) -\u003e Option\u003c(usize, LocalAddress)\u003e {\n        if self.addresses.is_empty() {\n            return None;\n        }\n        // Feeler connection are used to test if a peer is still alive, we don't care about\n        // the features it supports or even if it's a valid peer. The only thing we care about\n        // is that we haven't banned it.\n        let (id, peer) = if feeler {\n            let idx = rand::random::\u003cusize\u003e() % self.addresses.len();\n            let peer = self.addresses.keys().nth(idx)?;\n            let address = self.addresses.get(peer)?.to_owned();\n            if let AddressState::Banned(_) = address.state {\n                return None;\n            }\n            (*peer, address)\n        } else if flags.has(ServiceFlags::from(1 \u003c\u003c 24)) {\n            // if we don't have an utreexo address, we fallback to a normal good address\n            self.get_random_utreexo_address()\n                .or_else(|| self.get_random_good_address())?\n        } else {\n            self.get_random_good_address()?\n        };\n        let now = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .unwrap()\n            .as_secs();\n        match peer.state {\n            AddressState::Banned(_) =\u003e None,\n            AddressState::Connected =\u003e self.get_random_good_address(),\n            AddressState::NeverTried | AddressState::Tried(_) =\u003e Some((id, peer)),\n            AddressState::Failed(time) =\u003e {\n                if now - time \u003e RETRY_TIME {\n                    Some((id, peer))\n                } else {\n                    None\n                }\n            }\n        }\n    }\n    pub fn dump_peers(\u0026self, datadir: \u0026str) -\u003e std::io::Result\u003c()\u003e {\n        let peers: Vec\u003c_\u003e = self\n            .addresses\n            .values()\n            .cloned()\n            .map(Into::\u003cDiskLocalAddress\u003e::into)\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        let peers = serde_json::to_string(\u0026peers);\n        if let Ok(peers) = peers {\n            std::fs::write(datadir.to_owned() + \"/peers.json\", peers)?;\n        }\n        Ok(())\n    }\n    fn get_random_good_address(\u0026self) -\u003e Option\u003c(usize, LocalAddress)\u003e {\n        if self.good_addresses.is_empty() {\n            return None;\n        }\n        let idx = rand::random::\u003cusize\u003e() % self.good_addresses.len();\n        let good_peer = self.good_addresses.get(idx)?;\n        Some((*good_peer, self.addresses.get(good_peer)?.to_owned()))\n    }\n    fn get_random_utreexo_address(\u0026self) -\u003e Option\u003c(usize, LocalAddress)\u003e {\n        if self.utreexo_addresses.is_empty() {\n            return None;\n        }\n        let idx = rand::random::\u003cusize\u003e() % self.utreexo_addresses.len();\n        let utreexo_peer = self.utreexo_addresses.get(idx)?;\n        Some((*utreexo_peer, self.addresses.get(utreexo_peer)?.to_owned()))\n    }\n    fn get_net_seeds(network: Network) -\u003e \u0026'static str {\n        match network {\n            Network::Bitcoin =\u003e include_str!(\"seeds/mainnet_seeds.json\"),\n            Network::Testnet =\u003e include_str!(\"seeds/testnet_seeds.json\"),\n            Network::Signet =\u003e include_str!(\"seeds/signet_seeds.json\"),\n            Network::Regtest =\u003e include_str!(\"seeds/regtest_seeds.json\"),\n        }\n    }\n    pub fn start_addr_man(\n        \u0026mut self,\n        datadir: String,\n        default_port: u16,\n        network: Network,\n        dns_seeds: \u0026[\u0026'static str],\n    ) -\u003e Result\u003cVec\u003cLocalAddress\u003e, std::io::Error\u003e {\n        let local_db = std::fs::read_to_string(format!(\"{datadir}/peers.json\"));\n        let peers = if let Ok(peers) = local_db {\n            info!(\"Peers database found, using it\");\n\n            serde_json::from_str::\u003cVec\u003cDiskLocalAddress\u003e\u003e(\u0026peers)\n        } else {\n            info!(\"No peers available, using fixed peers\");\n            let mut peers_from_dns = 0;\n            for seed in dns_seeds {\n                peers_from_dns += self.get_seeds_from_dns(seed, default_port)?;\n            }\n            info!(\"Got {peers_from_dns} peers from DNS Seeds\",);\n            let addresses = Self::get_net_seeds(network);\n            serde_json::from_str(addresses)\n        };\n        if let Ok(peers) = peers {\n            let peers = peers\n                .iter()\n                .cloned()\n                .map(Into::\u003cLocalAddress\u003e::into)\n                .collect::\u003cVec\u003c_\u003e\u003e();\n            self.push_addresses(\u0026peers);\n        }\n        let anchors = std::fs::read_to_string(format!(\"{datadir}/anchors.json\"));\n        if anchors.is_err() {\n            return Ok(Vec::new());\n        }\n        if let Ok(anchors) = serde_json::from_str::\u003cVec\u003cDiskLocalAddress\u003e\u003e(\u0026anchors.unwrap()) {\n            let anchors = anchors\n                .iter()\n                .cloned()\n                .map(Into::\u003cLocalAddress\u003e::into)\n                .collect::\u003cVec\u003c_\u003e\u003e();\n            return Ok(anchors);\n        }\n        Ok(Vec::new())\n    }\n    /// This function moves addresses between buckets, like if the ban time of a peer expired,\n    /// or if we tried to connect to a peer and it failed in the past, but now it might be online\n    /// again.\n    pub fn rearrange_buckets(\u0026mut self) {\n        let now = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .unwrap()\n            .as_secs();\n        for (_, address) in self.addresses.iter_mut() {\n            match address.state {\n                AddressState::Banned(ban_time) =\u003e {\n                    if ban_time \u003c now {\n                        address.state = AddressState::NeverTried;\n                    }\n                }\n                AddressState::Tried(tried_time) =\u003e {\n                    if tried_time + RETRY_TIME \u003c now {\n                        address.state = AddressState::NeverTried;\n                    }\n                }\n                AddressState::Failed(failed_time) =\u003e {\n                    if failed_time + RETRY_TIME \u003c now {\n                        address.state = AddressState::NeverTried;\n                    }\n                }\n                AddressState::Connected | AddressState::NeverTried =\u003e {}\n            }\n        }\n    }\n    /// Updates the state of an address\n    pub fn update_set_state(\u0026mut self, idx: usize, state: AddressState) -\u003e \u0026mut Self {\n        if matches!(state, AddressState::Banned(_)) {\n            return self;\n        }\n\n        match state {\n            AddressState::Banned(_) =\u003e {\n                self.good_addresses.retain(|\u0026x| x != idx);\n            }\n            AddressState::Tried(_) =\u003e {\n                if !self.good_addresses.contains(\u0026idx) {\n                    self.good_addresses.push(idx);\n                }\n            }\n            AddressState::NeverTried =\u003e {\n                self.good_addresses.retain(|\u0026x| x != idx);\n            }\n            AddressState::Connected =\u003e {\n                if !self.good_addresses.contains(\u0026idx) {\n                    self.good_addresses.push(idx);\n                }\n            }\n            AddressState::Failed(_) =\u003e {\n                self.good_addresses.retain(|\u0026x| x != idx);\n            }\n        }\n        if let Some(address) = self.addresses.get_mut(\u0026idx) {\n            address.state = state;\n        };\n        self\n    }\n    /// Updates the service flags after we receive a version message\n    pub fn update_set_service_flag(\u0026mut self, idx: usize, flags: ServiceFlags) -\u003e \u0026mut Self {\n        if let Some(address) = self.addresses.get_mut(\u0026idx) {\n            address.services = flags;\n        }\n        self\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DiskLocalAddress {\n    /// An actual address\n    address: Address,\n    /// Last time we successfully connected to this peer, only relevant is state == State::Tried\n    last_connected: u64,\n    /// Our local state for this peer, as defined in AddressState\n    state: AddressState,\n    /// Network services announced by this peer\n    services: u64,\n    /// Network port this peers listens to\n    port: u16,\n    /// An id to identify this address\n    id: Option\u003cusize\u003e,\n}\nimpl From\u003cLocalAddress\u003e for DiskLocalAddress {\n    fn from(value: LocalAddress) -\u003e Self {\n        let address = match value.address {\n            AddrV2::Ipv4(ip) =\u003e Address::V4(ip),\n            AddrV2::Ipv6(ip) =\u003e Address::V6(ip),\n            AddrV2::Cjdns(ip) =\u003e Address::Cjdns(ip),\n            AddrV2::I2p(ip) =\u003e Address::I2p(ip),\n            AddrV2::TorV2(ip) =\u003e Address::OnionV2(ip),\n            AddrV2::TorV3(ip) =\u003e Address::OnionV3(ip),\n            AddrV2::Unknown(_, _) =\u003e Address::V4(Ipv4Addr::LOCALHOST),\n        };\n\n        DiskLocalAddress {\n            address,\n            last_connected: value.last_connected,\n            state: if value.state == AddressState::Connected {\n                AddressState::Tried(\n                    SystemTime::now()\n                        .duration_since(UNIX_EPOCH)\n                        .unwrap()\n                        .as_secs(),\n                )\n            } else {\n                value.state\n            },\n            services: value.services.to_u64(),\n            port: value.port,\n            id: Some(value.id),\n        }\n    }\n}\nimpl From\u003cDiskLocalAddress\u003e for LocalAddress {\n    fn from(value: DiskLocalAddress) -\u003e Self {\n        let address = match value.address {\n            Address::V4(ip) =\u003e AddrV2::Ipv4(ip),\n            Address::V6(ip) =\u003e AddrV2::Ipv6(ip),\n            Address::Cjdns(ip) =\u003e AddrV2::Cjdns(ip),\n            Address::I2p(ip) =\u003e AddrV2::I2p(ip),\n            Address::OnionV2(ip) =\u003e AddrV2::TorV2(ip),\n            Address::OnionV3(ip) =\u003e AddrV2::TorV3(ip),\n        };\n        let services = ServiceFlags::from(value.services);\n        LocalAddress {\n            address,\n            last_connected: value.last_connected,\n            state: value.state,\n            services,\n            port: value.port,\n            id: value.id.unwrap_or_else(rand::random::\u003cusize\u003e),\n        }\n    }\n}\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum Address {\n    /// Regular ipv4 address\n    V4(Ipv4Addr),\n    /// Regular ipv6 address\n    V6(Ipv6Addr),\n    /// Tor v2 address, this may never be used, as OnionV2 is deprecated\n    /// but we'll keep it here for completeness sake\n    OnionV2([u8; 10]),\n    /// Tor v3 address. This is the preferred way to connect to a tor node\n    OnionV3([u8; 32]),\n    /// Cjdns ipv6 address\n    Cjdns(Ipv6Addr),\n    /// I2p address, a 32 byte node key\n    I2p([u8; 32]),\n}\n\n#[cfg(test)]\n\nfn load_addresses_from_json(file_path: \u0026str) -\u003e io::Result\u003cVec\u003cLocalAddress\u003e\u003e {\n    use rand::Rng;\n\n    let mut contents = String::new();\n    File::open(file_path)?.read_to_string(\u0026mut contents)?;\n\n    let seeds: Vec\u003cSeedData\u003e = serde_json::from_str(\u0026contents).expect(\"JSON not well-formatted\");\n    let mut addresses = Vec::new();\n    let mut rng = rand::thread_rng();\n\n    for seed in seeds {\n        let state = match seed.state {\n            AddressState::Tried(time) =\u003e AddressState::Tried(time),\n            _ =\u003e continue,\n        };\n\n        let _address = AddrV2::Ipv4(seed.address.V4);\n\n        let local_address = LocalAddress {\n            address: _address,\n            last_connected: seed.last_connected,\n            state: state,\n            services: ServiceFlags::from(seed.services),\n            port: seed.port,\n            id: rng.gen(),\n        };\n        addresses.push(local_address);\n    }\n\n    Ok(addresses)\n}\n#[test]\nfn test_parse() {\n    let signet_address =\n        load_addresses_from_json(\"./src/p2p_wire/seeds/signet_seeds.json\").unwrap();\n\n    assert!(!signet_address.is_empty());\n    let random = rand::thread_rng().gen_range(1..=14);\n    let loc_adr_1 = LocalAddress::from(signet_address[random].address.clone());\n    assert_eq!(loc_adr_1.address, signet_address[random].address);\n}\n#[test]\nfn test_address_man() {\n    let mut address_man = AddressMan {\n        addresses: HashMap::new(),\n        good_addresses: Vec::new(),\n        utreexo_addresses: Vec::new(),\n    };\n\n    let signet_address =\n        load_addresses_from_json(\"./src/p2p_wire/seeds/signet_seeds.json\").unwrap();\n\n    address_man.push_addresses(\u0026signet_address);\n\n    assert!(!address_man.good_addresses.is_empty());\n\n    assert!(!address_man.utreexo_addresses.is_empty());\n\n    assert!(!address_man.get_addresses_to_send().is_empty());\n\n    assert!(address_man\n        .get_address_to_connect(ServiceFlags::default(), true)\n        .is_some());\n\n    assert!(address_man\n        .get_address_to_connect(ServiceFlags::default(), false)\n        .is_some());\n\n    assert!(address_man.dump_peers(\"./data\").is_ok());\n\n    assert!(address_man.get_random_good_address().is_some());\n\n    assert!(address_man.get_random_utreexo_address().is_some());\n\n    assert!(!AddressMan::get_net_seeds(Network::Signet).is_empty());\n    assert!(!AddressMan::get_net_seeds(Network::Bitcoin).is_empty());\n    assert!(!AddressMan::get_net_seeds(Network::Regtest).is_empty());\n    assert!(!AddressMan::get_net_seeds(Network::Testnet).is_empty());\n\n    assert!(address_man\n        .get_seeds_from_dns(\u0026get_chain_dns_seeds(Network::Signet)[0], 8333)\n        .is_ok());\n\n    assert!(address_man\n        .start_addr_man(\n            \"./data\".to_string(),\n            8333,\n            Network::Signet,\n            \u0026get_chain_dns_seeds(Network::Signet)\n        )\n        .is_ok());\n\n    address_man.rearrange_buckets();\n}\n","traces":[{"line":83,"address":[1590912,1591260],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":86,"address":[1590955,1591025],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[1591153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[1591536,1591296],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":100,"address":[1591318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[1591344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[1591411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[1591420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[1591429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[1591568],"length":1,"stats":{"Line":0},"fn_name":"from_str"},{"line":111,"address":[1591589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[1592672,1591616,1592699],"length":1,"stats":{"Line":1},"fn_name":"try_from"},{"line":117,"address":[1591652],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[1591805,1591727,1592032],"length":1,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[1592010,1592082,1592184],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[1592152,1592190],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[1592174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[1592525,1592602],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[1592248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[1592278,1592348],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[1592473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[1592485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[1592498],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[1592720],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[1592880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[1592885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[1592896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[1592916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[1592974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[1593003],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[1592950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[1593056],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[1593073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[1593104],"length":1,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[1593235,1593166],"length":1,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[1593253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[1593270],"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[1593346],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[1593361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[1593450],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[1593404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[1593472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[1593497],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[1637552,1637603],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":205,"address":[1637666],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[1637683,1637866,1637995],"length":1,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[1637874],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[1637988],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[1638043],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[1638030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[1637715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[1637653],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[1593553],"length":1,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[1593600,1595093,1595179],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[1593674],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[1593812,1593719],"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[1593821,1595156],"length":1,"stats":{"Line":2},"fn_name":null},{"line":232,"address":[1594488,1594701,1595070],"length":1,"stats":{"Line":3},"fn_name":null},{"line":235,"address":[1594791],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[1594963,1595046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[1594836],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[1594269],"length":1,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[1594316],"length":1,"stats":{"Line":1},"fn_name":null},{"line":246,"address":[1595200,1596946],"length":1,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[1595275,1596535],"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[1595313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[1596309,1595660,1595299],"length":1,"stats":{"Line":3},"fn_name":null},{"line":258,"address":[1595911,1596007,1595357],"length":1,"stats":{"Line":2},"fn_name":null},{"line":259,"address":[1596042,1596123,1595929],"length":1,"stats":{"Line":2},"fn_name":null},{"line":260,"address":[1596063,1596183,1596133],"length":1,"stats":{"Line":2},"fn_name":null},{"line":261,"address":[1596162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[1596201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[1596232],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[1595876,1596209,1595326,1595640],"length":1,"stats":{"Line":2},"fn_name":null},{"line":267,"address":[1595889,1595503,1595824,1595477],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[1595495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[1595407,1595588,1595650,1595250],"length":1,"stats":{"Line":3},"fn_name":null},{"line":272,"address":[1595785,1596363],"length":1,"stats":{"Line":2},"fn_name":null},{"line":276,"address":[1596501],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[1596650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[1596743,1596673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[1596537],"length":1,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[1596685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[1596750,1596808,1596701,1596913],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[1596810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[1596800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[1597838,1596976,1597740],"length":1,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[1597023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[1597133,1597177],"length":1,"stats":{"Line":2},"fn_name":null},{"line":297,"address":[1597185,1597549],"length":1,"stats":{"Line":2},"fn_name":null},{"line":298,"address":[1597554,1597280,1597375,1596999],"length":1,"stats":{"Line":3},"fn_name":null},{"line":300,"address":[1597287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":302,"address":[1597856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[1597894],"length":1,"stats":{"Line":1},"fn_name":null},{"line":304,"address":[1597956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[1598069,1597984,1597908],"length":1,"stats":{"Line":2},"fn_name":null},{"line":307,"address":[1598181,1598104,1598002],"length":1,"stats":{"Line":2},"fn_name":null},{"line":308,"address":[1597886,1598188,1598117,1598280],"length":1,"stats":{"Line":3},"fn_name":null},{"line":310,"address":[1598304],"length":1,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[1598342],"length":1,"stats":{"Line":1},"fn_name":null},{"line":312,"address":[1598404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[1598517,1598356,1598432],"length":1,"stats":{"Line":2},"fn_name":null},{"line":315,"address":[1598450,1598629,1598552],"length":1,"stats":{"Line":2},"fn_name":null},{"line":316,"address":[1598636,1598728,1598334,1598565],"length":1,"stats":{"Line":3},"fn_name":null},{"line":318,"address":[1598752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":319,"address":[1598759],"length":1,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[1598792],"length":1,"stats":{"Line":1},"fn_name":null},{"line":321,"address":[1598815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":322,"address":[1598861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":323,"address":[1598838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":326,"address":[1599930,1603075,1598896],"length":1,"stats":{"Line":1},"fn_name":null},{"line":333,"address":[1599201,1599044],"length":1,"stats":{"Line":2},"fn_name":null},{"line":334,"address":[1600805,1599344],"length":1,"stats":{"Line":1},"fn_name":null},{"line":335,"address":[1599557,1599645,1599413],"length":1,"stats":{"Line":3},"fn_name":null},{"line":337,"address":[1599798,1599571],"length":1,"stats":{"Line":2},"fn_name":null},{"line":339,"address":[1599458,1599948,1600060],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[1599970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[1602897,1599982,1600205,1600354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[1602902,1600370,1602772],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[1600496,1600406,1600293,1600649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[1600419,1600766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[1600790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[1600810,1599892],"length":1,"stats":{"Line":2},"fn_name":null},{"line":349,"address":[1600858,1601021],"length":1,"stats":{"Line":2},"fn_name":null},{"line":354,"address":[1601224,1601149],"length":1,"stats":{"Line":2},"fn_name":null},{"line":356,"address":[1601340],"length":1,"stats":{"Line":1},"fn_name":null},{"line":357,"address":[1601491,1601547],"length":1,"stats":{"Line":2},"fn_name":null},{"line":358,"address":[1601631,1602513],"length":1,"stats":{"Line":2},"fn_name":null},{"line":360,"address":[1601649,1601728,1601553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[1601889,1601804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[1601993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[1602247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[1603104],"length":1,"stats":{"Line":1},"fn_name":null},{"line":374,"address":[1603124],"length":1,"stats":{"Line":1},"fn_name":null},{"line":378,"address":[1603398,1603228,1603348],"length":1,"stats":{"Line":2},"fn_name":null},{"line":379,"address":[1603369],"length":1,"stats":{"Line":1},"fn_name":null},{"line":380,"address":[1603447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[1603459,1603651],"length":1,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[1603616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[1603405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":386,"address":[1603417,1603526,1603606],"length":1,"stats":{"Line":3},"fn_name":null},{"line":387,"address":[1603571],"length":1,"stats":{"Line":1},"fn_name":null},{"line":390,"address":[1603478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[1603745,1603490,1603665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[1603710],"length":1,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[1603760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[1603789,1603850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[1603802],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[1603809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[1603931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[1603891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[1604076],"length":1,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[1603857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[1603962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[1604098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[1603999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[1604028,1604115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[1604125],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[1604147],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[1604160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[1604188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[1604244],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[1605246,1604272],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":457,"address":[1604294],"length":1,"stats":{"Line":1},"fn_name":null},{"line":458,"address":[1604331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":459,"address":[1604367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[1604630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[1604565],"length":1,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[1604432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[1604497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[1604687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[1604750],"length":1,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[1604826,1604860,1604759,1605069],"length":1,"stats":{"Line":3},"fn_name":null},{"line":480,"address":[1604887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":481,"address":[1605084],"length":1,"stats":{"Line":1},"fn_name":null},{"line":482,"address":[1605093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":487,"address":[1606079,1605280],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":488,"address":[1605302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":489,"address":[1605347],"length":1,"stats":{"Line":1},"fn_name":null},{"line":490,"address":[1605391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[1605610],"length":1,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[1605680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[1605464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[1605537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[1605748,1605819],"length":1,"stats":{"Line":2},"fn_name":null},{"line":499,"address":[1605874],"length":1,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[1605883],"length":1,"stats":{"Line":1},"fn_name":null},{"line":502,"address":[1605901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":503,"address":[1605910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":526,"address":[1607617,1606128,1607701],"length":1,"stats":{"Line":1},"fn_name":"load_addresses_from_json"},{"line":529,"address":[1606171],"length":1,"stats":{"Line":1},"fn_name":null},{"line":530,"address":[1607664,1607699,1606207,1606267],"length":1,"stats":{"Line":2},"fn_name":null},{"line":532,"address":[1606552],"length":1,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[1606652],"length":1,"stats":{"Line":1},"fn_name":null},{"line":534,"address":[1606767,1606700],"length":1,"stats":{"Line":2},"fn_name":null},{"line":536,"address":[1606882,1606775],"length":1,"stats":{"Line":2},"fn_name":null},{"line":537,"address":[1607076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":538,"address":[1607223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":542,"address":[1607259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":546,"address":[1607343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":548,"address":[1607356],"length":1,"stats":{"Line":1},"fn_name":null},{"line":549,"address":[1607424],"length":1,"stats":{"Line":1},"fn_name":null},{"line":550,"address":[1607445],"length":1,"stats":{"Line":1},"fn_name":null},{"line":552,"address":[1607605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":555,"address":[1607101],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":126,"coverable":205},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","chain_selector.rs"],"content":"// SPDX-License-Identifier: MIT\n\n//! A module that connects with multiple peers and finds the best chain.\n//!\n//! # The theory\n//!\n//! In Bitcoin, the history of transactions processed by the network is defined by a sequence of\n//! blocks, chainned by their cryptographic hash. A block commits the hash for the block right\n//! before it. Therefore, if we pick any given block, there's exactly one history leading to the\n//! very first block, that commits to no one. However, if you go in the other way, starting at the\n//! first block and going up, there may not be only one history. Multiple blocks may commit to the\n//! same parent. We need a way to pick just one such chain, among all others.\n//!\n//! To do that, we use the most work rule, sometimes called \"Nakamoto Consensus\" after Bitcoin's\n//! creator, Satoshi Nakamoto. Every block has to solve a probabilistic challenge of finding a\n//! combination of data that hashes to a value smaller than a network-agreed value. Because hash\n//! functions are pseudorandom, one must make certain amount of hashes (on average) before finding a\n//! valid one. If we define the amount of hashes needed to find a block as this block's \"work\",\n//! by adding-up the work in each of a chain's blocks, we arrive with the `chainwork`. The Nakamoto\n//! consensus consists in taking the chain with most work as the best one.\n//!\n//! This works because anyone in the network will compute the same amount of work and pick the same\n//! one, regardless of where and when. Because work is a intrinsic and deterministic property of a\n//! block, everyone comparing the same chain, be on earth, on mars; in 2020 or 2100, they will\n//! choose the exact same chain, always.\n//!\n//! The most critial part of syncing-up a Bitcoin node is making sure you know about the most-work\n//! chain. If someone can eclypse you, they can make you start following a chain that only you and\n//! the attacker care about. If you get paid in this chain, you can't pay someone else outside this\n//! chain, because they will be following other chains. Luckly, we only need one honest peer, to\n//! find the best-work chain and avoid any attacker to fools us into accepting payments in a \"fake\n//! Bitcoin\"\n//!\n//! # Implementation\n//!\n//! In Floresta, we try to pick a good balance between data downloaded and security. We could\n//! simply download all chains from all peers and pick the most work one. But each header is\n//! 80 bytes-long, with ~800k blocks, that's arround 60 MBs. If we have 10 peers, that's 600MBs\n//! (excluding overhead by the p2p messages). Moreover, it's very uncommon to actually have peers\n//! in different chains. So we can optmistically download all headers from one random peer, and\n//! then check with the others if they aggree. If they have another chain for us, we download that\n//! chain, and pick whichever has more work.\n//!\n//! Most likely we'll only download one chain and all peers will agree with it. Then we can start\n//! downloading the actual blocks and validating them.\nuse std::collections::HashSet;\nuse std::sync::Arc;\nuse std::time::Duration;\nuse std::time::Instant;\n\nuse async_std::future::timeout;\nuse async_std::sync::RwLock;\nuse bitcoin::block::Header;\nuse bitcoin::consensus::deserialize;\nuse bitcoin::p2p::utreexo::UtreexoBlock;\nuse bitcoin::p2p::ServiceFlags;\nuse bitcoin::BlockHash;\nuse floresta_chain::pruned_utreexo::BlockchainInterface;\nuse floresta_chain::pruned_utreexo::UpdatableChainstate;\nuse log::info;\nuse log::warn;\nuse rustreexo::accumulator::node_hash::NodeHash;\nuse rustreexo::accumulator::stump::Stump;\n\nuse super::error::WireError;\nuse super::peer::PeerMessages;\nuse crate::address_man::AddressState;\nuse crate::node::periodic_job;\nuse crate::node::try_and_log;\nuse crate::node::InflightRequests;\nuse crate::node::NodeNotification;\nuse crate::node::NodeRequest;\nuse crate::node::UtreexoNode;\nuse crate::node_context::NodeContext;\nuse crate::node_context::PeerId;\n\n#[derive(Debug, Default, Clone)]\n/// A p2p driver that attemps to connect with multiple peers, ask which chain are them following\n/// and download and verify the headers, **not** the actual blocks. This is the first part of a\n/// loger IBD pipeline.\n/// The actual blocks should be downloaded by a SyncPeer.\npub struct ChainSelector {\n    /// The state we are in\n    state: ChainSelectorState,\n    /// To save in bandwi****, we download headers from only one peer, and then look for forks\n    /// afterwards. This is the peer we are using during this phase\n    sync_peer: PeerId,\n    /// Peers that already sent us a message we are waiting for\n    done_peers: HashSet\u003cPeerId\u003e,\n}\n\n#[derive(Debug, Default, Clone, PartialEq, Eq)]\npub enum ChainSelectorState {\n    #[default]\n    /// We are opening connection with some peers\n    CreatingConnections,\n    /// We are downloading headers from only one peer, assuming this peer is honest\n    DownloadingHeaders,\n    /// We've downloaded all headers, and now we are checking with our peers if they\n    /// have an alternative tip with more PoW. Very unlikely, but we shouldn't trust\n    /// only one peer...\n    LookingForForks,\n    /// We've downloaded all headers\n    Done,\n}\n\npub enum FindAccResult {\n    Found(Vec\u003cu8\u003e),\n    KeepLooking(Vec\u003c(PeerId, Vec\u003cu8\u003e)\u003e),\n}\n\nimpl NodeContext for ChainSelector {\n    const REQUEST_TIMEOUT: u64 = 10; // Ban peers stalling our IBD\n    const TRY_NEW_CONNECTION: u64 = 10; // Try creating connections more aggressively\n\n    fn get_required_services(\u0026self) -\u003e ServiceFlags {\n        ServiceFlags::NETWORK | ServiceFlags::UTREEXO\n    }\n}\n\nimpl\u003cChain\u003e UtreexoNode\u003cChainSelector, Chain\u003e\nwhere\n    WireError: From\u003c\u003cChain as BlockchainInterface\u003e::Error\u003e,\n    Chain: BlockchainInterface + UpdatableChainstate + 'static,\n{\n    /// This function is called every time we get a `Headers` message from a peer.\n    /// It will validate the headers and add them to our chain, if they are valid.\n    /// If we get an empty headers message, we'll check what to do next, depending on\n    /// our current state. We may poke our peers to see if they have an alternative tip,\n    /// or we may just finish the IBD, if no one have an alternative tip.\n    async fn handle_headers(\n        \u0026mut self,\n        peer: PeerId,\n        headers: Vec\u003cHeader\u003e,\n    ) -\u003e Result\u003c(), WireError\u003e {\n        if headers.is_empty() {\n            self.empty_headers_message(peer).await?;\n            return Ok(());\n        }\n\n        info!(\n            \"Downloading headers from peer={peer} at height={} hash={}\",\n            self.chain.get_best_block()?.0 + 1,\n            headers[0].block_hash()\n        );\n\n        for header in headers.iter() {\n            if let Err(e) = self.chain.accept_header(*header) {\n                log::error!(\"Error while downloading headers from peer={peer} err={e}\");\n\n                self.send_to_peer(peer, NodeRequest::Shutdown).await?;\n\n                let peer = self.peers.get(\u0026peer).unwrap();\n                self.0.address_man.update_set_state(\n                    peer.address_id as usize,\n                    AddressState::Banned(ChainSelector::BAN_TIME),\n                );\n            }\n        }\n\n        self.request_headers(headers.last().unwrap().block_hash())\n            .await\n    }\n\n    /// Takes a serialized accumulator and parses it into a Stump\n    fn parse_acc(mut acc: Vec\u003cu8\u003e) -\u003e Result\u003cStump, WireError\u003e {\n        if acc.is_empty() {\n            return Ok(Stump::default());\n        }\n        let leaves = deserialize(acc.drain(0..8).as_slice()).unwrap_or(0);\n        let mut roots = Vec::new();\n        while !acc.is_empty() {\n            let slice = acc.drain(0..32);\n            let mut root = [0u8; 32];\n            root.copy_from_slice(\u0026slice.collect::\u003cVec\u003cu8\u003e\u003e());\n            roots.push(NodeHash::from(root));\n        }\n        Ok(Stump { leaves, roots })\n    }\n\n    /// Sends a request to two peers and wait for their response\n    ///\n    /// This function will send a `GetUtreexoState` request to two peers and wait for their\n    /// response. If both peers respond, it will return the accumulator from both peers.\n    /// If only one peer responds, it will return the accumulator from that peer and `None`\n    /// for the other. If no peer responds, it will return `None` for both.\n    /// We use this during the cut-and-choose protocol, to find where they disagree.\n    async fn grab_both_peers_version(\n        \u0026mut self,\n        peer1: PeerId,\n        peer2: PeerId,\n        block_hash: BlockHash,\n        block_height: u32,\n    ) -\u003e Result\u003c(Option\u003cVec\u003cu8\u003e\u003e, Option\u003cVec\u003cu8\u003e\u003e), WireError\u003e {\n        self.send_to_peer(\n            peer1,\n            NodeRequest::GetUtreexoState((block_hash, block_height)),\n        )\n        .await?;\n\n        self.send_to_peer(\n            peer2,\n            NodeRequest::GetUtreexoState((block_hash, block_height)),\n        )\n        .await?;\n\n        let mut peer1_version = None;\n        let mut peer2_version = None;\n        for _ in 0..2 {\n            if let Ok(Ok(NodeNotification::FromPeer(peer, PeerMessages::UtreexoState(state)))) =\n                timeout(Duration::from_secs(60), self.node_rx.recv()).await\n            {\n                if peer == peer1 {\n                    peer1_version = Some(state);\n                } else if peer == peer2 {\n                    peer2_version = Some(state);\n                }\n            }\n        }\n\n        Ok((peer1_version, peer2_version))\n    }\n\n    /// Find which peer is lying about what the accumulator state is at given\n    ///\n    /// This function will ask peers their accumulator for a given block, and check whether\n    /// they agree or not. If they don't, we cut the search in half and keep looking for the\n    /// fork point. Once we find the fork point, we ask for the block that comes after the fork\n    /// download the block and proof, update the acc they agreed on, update the stump and see\n    /// who is lying.\n    async fn find_who_is_lying(\n        \u0026mut self,\n        peer1: PeerId,\n        peer2: PeerId,\n    ) -\u003e Result\u003cOption\u003cPeerId\u003e, WireError\u003e {\n        let (mut height, mut hash) = self.chain.get_best_block()?;\n        let mut prev_height = 0;\n        let agree = false;\n        // we first norrow down the possible fork point to a couple of blocks, looking\n        // for all blocks in a linear search would be too slow\n        loop {\n            // ask both peers for the utreexo state\n            self.send_to_peer(peer1, NodeRequest::GetUtreexoState((hash, height)))\n                .await?;\n            self.send_to_peer(peer2, NodeRequest::GetUtreexoState((hash, height)))\n                .await?;\n\n            let (peer1_acc, peer2_acc) = self\n                .grab_both_peers_version(peer1, peer2, hash, height)\n                .await?;\n\n            let (peer1_acc, peer2_acc) = match (peer1_acc, peer2_acc) {\n                (Some(acc1), Some(acc2)) =\u003e (acc1, acc2),\n                (None, Some(_)) =\u003e return Ok(Some(peer2)),\n                (Some(_), None) =\u003e return Ok(Some(peer1)),\n                (None, None) =\u003e return Ok(None),\n            };\n\n            // if we have different states, we need to keep looking until we find the\n            // fork point\n            let interval = height.abs_diff(prev_height);\n            prev_height = height;\n\n            if interval \u003c 5 {\n                break;\n            }\n\n            if peer1_acc == peer2_acc {\n                // if they're equal, then the disagreement is in a newer block\n                height += interval / 2;\n            } else {\n                // if they're different, then the disagreement is in an older block\n                height -= interval / 2;\n            }\n\n            hash = self.chain.get_block_hash(height).unwrap();\n        }\n        info!(\"Fork point is arround height={height} hash={hash}\");\n        // at the end, this variable should hold the last block where they agreed\n        let mut fork = 0;\n        loop {\n            // keep asking blocks until we find the fork point\n            let (peer1_acc, peer2_acc) = self\n                .grab_both_peers_version(peer1, peer2, hash, height)\n                .await?;\n\n            // as we go, we'll approach the fork from two possible sides: we came from the side\n            // they disagree, and therefore the point of inflection is the first block they agree.\n            // on the other hand, if are agreeing, and we find they disagreeing, the last block\n            // they've agreed on is the previous one (not the current one)\n            match agree {\n                true =\u003e {\n                    // they agreed in the last block, so the fork is in the next one\n                    if peer1_acc != peer2_acc {\n                        fork = height - 1;\n                    }\n                }\n\n                false =\u003e {\n                    // they disagreed in the last block and now agree, the last block is the fork\n                    if peer1_acc == peer2_acc {\n                        fork = height;\n                    }\n                }\n            }\n\n            if fork != 0 {\n                break;\n            }\n\n            // if we still don't know where the fork is, we need to keep looking\n            if agree {\n                // if they agree on this current block, we need to look in the next one\n                height += 1;\n            } else {\n                // if they disagree on this current block, we need to look in the previous one\n                height -= 1;\n            }\n        }\n\n        // now we know where the fork is, we need to check who is lying\n        let (Some(peer1_acc), Some(peer2_acc)) = self\n            .grab_both_peers_version(peer1, peer2, hash, fork + 1)\n            .await?\n        else {\n            return Ok(None);\n        };\n\n        let (aggreed, _) = self\n            .grab_both_peers_version(peer1, peer2, hash, fork)\n            .await?;\n\n        let agreed = match aggreed {\n            Some(acc) =\u003e Self::parse_acc(acc)?,\n            None =\u003e return Ok(None),\n        };\n\n        let block = self.chain.get_block_hash(fork + 1).unwrap();\n        self.send_to_peer(peer1, NodeRequest::GetBlock((vec![block], true)))\n            .await?;\n\n        let NodeNotification::FromPeer(_, PeerMessages::Block(block)) =\n            self.node_rx.recv().await.unwrap()\n        else {\n            return Ok(None);\n        };\n\n        let acc1 = self.update_acc(agreed, block, fork + 1)?;\n        let peer1_acc = Self::parse_acc(peer1_acc)?;\n        let peer2_acc = Self::parse_acc(peer2_acc)?;\n\n        if peer1_acc != acc1 \u0026\u0026 peer2_acc != acc1 {\n            return Ok(None);\n        }\n\n        if peer1_acc != acc1 {\n            return Ok(Some(peer1));\n        }\n\n        Ok(Some(peer2))\n    }\n\n    /// Updates a Stump, with the data from a Utreexo block\n    fn update_acc(\u0026self, acc: Stump, block: UtreexoBlock, height: u32) -\u003e Result\u003cStump, WireError\u003e {\n        let (proof, del_hashes, _) = floresta_chain::proof_util::process_proof(\n            block.udata.as_ref().unwrap(),\n            \u0026block.block.txdata,\n            \u0026self.chain,\n        )?;\n\n        Ok(self\n            .chain\n            .update_acc(acc, block, height, proof, del_hashes)?)\n    }\n\n    /// Finds the accumulator for one block\n    ///\n    /// This method will find what the accumulator looks like for a block with (height, hash).\n    /// Check-out [this](https://blog.dlsouza.lol/2023/09/28/pow-fraud-proof.html) post\n    /// to learn how the cut-and-choose protocol works\n    async fn find_accumulator_for_block(\n        \u0026mut self,\n        height: u32,\n        hash: BlockHash,\n    ) -\u003e Result\u003cStump, WireError\u003e {\n        let mut candidate_accs = Vec::new();\n\n        match self.find_accumulator_for_block_step(hash, height).await {\n            Ok(FindAccResult::Found(acc)) =\u003e {\n                // everyone agrees. Just parse the accumulator and finish-up\n                let acc = Self::parse_acc(acc)?;\n                return Ok(acc);\n            }\n            Ok(FindAccResult::KeepLooking(mut accs)) =\u003e {\n                accs.sort();\n                accs.dedup();\n                candidate_accs = accs;\n            }\n            _ =\u003e {}\n        }\n\n        let mut invalid_accs = HashSet::new();\n        for peer in candidate_accs.windows(2) {\n            if invalid_accs.contains(\u0026peer[0].1) || invalid_accs.contains(\u0026peer[1].1) {\n                continue;\n            }\n            let (peer1, peer2) = (peer[0].0, peer[1].0);\n\n            if let Some(liar) = self.find_who_is_lying(peer1, peer2).await? {\n                // if we found a liar, we need to ban them\n                self.send_to_peer(liar, NodeRequest::Shutdown).await?;\n                if liar == peer1 {\n                    invalid_accs.insert(peer[0].1.clone());\n                } else {\n                    invalid_accs.insert(peer[1].1.clone());\n                }\n            }\n        }\n        //filter out the invalid accs\n        candidate_accs.retain(|acc| !invalid_accs.contains(\u0026acc.1));\n        //we should have only one candidate left\n        assert_eq!(candidate_accs.len(), 1);\n\n        Self::parse_acc(candidate_accs.pop().unwrap().1)\n    }\n\n    /// If we get an empty `haders` message, our next action depends on which state are\n    /// we in:\n    ///   - If we are downloading headers for the first time, this means we've just\n    ///     finished and should go to the next phase\n    ///   - If we are checking with our peer if they have an alternative tip, this peer\n    ///     has send all blocks they have. Once all peers have finished, we just pick the\n    ///     most PoW chain among all chains that we got\n    async fn empty_headers_message(\u0026mut self, peer: PeerId) -\u003e Result\u003c(), WireError\u003e {\n        match self.1.state {\n            ChainSelectorState::DownloadingHeaders =\u003e {\n                self.poke_peers().await?;\n                self.1.state = ChainSelectorState::LookingForForks;\n            }\n            ChainSelectorState::LookingForForks =\u003e {\n                self.1.done_peers.insert(peer);\n                for peer in self.0.peer_ids.iter() {\n                    // at least one peer haven't finished\n                    if !self.1.done_peers.contains(peer) {\n                        return Ok(());\n                    }\n                }\n\n                if let Some(assume_utreexo) = self.config.assume_utreexo.as_ref() {\n                    let acc = Stump {\n                        leaves: assume_utreexo.leaves,\n                        roots: assume_utreexo.roots.clone(),\n                    };\n                    self.chain.mark_chain_as_assumed(acc)?;\n                }\n\n                let has_peers = self\n                    .peer_by_service\n                    .contains_key(\u0026ServiceFlags::from(1 \u003c\u003c 25));\n\n                if self.config.pow_fraud_proofs \u0026\u0026 has_peers {\n                    self.check_tips().await?;\n                }\n\n                self.1.state = ChainSelectorState::Done;\n            }\n            _ =\u003e {}\n        }\n\n        Ok(())\n    }\n\n    async fn is_our_chain_invalid(\u0026mut self, other_tip: BlockHash) -\u003e Result\u003c(), WireError\u003e {\n        let fork = self.chain.get_fork_point(other_tip)?;\n        self.send_to_random_peer(\n            NodeRequest::GetBlock((vec![fork], true)),\n            ServiceFlags::UTREEXO,\n        )\n        .await?;\n\n        let block = loop {\n            let Ok(NodeNotification::FromPeer(_, PeerMessages::Block(block))) =\n                self.node_rx.recv().await\n            else {\n                continue;\n            };\n            break block;\n        };\n\n        let (proof, del_hashes, inputs) = floresta_chain::proof_util::process_proof(\n            block.udata.as_ref().unwrap(),\n            \u0026block.block.txdata,\n            \u0026self.chain,\n        )?;\n\n        let fork_height = self.chain.get_block_height(\u0026fork)?.unwrap_or(0);\n        let acc = self.find_accumulator_for_block(fork_height, fork).await?;\n        let is_valid = self\n            .chain\n            .validate_block(\u0026block.block, proof, inputs, del_hashes, acc);\n\n        if is_valid.is_err() {\n            self.chain.switch_chain(other_tip)?;\n            self.chain.invalidate_block(fork)?;\n        }\n\n        Ok(())\n    }\n\n    async fn check_tips(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        let (height, _) = self.chain.get_best_block()?;\n        let validation_index = self.chain.get_validation_index()?;\n        if (validation_index + 100) \u003c height {\n            let mut tips = self.chain.get_chain_tips()?;\n            let (height, hash) = self.chain.get_best_block()?;\n            let acc = self.find_accumulator_for_block(height, hash).await?;\n\n            // only one tip, our peers are following the same chain\n            if tips.len() == 1 {\n                info!(\n                    \"Assuming chain with {} blocks\",\n                    self.chain.get_best_block()?.0\n                );\n\n                self.1.state = ChainSelectorState::Done;\n                self.chain.mark_chain_as_assumed(acc).unwrap();\n                self.chain.toggle_ibd(false);\n            }\n            // if we have more than one tip, we need to check if our best chain has an invalid block\n            tips.remove(0); // no need to check our best one\n            for tip in tips {\n                self.is_our_chain_invalid(tip).await?;\n            }\n\n            return Ok(());\n        }\n\n        info!(\"chain close enough to tip, not asking for utreexo state\");\n        self.1.state = ChainSelectorState::Done;\n        Ok(())\n    }\n\n    /// Ask for headers, given a tip\n    ///\n    /// This function will send a `getheaders` request to our peers, assuming this\n    /// peer is following a chain with `tip` inside it. We use this in case some of\n    /// our peer is in a fork, so we can learn about all blocks in that fork and\n    /// compare the candidate chains to pick the best one.\n    async fn request_headers(\u0026mut self, tip: BlockHash) -\u003e Result\u003c(), WireError\u003e {\n        let locator = self\n            .chain\n            .get_block_locator_for_tip(tip)\n            .unwrap_or_default();\n        self.send_to_peer(self.1.sync_peer, NodeRequest::GetHeaders(locator))\n            .await?;\n\n        let peer = self.1.sync_peer;\n        self.inflight\n            .insert(InflightRequests::Headers, (peer, Instant::now()));\n\n        Ok(())\n    }\n\n    /// Checks if some request has timed-out.\n    ///\n    /// If it does, we disconnect and ban this peer\n    async fn check_for_timeout(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        let mut failed = vec![];\n\n        for (request, (peer, instant)) in self.inflight.clone() {\n            if instant.elapsed().as_secs() \u003e ChainSelector::REQUEST_TIMEOUT {\n                self.increase_banscore(peer, 2).await?;\n                failed.push(request)\n            }\n        }\n\n        for request in failed {\n            self.inflight.remove(\u0026request);\n        }\n\n        Ok(())\n    }\n\n    /// Sends a `getheaders` to all our peers\n    ///\n    /// After we download all blocks from one peer, we ask our peers if they\n    /// agree with our sync peer on what is the best chain. If they are in a fork,\n    /// we'll download that fork and compare with our own chain. We should always pick\n    /// the most PoW one.\n    async fn poke_peers(\u0026self) -\u003e Result\u003c(), WireError\u003e {\n        let locator = self.chain.get_block_locator().unwrap();\n        for peer in self.0.peer_ids.iter() {\n            let get_headers = NodeRequest::GetHeaders(locator.clone());\n            self.send_to_peer(*peer, get_headers).await?;\n        }\n\n        Ok(())\n    }\n\n    pub async fn run(\u0026mut self, stop_signal: Arc\u003cRwLock\u003cbool\u003e\u003e) -\u003e Result\u003c(), WireError\u003e {\n        self.create_connection(false).await;\n\n        info!(\"Starting ibd, selecting the best chain\");\n\n        loop {\n            while let Ok(notification) =\n                timeout(Duration::from_millis(10), self.node_rx.recv()).await\n            {\n                try_and_log!(self.handle_notification(notification).await);\n            }\n\n            periodic_job!(\n                self.maybe_open_connection().await,\n                self.last_connection,\n                TRY_NEW_CONNECTION,\n                ChainSelector\n            );\n\n            if self.1.state == ChainSelectorState::CreatingConnections {\n                // If we have enough peers, try to download headers\n                if !self.peer_ids.is_empty() {\n                    let new_sync_peer = rand::random::\u003cusize\u003e() % self.peer_ids.len();\n                    self.1.sync_peer = *self.peer_ids.get(new_sync_peer).unwrap();\n\n                    try_and_log!(self.request_headers(self.chain.get_best_block()?.1).await);\n\n                    self.1.state = ChainSelectorState::DownloadingHeaders;\n                }\n            }\n\n            // We downloaded all headers in the most-pow chain, and all our peers agree\n            // this is the most-pow chain, we're done!\n            if self.1.state == ChainSelectorState::Done {\n                break;\n            }\n\n            try_and_log!(self.check_for_timeout().await);\n\n            if *stop_signal.read().await {\n                break;\n            }\n        }\n\n        Ok(())\n    }\n\n    async fn find_accumulator_for_block_step(\n        \u0026mut self,\n        block: BlockHash,\n        height: u32,\n    ) -\u003e Result\u003cFindAccResult, WireError\u003e {\n        for peer_id in self.0.peer_ids.iter() {\n            let peer = self.peers.get(peer_id).unwrap();\n            if peer.services.has(ServiceFlags::from(1 \u003c\u003c 25)) {\n                self.send_to_peer(*peer_id, NodeRequest::GetUtreexoState((block, height)))\n                    .await?;\n                self.0.inflight.insert(\n                    InflightRequests::UtreexoState(*peer_id),\n                    (*peer_id, Instant::now()),\n                );\n            }\n        }\n\n        if self.inflight.is_empty() {\n            return Err(WireError::NoPeersAvailable);\n        }\n\n        let mut peer_accs = Vec::new();\n        loop {\n            // wait for all peers to respond or timeout after 1 minute\n            if self.inflight.is_empty() {\n                break;\n            }\n\n            if let Ok(Ok(message)) = timeout(Duration::from_secs(60), self.node_rx.recv()).await {\n                match message {\n                    NodeNotification::FromPeer(peer, message) =\u003e {\n                        if let PeerMessages::UtreexoState(state) = message {\n                            self.inflight.remove(\u0026InflightRequests::UtreexoState(peer));\n                            info!(\"got state {state:?}\");\n                            peer_accs.push((peer, state));\n                        }\n                    }\n                }\n            }\n\n            for inflight in self.inflight.clone().iter() {\n                if inflight.1 .1.elapsed().as_secs() \u003e 60 {\n                    self.inflight.remove(inflight.0);\n                }\n            }\n        }\n\n        if peer_accs.len() == 1 {\n            warn!(\"Only one peers with the UTREEXO_FILTER service flag\");\n            return Ok(FindAccResult::Found(peer_accs.pop().unwrap().1));\n        }\n\n        let mut accs = HashSet::new();\n        for (_, acc) in peer_accs.iter() {\n            accs.insert(acc);\n        }\n\n        // if all peers have the same state, we can assume it's the correct one\n        if accs.len() == 1 {\n            return Ok(FindAccResult::Found(peer_accs.pop().unwrap().1));\n        }\n\n        // if we have different states, we need to keep looking until we find the\n        // fork point\n        Ok(FindAccResult::KeepLooking(peer_accs))\n    }\n\n    async fn handle_notification(\n        \u0026mut self,\n        notification: Result\u003cNodeNotification, async_std::channel::RecvError\u003e,\n    ) -\u003e Result\u003c(), WireError\u003e {\n        match notification? {\n            NodeNotification::FromPeer(peer, message) =\u003e match message {\n                PeerMessages::Headers(headers) =\u003e {\n                    self.inflight.remove(\u0026InflightRequests::Headers);\n                    return self.handle_headers(peer, headers).await;\n                }\n\n                PeerMessages::Ready(version) =\u003e {\n                    self.handle_peer_ready(peer, \u0026version).await?;\n                }\n\n                PeerMessages::Disconnected(idx) =\u003e {\n                    if peer == self.1.sync_peer {\n                        self.1.state = ChainSelectorState::CreatingConnections;\n                    }\n                    self.handle_disconnection(peer, idx)?;\n                }\n\n                PeerMessages::Addr(addresses) =\u003e {\n                    let addresses: Vec\u003c_\u003e =\n                        addresses.iter().cloned().map(|addr| addr.into()).collect();\n                    self.address_man.push_addresses(\u0026addresses);\n                }\n\n                _ =\u003e {}\n            },\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":116,"address":[1616944],"length":1,"stats":{"Line":0},"fn_name":"get_required_services"},{"line":117,"address":[1616949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[6338480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[6338848],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[6338624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[6338928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[3543598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":558,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":592,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":601,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":607,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":612,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":613,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":614,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":619,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":623,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":627,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":647,"address":[6338992],"length":1,"stats":{"Line":0},"fn_name":null},{"line":652,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":653,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":655,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":656,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":657,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":659,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":665,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":671,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":672,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":675,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":676,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":677,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":678,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":679,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":680,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":681,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":689,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":695,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":700,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":705,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":706,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":711,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":714,"address":[6338672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":718,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":719,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":722,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":726,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":729,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":730,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":731,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":736,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":737,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":738,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":739,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":742,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":745,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":318},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","error.rs"],"content":"use floresta_chain::BlockchainError;\nuse floresta_common::impl_error_from;\nuse thiserror::Error;\n\nuse super::peer::PeerError;\nuse crate::node::NodeRequest;\n\n#[derive(Error, Debug)]\npub enum WireError {\n    #[error(\"Blockchain error\")]\n    Blockchain(BlockchainError),\n    #[error(\"Error while writing into a channel\")]\n    ChannelSend(async_std::channel::SendError\u003cNodeRequest\u003e),\n    #[error(\"Peer error\")]\n    PeerError(PeerError),\n    #[error(\"Coinbase didn't mature\")]\n    CoinbaseNotMatured,\n    #[error(\"Peer not found in our current connections\")]\n    PeerNotFound,\n    #[error(\"We don't have any peers\")]\n    NoPeersAvailable,\n    #[error(\"Our peer is misbehaving\")]\n    PeerMisbehaving,\n    #[error(\"Error while reading from a channel\")]\n    ChannelRecv(#[from] async_std::channel::RecvError),\n    #[error(\"Generic io error\")]\n    Io(std::io::Error),\n    #[error(\"We don't have any utreexo peers\")]\n    NoUtreexoPeersAvailable,\n    #[error(\"We couldn't find a peer to send the request\")]\n    NoPeerToSendRequest,\n    #[error(\"Peer timed out\")]\n    PeerTimeout,\n}\nimpl_error_from!(WireError, PeerError, PeerError);\nimpl_error_from!(WireError, BlockchainError, Blockchain);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","mempool.rs"],"content":"// SPDX-License-Identifier: MIT\n//! A simple mempool that keeps our transactions in memory. It try to rebroadcast\n//! our transactions every 1 hour.\n//! Once our transaction is included in a block, we remove it from the mempool.\nuse std::collections::HashMap;\nuse std::time::Duration;\nuse std::time::Instant;\n\nuse bitcoin::Block;\nuse bitcoin::Transaction;\nuse bitcoin::Txid;\n/// Holds the transactions that we broadcasted and are still in the mempool.\n#[derive(Debug, Default)]\npub struct Mempool(HashMap\u003cTxid, (Transaction, Instant)\u003e);\n\nimpl Mempool {\n    pub fn new() -\u003e Mempool {\n        Mempool(HashMap::new())\n    }\n    /// Find all transactions that are in the mempool and were included in the given block.\n    /// Remove them from the mempool and return them.\n    pub fn consume_block(\u0026mut self, block: \u0026Block) -\u003e Vec\u003cTransaction\u003e {\n        if self.0.is_empty() {\n            return Vec::new();\n        }\n        let mut delta = Vec::new();\n        for tx in block.txdata.iter() {\n            if self.0.contains_key(\u0026tx.txid()) {\n                delta.push(self.0.remove(\u0026tx.txid()));\n            }\n        }\n        delta.into_iter().flat_map(|tx| Some(tx?.0)).collect()\n    }\n    /// Add a transaction to the mempool.\n    pub fn accept_to_mempool(\u0026mut self, transaction: Transaction) {\n        self.0\n            .insert(transaction.txid(), (transaction, Instant::now()));\n    }\n    /// Get a transaction from the mempool.\n    pub fn get_from_mempool(\u0026self, id: \u0026Txid) -\u003e Option\u003c\u0026Transaction\u003e {\n        if let Some(tx) = self.0.get(id) {\n            return Some(\u0026tx.0);\n        }\n        None\n    }\n    /// Get all transactions that were in the mempool for more than 1 hour.\n    pub fn get_stale(\u0026mut self) -\u003e Vec\u003cTxid\u003e {\n        let mut stale = Vec::new();\n        for (txid, transaction) in self.0.iter_mut() {\n            if transaction.1.elapsed() \u003e Duration::from_secs(60 * 60) {\n                transaction.1 = Instant::now();\n                stale.push(*txid);\n            }\n        }\n        stale\n    }\n}\n","traces":[{"line":17,"address":[1547568],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[16496894],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[16497605,16496944,16497574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[16496995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[1547749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[16497013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[1548014,1547723,1547810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[16497453,16497357],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[1548160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[16497376,16497272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[1548272,1548632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[1548605,1548297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[1548375,1548313,1548617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[16498032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[16498046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[16498093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[1548754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[16498128,16498753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[1548819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[1548897,1548837,1549057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[1549099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[1549291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[1549337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[1549020],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":24},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","mod.rs"],"content":"//! Main module for the p2p chain. This is a blockchain provider, just like cli-chain, but it's\n//! backed by p2p Bitcoin's p2p network.\n\nuse std::net::SocketAddr;\n\nuse bitcoin::BlockHash;\nuse bitcoin::Network;\nuse rustreexo::accumulator::node_hash::NodeHash;\n\nuse self::address_man::LocalAddress;\n\n#[derive(Debug, Clone)]\n/// Configuration for the Utreexo node.\npub struct UtreexoNodeConfig {\n    /// The blockchain we are in, defaults to Bitcoin. Possible values are Bitcoin,\n    /// Testnet, Regtest and Signet.\n    pub network: Network,\n    /// Whether to use PoW fraud proofs. Defaults to false.\n    ///\n    /// PoW fraud proof is a mechanism to skip the verification of the whole blockchain,\n    /// but while also giving a better security than simple SPV. Check out the documentation\n    /// in `pow_fraud_proofs.md` under the `docs` folder.\n    pub pow_fraud_proofs: bool,\n    /// Whether to use compact filters. Defaults to false.\n    ///\n    /// Compact filters are useful to rescan the blockchain for a specific address, without\n    /// needing to download the whole chain. It will download ~1GB of filters, and then\n    /// download the blocks that match the filters.\n    pub compact_filters: bool,\n    /// Fixed peers to connect to. Defaults to None.\n    ///\n    /// If you want to connect to a specific peer, you can set this to a string with the\n    /// format `ip:port`. For example, `localhost:8333`.\n    pub fixed_peer: Option\u003cLocalAddress\u003e,\n    /// Maximum ban score. Defaults to 100.\n    ///\n    /// If a peer misbehaves, we increase its ban score. If the ban score reaches this value,\n    /// we disconnect from the peer.\n    pub max_banscore: u32,\n    /// Maximum number of outbound connections. Defaults to 8.\n    pub max_outbound: u32,\n    /// Maximum number of inflight requests. Defaults to 10.\n    ///\n    /// More inflight requests means more memory usage, but also more parallelism.\n    pub max_inflight: u32,\n    /// Data directory for the node. Defaults to `.floresta-node`.\n    pub datadir: String,\n    /// A SOCKS5 proxy to use. Defaults to None.\n    pub proxy: Option\u003cSocketAddr\u003e,\n    /// If enabled, the node will assume that the provided Utreexo state is valid, and will\n    /// start running from there\n    pub assume_utreexo: Option\u003cAssumeUtreexoValue\u003e,\n    /// If we assumeutreexo or pow_fraud_proof, we can skip the IBD and make our node usable\n    /// faster, with the tradeoff of security. If this is enabled, we will still download the\n    /// blocks in the background, and verify the final Utreexo state. So, the worse case scenario\n    /// is that we are vulnerable to a fraud proof attack for a few hours, but we can spot it\n    /// and react in a couple of hours at most, so the attack window is very small.\n    pub backfill: bool,\n}\n\n/// If enabled, the node will assume that the provided Utreexo state is valid, and will\n/// start running from there. You may use this to make your node start faster, but you\n/// should be sure that the provided state is valid. You may or not verify the state,\n/// by downloading all blocks on background, and then verifying the final Utreexo state.\n#[derive(Debug, Clone)]\npub struct AssumeUtreexoValue {\n    /// The latest block assumed to be valid. This acc is the roots at this block\n    pub block_hash: BlockHash,\n    /// Same as block_hash, but in height\n    pub height: u32,\n    /// The roots of the Utreexo accumulator at this block\n    pub roots: Vec\u003cNodeHash\u003e,\n    /// The number of leaves in the Utreexo accumulator at this block\n    pub leaves: u64,\n}\n\nimpl Default for UtreexoNodeConfig {\n    fn default() -\u003e Self {\n        UtreexoNodeConfig {\n            network: Network::Bitcoin,\n            pow_fraud_proofs: false,\n            compact_filters: false,\n            fixed_peer: None,\n            max_banscore: 100,\n            max_outbound: 8,\n            max_inflight: 10,\n            datadir: \".floresta-node\".to_string(),\n            proxy: None,\n            backfill: false,\n            assume_utreexo: None,\n        }\n    }\n}\n\npub mod address_man;\npub mod chain_selector;\npub mod error;\npub mod mempool;\npub mod node;\npub mod node_context;\npub mod node_interface;\npub mod peer;\npub mod running_node;\npub mod socks;\npub mod stream_reader;\npub mod sync_node;\n","traces":[{"line":78,"address":[1559898,1559568],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":87,"address":[1559599],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","node.rs"],"content":"//! Main file for this blockchain. A node is the central task that runs and handles important\n//! events, such as new blocks, peer connection/disconnection, new addresses, etc.\n//! A node should not care about peer-specific messages, peers'll handle things like pings.\nuse std::collections::HashMap;\nuse std::fmt::Debug;\nuse std::net::IpAddr;\nuse std::net::SocketAddr;\nuse std::ops::Deref;\nuse std::ops::DerefMut;\nuse std::sync::Arc;\nuse std::sync::Mutex;\nuse std::time::Duration;\nuse std::time::Instant;\nuse std::time::SystemTime;\nuse std::time::UNIX_EPOCH;\n\nuse async_std::channel::bounded;\nuse async_std::channel::Receiver;\nuse async_std::channel::Sender;\nuse async_std::channel::{self};\nuse async_std::future::timeout;\nuse async_std::net::TcpStream;\nuse async_std::sync::RwLock;\nuse async_std::task::spawn;\nuse bitcoin::p2p::address::AddrV2;\nuse bitcoin::p2p::address::AddrV2Message;\nuse bitcoin::p2p::utreexo::UtreexoBlock;\nuse bitcoin::p2p::ServiceFlags;\nuse bitcoin::BlockHash;\nuse bitcoin::Txid;\nuse floresta_chain::pruned_utreexo::chainparams::get_chain_dns_seeds;\nuse floresta_chain::pruned_utreexo::BlockchainInterface;\nuse floresta_chain::pruned_utreexo::UpdatableChainstate;\nuse floresta_chain::Network;\nuse floresta_compact_filters::kv_filter_database::KvFilterStore;\nuse floresta_compact_filters::network_filters::NetworkFilters;\nuse futures::Future;\nuse log::debug;\nuse log::info;\nuse log::warn;\n\nuse super::address_man::AddressMan;\nuse super::address_man::AddressState;\nuse super::address_man::LocalAddress;\nuse super::error::WireError;\nuse super::mempool::Mempool;\nuse super::node_context::NodeContext;\nuse super::node_interface::NodeInterface;\nuse super::node_interface::PeerInfo;\nuse super::node_interface::UserRequest;\nuse super::peer::Peer;\nuse super::peer::PeerMessages;\nuse super::peer::Version;\nuse super::running_node::RunningNode;\nuse super::socks::Socks5Addr;\nuse super::socks::Socks5Error;\nuse super::socks::Socks5StreamBuilder;\nuse super::UtreexoNodeConfig;\nuse crate::node_context::PeerId;\n\n#[derive(Debug)]\npub enum NodeNotification {\n    FromPeer(u32, PeerMessages),\n}\n\n#[derive(Debug, Clone, PartialEq, Hash)]\n/// Sent from node to peers, usually to request something\npub enum NodeRequest {\n    /// Get this block's data\n    GetBlock((Vec\u003cBlockHash\u003e, bool)),\n    /// Asks peer for headers\n    GetHeaders(Vec\u003cBlockHash\u003e),\n    /// Ask for other peers addresses\n    GetAddresses,\n    /// Asks this peer to shutdown\n    Shutdown,\n    /// Sends a transaction to peers\n    BroadcastTransaction(Txid),\n    /// Ask for an unconfirmed transaction\n    MempoolTransaction(Txid),\n    /// Sends know addresses to our peers\n    SendAddresses(Vec\u003cAddrV2Message\u003e),\n    GetUtreexoState((BlockHash, u32)),\n    GetFilter((BlockHash, u32)),\n}\n\n#[derive(Debug, Hash, PartialEq, Eq, Clone)]\npub(crate) enum InflightRequests {\n    Headers,\n    UtreexoState(PeerId),\n    Blocks(BlockHash),\n    RescanBlock(BlockHash),\n    UserRequest(UserRequest),\n    Connect(u32),\n    GetFilters,\n}\n\n#[derive(Debug, Clone)]\npub struct LocalPeerView {\n    pub(crate) state: PeerStatus,\n    pub(crate) address_id: u32,\n    pub(crate) channel: Sender\u003cNodeRequest\u003e,\n    pub(crate) services: ServiceFlags,\n    pub(crate) user_agent: String,\n    pub(crate) address: IpAddr,\n    pub(crate) port: u16,\n    pub(crate) _last_message: Instant,\n    pub(crate) feeler: bool,\n    pub(crate) height: u32,\n    pub(crate) banscore: u32,\n}\n\n#[derive(Debug, PartialEq, Clone, Copy)]\npub enum RescanStatus {\n    InProgress(u32),\n    Completed(Instant),\n    None,\n}\n\nimpl Default for RunningNode {\n    fn default() -\u003e Self {\n        RunningNode {\n            last_rescan_request: RescanStatus::None,\n            last_feeler: Instant::now(),\n            last_address_rearrange: Instant::now(),\n            user_requests: Arc::new(NodeInterface {\n                requests: Mutex::new(Vec::new()),\n            }),\n        }\n    }\n}\n\npub struct NodeCommon\u003cChain: BlockchainInterface + UpdatableChainstate\u003e {\n    pub(crate) peer_id_count: u32,\n    pub(crate) last_headers_request: Instant,\n    pub(crate) last_tip_update: Instant,\n    pub(crate) last_connection: Instant,\n    pub(crate) last_peer_db_dump: Instant,\n    pub(crate) last_broadcast: Instant,\n    pub(crate) last_send_addresses: Instant,\n    pub(crate) last_block_request: u32,\n    pub(crate) network: Network,\n    pub(crate) last_get_address_request: Instant,\n    pub(crate) peer_by_service: HashMap\u003cServiceFlags, Vec\u003cu32\u003e\u003e,\n    pub(crate) peer_ids: Vec\u003cu32\u003e,\n    pub(crate) peers: HashMap\u003cu32, LocalPeerView\u003e,\n    pub(crate) chain: Chain,\n    pub(crate) blocks: HashMap\u003cBlockHash, (PeerId, UtreexoBlock)\u003e,\n    pub(crate) inflight: HashMap\u003cInflightRequests, (u32, Instant)\u003e,\n    pub(crate) node_rx: Receiver\u003cNodeNotification\u003e,\n    pub(crate) node_tx: Sender\u003cNodeNotification\u003e,\n    pub(crate) mempool: Arc\u003cRwLock\u003cMempool\u003e\u003e,\n    pub(crate) datadir: String,\n    pub(crate) address_man: AddressMan,\n    pub(crate) max_banscore: u32,\n    pub(crate) socks5: Option\u003cSocks5StreamBuilder\u003e,\n    pub(crate) fixed_peer: Option\u003cLocalAddress\u003e,\n    pub(crate) config: UtreexoNodeConfig,\n    pub(crate) block_filters: Option\u003cArc\u003cNetworkFilters\u003cKvFilterStore\u003e\u003e\u003e,\n    pub(crate) last_filter: BlockHash,\n}\n\npub struct UtreexoNode\u003cContext, Chain: BlockchainInterface + UpdatableChainstate\u003e(\n    pub(crate) NodeCommon\u003cChain\u003e,\n    pub(crate) Context,\n);\n\nimpl\u003cChain: BlockchainInterface + UpdatableChainstate, T\u003e Deref for UtreexoNode\u003cT, Chain\u003e {\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n    type Target = NodeCommon\u003cChain\u003e;\n}\n\nimpl\u003cT, Chain: BlockchainInterface + UpdatableChainstate\u003e DerefMut for UtreexoNode\u003cT, Chain\u003e {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.0\n    }\n}\n\n#[derive(Debug, PartialEq, Clone, Copy)]\npub(crate) enum PeerStatus {\n    Awaiting,\n    Ready,\n}\n\nimpl\u003cT, Chain\u003e UtreexoNode\u003cT, Chain\u003e\nwhere\n    T: 'static + Default + NodeContext,\n    WireError: From\u003c\u003cChain as BlockchainInterface\u003e::Error\u003e,\n    Chain: BlockchainInterface + UpdatableChainstate + 'static,\n{\n    pub fn new(\n        config: UtreexoNodeConfig,\n        chain: Chain,\n        mempool: Arc\u003cRwLock\u003cMempool\u003e\u003e,\n        block_filters: Option\u003cArc\u003cNetworkFilters\u003cKvFilterStore\u003e\u003e\u003e,\n    ) -\u003e Self {\n        let (node_tx, node_rx) = channel::unbounded();\n        let socks5 = config.proxy.map(Socks5StreamBuilder::new);\n        UtreexoNode(\n            NodeCommon {\n                last_filter: chain.get_block_hash(0).unwrap(),\n                block_filters,\n                inflight: HashMap::new(),\n                peer_id_count: 0,\n                peers: HashMap::new(),\n                last_block_request: chain.get_validation_index().expect(\"Invalid chain\"),\n                chain,\n                peer_ids: Vec::new(),\n                peer_by_service: HashMap::new(),\n                mempool,\n                network: config.network.into(),\n                node_rx,\n                node_tx,\n                address_man: AddressMan::default(),\n                last_headers_request: Instant::now(),\n                last_tip_update: Instant::now(),\n                last_connection: Instant::now(),\n                last_peer_db_dump: Instant::now(),\n                last_broadcast: Instant::now(),\n                blocks: HashMap::new(),\n                last_get_address_request: Instant::now(),\n                last_send_addresses: Instant::now(),\n                datadir: config.datadir.clone(),\n                socks5,\n                max_banscore: config.max_banscore,\n                fixed_peer: config.fixed_peer.clone(),\n                config,\n            },\n            T::default(),\n        )\n    }\n\n    pub(crate) fn get_peer_info(\u0026self, peer: \u0026u32) -\u003e Option\u003cPeerInfo\u003e {\n        let peer = self.peers.get(peer)?;\n        Some(PeerInfo {\n            address: format!(\"{}:{}\", peer.address, peer.port),\n            services: peer.services.to_string(),\n            user_agent: peer.user_agent.clone(),\n            initial_height: peer.height,\n        })\n    }\n    pub(crate) fn handle_disconnection(\u0026mut self, peer: u32, idx: usize) -\u003e Result\u003c(), WireError\u003e {\n        if let Some(p) = self.peers.remove(\u0026peer) {\n            p.channel.close();\n            if !p.feeler \u0026\u0026 p.state == PeerStatus::Ready {\n                info!(\"Peer disconnected: {}\", peer);\n            }\n        }\n\n        self.peer_ids.retain(|\u0026id| id != peer);\n        for (_, v) in self.peer_by_service.iter_mut() {\n            v.retain(|\u0026id| id != peer);\n        }\n\n        self.address_man.update_set_state(\n            idx,\n            AddressState::Tried(\n                SystemTime::now()\n                    .duration_since(UNIX_EPOCH)\n                    .unwrap()\n                    .as_secs(),\n            ),\n        );\n        Ok(())\n    }\n    pub(crate) async fn handle_peer_ready(\n        \u0026mut self,\n        peer: u32,\n        version: \u0026Version,\n    ) -\u003e Result\u003c(), WireError\u003e {\n        if version.feeler {\n            self.send_to_peer(peer, NodeRequest::Shutdown).await?;\n            self.address_man.update_set_state(\n                version.address_id,\n                AddressState::Tried(\n                    SystemTime::now()\n                        .duration_since(UNIX_EPOCH)\n                        .unwrap()\n                        .as_secs(),\n                ),\n            );\n            self.address_man\n                .update_set_service_flag(version.address_id, version.services);\n            return Ok(());\n        }\n        info!(\n            \"New peer id={} version={} blocks={} services={}\",\n            version.id, version.user_agent, version.blocks, version.services\n        );\n        self.inflight.remove(\u0026InflightRequests::Connect(peer));\n\n        if let Some(peer_data) = self.0.peers.get_mut(\u0026peer) {\n            // This peer doesn't have basic services, so we disconnect it\n            if !version\n                .services\n                .has(ServiceFlags::NETWORK | ServiceFlags::WITNESS)\n            {\n                self.send_to_peer(peer, NodeRequest::Shutdown).await?;\n                self.peers.remove(\u0026peer);\n                return Ok(());\n            }\n            peer_data.state = PeerStatus::Ready;\n            peer_data.services = version.services;\n            peer_data.user_agent.clone_from(\u0026version.user_agent);\n            peer_data.height = version.blocks;\n\n            if peer_data.services.has(ServiceFlags::UTREEXO) {\n                self.0\n                    .peer_by_service\n                    .entry(ServiceFlags::UTREEXO)\n                    .or_default()\n                    .push(peer);\n            }\n\n            if peer_data.services.has(ServiceFlags::COMPACT_FILTERS) {\n                self.0\n                    .peer_by_service\n                    .entry(ServiceFlags::COMPACT_FILTERS)\n                    .or_default()\n                    .push(peer);\n            }\n\n            if peer_data.services.has(ServiceFlags::from(1 \u003c\u003c 25)) {\n                self.0\n                    .peer_by_service\n                    .entry(ServiceFlags::from(1 \u003c\u003c 25))\n                    .or_default()\n                    .push(peer);\n            }\n\n            self.address_man\n                .update_set_state(version.address_id, AddressState::Connected)\n                .update_set_service_flag(version.address_id, version.services);\n\n            self.peer_ids.push(peer);\n        }\n        Ok(())\n    }\n\n    pub(crate) fn get_default_port(\u0026self) -\u003e u16 {\n        match self.network {\n            Network::Bitcoin =\u003e 8333,\n            Network::Testnet =\u003e 18333,\n            Network::Signet =\u003e 38333,\n            Network::Regtest =\u003e 18444,\n        }\n    }\n\n    pub(crate) async fn send_to_peer(\n        \u0026self,\n        peer_id: u32,\n        req: NodeRequest,\n    ) -\u003e Result\u003c(), WireError\u003e {\n        if let Some(peer) = \u0026self.peers.get(\u0026peer_id) {\n            if peer.state == PeerStatus::Ready {\n                peer.channel\n                    .send(req)\n                    .await\n                    .map_err(WireError::ChannelSend)?;\n            }\n        }\n        Ok(())\n    }\n\n    /// Increses the \"banscore\" of a peer.\n    ///\n    /// This is a always increasing number that, if reaches our `max_banscore` setting,\n    /// will cause our peer to be banned for one BANTIME.\n    /// The amount of each increment is given by factor, and it's callibrated for each misbehaving\n    /// action that a peer may incur in.\n    pub(crate) async fn increase_banscore(\n        \u0026mut self,\n        peer_id: u32,\n        factor: u32,\n    ) -\u003e Result\u003c(), WireError\u003e {\n        let Some(peer) = self.0.peers.get_mut(\u0026peer_id) else {\n            return Ok(());\n        };\n        peer.banscore += factor;\n        // This peer is misbehaving too often, ban it\n        if peer.banscore \u003e= self.0.max_banscore {\n            warn!(\"banning peer {} for misbehaving\", peer_id);\n            let _ = peer.channel.send(NodeRequest::Shutdown).await;\n            self.0.address_man.update_set_state(\n                peer.address_id as usize,\n                AddressState::Banned(RunningNode::BAN_TIME),\n            );\n\n            // remove all inflight requests for that peer\n            let peer_req = self\n                .inflight\n                .keys()\n                .filter(|k| self.inflight.get(k).unwrap().0 == peer_id)\n                .cloned()\n                .collect::\u003cVec\u003c_\u003e\u003e();\n            for peer in peer_req {\n                self.inflight.remove_entry(\u0026peer);\n            }\n        }\n\n        Ok(())\n    }\n\n    pub(crate) fn has_utreexo_peers(\u0026self) -\u003e bool {\n        self.peer_by_service\n            .get(\u0026ServiceFlags::UTREEXO)\n            .unwrap_or(\u0026Vec::new())\n            .is_empty()\n    }\n\n    pub(crate) fn has_compact_filters_peer(\u0026self) -\u003e bool {\n        self.peer_by_service\n            .get(\u0026ServiceFlags::COMPACT_FILTERS)\n            .map(|peers| peers.is_empty())\n            .unwrap_or(false)\n    }\n\n    #[inline]\n    pub(crate) async fn send_to_random_peer(\n        \u0026mut self,\n        req: NodeRequest,\n        required_service: ServiceFlags,\n    ) -\u003e Result\u003cu32, WireError\u003e {\n        if self.peers.is_empty() {\n            return Err(WireError::NoPeersAvailable);\n        }\n\n        let Some(peers) = self.peer_by_service.get(\u0026required_service) else {\n            return Err(WireError::NoPeersAvailable);\n        };\n\n        if peers.is_empty() {\n            return Err(WireError::NoPeersAvailable);\n        }\n\n        let rand = rand::random::\u003cusize\u003e() % peers.len();\n        let peer = peers[rand];\n        self.peers\n            .get(\u0026peer)\n            .unwrap()\n            .channel\n            .send(req)\n            .await\n            .map_err(WireError::ChannelSend)?;\n\n        Ok(peer)\n    }\n\n    pub(crate) async fn init_peers(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        let anchors = self\n            .0\n            .address_man\n            .start_addr_man(\n                self.datadir.clone(),\n                self.get_default_port(),\n                self.network,\n                \u0026get_chain_dns_seeds(self.network),\n            )\n            .map_err(WireError::Io)?;\n        for address in anchors {\n            self.open_connection(false, address.id, address).await;\n        }\n        Ok(())\n    }\n\n    pub(crate) async fn shutdown(\u0026mut self) {\n        info!(\"Shutting down node\");\n        for peer in self.peer_ids.iter() {\n            try_and_log!(self.send_to_peer(*peer, NodeRequest::Shutdown).await);\n        }\n        try_and_log!(self.save_peers());\n        try_and_log!(self.chain.flush());\n    }\n\n    pub(crate) async fn handle_broadcast(\u0026self) -\u003e Result\u003c(), WireError\u003e {\n        for (_, peer) in self.peers.iter() {\n            if peer.services.has(ServiceFlags::from(1 \u003c\u003c 24)) {\n                continue;\n            }\n\n            let transactions = self.chain.get_unbroadcasted();\n\n            for transaction in transactions {\n                let txid = transaction.txid();\n                self.mempool.write().await.accept_to_mempool(transaction);\n                peer.channel\n                    .send(NodeRequest::BroadcastTransaction(txid))\n                    .await\n                    .map_err(WireError::ChannelSend)?;\n            }\n            let stale = self.mempool.write().await.get_stale();\n            for tx in stale {\n                peer.channel\n                    .send(NodeRequest::BroadcastTransaction(tx))\n                    .await\n                    .map_err(WireError::ChannelSend)?;\n            }\n        }\n        Ok(())\n    }\n\n    pub(crate) async fn ask_for_addresses(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        let _ = self\n            .send_to_random_peer(NodeRequest::GetAddresses, ServiceFlags::NONE)\n            .await?;\n        Ok(())\n    }\n\n    pub(crate) fn save_peers(\u0026self) -\u003e Result\u003c(), WireError\u003e {\n        self.address_man\n            .dump_peers(\u0026self.datadir)\n            .map_err(WireError::Io)\n    }\n\n    pub(crate) async fn maybe_open_connection(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        // If the user passes in a `--connect` cli argument, we only connect with\n        // that particular peer.\n        if self.fixed_peer.is_some() \u0026\u0026 !self.peers.is_empty() {\n            return Ok(());\n        }\n        if self.peers.len() \u003c T::MAX_OUTGOING_PEERS {\n            self.create_connection(false).await;\n        }\n        Ok(())\n    }\n\n    pub(crate) async fn open_feeler_connection(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        // No feeler if `-connect` is set\n        if self.fixed_peer.is_some() {\n            return Ok(());\n        }\n        self.create_connection(true).await;\n        Ok(())\n    }\n\n    pub(crate) async fn request_blocks(\u0026mut self, blocks: Vec\u003cBlockHash\u003e) -\u003e Result\u003c(), WireError\u003e {\n        let blocks: Vec\u003c_\u003e = blocks\n            .into_iter()\n            .filter(|block| {\n                !self\n                    .inflight\n                    .contains_key(\u0026InflightRequests::Blocks(*block))\n            })\n            .collect();\n\n        let peer = self\n            .send_to_random_peer(\n                NodeRequest::GetBlock((blocks.clone(), true)),\n                ServiceFlags::UTREEXO,\n            )\n            .await?;\n\n        for block in blocks.iter() {\n            self.inflight\n                .insert(InflightRequests::Blocks(*block), (peer, Instant::now()));\n        }\n\n        Ok(())\n    }\n\n    pub(crate) async fn create_connection(\u0026mut self, feeler: bool) -\u003e Option\u003c()\u003e {\n        // We should try to keep at least two utreexo connections\n        let required_services = self.1.get_required_services();\n\n        let (peer_id, address) = match \u0026self.fixed_peer {\n            Some(address) =\u003e (0, address.clone()),\n            None =\u003e self\n                .address_man\n                .get_address_to_connect(required_services, feeler)?,\n        };\n\n        self.address_man\n            .update_set_state(peer_id, AddressState::Connected);\n        debug!(\"attempting connection with: {}\", address.get_net_address());\n        // Don't connect to the same peer twice\n        if self\n            .0\n            .peers\n            .iter()\n            .any(|peers| peers.1.address == address.get_net_address())\n        {\n            return None;\n        }\n\n        self.open_connection(feeler, peer_id, address).await;\n        Some(())\n    }\n\n    /// Opens a new connection that doesn't require a proxy.\n    #[allow(clippy::too_many_arguments)]\n    pub(crate) fn open_non_proxy_connection(\n        feeler: bool,\n        peer_id: usize,\n        address: LocalAddress,\n        requests_rx: Receiver\u003cNodeRequest\u003e,\n        peer_id_count: u32,\n        mempool: Arc\u003cRwLock\u003cMempool\u003e\u003e,\n        network: bitcoin::Network,\n        node_tx: Sender\u003cNodeNotification\u003e,\n    ) -\u003e impl Future\u003cOutput = ()\u003e + Send + 'static {\n        Peer::\u003cTcpStream\u003e::create_outbound_connection(\n            peer_id_count,\n            (address.get_net_address(), address.get_port()),\n            mempool,\n            network,\n            node_tx,\n            requests_rx,\n            peer_id,\n            feeler,\n        )\n    }\n    /// Opens a connection through a socks5 interface\n    #[allow(clippy::too_many_arguments)]\n    pub(crate) async fn open_proxy_connection(\n        proxy: SocketAddr,\n        feeler: bool,\n        mempool: Arc\u003cRwLock\u003cMempool\u003e\u003e,\n        network: bitcoin::Network,\n        node_tx: Sender\u003cNodeNotification\u003e,\n        peer_id: usize,\n        address: LocalAddress,\n        requests_rx: Receiver\u003cNodeRequest\u003e,\n        peer_id_count: u32,\n    ) -\u003e Result\u003c(), Socks5Error\u003e {\n        let addr = match address.get_address() {\n            AddrV2::Cjdns(addr) =\u003e Socks5Addr::Ipv6(addr),\n            AddrV2::I2p(addr) =\u003e Socks5Addr::Domain(addr.into()),\n            AddrV2::Ipv4(addr) =\u003e Socks5Addr::Ipv4(addr),\n            AddrV2::Ipv6(addr) =\u003e Socks5Addr::Ipv6(addr),\n            AddrV2::TorV2(addr) =\u003e Socks5Addr::Domain(addr.into()),\n            AddrV2::TorV3(addr) =\u003e Socks5Addr::Domain(addr.into()),\n            AddrV2::Unknown(_, _) =\u003e {\n                return Err(Socks5Error::InvalidAddress);\n            }\n        };\n\n        let proxy = TcpStream::connect(proxy).await?;\n        let stream = Socks5StreamBuilder::connect(proxy, addr, address.get_port()).await?;\n        Peer::create_peer_from_transport(\n            stream,\n            peer_id_count,\n            mempool,\n            network,\n            node_tx,\n            requests_rx,\n            peer_id,\n            feeler,\n        );\n        Ok(())\n    }\n\n    /// Creates a new outgoing connection with `address`. Connection may or may not be feeler,\n    /// a special connection type that is used to learn about good peers, but are not kept afer\n    /// handshake.\n    pub(crate) async fn open_connection(\n        \u0026mut self,\n        feeler: bool,\n        peer_id: usize,\n        address: LocalAddress,\n    ) {\n        let (requests_tx, requests_rx) = bounded(1024);\n        if let Some(ref proxy) = self.socks5 {\n            spawn(timeout(\n                Duration::from_secs(10),\n                Self::open_proxy_connection(\n                    proxy.address,\n                    feeler,\n                    self.mempool.clone(),\n                    self.network.into(),\n                    self.node_tx.clone(),\n                    peer_id,\n                    address.clone(),\n                    requests_rx,\n                    self.peer_id_count,\n                ),\n            ));\n        } else {\n            spawn(Self::open_non_proxy_connection(\n                feeler,\n                peer_id,\n                address.clone(),\n                requests_rx,\n                self.peer_id_count,\n                self.mempool.clone(),\n                self.network.into(),\n                self.node_tx.clone(),\n            ));\n        }\n\n        let peer_count: u32 = self.peer_id_count;\n\n        self.inflight.insert(\n            InflightRequests::Connect(peer_count),\n            (peer_count, Instant::now()),\n        );\n\n        self.peers.insert(\n            peer_count,\n            LocalPeerView {\n                address: address.get_net_address(),\n                port: address.get_port(),\n                user_agent: \"\".to_string(),\n                state: PeerStatus::Awaiting,\n                channel: requests_tx,\n                services: ServiceFlags::NONE,\n                _last_message: Instant::now(),\n                feeler,\n                address_id: peer_id as u32,\n                height: 0,\n                banscore: 0,\n            },\n        );\n\n        self.peer_id_count += 1;\n    }\n}\n\n/// Run a task and log any errors that might occur.\nmacro_rules! try_and_log {\n    ($what:expr) =\u003e {\n        let result = $what;\n\n        if let Err(error) = result {\n            log::error!(\"{}:{} - {:?}\", line!(), file!(), error);\n        }\n    };\n}\nmacro_rules! periodic_job {\n    ($what:expr, $timer:expr, $interval:ident, $context:ty) =\u003e {\n        if $timer.elapsed() \u003e Duration::from_secs(\u003c$context\u003e::$interval) {\n            try_and_log!($what);\n            $timer = Instant::now();\n        }\n    };\n    ($what:expr, $timer:expr, $interval:ident, $context:ty, $no_log:literal) =\u003e {\n        if $timer.elapsed() \u003e Duration::from_secs(\u003c$context\u003e::$interval) {\n            $what;\n            $timer = Instant::now();\n        }\n    };\n}\npub(crate) use periodic_job;\npub(crate) use try_and_log;\n","traces":[{"line":121,"address":[1526096],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":124,"address":[1526121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[1526135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[1526181],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[6441456,6444125,6444336,6447198,6444301,6447018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[6382032,6382064,6381968,6382000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[6342368,6342528,6342288,6342448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[6397936,6397968,6397904,6398000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[6405840,6406032,6406128,6405936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":582,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[6440928,6441441,6440400,6439872,6439344,6440847,6440385,6440913,6441375,6439791,6439857,6440319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":607,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[6421456,6421936,6421696,6422176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":627,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":628,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":631,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":632,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":635,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":643,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":645,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":647,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":651,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":657,"address":[6353632,6353728,6353920,6353824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":665,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":670,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":671,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":672,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":673,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":674,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":675,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":676,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":680,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":681,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":682,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":683,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":684,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":685,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":695,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":700,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":705,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":706,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":707,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":709,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":710,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":711,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":712,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":716,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":327},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","node_context.rs"],"content":"//! During the lifetime of a Bitcoin client, we have a couple of phases that are slightly different\n//! from each other, having to implement their own state-machines and logic for handing requests.\n//! While we could simply put everything in one struct and have a single `impl` block, that would\n//! create a massive amount of if's in the code, taking different paths depending on which state\n//! are we in. For that reason, we define the basics of a node, like code shared by all the\n//! states into one base struct called `UtreexoNode`, we then further refine this struct using\n//! fine-tunned `Contexts`, that should implement [NodeContext] and are passed-in as a generic\n//! parameter by the caller.\n//!\n//! The three flavors of node are:\n//!  - ChainSelector: This finds the best PoW chain, by downloding multiple candidates and taking\n//!                   the one with more PoW. It should do it's job quickly, as it blocks our main\n//!                   client and can't proceed without this information.\n//!  - SyncNode: Used to download and verify all blocks in a chain. This is computationally\n//!              expensive and may take a while to run. After this ends it's job, it gives us 100%\n//!              centanty that this chain is valid.\n//!  - Running Node: This is the one that users interacts with, and should be the one running most\n//!                  of the time. This node is started right after `ChainSelector` returns, and\n//!                  will handle new blocks (even if `SyncNode` haven't returned) and handle\n//!                  requests by users.\n\nuse bitcoin::p2p::ServiceFlags;\n\n/// This trait mainly defines a bunch of constants that we need for the node, but we may tweak\n/// those values for each one. It's also an organized way of defining those constants anyway.\npub trait NodeContext {\n    const REQUEST_TIMEOUT: u64;\n    /// Max number of simultaneous connections we initiates we are willing to hold\n    const MAX_OUTGOING_PEERS: usize = 10;\n    /// We ask for peers every ASK_FOR_PEERS_INTERVAL seconds\n    const ASK_FOR_PEERS_INTERVAL: u64 = 60 * 60; // One hour\n    /// Save our database of peers every PEER_DB_DUMP_INTERVAL seconds\n    const PEER_DB_DUMP_INTERVAL: u64 = 60 * 5; // 5 minutes\n    /// Attempt to open a new connection (if needed) every TRY_NEW_CONNECTION seconds\n    const TRY_NEW_CONNECTION: u64 = 10; // 10 seconds\n    /// If ASSUME_STALE seconds passed since our last tip update, treat it as stale\n    const ASSUME_STALE: u64 = 15 * 60; // 15 minutes\n    /// While on IBD, if we've been without blocks for this long, ask for headers again\n    const IBD_REQUEST_BLOCKS_AGAIN: u64 = 30; // 30 seconds\n    /// How often we broadcast transactions\n    const BROADCAST_DELAY: u64 = 30; // 30 seconds\n    /// Max number of simultaneous inflight requests we allow\n    const MAX_INFLIGHT_REQUESTS: usize = 1_000;\n    /// Interval at which we open new feeler connections\n    const FEELER_INTERVAL: u64 = 60 * 5; // 5 minutes\n    /// Interval at which we rearrange our addresses\n    const ADDRESS_REARRANGE_INTERVAL: u64 = 60 * 60; // 1 hour\n    /// How long we ban a peer for\n    const BAN_TIME: u64 = 60 * 60 * 24;\n    /// How often we check if we haven't missed a block\n    const BLOCK_CHECK_INTERVAL: u64 = 60 * 5; // 5 minutes\n    /// How often we send our addresses to our peers\n    const SEND_ADDRESSES_INTERVAL: u64 = 60 * 60; // 1 hour\n    fn get_required_services(\u0026self) -\u003e ServiceFlags {\n        ServiceFlags::NETWORK\n    }\n}\n\npub(crate) type PeerId = u32;\n","traces":[{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","node_interface.rs"],"content":"use std::net::IpAddr;\nuse std::sync::Mutex;\nuse std::time::Instant;\n\nuse bitcoin::p2p::utreexo::UtreexoBlock;\nuse bitcoin::Block;\nuse bitcoin::BlockHash;\nuse bitcoin::Transaction;\nuse bitcoin::Txid;\nuse serde::Deserialize;\nuse serde::Serialize;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum UserRequest {\n    Block(BlockHash),\n    UtreexoBlock(BlockHash),\n    MempoolTransaction(Txid),\n    GetPeerInfo,\n    Connect((IpAddr, u16)),\n}\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PeerInfo {\n    pub address: String,\n    pub services: String,\n    pub user_agent: String,\n    pub initial_height: u32,\n}\n\n#[derive(Debug, Clone)]\npub enum NodeResponse {\n    Block(Block),\n    UtreexoBlock(UtreexoBlock),\n    MempoolTransaction(Transaction),\n    GetPeerInfo(Vec\u003cPeerInfo\u003e),\n    Connect(bool),\n}\n\npub trait NodeMethods {\n    fn get_block(\u0026self, block: BlockHash) -\u003e Result\u003cOption\u003cBlock\u003e, oneshot::RecvError\u003e;\n    fn get_utreexo_block(\n        \u0026self,\n        block: BlockHash,\n    ) -\u003e Result\u003cOption\u003cUtreexoBlock\u003e, oneshot::RecvError\u003e;\n    fn get_mempool_transaction(\n        \u0026self,\n        txid: Txid,\n    ) -\u003e Result\u003cOption\u003cTransaction\u003e, oneshot::RecvError\u003e;\n    fn get_peer_info(\u0026self) -\u003e Result\u003cVec\u003cPeerInfo\u003e, oneshot::RecvError\u003e;\n    fn connect(\u0026self, addr: IpAddr, port: u16) -\u003e Result\u003cbool, oneshot::RecvError\u003e;\n}\n#[derive(Debug)]\npub struct NodeInterface {\n    pub(super) requests: Mutex\u003cVec\u003cRequestData\u003e\u003e,\n}\n#[derive(Debug)]\npub struct RequestData {\n    pub time: Instant,\n    pub resolve: oneshot::Sender\u003cOption\u003cNodeResponse\u003e\u003e,\n    pub req: UserRequest,\n}\nimpl NodeInterface {\n    pub fn send_answer(\u0026self, request: UserRequest, answer: Option\u003cNodeResponse\u003e) {\n        let mut requests = self.requests.lock().unwrap();\n        let req = requests.iter().position(|x| x.req == request);\n        if let Some(req) = req {\n            let req = requests.remove(req);\n            req.resolve.send(answer).unwrap();\n        }\n    }\n}\nimpl NodeMethods for NodeInterface {\n    fn connect(\u0026self, addr: IpAddr, port: u16) -\u003e Result\u003cbool, oneshot::RecvError\u003e {\n        let (tx, rx) = oneshot::channel();\n        self.requests.lock().unwrap().push(RequestData {\n            time: Instant::now(),\n            resolve: tx,\n            req: UserRequest::Connect((addr, port)),\n        });\n        let connected = rx.recv()?;\n        Ok(match connected {\n            Some(NodeResponse::Connect(connected)) =\u003e connected,\n            _ =\u003e unreachable!(),\n        })\n    }\n    fn get_block(\u0026self, block: BlockHash) -\u003e Result\u003cOption\u003cBlock\u003e, oneshot::RecvError\u003e {\n        let (tx, rx) = oneshot::channel();\n        self.requests.lock().unwrap().push(RequestData {\n            time: Instant::now(),\n            resolve: tx,\n            req: UserRequest::Block(block),\n        });\n        let blk = rx.recv()?;\n        Ok(match blk {\n            Some(NodeResponse::Block(blk)) =\u003e Some(blk),\n            None =\u003e None,\n            _ =\u003e unreachable!(),\n        })\n    }\n\n    fn get_utreexo_block(\n        \u0026self,\n        block: BlockHash,\n    ) -\u003e Result\u003cOption\u003cUtreexoBlock\u003e, oneshot::RecvError\u003e {\n        let (tx, rx) = oneshot::channel();\n        self.requests.lock().unwrap().push(RequestData {\n            time: Instant::now(),\n            resolve: tx,\n            req: UserRequest::UtreexoBlock(block),\n        });\n        let blk = rx.recv()?;\n        Ok(match blk {\n            Some(NodeResponse::UtreexoBlock(blk)) =\u003e Some(blk),\n            None =\u003e None,\n            _ =\u003e unreachable!(),\n        })\n    }\n\n    fn get_mempool_transaction(\n        \u0026self,\n        txid: Txid,\n    ) -\u003e Result\u003cOption\u003cTransaction\u003e, oneshot::RecvError\u003e {\n        let (tx, rx) = oneshot::channel();\n        self.requests.lock().unwrap().push(RequestData {\n            time: Instant::now(),\n            resolve: tx,\n            req: UserRequest::MempoolTransaction(txid),\n        });\n        let tx = rx.recv()?;\n        Ok(match tx {\n            Some(NodeResponse::MempoolTransaction(tx)) =\u003e Some(tx),\n            None =\u003e None,\n            _ =\u003e unreachable!(),\n        })\n    }\n\n    fn get_peer_info(\u0026self) -\u003e Result\u003cVec\u003cPeerInfo\u003e, oneshot::RecvError\u003e {\n        let (tx, rx) = oneshot::channel();\n        self.requests.lock().unwrap().push(RequestData {\n            time: Instant::now(),\n            resolve: tx,\n            req: UserRequest::GetPeerInfo,\n        });\n        let peer_info = rx.recv()?;\n        Ok(match peer_info {\n            Some(NodeResponse::GetPeerInfo(peer_info)) =\u003e peer_info,\n            None =\u003e Vec::new(),\n            _ =\u003e unreachable!(),\n        })\n    }\n}\n","traces":[{"line":62,"address":[1532352,1532946],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[1532383,1532455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[1532575,1532518],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[1532717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[1532797,1532757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[1532824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[1533783,1533844,1532992],"length":1,"stats":{"Line":0},"fn_name":"connect"},{"line":73,"address":[1533033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[1533090,1533362,1533138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[1533235],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[1533279],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[1533292],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[1533460,1533615,1533017,1533798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[1533588,1533694,1533636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[1533680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[1533650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[1534802,1533872,1534863],"length":1,"stats":{"Line":0},"fn_name":"get_block"},{"line":86,"address":[1533907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[1534020,1533972,1534200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[1534117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[1534156],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[1534169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[1534298,1534466,1533899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[1534497,1534434],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[1534579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[1534483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[1534637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[1534896,1535887,1535826],"length":1,"stats":{"Line":0},"fn_name":"get_utreexo_block"},{"line":104,"address":[1534931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[1535224,1535044,1534996],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[1535141],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[1535180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[1535193],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[1534923,1535322,1535490],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[1535521,1535458],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[1535603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[1535507],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[1535661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[1536894,1536833,1535920],"length":1,"stats":{"Line":0},"fn_name":"get_mempool_transaction"},{"line":122,"address":[1535955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[1536248,1536020,1536068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[1536165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[1536204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[1536217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[1536514,1535947,1536346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[1536482,1536544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[1536610],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[1536531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[1536668],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[1536928,1538082,1538010],"length":1,"stats":{"Line":0},"fn_name":"get_peer_info"},{"line":137,"address":[1536958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[1537031,1537231,1537079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[1537176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[1537210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[1537223],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[1536950,1537329,1537505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[1537623,1537473,1537537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[1537692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[1537530,1537616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[1537801],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":60},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","peer.rs"],"content":"use std::fmt::Debug;\nuse std::sync::Arc;\nuse std::time::Duration;\nuse std::time::Instant;\n\nuse async_std::channel::unbounded;\nuse async_std::channel::Receiver;\nuse async_std::channel::Sender;\nuse async_std::io::BufReader;\nuse async_std::net::TcpStream;\nuse async_std::net::ToSocketAddrs;\nuse async_std::sync::RwLock;\nuse async_std::task::spawn;\nuse bitcoin::bip158;\nuse bitcoin::block::Header as BlockHeader;\nuse bitcoin::consensus::serialize;\nuse bitcoin::hashes::Hash;\nuse bitcoin::p2p::address::AddrV2Message;\nuse bitcoin::p2p::message::NetworkMessage;\nuse bitcoin::p2p::message::RawNetworkMessage;\nuse bitcoin::p2p::message_blockdata::Inventory;\nuse bitcoin::p2p::message_network::VersionMessage;\nuse bitcoin::p2p::utreexo::UtreexoBlock;\nuse bitcoin::p2p::ServiceFlags;\nuse bitcoin::BlockHash;\nuse bitcoin::Network;\nuse bitcoin::Transaction;\nuse futures::AsyncRead;\nuse futures::AsyncWrite;\nuse futures::AsyncWriteExt;\nuse futures::FutureExt;\nuse log::error;\nuse log::warn;\nuse thiserror::Error;\n\nuse self::peer_utils::make_pong;\nuse super::mempool::Mempool;\nuse super::node::NodeNotification;\nuse super::node::NodeRequest;\nuse super::stream_reader::StreamReader;\n\n/// If we send a ping, and our peer takes more than PING_TIMEOUT to\n/// reply, disconnect.\nconst PING_TIMEOUT: u64 = 30;\n/// If the last message we've got was more than XX, send out a ping\nconst SEND_PING_TIMEOUT: u64 = 60;\n\n#[derive(Debug, PartialEq)]\nenum State {\n    None,\n    SentVersion(Instant),\n    SentVerack,\n    Connected,\n}\n/// A trait defining how the transport we use should behave. Transport is anything\n/// that allows to read/write from/into. Like a TcpStream or a Socks5 proxy\npub trait Transport:\n    AsyncRead + AsyncWrite + Unpin + Clone + Sync + Send + AsyncWriteExt + 'static\n{\n    /// Asks the stream to shutdown, the final part of the disconnection process\n    fn shutdown(\u0026mut self) -\u003e Result\u003c()\u003e;\n}\n\nimpl Transport for TcpStream {\n    fn shutdown(\u0026mut self) -\u003e Result\u003c()\u003e {\n        Ok(TcpStream::shutdown(self, std::net::Shutdown::Both)?)\n    }\n}\n\npub struct Peer\u003cT: Transport\u003e {\n    stream: T,\n    mempool: Arc\u003cRwLock\u003cMempool\u003e\u003e,\n    network: Network,\n    blocks_only: bool,\n    services: ServiceFlags,\n    user_agent: String,\n    messages: u64,\n    start_time: Instant,\n    last_message: Instant,\n    current_best_block: i32,\n    last_ping: Option\u003cInstant\u003e,\n    id: u32,\n    node_tx: Sender\u003cNodeNotification\u003e,\n    state: State,\n    send_headers: bool,\n    node_requests: Receiver\u003cNodeRequest\u003e,\n    address_id: usize,\n    feeler: bool,\n    wants_addrv2: bool,\n    shutdown: bool,\n}\n#[derive(Debug, Error)]\npub enum PeerError {\n    #[error(\"Error while sending to peer\")]\n    Send,\n    #[error(\"Error while reading from peer\")]\n    Read(#[from] std::io::Error),\n    #[error(\"Error while parsing message\")]\n    Parse(#[from] bitcoin::consensus::encode::Error),\n    #[error(\"Peer sent us a message that we aren't expecting\")]\n    UnexpectedMessage,\n    #[error(\"Peer sent us a message that is too big\")]\n    MessageTooBig,\n    #[error(\"Peer sent us a message with the wrong magic bits\")]\n    MagicBitsMismatch,\n    #[error(\"Peer sent us too many message in a short period of time\")]\n    TooManyMessages,\n    #[error(\"Peer timed a ping out\")]\n    Timeout,\n}\nimpl Debug for Peer\u003cTcpStream\u003e {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.id)?;\n        write!(f, \"{:?}\", self.stream.peer_addr())?;\n        Ok(())\n    }\n}\n\ntype Result\u003cT\u003e = std::result::Result\u003cT, PeerError\u003e;\n\nimpl\u003cT: Transport\u003e Peer\u003cT\u003e {\n    pub async fn read_loop(mut self) -\u003e Result\u003c()\u003e {\n        let err = self.peer_loop_inner().await;\n\n        if let Err(err) = err {\n            warn!(\"Peer {} connection loop closed: {err:?}\", self.id);\n        }\n\n        self.send_to_node(PeerMessages::Disconnected(self.address_id))\n            .await;\n        Ok(())\n    }\n    async fn peer_loop_inner(\u0026mut self) -\u003e Result\u003c()\u003e {\n        // send a version\n        let version = peer_utils::build_version_message();\n        self.write(version).await?;\n        self.state = State::SentVersion(Instant::now());\n        let read_stream = BufReader::new(self.stream.clone());\n        let (tx, rx) = unbounded();\n        let magic = self.network.magic();\n        let stream: StreamReader\u003c_, RawNetworkMessage\u003e = StreamReader::new(read_stream, magic, tx);\n        spawn(stream.read_loop());\n        loop {\n            futures::select! {\n                request = self.node_requests.recv().fuse() =\u003e {\n                    if let Ok(request) = request {\n                        self.handle_node_request(request).await?;\n                    }\n                }\n                peer_request = async_std::future::timeout(Duration::from_secs(10), rx.recv()).fuse() =\u003e {\n                    if let Ok(Ok(peer_request)) = peer_request {\n                        self.handle_peer_message(peer_request?).await?;\n                    }\n                }\n            };\n            if self.shutdown {\n                return Ok(());\n            }\n            // If we send a ping and our peer doesn't respond in time, disconnect\n            if let Some(when) = self.last_ping {\n                if when.elapsed().as_secs() \u003e PING_TIMEOUT {\n                    return Err(PeerError::Timeout);\n                }\n            }\n\n            // Send a ping to check if this peer is still good\n            let last_message = self.last_message.elapsed().as_secs();\n            if last_message \u003e SEND_PING_TIMEOUT {\n                let nonce = rand::random();\n                self.last_ping = Some(Instant::now());\n                self.write(NetworkMessage::Ping(nonce)).await?;\n            }\n\n            // divide the number of messages by the number of seconds we've been connected,\n            // if it's more than 100 msg/sec, this peer is sending us too many messages, and we should\n            // disconnect.\n            let msg_sec = self\n                .messages\n                .checked_div(Instant::now().duration_since(self.start_time).as_secs())\n                .unwrap_or(0);\n\n            if msg_sec \u003e 10 {\n                error!(\n                    \"Peer {} is sending us too many messages, disconnecting\",\n                    self.id\n                );\n                return Err(PeerError::TooManyMessages);\n            }\n\n            if let State::SentVersion(when) = self.state {\n                if Instant::now().duration_since(when) \u003e Duration::from_secs(10) {\n                    return Err(PeerError::UnexpectedMessage);\n                }\n            }\n        }\n    }\n    pub async fn handle_node_request(\u0026mut self, request: NodeRequest) -\u003e Result\u003c()\u003e {\n        match request {\n            NodeRequest::GetBlock((block_hashes, proof)) =\u003e {\n                let inv = if proof {\n                    block_hashes\n                        .iter()\n                        .map(|block| Inventory::UtreexoWitnessBlock(*block))\n                        .collect()\n                } else {\n                    block_hashes\n                        .iter()\n                        .map(|block| Inventory::Block(*block))\n                        .collect()\n                };\n\n                let _ = self.write(NetworkMessage::GetData(inv)).await;\n            }\n            NodeRequest::GetUtreexoState((block_hash, height)) =\u003e {\n                let get_filter = bitcoin::p2p::message_filter::GetCFilters {\n                    filter_type: 1,\n                    start_height: height,\n                    stop_hash: block_hash,\n                };\n\n                let _ = self.write(NetworkMessage::GetCFilters(get_filter)).await;\n            }\n            NodeRequest::GetHeaders(locator) =\u003e {\n                let _ = self\n                    .write(NetworkMessage::GetHeaders(\n                        bitcoin::p2p::message_blockdata::GetHeadersMessage {\n                            version: 0,\n                            locator_hashes: locator,\n                            stop_hash: BlockHash::all_zeros(),\n                        },\n                    ))\n                    .await;\n            }\n            NodeRequest::Shutdown =\u003e {\n                self.shutdown = true;\n                let _ = self.stream.shutdown();\n            }\n            NodeRequest::GetAddresses =\u003e {\n                self.write(NetworkMessage::GetAddr).await?;\n            }\n            NodeRequest::BroadcastTransaction(tx) =\u003e {\n                self.write(NetworkMessage::Inv(vec![Inventory::Transaction(tx)]))\n                    .await?;\n            }\n            NodeRequest::MempoolTransaction(txid) =\u003e {\n                self.write(NetworkMessage::GetData(vec![Inventory::Transaction(txid)]))\n                    .await?;\n            }\n            NodeRequest::SendAddresses(addresses) =\u003e {\n                self.write(NetworkMessage::AddrV2(addresses)).await?;\n            }\n            NodeRequest::GetFilter((stop_hash, start_height)) =\u003e {\n                let get_filter = bitcoin::p2p::message_filter::GetCFilters {\n                    filter_type: 0,\n                    start_height,\n                    stop_hash,\n                };\n\n                self.write(NetworkMessage::GetCFilters(get_filter)).await?;\n            }\n        }\n        Ok(())\n    }\n    pub async fn handle_peer_message(\u0026mut self, message: RawNetworkMessage) -\u003e Result\u003c()\u003e {\n        self.last_message = Instant::now();\n\n        match self.state {\n            State::Connected =\u003e match message.payload().to_owned() {\n                NetworkMessage::Inv(inv) =\u003e {\n                    for inv_entry in inv {\n                        match inv_entry {\n                            Inventory::Error =\u003e {}\n                            Inventory::Transaction(_) =\u003e {}\n                            Inventory::Block(block_hash)\n                            | Inventory::WitnessBlock(block_hash)\n                            | Inventory::CompactBlock(block_hash) =\u003e {\n                                self.send_to_node(PeerMessages::NewBlock(block_hash)).await;\n                            }\n                            _ =\u003e {}\n                        }\n                    }\n                }\n                NetworkMessage::GetHeaders(_) =\u003e {\n                    self.write(NetworkMessage::Headers(Vec::new())).await?;\n                }\n                NetworkMessage::Block(block) =\u003e {\n                    self.send_to_node(PeerMessages::Block(block)).await;\n                }\n                NetworkMessage::Headers(headers) =\u003e {\n                    self.send_to_node(PeerMessages::Headers(headers)).await;\n                }\n                NetworkMessage::SendHeaders =\u003e {\n                    self.send_headers = true;\n                    self.write(NetworkMessage::SendHeaders).await?;\n                }\n                NetworkMessage::Ping(nonce) =\u003e {\n                    self.handle_ping(nonce).await?;\n                }\n                NetworkMessage::FeeFilter(_) =\u003e {\n                    self.write(NetworkMessage::FeeFilter(1000)).await?;\n                }\n                NetworkMessage::AddrV2(addresses) =\u003e {\n                    self.send_to_node(PeerMessages::Addr(addresses)).await;\n                }\n                NetworkMessage::GetBlocks(_) =\u003e {\n                    self.write(NetworkMessage::Inv(Vec::new())).await?;\n                }\n                NetworkMessage::GetAddr =\u003e {\n                    self.write(NetworkMessage::AddrV2(Vec::new())).await?;\n                }\n                NetworkMessage::GetData(inv) =\u003e {\n                    for inv_el in inv {\n                        self.handle_get_data(inv_el).await?;\n                    }\n                }\n                NetworkMessage::Tx(tx) =\u003e {\n                    self.send_to_node(PeerMessages::Transaction(tx)).await;\n                }\n                NetworkMessage::NotFound(inv) =\u003e {\n                    for inv_el in inv {\n                        self.send_to_node(PeerMessages::NotFound(inv_el)).await;\n                    }\n                }\n                NetworkMessage::SendAddrV2 =\u003e {\n                    self.wants_addrv2 = true;\n                    self.write(NetworkMessage::SendAddrV2).await?;\n                }\n                NetworkMessage::Pong(_) =\u003e {\n                    self.last_ping = None;\n                }\n                NetworkMessage::Unknown { command, payload } =\u003e {\n                    warn!(\"Unknown message: {} {:?}\", command, payload);\n                }\n                NetworkMessage::CFilter(filter_msg) =\u003e match filter_msg.filter_type {\n                    0 =\u003e {\n                        let filter = bip158::BlockFilter::new(\u0026filter_msg.filter);\n\n                        // FIXME\n                        let filter = unsafe {\n                            std::mem::transmute::\u003c\n                                bitcoin::bip158::BlockFilter,\n                                floresta_compact_filters::BlockFilter,\n                            \u003e(filter)\n                        };\n                        self.send_to_node(PeerMessages::BlockFilter((\n                            filter_msg.block_hash,\n                            filter,\n                        )))\n                        .await;\n                    }\n                    1 =\u003e {\n                        self.send_to_node(PeerMessages::UtreexoState(filter_msg.filter))\n                            .await;\n                    }\n                    _ =\u003e {}\n                },\n                // Explicitly ignore these messages, if something changes in the future\n                // this would cause a compile error.\n                NetworkMessage::Verack\n                | NetworkMessage::Version(_)\n                | NetworkMessage::WtxidRelay\n                | NetworkMessage::Reject(_)\n                | NetworkMessage::Alert(_)\n                | NetworkMessage::BlockTxn(_)\n                | NetworkMessage::CFCheckpt(_)\n                | NetworkMessage::CFHeaders(_)\n                | NetworkMessage::CmpctBlock(_)\n                | NetworkMessage::FilterAdd(_)\n                | NetworkMessage::FilterClear\n                | NetworkMessage::FilterLoad(_)\n                | NetworkMessage::GetBlockTxn(_)\n                | NetworkMessage::GetCFCheckpt(_)\n                | NetworkMessage::GetCFHeaders(_)\n                | NetworkMessage::Addr(_)\n                | NetworkMessage::GetCFilters(_)\n                | NetworkMessage::MemPool\n                | NetworkMessage::MerkleBlock(_)\n                | NetworkMessage::SendCmpct(_) =\u003e {}\n            },\n            State::None | State::SentVersion(_) =\u003e match message.payload().to_owned() {\n                bitcoin::p2p::message::NetworkMessage::Version(version) =\u003e {\n                    self.handle_version(version).await?;\n                    self.send_to_node(PeerMessages::Ready(Version {\n                        user_agent: self.user_agent.clone(),\n                        protocol_version: 0,\n                        id: self.id,\n                        blocks: self.current_best_block.unsigned_abs(),\n                        address_id: self.address_id,\n                        services: self.services,\n                        feeler: self.feeler,\n                    }))\n                    .await;\n                }\n                _ =\u003e {\n                    warn!(\n                        \"unexpected message: {:?} from peer {}\",\n                        message.payload(),\n                        self.id\n                    );\n                    return Err(PeerError::UnexpectedMessage);\n                }\n            },\n            State::SentVerack =\u003e match message.payload() {\n                bitcoin::p2p::message::NetworkMessage::Verack =\u003e {\n                    self.state = State::Connected;\n                }\n                bitcoin::p2p::message::NetworkMessage::SendAddrV2 =\u003e {\n                    self.wants_addrv2 = true;\n                }\n                bitcoin::p2p::message::NetworkMessage::SendHeaders =\u003e {\n                    self.send_headers = true;\n                }\n                bitcoin::p2p::message::NetworkMessage::WtxidRelay =\u003e {}\n                _ =\u003e {\n                    warn!(\n                        \"unexpected message: {:?} from peer {}\",\n                        message.payload(),\n                        self.id\n                    );\n                    return Err(PeerError::UnexpectedMessage);\n                }\n            },\n        }\n        Ok(())\n    }\n}\nimpl\u003cT: Transport\u003e Peer\u003cT\u003e {\n    pub async fn write(\u0026mut self, msg: NetworkMessage) -\u003e Result\u003c()\u003e {\n        let data = \u0026mut RawNetworkMessage::new(self.network.magic(), msg);\n        let data = serialize(\u0026data);\n        self.stream.write_all(data.as_slice()).await?;\n        Ok(())\n    }\n    pub async fn handle_get_data(\u0026mut self, inv: Inventory) -\u003e Result\u003c()\u003e {\n        match inv {\n            Inventory::WitnessTransaction(txid) =\u003e {\n                let tx = self.mempool.read().await.get_from_mempool(\u0026txid).cloned();\n                if let Some(tx) = tx {\n                    self.write(NetworkMessage::Tx(tx)).await?;\n                }\n            }\n            Inventory::Transaction(txid) =\u003e {\n                let tx = self.mempool.read().await.get_from_mempool(\u0026txid).cloned();\n                if let Some(tx) = tx {\n                    self.write(NetworkMessage::Tx(tx)).await?;\n                }\n            }\n            _ =\u003e {}\n        }\n        Ok(())\n    }\n    #[allow(clippy::too_many_arguments)]\n    pub fn create_peer_from_transport(\n        stream: T,\n        id: u32,\n        mempool: Arc\u003cRwLock\u003cMempool\u003e\u003e,\n        network: Network,\n        node_tx: Sender\u003cNodeNotification\u003e,\n        node_requests: Receiver\u003cNodeRequest\u003e,\n        address_id: usize,\n        feeler: bool,\n    ) {\n        let peer = Peer {\n            address_id,\n            blocks_only: false,\n            current_best_block: -1,\n            id,\n            mempool,\n            last_ping: None,\n            last_message: Instant::now(),\n            network,\n            node_tx,\n            services: ServiceFlags::NONE,\n            stream,\n            messages: 0,\n            start_time: Instant::now(),\n            user_agent: \"\".into(),\n            state: State::None,\n            send_headers: false,\n            node_requests,\n            feeler,\n            wants_addrv2: false,\n            shutdown: false,\n        };\n        spawn(peer.read_loop());\n    }\n\n    #[allow(clippy::too_many_arguments)]\n    pub async fn create_outbound_connection\u003cA: ToSocketAddrs + Debug\u003e(\n        id: u32,\n        address: A,\n        mempool: Arc\u003cRwLock\u003cMempool\u003e\u003e,\n        network: Network,\n        node_tx: Sender\u003cNodeNotification\u003e,\n        node_requests: Receiver\u003cNodeRequest\u003e,\n        address_id: usize,\n        feeler: bool,\n    ) {\n        let stream =\n            async_std::future::timeout(Duration::from_secs(10), TcpStream::connect(address)).await;\n        let Ok(Ok(stream)) = stream else {\n            let _ = node_tx\n                .send(NodeNotification::FromPeer(\n                    id,\n                    PeerMessages::Disconnected(id as usize),\n                ))\n                .await;\n            return;\n        };\n        let peer = Peer {\n            address_id,\n            blocks_only: false,\n            current_best_block: -1,\n            id,\n            mempool,\n            last_ping: None,\n            last_message: Instant::now(),\n            network,\n            node_tx,\n            services: ServiceFlags::NONE,\n            stream,\n            messages: 0,\n            start_time: Instant::now(),\n            user_agent: \"\".into(),\n            state: State::None,\n            send_headers: false,\n            node_requests,\n            feeler,\n            wants_addrv2: false,\n            shutdown: false,\n        };\n        spawn(peer.read_loop());\n    }\n    async fn handle_ping(\u0026mut self, nonce: u64) -\u003e Result\u003c()\u003e {\n        let pong = make_pong(nonce);\n        self.write(pong).await\n    }\n    async fn handle_version(\u0026mut self, version: VersionMessage) -\u003e Result\u003c()\u003e {\n        self.user_agent = version.user_agent;\n        self.blocks_only = !version.relay;\n        self.current_best_block = version.start_height;\n        self.services = version.services;\n        if version.version \u003e= 70016 {\n            self.write(NetworkMessage::SendAddrV2).await?;\n        }\n        self.state = State::SentVerack;\n        let verack = NetworkMessage::Verack;\n        self.state = State::SentVerack;\n        self.write(verack).await\n    }\n    async fn send_to_node(\u0026self, message: PeerMessages) {\n        let message = NodeNotification::FromPeer(self.id, message);\n        let _ = self.node_tx.send(message).await;\n    }\n}\npub(super) mod peer_utils {\n    use std::net::IpAddr;\n    use std::net::Ipv4Addr;\n    use std::net::SocketAddr;\n    use std::time::SystemTime;\n    use std::time::UNIX_EPOCH;\n\n    use bitcoin::p2p::address;\n    use bitcoin::p2p::message::NetworkMessage;\n    use bitcoin::p2p::message::{self};\n    use bitcoin::p2p::message_network;\n    use floresta_common::constants::FLORESTA_VERSION;\n    use floresta_common::constants::RUSTREEXO_VERSION;\n    use floresta_common::constants::RUST_BITCOIN_VERSION;\n\n    /// Protocol version we speak\n    pub const PROTOCOL_VERSION: u32 = 70016;\n\n    pub(super) fn make_pong(nonce: u64) -\u003e NetworkMessage {\n        NetworkMessage::Pong(nonce)\n    }\n\n    pub(crate) fn build_version_message() -\u003e message::NetworkMessage {\n        use bitcoin::p2p::ServiceFlags;\n\n        // Building version message, see https://en.bitcoin.it/wiki/Protocol_documentation#version\n        let my_address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 38332);\n\n        // \"bitfield of features to be enabled for this connection\"\n        let services = ServiceFlags::NETWORK | ServiceFlags::from(1 \u003c\u003c 24) | ServiceFlags::WITNESS;\n\n        // \"standard UNIX timestamp in seconds\"\n        let timestamp = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .expect(\"Time error\")\n            .as_secs();\n\n        // \"The network address of the node receiving this message\"\n        let addr_recv = address::Address::new(\u0026my_address, ServiceFlags::NONE);\n\n        // \"The network address of the node emitting this message\"\n        let addr_from = address::Address::new(\u0026my_address, ServiceFlags::NONE);\n\n        // \"Node random nonce, randomly generated every time a version packet is sent. This nonce is used to detect connections to self.\"\n        let nonce: u64 = 1;\n\n        // \"User Agent (0x00 if string is 0 bytes long)\"\n        let user_agent = format!(\n            \"/rust-bitcoin:{}/rustreexo:{}/Floresta:{}/\",\n            RUST_BITCOIN_VERSION, RUSTREEXO_VERSION, FLORESTA_VERSION\n        );\n\n        // \"The last block received by the emitting node\"\n        let start_height: i32 = 0;\n\n        // Construct the message\n        message::NetworkMessage::Version(message_network::VersionMessage {\n            services,\n            timestamp: timestamp as i64,\n            receiver: addr_recv,\n            sender: addr_from,\n            nonce,\n            user_agent,\n            start_height,\n            relay: false,\n            version: PROTOCOL_VERSION,\n        })\n    }\n}\n#[derive(Debug)]\npub struct Version {\n    pub user_agent: String,\n    pub protocol_version: u32,\n    pub blocks: u32,\n    pub id: u32,\n    pub address_id: usize,\n    pub services: ServiceFlags,\n    pub feeler: bool,\n}\n/// Messages passed from different modules to the main node to process. They should minimal\n/// and only if it requires global states, everything else should be handled by the module\n/// itself.\n#[derive(Debug)]\npub enum PeerMessages {\n    /// A new block just arrived, we should ask for it and update our chain\n    NewBlock(BlockHash),\n    /// We got a full block from our peer, presumptively we asked for it\n    Block(UtreexoBlock),\n    /// A response to a `getheaders` request\n    Headers(Vec\u003cBlockHeader\u003e),\n    /// We got some p2p addresses, add this to our local database\n    Addr(Vec\u003cAddrV2Message\u003e),\n    /// Peer notify its readiness\n    Ready(Version),\n    /// Remote peer disconnected\n    Disconnected(usize),\n    /// Remote peer doesn't known the data we asked for\n    NotFound(Inventory),\n    /// Remote peer sent us a transaction\n    Transaction(Transaction),\n    UtreexoState(Vec\u003cu8\u003e),\n    BlockFilter((BlockHash, floresta_compact_filters::BlockFilter)),\n}\n","traces":[{"line":65,"address":[1583712],"length":1,"stats":{"Line":0},"fn_name":"shutdown"},{"line":66,"address":[1583739,1583815],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[1705392,1705980],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":113,"address":[1705683,1705425,1705487],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[1705916,1705715,1705409,1705585,1705959],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[1705909],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[5236635,5236712,5235776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[5232176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[1581568],"length":1,"stats":{"Line":0},"fn_name":"make_pong"},{"line":575,"address":[1581576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[1581584],"length":1,"stats":{"Line":0},"fn_name":"build_version_message"},{"line":582,"address":[1581634],"length":1,"stats":{"Line":0},"fn_name":null},{"line":585,"address":[1581712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[1581777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":594,"address":[1581929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[1581974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[1581601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":603,"address":[1582141],"length":1,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[1581610],"length":1,"stats":{"Line":0},"fn_name":null},{"line":612,"address":[1582440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":615,"address":[1582312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[1582376],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":268},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","running_node.rs"],"content":"/// After a node catches-up with the network, we can start listening for new blocks, handing any\n/// request our user might make and keep our peers alive. This mode requires way less bandwidth and\n/// CPU to run, being bound by the number of blocks found in a given period.\nuse std::net::IpAddr;\nuse std::sync::Arc;\nuse std::time::Duration;\nuse std::time::Instant;\n\nuse async_std::channel::SendError;\nuse async_std::future::timeout;\nuse async_std::sync::RwLock;\nuse bitcoin::p2p::address::AddrV2;\nuse bitcoin::p2p::address::AddrV2Message;\nuse bitcoin::p2p::message_blockdata::Inventory;\nuse bitcoin::p2p::utreexo::UtreexoBlock;\nuse bitcoin::p2p::ServiceFlags;\nuse floresta_chain::pruned_utreexo::partial_chain::PartialChainState;\nuse floresta_chain::pruned_utreexo::BlockchainInterface;\nuse floresta_chain::pruned_utreexo::UpdatableChainstate;\nuse floresta_chain::BlockValidationErrors;\nuse floresta_chain::BlockchainError;\nuse log::debug;\nuse log::error;\nuse log::info;\nuse log::warn;\nuse rustreexo::accumulator::stump::Stump;\n\nuse super::error::WireError;\nuse super::peer::PeerMessages;\nuse crate::address_man::AddressState;\nuse crate::address_man::LocalAddress;\nuse crate::node::periodic_job;\nuse crate::node::try_and_log;\nuse crate::node::InflightRequests;\nuse crate::node::NodeNotification;\nuse crate::node::NodeRequest;\nuse crate::node::RescanStatus;\nuse crate::node::UtreexoNode;\nuse crate::node_context::NodeContext;\nuse crate::node_interface::NodeInterface;\nuse crate::node_interface::NodeResponse;\nuse crate::node_interface::UserRequest;\nuse crate::p2p_wire::chain_selector::ChainSelector;\nuse crate::p2p_wire::sync_node::SyncNode;\n\n#[derive(Debug, Clone)]\npub struct RunningNode {\n    pub(crate) last_rescan_request: RescanStatus,\n    pub(crate) last_feeler: Instant,\n    pub(crate) last_address_rearrange: Instant,\n    pub(crate) user_requests: Arc\u003cNodeInterface\u003e,\n}\n\nimpl NodeContext for RunningNode {\n    const REQUEST_TIMEOUT: u64 = 30;\n    fn get_required_services(\u0026self) -\u003e ServiceFlags {\n        ServiceFlags::UTREEXO\n            | ServiceFlags::NETWORK\n            | ServiceFlags::WITNESS\n            | ServiceFlags::COMPACT_FILTERS\n    }\n}\n\nimpl\u003cChain\u003e UtreexoNode\u003cRunningNode, Chain\u003e\nwhere\n    WireError: From\u003c\u003cChain as BlockchainInterface\u003e::Error\u003e,\n    Chain: BlockchainInterface + UpdatableChainstate + 'static,\n{\n    /// Returns a handle to the node interface that we can use to request data from our\n    /// node. This struct is thread safe, so we can use it from multiple threads and have\n    /// multiple handles. It also doesn't require a mutable reference to the node, or any\n    /// synchronization mechanism.\n    pub fn get_handle(\u0026self) -\u003e Arc\u003cNodeInterface\u003e {\n        self.1.user_requests.clone()\n    }\n\n    #[allow(clippy::result_large_err)]\n    fn check_request_timeout(\u0026mut self) -\u003e Result\u003c(), SendError\u003cNodeResponse\u003e\u003e {\n        let mutex = self.1.user_requests.requests.lock().unwrap();\n        let mut to_remove = Vec::new();\n        for req in mutex.iter() {\n            if req.time.elapsed() \u003e Duration::from_secs(10) {\n                to_remove.push(req.req);\n            }\n        }\n        drop(mutex);\n        for request in to_remove {\n            self.1.user_requests.send_answer(request, None);\n        }\n\n        Ok(())\n    }\n\n    async fn handle_user_request(\u0026mut self) {\n        let mut requests = Vec::new();\n\n        for request in self.1.user_requests.requests.lock().unwrap().iter() {\n            if !self\n                .inflight\n                .contains_key(\u0026InflightRequests::UserRequest(request.req))\n            {\n                requests.push(request.req);\n            }\n        }\n        self.perform_user_request(requests).await;\n    }\n\n    fn handle_get_peer_info(\u0026self) {\n        let mut peers = Vec::new();\n        for peer in self.peer_ids.iter() {\n            peers.push(self.get_peer_info(peer));\n        }\n        let peers = peers.into_iter().flatten().collect();\n        self.1.user_requests.send_answer(\n            UserRequest::GetPeerInfo,\n            Some(NodeResponse::GetPeerInfo(peers)),\n        );\n    }\n\n    async fn perform_user_request(\u0026mut self, user_req: Vec\u003cUserRequest\u003e) {\n        for user_req in user_req {\n            let req = match user_req {\n                UserRequest::Block(block) =\u003e NodeRequest::GetBlock((vec![block], false)),\n                UserRequest::UtreexoBlock(block) =\u003e NodeRequest::GetBlock((vec![block], true)),\n                UserRequest::MempoolTransaction(txid) =\u003e NodeRequest::MempoolTransaction(txid),\n                UserRequest::GetPeerInfo =\u003e {\n                    self.handle_get_peer_info();\n                    continue;\n                }\n                UserRequest::Connect((addr, port)) =\u003e {\n                    let addr_v2 = match addr {\n                        IpAddr::V4(addr) =\u003e AddrV2::Ipv4(addr),\n                        IpAddr::V6(addr) =\u003e AddrV2::Ipv6(addr),\n                    };\n                    let id = rand::random::\u003cusize\u003e();\n                    let local_addr =\n                        LocalAddress::new(addr_v2, 0, AddressState::NeverTried, 0.into(), port, id);\n                    self.open_connection(false, 0, local_addr).await;\n                    self.1.user_requests.send_answer(\n                        UserRequest::Connect((addr, port)),\n                        Some(NodeResponse::Connect(true)),\n                    );\n                    continue;\n                }\n            };\n            let peer = self.send_to_random_peer(req, ServiceFlags::NONE).await;\n            if let Ok(peer) = peer {\n                self.inflight.insert(\n                    InflightRequests::UserRequest(user_req),\n                    (peer, Instant::now()),\n                );\n            }\n        }\n    }\n\n    async fn send_addresses(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        let addresses = self\n            .address_man\n            .get_addresses_to_send()\n            .into_iter()\n            .map(|(addr, time, services, port)| AddrV2Message {\n                services,\n                addr,\n                port,\n                time: time as u32,\n            })\n            .collect();\n\n        self.send_to_random_peer(NodeRequest::SendAddresses(addresses), ServiceFlags::NONE)\n            .await?;\n        Ok(())\n    }\n\n    async fn check_for_timeout(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        let mut timed_out = Vec::new();\n        for request in self.inflight.keys() {\n            let (_, time) = self.inflight.get(request).unwrap();\n            if time.elapsed() \u003e Duration::from_secs(RunningNode::REQUEST_TIMEOUT) {\n                timed_out.push(request.clone());\n                debug!(\"Request {:?} timed out\", request);\n            }\n        }\n\n        for request in timed_out {\n            let Some((peer, _)) = self.inflight.remove(\u0026request) else {\n                warn!(\n                    \"POSSIBLE BUG: Request {:?} timed out, but it wasn't in the inflight list\",\n                    request\n                );\n                continue;\n            };\n\n            // Punnishing this peer for taking too long to respond\n            self.increase_banscore(peer, 2).await?;\n\n            match request {\n                InflightRequests::UtreexoState(_) =\u003e {}\n                InflightRequests::Blocks(block) =\u003e {\n                    if !self.has_utreexo_peers() {\n                        continue;\n                    }\n                    let peer = self\n                        .send_to_random_peer(\n                            NodeRequest::GetBlock((vec![block], true)),\n                            ServiceFlags::UTREEXO,\n                        )\n                        .await?;\n                    self.inflight\n                        .insert(InflightRequests::Blocks(block), (peer, Instant::now()));\n                }\n                InflightRequests::RescanBlock(block) =\u003e {\n                    let peer = self\n                        .send_to_random_peer(\n                            NodeRequest::GetBlock((vec![block], false)),\n                            ServiceFlags::NONE,\n                        )\n                        .await?;\n                    self.inflight\n                        .insert(InflightRequests::RescanBlock(block), (peer, Instant::now()));\n                }\n                InflightRequests::Headers =\u003e {\n                    let peer = self\n                        .send_to_random_peer(NodeRequest::GetAddresses, ServiceFlags::NONE)\n                        .await?;\n                    self.last_headers_request = Instant::now();\n                    self.inflight\n                        .insert(InflightRequests::Headers, (peer, Instant::now()));\n                }\n                InflightRequests::UserRequest(req) =\u003e match req {\n                    UserRequest::Block(block) =\u003e {\n                        let peer = self\n                            .send_to_random_peer(\n                                NodeRequest::GetBlock((vec![block], true)),\n                                ServiceFlags::NONE,\n                            )\n                            .await?;\n                        self.inflight\n                            .insert(InflightRequests::UserRequest(req), (peer, Instant::now()));\n                    }\n                    UserRequest::MempoolTransaction(txid) =\u003e {\n                        let peer = self\n                            .send_to_random_peer(\n                                NodeRequest::MempoolTransaction(txid),\n                                ServiceFlags::NONE,\n                            )\n                            .await?;\n                        self.inflight\n                            .insert(InflightRequests::UserRequest(req), (peer, Instant::now()));\n                    }\n                    UserRequest::UtreexoBlock(block) =\u003e {\n                        let peer = self\n                            .send_to_random_peer(\n                                NodeRequest::GetBlock((vec![block], true)),\n                                ServiceFlags::NONE,\n                            )\n                            .await?;\n                        self.inflight\n                            .insert(InflightRequests::UserRequest(req), (peer, Instant::now()));\n                    }\n                    _ =\u003e {}\n                },\n                InflightRequests::Connect(peer) =\u003e {\n                    self.send_to_peer(peer, NodeRequest::Shutdown).await?\n                }\n                InflightRequests::GetFilters =\u003e {\n                    if let Some(ref block_filters) = self.block_filters {\n                        let last_success = block_filters.get_height() + 1;\n                        self.last_filter = self.chain.get_block_hash(last_success)?;\n                        self.download_filters().await?;\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    pub async fn catch_up(self, kill_signal: Arc\u003cRwLock\u003cbool\u003e\u003e) -\u003e Self {\n        let mut sync = UtreexoNode::\u003cSyncNode, Chain\u003e(self.0, SyncNode::default());\n        sync.run(kill_signal, |_| {}).await;\n\n        UtreexoNode(sync.0, self.1)\n    }\n\n    pub async fn run(\n        mut self,\n        kill_signal: Arc\u003cRwLock\u003cbool\u003e\u003e,\n        stop_signal: futures::channel::oneshot::Sender\u003c()\u003e,\n    ) {\n        try_and_log!(self.init_peers().await);\n        let startup_tip = self.chain.get_height().unwrap();\n\n        // Use this node state to Initial Block download\n        let mut ibd = UtreexoNode(self.0, ChainSelector::default());\n        try_and_log!(UtreexoNode::\u003cChainSelector, Chain\u003e::run(\u0026mut ibd, kill_signal.clone()).await);\n\n        if *kill_signal.read().await {\n            self = UtreexoNode(ibd.0, self.1);\n            self.shutdown().await;\n            return;\n        }\n\n        self = UtreexoNode(ibd.0, self.1);\n\n        // download all blocks from the network\n        if self.config.backfill \u0026\u0026 startup_tip == 0 {\n            let end = self.0.chain.get_validation_index().unwrap();\n            let chain = self\n                .chain\n                .get_partial_chain(startup_tip, end, Stump::default())\n                .unwrap();\n\n            let mut backfill = UtreexoNode::\u003cSyncNode, PartialChainState\u003e::new(\n                self.config.clone(),\n                chain,\n                self.mempool.clone(),\n                None,\n            );\n\n            UtreexoNode::\u003cSyncNode, PartialChainState\u003e::run(\n                \u0026mut backfill,\n                kill_signal.clone(),\n                |chain: \u0026PartialChainState| {\n                    if chain.has_invalid_blocks() {\n                        panic!(\n                            \"We assumed a chain with invalid blocks, something went really wrong\"\n                        );\n                    }\n\n                    for block in chain.list_valid_blocks() {\n                        self.chain\n                            .mark_block_as_valid(block.block_hash())\n                            .expect(\"Failed to mark block as valid\");\n                    }\n                },\n            )\n            .await;\n        }\n\n        self = self.catch_up(kill_signal.clone()).await;\n\n        self.last_block_request = self.chain.get_validation_index().unwrap_or(0);\n\n        info!(\"starting running node...\");\n        loop {\n            while let Ok(notification) =\n                timeout(Duration::from_millis(100), self.node_rx.recv()).await\n            {\n                try_and_log!(self.handle_notification(notification).await);\n            }\n\n            if *kill_signal.read().await {\n                self.shutdown().await;\n                break;\n            }\n\n            // Jobs that don't need a connected peer\n\n            // Save our peers db\n            periodic_job!(\n                self.save_peers(),\n                self.last_peer_db_dump,\n                PEER_DB_DUMP_INTERVAL,\n                RunningNode\n            );\n\n            // Rework our address database\n            periodic_job!(\n                self.address_man.rearrange_buckets(),\n                self.1.last_address_rearrange,\n                ADDRESS_REARRANGE_INTERVAL,\n                RunningNode,\n                true\n            );\n\n            // Perhaps we need more connections\n            periodic_job!(\n                self.maybe_open_connection().await,\n                self.last_connection,\n                TRY_NEW_CONNECTION,\n                RunningNode\n            );\n\n            // Requests using the node handle\n            try_and_log!(self.check_request_timeout());\n            self.handle_user_request().await;\n\n            // Check if some of our peers have timed out a request\n            try_and_log!(self.check_for_timeout().await);\n\n            // Those jobs bellow needs a connected peer to work\n            if self.peer_ids.is_empty() {\n                continue;\n            }\n            // Aks our peers for new addresses\n            periodic_job!(\n                self.ask_for_addresses().await,\n                self.last_get_address_request,\n                ASK_FOR_PEERS_INTERVAL,\n                RunningNode\n            );\n            // Open new feeler connection periodically\n            periodic_job!(\n                self.open_feeler_connection().await,\n                self.1.last_feeler,\n                FEELER_INTERVAL,\n                RunningNode\n            );\n            // Try broadcast transactions\n            periodic_job!(\n                self.handle_broadcast().await,\n                self.last_broadcast,\n                BROADCAST_DELAY,\n                RunningNode\n            );\n            // Send our addresses to our peers\n            periodic_job!(\n                self.send_addresses().await,\n                self.last_send_addresses,\n                SEND_ADDRESSES_INTERVAL,\n                RunningNode\n            );\n\n            try_and_log!(self.request_rescan_block().await);\n\n            // Check whether we are in a stale tip\n            periodic_job!(\n                self.check_for_stale_tip().await,\n                self.last_tip_update,\n                ASSUME_STALE,\n                RunningNode\n            );\n            try_and_log!(self.download_filters().await);\n            // requests that need a utreexo peer\n            if self.has_utreexo_peers() {\n                continue;\n            }\n\n            // Check if we haven't missed any block\n            if self.inflight.len() \u003c 10 {\n                try_and_log!(self.ask_missed_block().await);\n            }\n        }\n\n        stop_signal.send(()).unwrap();\n    }\n\n    async fn download_filters(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        if self.inflight.contains_key(\u0026InflightRequests::GetFilters) {\n            return Ok(());\n        }\n\n        if !self.has_compact_filters_peer() {\n            // open a feeler connection to find more peers with COMPACT_BLOCK_FILTERS flag\n            self.create_connection(true).await;\n            return Ok(());\n        }\n\n        let Some(ref filters) = self.block_filters else {\n            return Ok(());\n        };\n\n        info!(\"Downloading filters from height {}\", filters.get_height());\n        let height = filters.get_height();\n        let best_height = self.chain.get_height().unwrap();\n\n        let stop = if height + 1000 \u003e best_height {\n            best_height\n        } else {\n            height + 1000\n        };\n\n        let stop_hash = self.chain.get_block_hash(stop)?;\n        self.last_filter = stop_hash;\n\n        let peer = self\n            .send_to_random_peer(\n                NodeRequest::GetFilter((stop_hash, height + 1)),\n                ServiceFlags::COMPACT_FILTERS,\n            )\n            .await?;\n\n        self.inflight\n            .insert(InflightRequests::GetFilters, (peer, Instant::now()));\n        Ok(())\n    }\n\n    async fn ask_missed_block(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        let tip = self.chain.get_height().unwrap();\n        let next = self.chain.get_validation_index().unwrap();\n        if tip == next {\n            return Ok(());\n        }\n\n        let mut blocks = Vec::new();\n        for i in (next + 1)..=tip {\n            let hash = self.chain.get_block_hash(i)?;\n            // already requested\n            if self.inflight.contains_key(\u0026InflightRequests::Blocks(hash)) {\n                continue;\n            }\n\n            // already downloaded\n            if self.blocks.contains_key(\u0026hash) {\n                continue;\n            }\n\n            blocks.push(hash);\n        }\n\n        if blocks.is_empty() {\n            return Ok(());\n        }\n\n        self.request_blocks(blocks).await?;\n        Ok(())\n    }\n\n    async fn request_rescan_block(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        let tip = self.chain.get_height().unwrap();\n        if self.inflight.len() + 10 \u003e RunningNode::MAX_INFLIGHT_REQUESTS {\n            return Ok(());\n        }\n        // We use a grace period to avoid looping at the end of rescan\n        if let RescanStatus::Completed(time) = self.1.last_rescan_request {\n            if time.elapsed() \u003e Duration::from_secs(60) {\n                self.1.last_rescan_request = RescanStatus::None;\n            }\n        }\n        if self.1.last_rescan_request == RescanStatus::None\n            \u0026\u0026 self.chain.get_rescan_index().is_some()\n        {\n            self.1.last_rescan_request =\n                RescanStatus::InProgress(self.chain.get_rescan_index().unwrap());\n        }\n        if let RescanStatus::InProgress(height) = self.1.last_rescan_request {\n            for i in (height + 1)..=(height + 10) {\n                if i \u003e tip {\n                    self.1.last_rescan_request = RescanStatus::Completed(Instant::now());\n                    break;\n                }\n                self.1.last_rescan_request = RescanStatus::InProgress(i);\n                let hash = self.chain.get_block_hash(i)?;\n                let peer = self\n                    .send_to_random_peer(\n                        NodeRequest::GetBlock((vec![hash], false)),\n                        ServiceFlags::NONE,\n                    )\n                    .await?;\n                self.inflight\n                    .insert(InflightRequests::RescanBlock(hash), (peer, Instant::now()));\n            }\n        }\n\n        Ok(())\n    }\n\n    /// This function checks how many time has passed since our last tip update, if it's\n    /// been more than 15 minutes, try to update it.\n    async fn check_for_stale_tip(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        warn!(\"Potential stale tip detected, trying extra peers\");\n\n        // this catches an edge-case where all our utreexo peers are gone, and the GetData\n        // times-out. That yields an error, but doesn't ask the block again. Our last_block_request\n        // will be pointing to a block that will never arrive, so we basically deadlock.\n        self.last_block_request = self.chain.get_validation_index().unwrap();\n        // update this or we'll get this warning every second after 15 minutes without a block,\n        // until we get a new block.\n        self.last_tip_update = Instant::now();\n        self.create_connection(false).await;\n        self.send_to_random_peer(\n            NodeRequest::GetHeaders(self.chain.get_block_locator().unwrap()),\n            ServiceFlags::NONE,\n        )\n        .await?;\n        Ok(())\n    }\n\n    async fn handle_new_block(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        if self.inflight.contains_key(\u0026InflightRequests::Headers) {\n            return Ok(());\n        }\n\n        let locator = self.0.chain.get_block_locator().unwrap();\n\n        let peer = self\n            .send_to_random_peer(NodeRequest::GetHeaders(locator), ServiceFlags::NONE)\n            .await?;\n\n        self.inflight\n            .insert(InflightRequests::Headers, (peer, Instant::now()));\n\n        Ok(())\n    }\n\n    /// This function is called every time we get a Block message from a peer.\n    /// This block may be a rescan block, a user request or a new block that we\n    /// need to process.\n    async fn handle_block_data(\u0026mut self, block: UtreexoBlock, peer: u32) -\u003e Result\u003c(), WireError\u003e {\n        // Rescan block, a block that the wallet is interested in to check if it contains\n        // any transaction that we are interested in.\n        if self\n            .inflight\n            .remove(\u0026InflightRequests::RescanBlock(block.block.block_hash()))\n            .is_some()\n        {\n            self.request_rescan_block().await?;\n            return Ok(self.chain.process_rescan_block(\u0026block.block)?);\n        }\n        // If this block is a request made through the user interface, send it back to the\n        // user.\n        if self\n            .inflight\n            .remove(\u0026InflightRequests::UserRequest(UserRequest::Block(\n                block.block.block_hash(),\n            )))\n            .is_some()\n        {\n            if block.udata.is_some() {\n                self.1.user_requests.send_answer(\n                    UserRequest::UtreexoBlock(block.block.block_hash()),\n                    Some(NodeResponse::UtreexoBlock(block)),\n                );\n                return Ok(());\n            }\n            self.1.user_requests.send_answer(\n                UserRequest::Block(block.block.block_hash()),\n                Some(NodeResponse::Block(block.block)),\n            );\n            return Ok(());\n        }\n\n        // If none of the above, it means that this block is a new block that we need to\n        // process.\n\n        // Check if we actually requested this block. If a peer sends a block we didn't\n        // request, we should disconnect it.\n        if self\n            .inflight\n            .remove(\u0026InflightRequests::Blocks(block.block.block_hash()))\n            .is_none()\n        {\n            // We didn't request this block, so we should disconnect the peer.\n            if let Some(peer) = self.peers.get(\u0026peer).cloned() {\n                self.address_man.update_set_state(\n                    peer.address_id as usize,\n                    AddressState::Banned(RunningNode::BAN_TIME),\n                );\n            }\n            error!(\n                \"Peer {peer} sent us block {} which we didn't request\",\n                block.block.block_hash()\n            );\n            self.increase_banscore(peer, 5).await?;\n            return Ok(());\n        }\n\n        let validation_index = self.chain.get_validation_index()?;\n        let mut next_block = self.chain.get_block_hash(validation_index + 1)?;\n\n        debug!(\n            \"Block {} received, waiting for block {}\",\n            block.block.block_hash(),\n            next_block\n        );\n\n        self.blocks.insert(block.block.block_hash(), (peer, block));\n        while let Some((peer, block)) = self.blocks.remove(\u0026next_block) {\n            debug!(\"processing block {}\", block.block.block_hash(),);\n            let (proof, del_hashes, inputs) = floresta_chain::proof_util::process_proof(\n                \u0026block.udata.unwrap(),\n                \u0026block.block.txdata,\n                \u0026self.chain,\n            )?;\n\n            if let Err(e) = self\n                .chain\n                .connect_block(\u0026block.block, proof, inputs, del_hashes)\n            {\n                error!(\"Invalid block received by peer {} reason: {:?}\", peer, e);\n\n                if let BlockchainError::BlockValidation(e) = e {\n                    // Because the proof isn't committed to the block, we can't invalidate\n                    // it if the proof is invalid. Any other error should cause the block\n                    // to be invalidated.\n                    match e {\n                        BlockValidationErrors::InvalidTx(_)\n                        | BlockValidationErrors::NotEnoughPow\n                        | BlockValidationErrors::BadMerkleRoot\n                        | BlockValidationErrors::BadWitnessCommitment\n                        | BlockValidationErrors::NotEnoughMoney\n                        | BlockValidationErrors::FirstTxIsnNotCoinbase\n                        | BlockValidationErrors::BadCoinbaseOutValue\n                        | BlockValidationErrors::EmptyBlock\n                        | BlockValidationErrors::BlockExtendsAnOrphanChain\n                        | BlockValidationErrors::BadBip34\n                        | BlockValidationErrors::CoinbaseNotMatured =\u003e {\n                            self.send_to_peer(peer, NodeRequest::Shutdown).await?;\n                            try_and_log!(self.chain.invalidate_block(block.block.block_hash()));\n                        }\n                        BlockValidationErrors::InvalidProof =\u003e {}\n                    }\n                }\n\n                // Disconnect the peer and ban it.\n                if let Some(peer) = self.peers.get(\u0026peer).cloned() {\n                    self.address_man.update_set_state(\n                        peer.address_id as usize,\n                        AddressState::Banned(RunningNode::BAN_TIME),\n                    );\n                }\n                self.send_to_peer(peer, NodeRequest::Shutdown).await?;\n                return Err(WireError::PeerMisbehaving);\n            }\n\n            if !self.chain.is_in_idb() {\n                let mempool_delta = self.mempool.write().await.consume_block(\u0026block.block);\n                debug!(\n                    \"Block {} accepted, confirmed transactions: {:?}\",\n                    block.block.block_hash(),\n                    mempool_delta\n                );\n            }\n\n            let next = self.chain.get_validation_index()? + 1;\n\n            match self.chain.get_block_hash(next) {\n                Ok(_next_block) =\u003e next_block = _next_block,\n                Err(_) =\u003e break,\n            }\n            debug!(\"accepted block {}\", block.block.block_hash());\n        }\n\n        // Remove confirmed transactions from the mempool.\n        self.last_tip_update = Instant::now();\n\n        Ok(())\n    }\n\n    pub(crate) async fn handle_notification(\n        \u0026mut self,\n        notification: Result\u003cNodeNotification, async_std::channel::RecvError\u003e,\n    ) -\u003e Result\u003c(), WireError\u003e {\n        match notification? {\n            NodeNotification::FromPeer(peer, message) =\u003e match message {\n                PeerMessages::NewBlock(block) =\u003e {\n                    debug!(\"We got an inv with block {block} requesting it\");\n                    self.handle_new_block().await?;\n                }\n                PeerMessages::Block(block) =\u003e {\n                    debug!(\n                        \"Got data for block {} from peer {peer}\",\n                        block.block.block_hash()\n                    );\n                    self.handle_block_data(block, peer).await?;\n                }\n                PeerMessages::Headers(headers) =\u003e {\n                    debug!(\n                        \"Got headers from peer {peer} with {} headers\",\n                        headers.len()\n                    );\n                    self.inflight.remove(\u0026InflightRequests::Headers);\n                    for header in headers.iter() {\n                        self.chain.accept_header(*header)?;\n                    }\n\n                    if self.chain.is_in_idb() {\n                        let blocks = headers.iter().map(|header| header.block_hash()).collect();\n                        self.request_blocks(blocks).await?;\n                    }\n                }\n                PeerMessages::Ready(version) =\u003e {\n                    debug!(\"handshake with peer={peer} succeeded\");\n                    self.handle_peer_ready(peer, \u0026version).await?;\n                }\n                PeerMessages::Disconnected(idx) =\u003e {\n                    self.handle_disconnection(peer, idx)?;\n                }\n                PeerMessages::Addr(addresses) =\u003e {\n                    debug!(\"Got {} addresses from peer {}\", addresses.len(), peer);\n                    let addresses: Vec\u003c_\u003e =\n                        addresses.iter().cloned().map(|addr| addr.into()).collect();\n                    self.address_man.push_addresses(\u0026addresses);\n                }\n                PeerMessages::BlockFilter((hash, filter)) =\u003e {\n                    debug!(\"Got a block filter from peer {}\", peer);\n                    let height = self.chain.get_block_height(\u0026hash)?.unwrap_or(0);\n                    self.block_filters\n                        .as_ref()\n                        .map(|filters| filters.push_filter(height, filter));\n                    if hash == self.last_filter {\n                        self.download_filters().await?;\n                    }\n                }\n                PeerMessages::NotFound(inv) =\u003e match inv {\n                    Inventory::Error =\u003e {}\n                    Inventory::Block(block)\n                    | Inventory::WitnessBlock(block)\n                    | Inventory::UtreexoBlock(block)\n                    | Inventory::UtreexoWitnessBlock(block)\n                    | Inventory::CompactBlock(block) =\u003e {\n                        self.1\n                            .user_requests\n                            .send_answer(UserRequest::Block(block), None);\n                    }\n\n                    Inventory::WitnessTransaction(tx) | Inventory::Transaction(tx) =\u003e {\n                        self.1\n                            .user_requests\n                            .send_answer(UserRequest::MempoolTransaction(tx), None);\n                    }\n                    _ =\u003e {}\n                },\n                PeerMessages::Transaction(tx) =\u003e {\n                    debug!(\"saw a mempool transaction with txid={}\", tx.txid());\n                    self.1.user_requests.send_answer(\n                        UserRequest::MempoolTransaction(tx.txid()),\n                        Some(NodeResponse::MempoolTransaction(tx)),\n                    );\n                }\n                PeerMessages::UtreexoState(_) =\u003e {\n                    warn!(\n                        \"Utreexo state received from peer {}, but we didn't ask\",\n                        peer\n                    );\n                    self.increase_banscore(peer, 5).await?;\n                }\n            },\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":56,"address":[1526320],"length":1,"stats":{"Line":0},"fn_name":"get_required_services"},{"line":57,"address":[1526325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[6336608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":607,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":612,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":613,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":614,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":619,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":620,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":626,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":627,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":628,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":645,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":647,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":650,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":651,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":652,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":655,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":659,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":661,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":662,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":671,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":672,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":673,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":676,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":677,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":678,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":680,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":682,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":689,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":690,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":691,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":695,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":698,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":706,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":707,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":709,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":712,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":713,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":716,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":717,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":718,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":719,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":727,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":728,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":729,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":731,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":735,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":737,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":740,"address":[6334416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":744,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":745,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":746,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":747,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":748,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":751,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":752,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":753,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":755,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":757,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":758,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":759,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":762,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":763,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":764,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":767,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":768,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":769,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":772,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":773,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":774,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":776,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":777,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":779,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":780,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":781,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":782,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":783,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":785,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":786,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":787,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":788,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":790,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":791,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":792,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":796,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":797,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":798,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":800,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":802,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":803,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":804,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":807,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":808,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":809,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":810,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":812,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":814,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":815,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":818,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":821,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":822,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":823,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":824,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":826,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":830,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":465},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","socks.rs"],"content":"//! A wrapper around a TCP stream that handles the SOCKS5 handshake. This module only\n//! drives the handshake and returns the stream back to the caller. It does not\n//! perform any I/O on the stream after the handshake is complete. The caller is\n//! responsible for performing I/O on the stream.\n//! This module is built on top of the `futures` crate instead of an specific\n//! async runtime. This allows the caller to use this module with any async runtime\n//! they want.\n\nuse std::net::Ipv4Addr;\nuse std::net::Ipv6Addr;\nuse std::net::SocketAddr;\n\nuse futures::AsyncRead;\nuse futures::AsyncReadExt;\nuse futures::AsyncWrite;\nuse futures::AsyncWriteExt;\n\n#[derive(Clone, Debug)]\npub struct Socks5StreamBuilder {\n    pub address: SocketAddr,\n}\n/// The version of the SOCKS protocol we support, only SOCKS5 is supported.\nconst SOCKS_VERSION: u8 = 5;\n/// The SOCKS authentication method we support, only no authentication is supported.\nconst SOCKS_AUTH_METHOD_NONE: u8 = 0;\n/// The cmd value for a SOCKS5 connect request.\nconst SOCKS_CMD_CONNECT: u8 = 1;\n/// Magic value to indicate an IPv4 address.\nconst SOCKS_ADDR_TYPE_IPV4: u8 = 1;\n/// Magic value to indicate a domain address.\nconst SOCKS_ADDR_TYPE_DOMAIN: u8 = 3;\n/// Magic value to indicate an IPv6 address.\nconst SOCKS_ADDR_TYPE_IPV6: u8 = 4;\n\n#[derive(Debug)]\n#[allow(dead_code)]\npub enum Socks5Addr {\n    Ipv4(Ipv4Addr),\n    Ipv6(Ipv6Addr),\n    Domain(Box\u003c[u8]\u003e),\n}\nimpl From\u003cSocks5Addr\u003e for u8 {\n    fn from(val: Socks5Addr) -\u003e Self {\n        match val {\n            Socks5Addr::Ipv4(_) =\u003e SOCKS_ADDR_TYPE_IPV4,\n            Socks5Addr::Ipv6(_) =\u003e SOCKS_ADDR_TYPE_IPV6,\n            Socks5Addr::Domain(_) =\u003e SOCKS_ADDR_TYPE_DOMAIN,\n        }\n    }\n}\nimpl Socks5StreamBuilder {\n    pub fn new(address: SocketAddr) -\u003e Self {\n        Self { address }\n    }\n    pub async fn connect\u003cStream: AsyncRead + AsyncWrite + Clone + Unpin\u003e(\n        mut socket: Stream,\n        address: Socks5Addr,\n        port: u16,\n    ) -\u003e Result\u003cStream, Socks5Error\u003e {\n        socket\n            .write_all(\u0026[SOCKS_VERSION, 1, SOCKS_AUTH_METHOD_NONE])\n            .await\n            .unwrap();\n        let address = match address {\n            Socks5Addr::Ipv4(addr) =\u003e addr.octets().to_vec(),\n            Socks5Addr::Ipv6(addr) =\u003e addr.octets().to_vec(),\n            Socks5Addr::Domain(domain) =\u003e {\n                let mut buf = vec![domain.len() as u8];\n                buf.extend_from_slice(\u0026domain);\n                buf\n            }\n        };\n        let mut buf = [0_u8; 2];\n        socket.read_exact(\u0026mut buf).await?;\n\n        if buf[0] != SOCKS_VERSION {\n            return Err(Socks5Error::InvalidVersion);\n        }\n\n        if buf[1] != SOCKS_AUTH_METHOD_NONE {\n            return Err(Socks5Error::InvalidAuthMethod);\n        }\n\n        socket\n            .write_all(\u0026[SOCKS_VERSION, SOCKS_CMD_CONNECT, 0, SOCKS_ADDR_TYPE_IPV4])\n            .await?;\n        socket.write_all(\u0026address).await?;\n        socket.write_all(\u0026port.to_be_bytes()).await?;\n\n        let mut buf = [0_u8; 4];\n        socket.read_exact(\u0026mut buf).await?;\n\n        if buf[0] != SOCKS_VERSION {\n            return Err(Socks5Error::InvalidVersion);\n        }\n        if buf[1] != 0 {\n            return Err(Socks5Error::ConnectionFailed);\n        }\n\n        match buf[3] {\n            SOCKS_ADDR_TYPE_IPV4 =\u003e {\n                let mut buf = [0_u8; 6];\n                socket.read_exact(\u0026mut buf).await?;\n            }\n            SOCKS_ADDR_TYPE_IPV6 =\u003e {\n                let mut buf = [0_u8; 18];\n                socket.read_exact(\u0026mut buf).await?;\n            }\n            SOCKS_ADDR_TYPE_DOMAIN =\u003e {\n                let mut buf = [0_u8; 1];\n                socket.read_exact(\u0026mut buf).await?;\n                let mut buf = vec![0_u8; buf[0] as usize + 2];\n                socket.read_exact(\u0026mut buf).await?;\n            }\n            _ =\u003e return Err(Socks5Error::ConnectionFailed),\n        }\n        Ok(socket)\n    }\n}\n#[derive(Debug)]\npub enum Socks5Error {\n    InvalidVersion,\n    InvalidAuthMethod,\n    ConnectionFailed,\n    InvalidAddress,\n    ReadError,\n}\n\nimpl From\u003cfutures::io::Error\u003e for Socks5Error {\n    fn from(_error: futures::io::Error) -\u003e Self {\n        Socks5Error::ReadError\n    }\n}\n","traces":[{"line":43,"address":[1635040],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":44,"address":[1635048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[1635080],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[1635087],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[1635094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[1635120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[3704352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[1635168],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":131,"address":[1635177],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":50},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","stream_reader.rs"],"content":"//! A simple async reader that reads data from a [Source] and builds a [Item] from it, assuming\n//! item is [Decodable]. The main intent of this module is to read [RawNetworkMessages] from [TcpStream], because\n//! we don't know how many bytes to read upfront, so we might read an incomplete message and try\n//! to deserialize it, causing unrelated error. This module first reads the message reader\n//! that has constant size (for RawNetworkMessage is 24). Then we look for payload size inside\n//! this header. With payload size we can finally read the entire message and return a parsed\n//! structure.\n\nuse std::marker::PhantomData;\n\nuse async_std::channel::Sender;\nuse async_std::io::ReadExt;\nuse bitcoin::consensus::deserialize;\nuse bitcoin::consensus::deserialize_partial;\nuse bitcoin::consensus::Decodable;\nuse bitcoin::p2p::Magic;\nuse futures::AsyncRead;\n\nuse super::peer::PeerError;\n\n/// A simple type that wraps a stream and returns T, if T is [Decodable].\npub struct StreamReader\u003cSource: Sync + Send + ReadExt + Unpin + AsyncRead, Item: Decodable + Send\u003e {\n    /// Were we read bytes from, usually a TcpStream\n    source: Source,\n    /// Item is what we return, since we don't actually hold any concrete type, just use a\n    /// phantom data to bind a type.\n    phantom: PhantomData\u003cItem\u003e,\n    /// Magic bits, we expect this at the beginning of all messages\n    magic: Magic,\n    /// Where should we send data\n    sender: Sender\u003cResult\u003cItem, PeerError\u003e\u003e,\n}\nimpl\u003cSource, Item\u003e StreamReader\u003cSource, Item\u003e\nwhere\n    Item: Decodable + Unpin + Send + 'static,\n    Source: Sync + Send + ReadExt + Unpin + AsyncRead,\n{\n    /// Creates a new reader from a given stream\n    pub fn new(stream: Source, magic: Magic, sender: Sender\u003cResult\u003cItem, PeerError\u003e\u003e) -\u003e Self {\n        StreamReader {\n            source: stream,\n            phantom: PhantomData,\n            magic,\n            sender,\n        }\n    }\n    async fn read_loop_inner(\u0026mut self) -\u003e Result\u003c(), PeerError\u003e {\n        loop {\n            let mut data: Vec\u003cu8\u003e = vec![0; 24];\n\n            // Read the reader first, so learn the payload size\n            self.source.read_exact(\u0026mut data).await?;\n            let header: P2PMessageHeader = deserialize_partial(\u0026data)?.0;\n            if header.magic != self.magic {\n                return Err(PeerError::MagicBitsMismatch);\n            }\n            // Network Message too big\n            if header.length \u003e (1024 * 1024 * 32) as u32 {\n                return Err(PeerError::MessageTooBig);\n            }\n\n            data.resize(24 + header.length as usize, 0);\n            // Read everything else\n            self.source.read_exact(\u0026mut data[24..]).await?;\n            let message = deserialize(\u0026data)?;\n            let _ = self.sender.send(Ok(message)).await;\n        }\n    }\n    /// Tries to read from a parsed [Item] from [Source]. Only returns on error or if we have\n    /// a valid Item to return\n    pub async fn read_loop(mut self) {\n        let value = self.read_loop_inner().await;\n        if let Err(e) = value {\n            let _ = self.sender.send(Err(e)).await;\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct P2PMessageHeader {\n    magic: Magic,\n    _command: [u8; 12],\n    length: u32,\n    _checksum: u32,\n}\nimpl Decodable for P2PMessageHeader {\n    fn consensus_decode\u003cR: std::io::Read + ?Sized\u003e(\n        reader: \u0026mut R,\n    ) -\u003e Result\u003cSelf, bitcoin::consensus::encode::Error\u003e {\n        let magic = Magic::consensus_decode(reader)?;\n        let _command = \u003c[u8; 12]\u003e::consensus_decode(reader)?;\n        let length = u32::consensus_decode(reader)?;\n        let _checksum = u32::consensus_decode(reader)?;\n        Ok(Self {\n            _checksum,\n            _command,\n            length,\n            magic,\n        })\n    }\n}\n","traces":[{"line":39,"address":[5056544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[5053520,5053599,5054358,5056511,5053698,5053552,5053653,5053528,5053810],"length":1,"stats":{"Line":0},"fn_name":"{async_fn#0}\u003casync_std::io::buf_reader::BufReader\u003casync_std::net::tcp::stream::TcpStream\u003e, bitcoin::p2p::message::RawNetworkMessage\u003e"},{"line":48,"address":[5053696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[5053777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[5053722,5054407,5054534,5053870,5053643,5054853,5056438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[5055067,5054922,5054814,5056436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[5055139,5055027],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[5055187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[5055145,5055255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[3828849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[5057589,5057866,5056758,5056909,5057898,5056842,5057035,5056624,5056713,5056688,5056641],"length":1,"stats":{"Line":0},"fn_name":"{async_fn#0}\u003casync_std::io::buf_reader::BufReader\u003casync_std::net::tcp::stream::TcpStream\u003e, bitcoin::p2p::message::RawNetworkMessage\u003e"},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[3826123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[5052752],"length":1,"stats":{"Line":0},"fn_name":"consensus_decode\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":28},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","sync_node.rs"],"content":"//! A node that downlaods and validates the blockchain.\n\nuse std::sync::Arc;\nuse std::time::Duration;\nuse std::time::Instant;\n\nuse async_std::future::timeout;\nuse async_std::sync::RwLock;\nuse bitcoin::p2p::utreexo::UtreexoBlock;\nuse bitcoin::p2p::ServiceFlags;\nuse floresta_chain::pruned_utreexo::BlockchainInterface;\nuse floresta_chain::pruned_utreexo::UpdatableChainstate;\nuse floresta_chain::BlockValidationErrors;\nuse floresta_chain::BlockchainError;\nuse log::debug;\nuse log::error;\nuse log::info;\n\nuse super::error::WireError;\nuse super::peer::PeerMessages;\nuse crate::address_man::AddressState;\nuse crate::node::periodic_job;\nuse crate::node::try_and_log;\nuse crate::node::InflightRequests;\nuse crate::node::NodeNotification;\nuse crate::node::NodeRequest;\nuse crate::node::UtreexoNode;\nuse crate::node_context::NodeContext;\nuse crate::node_context::PeerId;\n\n#[derive(Clone, Debug, Default)]\npub struct SyncNode {\n    last_block_requested: u32,\n}\n\nimpl NodeContext for SyncNode {\n    fn get_required_services(\u0026self) -\u003e bitcoin::p2p::ServiceFlags {\n        ServiceFlags::WITNESS | ServiceFlags::UTREEXO | ServiceFlags::NETWORK\n    }\n\n    const MAX_OUTGOING_PEERS: usize = 5; // don't need many peers, half the default\n    const TRY_NEW_CONNECTION: u64 = 10; // ten seconds\n    const REQUEST_TIMEOUT: u64 = 30; // 30 seconds\n    const MAX_INFLIGHT_REQUESTS: usize = 100; // double the default\n}\n\nimpl\u003cChain\u003e UtreexoNode\u003cSyncNode, Chain\u003e\nwhere\n    WireError: From\u003c\u003cChain as BlockchainInterface\u003e::Error\u003e,\n    Chain: BlockchainInterface + UpdatableChainstate + 'static,\n{\n    pub async fn run(\u0026mut self, kill_signal: Arc\u003cRwLock\u003cbool\u003e\u003e, done_cb: impl FnOnce(\u0026Chain)) {\n        info!(\"Starting sync node\");\n        self.1.last_block_requested = self.chain.get_validation_index().unwrap();\n        loop {\n            while let Ok(Ok(msg)) = timeout(Duration::from_secs(1), self.node_rx.recv()).await {\n                self.handle_message(msg).await;\n            }\n\n            if *kill_signal.read().await {\n                break;\n            }\n\n            if !self.chain.is_in_idb() {\n                break;\n            }\n\n            periodic_job!(\n                self.maybe_open_connection().await,\n                self.last_connection,\n                TRY_NEW_CONNECTION,\n                SyncNode\n            );\n\n            self.handle_timeout().await;\n\n            if self.has_utreexo_peers() {\n                continue;\n            }\n\n            if self.inflight.len() \u003c SyncNode::MAX_INFLIGHT_REQUESTS {\n                let mut blocks = Vec::with_capacity(100);\n                for _ in 0..100 {\n                    let next_block = self.1.last_block_requested + 1;\n                    let next_block = self.chain.get_block_hash(next_block);\n                    match next_block {\n                        Ok(next_block) =\u003e {\n                            blocks.push(next_block);\n                            self.1.last_block_requested += 1;\n                        }\n                        Err(_) =\u003e {\n                            break;\n                        }\n                    }\n                }\n                try_and_log!(self.request_blocks(blocks).await);\n            }\n        }\n\n        done_cb(\u0026self.chain);\n    }\n\n    async fn handle_timeout(\u0026mut self) {\n        let mut to_remove = Vec::new();\n        for (block, (peer, when)) in self.inflight.iter() {\n            if when.elapsed().as_secs() \u003e SyncNode::REQUEST_TIMEOUT {\n                to_remove.push((*peer, block.clone()));\n            }\n        }\n\n        for (peer, block) in to_remove {\n            self.inflight.remove(\u0026block);\n            try_and_log!(self.increase_banscore(peer, 1).await);\n\n            let InflightRequests::Blocks(block) = block else {\n                continue;\n            };\n            try_and_log!(self.request_blocks(vec![block]).await);\n        }\n    }\n\n    async fn handle_block_data(\n        \u0026mut self,\n        peer: PeerId,\n        block: UtreexoBlock,\n    ) -\u003e Result\u003c(), WireError\u003e {\n        self.inflight\n            .remove(\u0026InflightRequests::Blocks(block.block.block_hash()));\n\n        self.blocks.insert(block.block.block_hash(), (peer, block));\n\n        let next_block = self.chain.get_validation_index()? + 1;\n        let mut next_block = self.chain.get_block_hash(next_block)?;\n\n        while let Some((peer, block)) = self.blocks.remove(\u0026next_block) {\n            if block.udata.is_none() {\n                error!(\"Block without proof received from peer {}\", peer);\n                self.send_to_peer(peer, NodeRequest::Shutdown).await?;\n                self.send_to_random_peer(\n                    NodeRequest::GetBlock((vec![block.block.block_hash()], true)),\n                    ServiceFlags::UTREEXO,\n                )\n                .await?;\n                self.inflight\n                    .insert(InflightRequests::Blocks(next_block), (peer, Instant::now()));\n                return Err(WireError::PeerMisbehaving);\n            }\n\n            debug!(\"processing block {}\", block.block.block_hash(),);\n            let (proof, del_hashes, inputs) = floresta_chain::proof_util::process_proof(\n                \u0026block.udata.unwrap(),\n                \u0026block.block.txdata,\n                \u0026self.chain,\n            )?;\n\n            if let Err(e) = self\n                .chain\n                .connect_block(\u0026block.block, proof, inputs, del_hashes)\n            {\n                error!(\"Invalid block received by peer {} reason: {:?}\", peer, e);\n\n                if let BlockchainError::BlockValidation(e) = e {\n                    // Because the proof isn't committed to the block, we can't invalidate\n                    // it if the proof is invalid. Any other error should cause the block\n                    // to be invalidated.\n                    match e {\n                        BlockValidationErrors::InvalidTx(_)\n                        | BlockValidationErrors::NotEnoughPow\n                        | BlockValidationErrors::BadMerkleRoot\n                        | BlockValidationErrors::BadWitnessCommitment\n                        | BlockValidationErrors::NotEnoughMoney\n                        | BlockValidationErrors::FirstTxIsnNotCoinbase\n                        | BlockValidationErrors::BadCoinbaseOutValue\n                        | BlockValidationErrors::EmptyBlock\n                        | BlockValidationErrors::BlockExtendsAnOrphanChain\n                        | BlockValidationErrors::BadBip34\n                        | BlockValidationErrors::CoinbaseNotMatured =\u003e {\n                            self.send_to_peer(peer, NodeRequest::Shutdown).await?;\n                            try_and_log!(self.chain.invalidate_block(block.block.block_hash()));\n                        }\n                        BlockValidationErrors::InvalidProof =\u003e {}\n                    }\n                }\n\n                // Disconnect the peer and ban it.\n                if let Some(peer) = self.peers.get(\u0026peer).cloned() {\n                    self.address_man.update_set_state(\n                        peer.address_id as usize,\n                        AddressState::Banned(SyncNode::BAN_TIME),\n                    );\n                }\n                self.send_to_peer(peer, NodeRequest::Shutdown).await?;\n                return Err(WireError::PeerMisbehaving);\n            }\n\n            let next = self.chain.get_validation_index()? + 1;\n\n            match self.chain.get_block_hash(next) {\n                Ok(_next_block) =\u003e next_block = _next_block,\n                Err(_) =\u003e break,\n            }\n            debug!(\"accepted block {}\", block.block.block_hash());\n        }\n\n        Ok(())\n    }\n\n    async fn handle_message(\u0026mut self, msg: NodeNotification) {\n        match msg {\n            NodeNotification::FromPeer(peer, notification) =\u003e match notification {\n                PeerMessages::Block(block) =\u003e {\n                    if let Err(e) = self.handle_block_data(peer, block).await {\n                        error!(\"Error processing block: {:?}\", e);\n                    }\n                }\n                PeerMessages::Ready(version) =\u003e {\n                    try_and_log!(self.handle_peer_ready(peer, \u0026version).await);\n                }\n                PeerMessages::Disconnected(idx) =\u003e {\n                    try_and_log!(self.handle_disconnection(peer, idx));\n                }\n                _ =\u003e {}\n            },\n        }\n    }\n}\n","traces":[{"line":37,"address":[1744784],"length":1,"stats":{"Line":0},"fn_name":"get_required_services"},{"line":38,"address":[1744789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[6450832,6450736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":108},{"path":["/","home","dane","Desktop","SOB","Floresta","florestad","src","cli.rs"],"content":"use clap::arg;\nuse clap::command;\nuse clap::Parser;\nuse clap::Subcommand;\nuse clap::ValueEnum;\n\n#[derive(Clone, Debug, ValueEnum, Default)]\npub enum Network {\n    #[default]\n    Bitcoin,\n    Signet,\n    Testnet,\n    Regtest,\n}\n\nimpl std::fmt::Display for Network {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Network::Bitcoin =\u003e write!(f, \"bitcoin\"),\n            Network::Signet =\u003e write!(f, \"signet\"),\n            Network::Testnet =\u003e write!(f, \"testnet\"),\n            Network::Regtest =\u003e write!(f, \"regtest\"),\n        }\n    }\n}\n#[derive(Parser)]\n#[command(author, version, about, long_about = None)]\npub struct Cli {\n    /// Sets a custom config file\n    #[arg(short, long, value_name = \"FILE\")]\n    pub config_file: Option\u003cString\u003e,\n    /// Which network should we use\n    #[arg(short, long, default_value_t=Network::Bitcoin)]\n    pub network: Network,\n    /// Turn debugging information on\n    #[arg(short, long, action = clap::ArgAction::Count)]\n    pub debug: u8,\n\n    /// option for saving log into data_Dir\n    /// if set, log will be saved into dataDir/output.log\n    #[arg(long)]\n    pub log_file: bool,\n\n    #[command(subcommand)]\n    pub command: Option\u003cCommands\u003e,\n}\n\n#[derive(Subcommand)]\npub enum Commands {\n    #[cfg(not(feature = \"experimental-p2p\"))]\n    /// Starts your wallet and server\n    Run {\n        /// Where should we store data\n        #[arg(long)]\n        data_dir: Option\u003cString\u003e,\n        /// Add a xpub to our wallet\n        #[arg(long)]\n        wallet_xpub: Option\u003cVec\u003cString\u003e\u003e,\n        /// Add individual addresses to your wallet\n        #[arg(long)]\n        wallet_addresses: Option\u003cVec\u003cString\u003e\u003e,\n        /// Your rpc user, as set in Utreexod\n        #[arg(long)]\n        rpc_user: Option\u003cString\u003e,\n        /// Your rpc password, as set in Utreexod\n        #[arg(long)]\n        rpc_password: Option\u003cString\u003e,\n        /// The hostname:port of Utreexod\n        #[arg(short, long)]\n        rpc_host: Option\u003cString\u003e,\n        #[arg(long)]\n        rpc_port: Option\u003cu32\u003e,\n        /// Whether or not we want to sync with a external provider\n        #[arg(long, default_value_t = false)]\n        use_batch_sync: bool,\n        /// If use_batch_sync is set, this option provides which server we use\n        #[arg(long)]\n        batch_sync: Option\u003cString\u003e,\n        /// Assume blocks before this one as having valid signatures, same with bitcoin core\n        #[arg(long)]\n        assume_valid: Option\u003cString\u003e,\n    },\n    #[cfg(feature = \"experimental-p2p\")]\n    /// Starts your wallet and server\n    #[command(author, version, about, long_about = None)]\n    Run {\n        /// Where should we store data\n        #[arg(long)]\n        data_dir: Option\u003cString\u003e,\n        /// Whether to build Compact Block Filters\n        ///\n        /// Those filters let you query for chain data after IBD, like wallet rescan,\n        /// finding an utxo, finding specific tx_ids.\n        /// Will cause more disk usage\n        #[arg(long = \"cfilters\", short = 'c', default_value_t = true)]\n        cfilters: bool,\n        #[arg(long, short, default_value = None)]\n        /// The url of a proxy we should open p2p connections through (e.g. 127.0.0.1:9050)\n        proxy: Option\u003cString\u003e,\n        #[arg(long, short, default_value = None)]\n        rescan: Option\u003cu32\u003e,\n        /// Add a xpub to our wallet\n        #[arg(long)]\n        wallet_xpub: Option\u003cVec\u003cString\u003e\u003e,\n        #[arg(long)]\n        wallet_descriptor: Option\u003cVec\u003cString\u003e\u003e,\n        /// Assume blocks before this one as having valid signatures, same with bitcoin core\n        #[arg(long)]\n        assume_valid: Option\u003cString\u003e,\n        #[arg(long, short)]\n        zmq_address: Option\u003cString\u003e,\n        #[arg(long)]\n        connect: Option\u003cString\u003e,\n        #[arg(long)]\n        rpc_address: Option\u003cString\u003e,\n        #[arg(long)]\n        electrum_address: Option\u003cString\u003e,\n    },\n}\n","traces":[{"line":17,"address":[3077648],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":18,"address":[3077675],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[3077706],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[3077754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[3077799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[3077844],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","home","dane","Desktop","SOB","Floresta","florestad","src","config_file.rs"],"content":"use serde::Deserialize;\n\n#[derive(Default, Debug, Deserialize)]\npub struct Wallet {\n    pub xpubs: Option\u003cVec\u003cString\u003e\u003e,\n    pub descriptors: Option\u003cVec\u003cString\u003e\u003e,\n    pub addresses: Option\u003cVec\u003cString\u003e\u003e,\n}\n\n#[derive(Default, Debug, Deserialize)]\npub struct ConfigFile {\n    pub wallet: Wallet,\n}\n\nimpl ConfigFile {\n    pub fn from_file(filename: \u0026str) -\u003e Result\u003cSelf, crate::error::Error\u003e {\n        let file = std::fs::read_to_string(filename)?;\n        Ok(toml::from_str(\u0026file)?)\n    }\n}\n","traces":[{"line":16,"address":[3663600,3664064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[3663633,3663758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[3663737,3663846,3663970],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["/","home","dane","Desktop","SOB","Floresta","florestad","src","error.rs"],"content":"use bitcoin::consensus::encode;\n#[cfg(feature = \"cli-blockchain\")]\nuse btcd_rpc::error::UtreexodError;\nuse floresta_chain::BlockValidationErrors;\nuse floresta_chain::BlockchainError;\n\nuse crate::slip132;\n#[derive(Debug)]\npub enum Error {\n    #[cfg(feature = \"cli-blockchain\")]\n    UtreexodError(UtreexodError),\n    Encode(encode::Error),\n    Db(kv::Error),\n    ParseNum(std::num::ParseIntError),\n    Rustreexo(String),\n    Io(std::io::Error),\n    BlockValidation(BlockValidationErrors),\n    ScriptValidation(bitcoin::blockdata::script::Error),\n    Blockchain(BlockchainError),\n    SerdeJson(serde_json::Error),\n    TomlParsing(toml::de::Error),\n    WalletInput(slip132::Error),\n    AddressParsing(bitcoin::address::ParseError),\n    Address(bitcoin::address::Error),\n    Miniscript(miniscript::Error),\n}\n\nimpl std::fmt::Display for Error {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Error::Encode(err) =\u003e write!(f, \"Encode error: {err}\"),\n            #[cfg(feature = \"cli-blockchain\")]\n            Error::UtreexodError(_) =\u003e write!(f, \"UtreexodError\"),\n            Error::Db(err) =\u003e write!(f, \"Database error {err}\"),\n            Error::ParseNum(err) =\u003e write!(f, \"int parse error: {err}\"),\n            Error::Rustreexo(err) =\u003e write!(f, \"Rustreexo error: {err}\"),\n            Error::Io(err) =\u003e write!(f, \"Io error {err}\"),\n            Error::ScriptValidation(err) =\u003e write!(f, \"Error during script evaluation: {err}\"),\n            Error::Blockchain(err) =\u003e write!(f, \"Error with our blockchain backend: {:?}\", err),\n            Error::SerdeJson(err) =\u003e write!(f, \"Error serializing object {err}\"),\n            Error::WalletInput(err) =\u003e write!(f, \"Error while parsing user input {:?}\", err),\n            Error::TomlParsing(err) =\u003e write!(f, \"Error deserializing toml file {err}\"),\n            Error::AddressParsing(err) =\u003e write!(f, \"Invalid address {err}\"),\n            Error::Miniscript(err) =\u003e write!(f, \"Miniscript error: {err}\"),\n            Error::BlockValidation(err) =\u003e write!(f, \"Error while validating block: {err:?}\"),\n            Error::Address(err) =\u003e write!(f, \"Error while validating address: {err}\"),\n        }\n    }\n}\n/// Implements `From\u003cT\u003e` where `T` is a possible error outcome in this crate, this macro only\n/// takes [T] and builds [Error] with the right variant.\nmacro_rules! impl_from_error {\n    ($field:ident, $error:ty) =\u003e {\n        impl From\u003c$error\u003e for Error {\n            fn from(err: $error) -\u003e Self {\n                Error::$field(err)\n            }\n        }\n    };\n}\n// impl_from_error!(Parsing, bitcoin::hashes::hex::Error);\n#[cfg(feature = \"cli-blockchain\")]\nimpl_from_error!(UtreexodError, UtreexodError);\nimpl_from_error!(Encode, encode::Error);\nimpl_from_error!(Db, kv::Error);\nimpl_from_error!(ParseNum, std::num::ParseIntError);\nimpl_from_error!(Rustreexo, String);\nimpl_from_error!(Io, std::io::Error);\nimpl_from_error!(ScriptValidation, bitcoin::blockdata::script::Error);\nimpl_from_error!(Blockchain, BlockchainError);\nimpl_from_error!(SerdeJson, serde_json::Error);\nimpl_from_error!(WalletInput, slip132::Error);\nimpl_from_error!(TomlParsing, toml::de::Error);\nimpl_from_error!(BlockValidation, BlockValidationErrors);\nimpl_from_error!(AddressParsing, bitcoin::address::ParseError);\nimpl_from_error!(Miniscript, miniscript::Error);\nimpl_from_error!(Address, bitcoin::address::Error);\n\nimpl std::error::Error for Error {}\n","traces":[{"line":29,"address":[3018000],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":30,"address":[5348945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[3018084,3018153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[3018226,3018291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[5349359,5349285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[3346722,3346647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[3346885,3346810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[3347211,3347136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[3347374,3347299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[5350337,5350262],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[3019751,3019676],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[5350500,5350425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[3019914,3019839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[3348277,3348352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[3346973,3347048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[3348114,3348189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[3349872,3349456,3349536,3349424,3349488,3349712,3349728,3349664,3349600,3349392,3349808,3349520,3349680,3349776],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":56,"address":[3349432,3349553,3349466,3349720,3349672,3349825,3349395,3349528,3349617,3349491,3349683,3349731,3349779,3349889],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":18},{"path":["/","home","dane","Desktop","SOB","Floresta","florestad","src","florestad.rs"],"content":"use std::fmt::Arguments;\nuse std::path::PathBuf;\nuse std::process::exit;\nuse std::str::FromStr;\nuse std::sync::Arc;\nuse std::sync::Mutex;\nuse std::sync::OnceLock;\n\nuse async_std::sync::RwLock;\nuse async_std::task;\nuse async_std::task::block_on;\npub use bitcoin::Network;\nuse fern::colors::Color;\nuse fern::colors::ColoredLevelConfig;\nuse fern::FormatCallback;\nuse floresta_chain::pruned_utreexo::BlockchainInterface;\nuse floresta_chain::AssumeValidArg;\nuse floresta_chain::BlockchainError;\nuse floresta_chain::ChainState;\nuse floresta_chain::KvChainStore;\nuse floresta_common::constants::DIR_NAME;\nuse floresta_compact_filters::kv_filter_database::KvFilterStore;\nuse floresta_compact_filters::network_filters::NetworkFilters;\nuse floresta_electrum::electrum_protocol::client_accept_loop;\nuse floresta_electrum::electrum_protocol::ElectrumServer;\nuse floresta_watch_only::kv_database::KvDatabase;\nuse floresta_watch_only::AddressCache;\nuse floresta_watch_only::AddressCacheDatabase;\nuse floresta_wire::address_man::LocalAddress;\nuse floresta_wire::mempool::Mempool;\nuse floresta_wire::node::UtreexoNode;\nuse floresta_wire::UtreexoNodeConfig;\nuse futures::channel::oneshot;\nuse log::debug;\nuse log::error;\nuse log::info;\nuse log::Record;\n#[cfg(feature = \"zmq-server\")]\nuse zmq::ZMQServer;\n\nuse crate::cli;\nuse crate::config_file::ConfigFile;\nuse crate::json_rpc;\nuse crate::wallet_input::InitialWalletSetup;\n\n#[derive(Default, Clone)]\n/// General configuration for the floresta daemon.\n///\n/// Those configs should be passed in by anyone that wants to start a floresta instance. Some of\n/// these are also exposed through the config file.\npub struct Config {\n    /// Where we should place our data\n    ///\n    /// This directory must be readable and writable by our proccess. We'll use this dir to store\n    /// both chain and wallet data, so this should be kept in a non-volatile medium. We are not\n    /// particurly aggressive in disk usage, so we don't need a fast disk to work.\n    ///\n    /// If not set, it defaults to $HOME/.floresta\n    pub data_dir: Option\u003cString\u003e,\n    /// We consider blocks prior to this one to have a valid signature\n    ///\n    /// This is a optimization mirrowed from Core, where blocks before this one are considered to\n    /// have valid signatures. The idea here is that if a block is burried under a lot of PoW, it's\n    /// very unlikely that it is invalid. We still validate everything else and build the\n    /// accumulator until this point (unless running on PoW-fraud proof or assumeutreexo mode) so\n    /// there's still some work to do.\n    pub assume_valid: Option\u003cString\u003e,\n    /// A vector of xpubs to cache\n    ///\n    /// This is a list of SLIP-132-encoded extended public key that we should add to our Watch-only\n    /// wallet. A descriptor may be only passed one time, if you call florestad with an already\n    /// cached address, that will be a no-op. After a xpub is cached, we derive multiple addresses\n    /// from it and try to find transactions involving it.\n    pub wallet_xpub: Option\u003cVec\u003cString\u003e\u003e,\n    /// A output descriptor to cache\n    ///\n    /// This should be a list of ouptut descriptors that we should add to our watch-only wallet.\n    /// This works just like wallet_xpub, but with a descriptor.\n    pub wallet_descriptor: Option\u003cVec\u003cString\u003e\u003e,\n    /// Whether we should rescan for wallet transactions\n    ///\n    /// If your wallet is missing some transaction (e.g. you've just added a new address), you can\n    /// set this value to some height, and we'll rescan from this block to the tip.\n    pub rescan: Option\u003cu32\u003e,\n    /// Where should we read from a config file\n    ///\n    /// This is a toml-encoded file with floresta's configs. For a sample of how this file looks\n    /// like, see config.toml.sample inside floresta's codebase.\n    ///\n    /// If a setting is modified by the config file and this config struct, the following logic is\n    /// used:\n    ///     - For vectors, we use the combination of both vectors\n    ///     - for mutually exclusive options, this struct has precedense over the config file\n    pub config_file: Option\u003cString\u003e,\n    /// A proxy that we should use to connect with others\n    ///\n    /// This should be a socks5 proxy, like Tor's socks. If provided, all our outgoing connections\n    /// will be made through this one, except dns seed connections.\n    pub proxy: Option\u003cString\u003e,\n    /// The network we are running in, it may be one of: bitcoin, signet, regtest or testnet.\n    pub network: cli::Network,\n    /// Whther we should build and store compact block filters\n    ///\n    /// Those filters are used for rescanning our wallet for historical transactions. If you don't\n    /// have this on, the only way to find historical transactions is to download all blocks, which\n    /// is very inefficient and resource/time consuming. But keep in mind that filters will take\n    /// up disk space.\n    pub cfilters: bool,\n    #[cfg(feature = \"zmq-server\")]\n    /// The address to listen to for our ZMQ server\n    ///\n    /// We have an (optional) ZMQ server, that pushes new blocks over a PUSH/PULL ZMQ queue, this\n    /// is the address that we'll listen for incomming connections.\n    pub zmq_address: Option\u003cString\u003e,\n    pub connect: Option\u003cString\u003e,\n    #[cfg(feature = \"json-rpc\")]\n    /// The address our json-rpc should listen to\n    pub json_rpc_address: Option\u003cString\u003e,\n    /// The address our electrum server should listen to\n    pub electrum_address: Option\u003cString\u003e,\n    /// Whether we should write logs to the stdio\n    pub log_to_stdout: bool,\n    //// Whether we should log to a fs file\n    pub log_to_file: bool,\n}\n\npub struct Florestad {\n    /// The config used by this node, see [Config] for more details\n    config: Config,\n    /// A channel that tells others to stop what they are doing because we\n    /// are about to die\n    stop_signal: Arc\u003cRwLock\u003cbool\u003e\u003e,\n    /// A channel that notifies we are done, and it's safe to die now\n    stop_notify: Arc\u003cMutex\u003cOption\u003coneshot::Receiver\u003c()\u003e\u003e\u003e\u003e,\n    /// A handle to our json-rpc server\n    json_rpc: OnceLock\u003cjsonrpc_http_server::Server\u003e,\n}\n\nimpl Florestad {\n    /// Kills a running florestad, this will return as soon as the main node stops.\n    ///\n    /// It's not safe to stop you program before this thread returns because some\n    /// information may not be fully flushed to disk yet, and killing the process\n    /// before flushing everything is equivalent to an unclean shutdown.\n    #[allow(unused)]\n    pub fn stop(\u0026self) {\n        async_std::task::block_on(async move {\n            *self.stop_signal.write().await = true;\n            let chan = {\n                let mut guard = self.stop_notify.lock().unwrap();\n                std::mem::take(\u0026mut *guard)\n            };\n            if let Some(chan) = chan {\n                if let Err(e) = chan.await {\n                    error!(\"POSSIBLE BUG: unexpected error while shutting down {e:?}\");\n                }\n            }\n        });\n    }\n\n    pub fn get_stop_signal(\u0026self) -\u003e Arc\u003cRwLock\u003cbool\u003e\u003e {\n        self.stop_signal.clone()\n    }\n\n    pub async fn wait_shutdown(\u0026self) {\n        let chan = {\n            let mut guard = self.stop_notify.lock().unwrap();\n            std::mem::take(\u0026mut *guard)\n        };\n        if let Some(chan) = chan {\n            if let Err(e) = chan.await {\n                error!(\"POSSIBLE BUG: unexpected error while shutting down {e:?}\");\n            }\n        }\n    }\n\n    /// Actually runs florestad, spawning all modules and waiting util\n    /// someone asks to stop.\n    pub fn start(\u0026self) {\n        // Setup global logger\n        let data_dir = self\n            .config\n            .data_dir\n            .clone()\n            .or_else(|| {\n                dirs::home_dir().map(|x: PathBuf| {\n                    format!(\n                        \"{}/{}/\",\n                        x.to_str().unwrap_or_default().to_owned(),\n                        DIR_NAME,\n                    )\n                })\n            })\n            .unwrap_or(\"floresta\".into());\n\n        if self.config.log_to_stdout || self.config.log_to_file {\n            Self::setup_logger(\u0026data_dir, self.config.log_to_file)\n                .expect(\"failure to setup logger\");\n        }\n\n        let data_dir = match self.config.network {\n            cli::Network::Bitcoin =\u003e data_dir,\n            cli::Network::Signet =\u003e data_dir + \"/signet/\",\n            cli::Network::Testnet =\u003e data_dir + \"/testnet3/\",\n            cli::Network::Regtest =\u003e data_dir + \"/regtest/\",\n        };\n\n        // The config file inside our datadir directory. Any datadir\n        // passed as argument will be used instead\n        let system_config_file = format!(\"{data_dir}/config.toml\");\n        let config_file = match \u0026self.config.config_file {\n            Some(path) =\u003e Self::get_config_file(path),\n            None =\u003e Self::get_config_file(\u0026system_config_file),\n        };\n\n        // Load the watch-only wallet\n        debug!(\"Loading wallet\");\n        let mut wallet = Self::load_wallet(\u0026data_dir);\n        wallet.setup().expect(\"Could not initialize wallet\");\n        debug!(\"Done loading wallet\");\n\n        // Try to add more wallets to watch if needed\n        let result = Self::setup_wallet(\n            Self::get_both_vec(self.config.wallet_xpub.clone(), config_file.wallet.xpubs),\n            Self::get_both_vec(\n                self.config.wallet_descriptor.clone(),\n                config_file.wallet.descriptors,\n            ),\n            Self::get_both_vec(config_file.wallet.addresses.clone(), None),\n            \u0026mut wallet,\n            self.config.network.clone(),\n        );\n\n        if let Err(e) = result {\n            log::error!(\"Something went wrong while setting wallet up: {e}\");\n            return;\n        }\n\n        info!(\"loading blockchain database\");\n\n        let blockchain_state = Arc::new(Self::load_chain_state(\n            \u0026data_dir,\n            Self::get_net(\u0026self.config.network),\n            self.config\n                .assume_valid\n                .as_ref()\n                .map(|value| value.parse().expect(\"invalid assumevalid\")),\n        ));\n\n        if let Some(height) = self.config.rescan {\n            blockchain_state\n                .rescan(height)\n                .expect(\"Fail while setting rescan\");\n        }\n\n        #[cfg(feature = \"compact-filters\")]\n        let cfilters = if self.config.cfilters {\n            // Block Filters\n            let filter_store = KvFilterStore::new(\u0026(data_dir.clone() + \"/cfilters\").into());\n            Some(Arc::new(NetworkFilters::new(filter_store, 0)))\n        } else {\n            None\n        };\n        #[cfg(not(feature = \"compact-filters\"))]\n        let cfilters = None;\n\n        // Handle the `-connect` cli option\n        let connect = match self\n            .config\n            .clone()\n            .connect\n            .map(|host| LocalAddress::from_str(\u0026host))\n        {\n            Some(Ok(host)) =\u003e {\n                debug!(\"Connecting to {:?}\", host);\n                Some(host)\n            }\n            Some(Err(e)) =\u003e {\n                error!(\"Invalid host: {}\", e);\n                exit(-1);\n            }\n            None =\u003e None,\n        };\n\n        // For now we only have compatible bridges on signet\n        let pow_fraud_proofs = match self.config.network {\n            cli::Network::Bitcoin =\u003e false,\n            cli::Network::Signet =\u003e true,\n            cli::Network::Testnet =\u003e false,\n            cli::Network::Regtest =\u003e false,\n        };\n\n        let config = UtreexoNodeConfig {\n            network: Self::get_net(\u0026self.config.network),\n            pow_fraud_proofs,\n            proxy: self\n                .config\n                .proxy\n                .as_ref()\n                .map(|address| address.parse().expect(\"Invalid address\")),\n            datadir: data_dir,\n            fixed_peer: connect,\n            max_banscore: 50,\n            compact_filters: self.config.cfilters,\n            max_outbound: 10,\n            max_inflight: 20,\n            assume_utreexo: None,\n            backfill: false,\n        };\n\n        // Chain Provider (p2p)\n        let chain_provider = UtreexoNode::new(\n            config,\n            blockchain_state.clone(),\n            Arc::new(async_std::sync::RwLock::new(Mempool::new())),\n            cfilters.clone(),\n        );\n\n        // ZMQ\n        #[cfg(feature = \"zmq-server\")]\n        {\n            info!(\"Starting ZMQ server\");\n            if let Ok(zserver) =\n                ZMQServer::new(\u0026ctx.zmq_address.unwrap_or(\"tcp://127.0.0.1:5150\".into()))\n            {\n                blockchain_state.subscribe(Arc::new(zserver));\n                info!(\"Done!\");\n            } else {\n                error!(\"Could not create zmq server, skipping\");\n            };\n        }\n\n        info!(\"Starting server\");\n        let wallet = Arc::new(RwLock::new(wallet));\n\n        // JSON-RPC\n        #[cfg(feature = \"json-rpc\")]\n        {\n            let server = json_rpc::server::RpcImpl::create(\n                blockchain_state.clone(),\n                wallet.clone(),\n                chain_provider.get_handle(),\n                self.stop_signal.clone(),\n                Self::get_net(\u0026self.config.network),\n                cfilters.clone(),\n                self.config\n                    .json_rpc_address\n                    .as_ref()\n                    .map(|x| x.parse().expect(\"Invalid json rpc address\")),\n            );\n\n            if self.json_rpc.set(server).is_err() {\n                panic!(\"we should be the first one setting this\");\n            }\n        }\n\n        // Electrum\n        let electrum_address = self\n            .config\n            .electrum_address\n            .clone()\n            .unwrap_or(\"0.0.0.0:50001\".into());\n\n        let electrum_server = block_on(ElectrumServer::new(\n            electrum_address,\n            wallet,\n            blockchain_state,\n            cfilters,\n            chain_provider.get_handle(),\n        ))\n        .expect(\"Could not create an Electrum Server\");\n\n        // Spawn all services\n\n        // Electrum accept loop\n        task::spawn(client_accept_loop(\n            electrum_server.tcp_listener.clone(),\n            electrum_server.message_transmitter.clone(),\n        ));\n        // Electrum main loop\n        task::spawn(electrum_server.main_loop());\n        info!(\"Server running on: 0.0.0.0:50001\");\n\n        // Chain provider\n        let kill_signal = self.stop_signal.clone();\n        let (sender, receiver) = oneshot::channel();\n\n        let mut recv = self.stop_notify.lock().unwrap();\n        *recv = Some(receiver);\n\n        task::spawn(chain_provider.run(kill_signal, sender));\n    }\n\n    fn setup_logger(data_dir: \u0026String, log_file: bool) -\u003e Result\u003c(), fern::InitError\u003e {\n        let colors = ColoredLevelConfig::new()\n            .error(Color::Red)\n            .warn(Color::Yellow)\n            .info(Color::Green)\n            .debug(Color::Blue)\n            .trace(Color::BrightBlack);\n\n        let formatter = |use_colors: bool| {\n            move |out: FormatCallback, message: \u0026Arguments, record: \u0026Record| {\n                out.finish(format_args!(\n                    \"[{} {} {}] {}\",\n                    chrono::Local::now().format(\"%Y-%m-%d %H:%M:%S\"),\n                    match use_colors {\n                        true =\u003e colors.color(record.level()).to_string(),\n                        false =\u003e record.level().to_string(),\n                    },\n                    record.target(),\n                    message\n                ))\n            }\n        };\n        let stdout_dispatcher = fern::Dispatch::new()\n            .format(formatter(true))\n            .level(log::LevelFilter::Info)\n            .chain(std::io::stdout());\n\n        match log_file {\n            true =\u003e {\n                let file_dispatcher = fern::Dispatch::new()\n                    .format(formatter(false))\n                    .level(log::LevelFilter::Info)\n                    .chain(fern::log_file(format!(\"{}/output.log\", data_dir))?);\n                fern::Dispatch::new()\n                    .chain(stdout_dispatcher)\n                    .chain(file_dispatcher)\n                    .apply()?;\n            }\n            false =\u003e {\n                fern::Dispatch::new().chain(stdout_dispatcher).apply()?;\n            }\n        }\n\n        Ok(())\n    }\n\n    pub fn from_config(config: Config) -\u003e Self {\n        Self {\n            config,\n            stop_signal: Arc::new(RwLock::new(false)),\n            stop_notify: Arc::new(Mutex::new(None)),\n            json_rpc: OnceLock::new(),\n        }\n    }\n\n    pub fn new() -\u003e Self {\n        Self::from_config(Config::default())\n    }\n\n    /// Loads a config file from disk, returns default if some error happens\n    fn get_config_file(path: \u0026str) -\u003e ConfigFile {\n        let data = ConfigFile::from_file(path);\n\n        if let Ok(data) = data {\n            data\n        } else {\n            match data.unwrap_err() {\n                crate::error::Error::TomlParsing(e) =\u003e {\n                    error!(\"Error while parsing config file, ignoring it\");\n                    debug!(\"{e}\");\n                    ConfigFile::default()\n                }\n                crate::error::Error::Io(e) =\u003e {\n                    error!(\"Error reading config file, ignoring it\");\n                    debug!(\"{e}\");\n                    ConfigFile::default()\n                }\n                // Shouldn't be any other error\n                _ =\u003e unreachable!(),\n            }\n        }\n    }\n\n    fn get_key_from_env() -\u003e Option\u003cString\u003e {\n        let xpub = std::env::var(\"WALLET_XPUB\");\n        match xpub {\n            Ok(key) =\u003e return Some(key),\n            Err(e) =\u003e match e {\n                std::env::VarError::NotPresent =\u003e {}\n                std::env::VarError::NotUnicode(xpub) =\u003e error!(\"Invalid xpub {xpub:?}\"),\n            },\n        }\n        None\n    }\n\n    fn load_chain_state(\n        data_dir: \u0026String,\n        network: Network,\n        assume_valid: Option\u003cbitcoin::BlockHash\u003e,\n    ) -\u003e ChainState\u003cKvChainStore\u003e {\n        let db = KvChainStore::new(data_dir.to_string()).expect(\"Could not read db\");\n        let assume_valid =\n            assume_valid.map_or(AssumeValidArg::Hardcoded, AssumeValidArg::UserInput);\n\n        match ChainState::\u003cKvChainStore\u003e::load_chain_state(db, network.into(), assume_valid) {\n            Ok(chainstate) =\u003e chainstate,\n            Err(err) =\u003e match err {\n                BlockchainError::ChainNotInitialized =\u003e {\n                    let db = KvChainStore::new(data_dir.to_string()).expect(\"Could not read db\");\n\n                    ChainState::\u003cKvChainStore\u003e::new(db, network.into(), assume_valid)\n                }\n                _ =\u003e unreachable!(),\n            },\n        }\n    }\n\n    fn load_wallet(data_dir: \u0026String) -\u003e AddressCache\u003cKvDatabase\u003e {\n        let database = KvDatabase::new(data_dir.to_owned()).expect(\"Could not create a database\");\n        AddressCache::new(database)\n    }\n\n    fn get_net(net: \u0026cli::Network) -\u003e bitcoin::Network {\n        match net {\n            cli::Network::Bitcoin =\u003e bitcoin::Network::Bitcoin,\n            cli::Network::Signet =\u003e bitcoin::Network::Signet,\n            cli::Network::Testnet =\u003e bitcoin::Network::Testnet,\n            cli::Network::Regtest =\u003e bitcoin::Network::Regtest,\n        }\n    }\n\n    fn setup_wallet\u003cD: AddressCacheDatabase\u003e(\n        mut xpubs: Vec\u003cString\u003e,\n        descriptors: Vec\u003cString\u003e,\n        addresses: Vec\u003cString\u003e,\n        wallet: \u0026mut AddressCache\u003cD\u003e,\n        network: cli::Network,\n    ) -\u003e anyhow::Result\u003c()\u003e {\n        if let Some(key) = Self::get_key_from_env() {\n            xpubs.push(key);\n        }\n        let setup = InitialWalletSetup::build(\n            \u0026xpubs,\n            \u0026descriptors,\n            \u0026addresses,\n            Self::get_net(\u0026network),\n            100,\n        )?;\n        for descriptor in setup.descriptors {\n            let descriptor = descriptor.to_string();\n            if !wallet.is_cached(\u0026descriptor)? {\n                wallet.push_descriptor(\u0026descriptor)?;\n            }\n        }\n        for addresses in setup.addresses {\n            wallet.cache_address(addresses.script_pubkey());\n        }\n        info!(\"Wallet setup completed!\");\n        anyhow::Ok(())\n    }\n\n    fn get_both_vec\u003cT\u003e(a: Option\u003cVec\u003cT\u003e\u003e, b: Option\u003cVec\u003cT\u003e\u003e) -\u003e Vec\u003cT\u003e {\n        let mut result: Vec\u003cT\u003e = Vec::new();\n        if let Some(a) = a {\n            result.extend(a);\n        }\n        if let Some(b) = b {\n            result.extend(b);\n        }\n        result\n    }\n}\n\nimpl Default for Florestad {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl From\u003cConfig\u003e for Florestad {\n    fn from(config: Config) -\u003e Self {\n        Self {\n            config,\n            stop_signal: Arc::new(RwLock::new(false)),\n            stop_notify: Arc::new(Mutex::new(None)),\n            json_rpc: OnceLock::new(),\n        }\n    }\n}\n","traces":[{"line":146,"address":[2952400],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[5243560,5242336,5242474,5242367,5242538,5242421,5242709],"length":1,"stats":{"Line":0},"fn_name":"{async_block#0}"},{"line":148,"address":[5242769,5242504,5242603,5242411,5242429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[5243179,5243097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[5243249,5243306],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[5243375,5243456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[5242525,5243440,5243820,5243835,5243571,5243463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[5243829,5243778,5243882,5244014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[2952448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[2952453],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[2952488,2952480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[3458866,3458737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[3458944,3459017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[3459090,3459169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[3381776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[3459657,3459604,3459789,3459553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[2952512,2956061,2963971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[2953008,2952598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[5244208],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":186,"address":[5244222,5244272,5244897],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":187,"address":[5244674,5244518],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[5244370,5244302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[2952936,2964005,2953059],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[2953075],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[2953109,2953251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[2953155,2953282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[2953284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[2953353,2953665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[2953431,2953675],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[2953685,2953509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[2953752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[2953888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[2953967,2954161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[2954069,2953936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[2954092,2954234,2954314],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[2954256,2954443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[2954467,2954515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[2954549,2954685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[2954615,2954814],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[2955025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[2954901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[2954961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[2955040,2955104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[2955163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[2955355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[2955778,2955408,2955628,2955552],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[2956079,2955453,2956165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[2956355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[2956093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[2956302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[5244928,5244960],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":250,"address":[2956444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[2956553,2956486],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[2956501,2956609,2956969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[2956611,2956664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[2956881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[2956589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[2957015,2956654,2957114,2957162],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[5245024,5245051],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":274,"address":[2957228],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[2957482,2957601,2957754,2957324],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[2957488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[2957369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[2963285,2963352,2963484,2957383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[2963291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[2957140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[2958327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[2958366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[2958376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[2958386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[2958396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[2958412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[2958455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[2958667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[2958990],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[2959036,2959100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[2959116,2959189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[2959251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[2959503,2959629,2959410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[2959509,2959766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[2959813,2959877],"length":1,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[2959962,2959901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[2959986,2960055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[2960071,2960147],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[2960163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[2960230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[2960360,2960277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[5245310,5245280],"length":1,"stats":{"Line":0},"fn_name":"{closure#4}"},{"line":352,"address":[2960539],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[2962986],"length":1,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[2960855,2960749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[2960783,2962964,2960898],"length":1,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[2961241,2961114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[2960906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[2960946],"length":1,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[2960978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[2961010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[2961050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[2961455,2961514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[2961370,2961298],"length":1,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[2961386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[2961540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[2961647,2961780],"length":1,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[2961713,2961908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[2961924,2962004],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[2962036,2962109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[2962171,2962726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[2962360,2962511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[2964032,2966792,2966653],"length":1,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[2964266,2964557,2964060,2964363,2964169,2964460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[2964161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[2964258],"length":1,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[2964355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[2964452],"length":1,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[2964549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[2964654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[5245440,5246447,5245391],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":404,"address":[5246277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[5245495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[5245690],"length":1,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[5245734,5245880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[5245703,5245762],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[5246024],"length":1,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[2964990,2964891,2964816,2964662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[2964683,2964871,2966845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[2964879,2964920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[2965025,2964928,2966826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[2965041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[2965997,2965068,2965568,2965643],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[2966770,2965623,2965427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[2965674,2965631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[2966748,2966674,2965754,2966028],"length":1,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[2966312,2966546,2966602,2966136,2966447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[2966184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[2966319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[2965358,2964046,2965053,2965119],"length":1,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[2965333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[2966864,2967235],"length":1,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[2966910,2966962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[2966987,2967067],"length":1,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[2967098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[2967264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[2967280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[2969339,2968598,2967328],"length":1,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[2967367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[2967493,2969223,2967412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[2967475],"length":1,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[2967498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[2967803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[2968657,2968750,2967827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[2968877,2969073,2968943,2968663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[2968891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[2967737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[2967920,2968013,2967761],"length":1,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[2967926,2968206,2968338,2968140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[2968154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[2970011,2969392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[2969409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[2969432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[2969445],"length":1,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[2969503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[2969594,2969780,2969912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[2969585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[2971266,2970048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[2970096],"length":1,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[2970212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[2971294,2970329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[2970627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[2970682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[2970780,2970864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[2971244,2970937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[2971344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[2971368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[2971441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[2971504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[2971509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[2971540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[2971547],"length":1,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[2971554],"length":1,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[2971561],"length":1,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[5246480,5248527,5249338],"length":1,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":558,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[2971584],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":569,"address":[2971592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[2971987,2971616],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":577,"address":[2971714,2971662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[2971739,2971819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[2971850],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":208},{"path":["/","home","dane","Desktop","SOB","Floresta","florestad","src","json_rpc","mod.rs"],"content":"pub mod res;\npub mod server;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dane","Desktop","SOB","Floresta","florestad","src","json_rpc","res.rs"],"content":"use std::fmt::Display;\n\nuse jsonrpc_core::ErrorCode;\nuse serde::Deserialize;\nuse serde::Serialize;\n\n#[derive(Deserialize, Serialize)]\npub struct GetBlockchainInfoRes {\n    pub best_block: String,\n    pub height: u32,\n    pub ibd: bool,\n    pub validated: u32,\n    pub latest_work: String,\n    pub latest_block_time: u32,\n    pub leaf_count: u32,\n    pub root_count: u32,\n    pub root_hashes: Vec\u003cString\u003e,\n    pub chain: String,\n    pub progress: f32,\n    pub difficulty: u64,\n}\n\n#[derive(Deserialize, Serialize)]\npub struct RawTxJson {\n    pub in_active_chain: bool,\n    pub hex: String,\n    pub txid: String,\n    pub hash: String,\n    pub size: u32,\n    pub vsize: u32,\n    pub weight: u32,\n    pub version: u32,\n    pub locktime: u32,\n    pub vin: Vec\u003cTxInJson\u003e,\n    pub vout: Vec\u003cTxOutJson\u003e,\n    pub blockhash: String,\n    pub confirmations: u32,\n    pub blocktime: u32,\n    pub time: u32,\n}\n\n#[derive(Deserialize, Serialize)]\npub struct TxOutJson {\n    pub value: u64,\n    pub n: u32,\n    pub script_pub_key: ScriptPubKeyJson,\n}\n\n#[derive(Deserialize, Serialize)]\npub struct ScriptPubKeyJson {\n    pub asm: String,\n    pub hex: String,\n    pub req_sigs: u32,\n    #[serde(rename = \"type\")]\n    pub type_: String,\n    pub address: String,\n}\n\n#[derive(Deserialize, Serialize)]\npub struct TxInJson {\n    pub txid: String,\n    pub vout: u32,\n    pub script_sig: ScriptSigJson,\n    pub sequence: u32,\n    pub witness: Vec\u003cString\u003e,\n}\n\n#[derive(Deserialize, Serialize)]\npub struct ScriptSigJson {\n    pub asm: String,\n    pub hex: String,\n}\n\n#[derive(Deserialize, Serialize)]\npub struct BlockJson {\n    pub hash: String,\n    pub confirmations: u32,\n    pub strippedsize: usize,\n    pub size: usize,\n    pub weight: usize,\n    pub height: u32,\n    pub version: i32,\n    #[serde(rename = \"versionHex\")]\n    pub version_hex: String,\n    pub merkleroot: String,\n    pub tx: Vec\u003cString\u003e,\n    pub time: u32,\n    pub mediantime: u32,\n    pub nonce: u32,\n    pub bits: String,\n    pub difficulty: u128,\n    pub chainwork: String,\n    pub n_tx: usize,\n    pub previousblockhash: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub nextblockhash: Option\u003cString\u003e,\n}\n\n#[derive(Debug)]\npub enum Error {\n    TxNotFound,\n    InvalidDescriptor,\n    BlockNotFound,\n    Chain,\n    InvalidPort,\n    InvalidAddress,\n    Node,\n    NoBlockFilters,\n    InvalidNetwork,\n}\n\nimpl Display for Error {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let msg = match self {\n            Error::TxNotFound =\u003e \"Transaction not found\",\n            Error::InvalidDescriptor =\u003e \"Invalid descriptor\",\n            Error::BlockNotFound =\u003e \"Block not found\",\n            Error::Chain =\u003e \"Chain error\",\n            Error::InvalidPort =\u003e \"Invalid port\",\n            Error::InvalidAddress =\u003e \"Invalid address\",\n            Error::Node =\u003e \"Node returned an error\",\n            Error::NoBlockFilters =\u003e \"You don't have block filters enabled, please start florestad with --cfilters to run this RPC\",\n            Error::InvalidNetwork =\u003e \"Invalid network\"\n        };\n        write!(f, \"{}\", msg)\n    }\n}\n\nimpl From\u003cError\u003e for i64 {\n    fn from(val: Error) -\u003e Self {\n        match val {\n            Error::BlockNotFound =\u003e 1,\n            Error::Chain =\u003e 2,\n            Error::TxNotFound =\u003e 3,\n            Error::InvalidDescriptor =\u003e 4,\n            Error::InvalidPort =\u003e 5,\n            Error::InvalidAddress =\u003e 6,\n            Error::Node =\u003e 7,\n            Error::NoBlockFilters =\u003e 8,\n            Error::InvalidNetwork =\u003e 9,\n        }\n    }\n}\n\nimpl From\u003cError\u003e for ErrorCode {\n    fn from(val: Error) -\u003e Self {\n        let code = val.into();\n        ErrorCode::ServerError(code)\n    }\n}\n\nimpl From\u003cError\u003e for jsonrpc_core::Error {\n    fn from(value: Error) -\u003e Self {\n        jsonrpc_core::Error {\n            message: value.to_string(),\n            code: value.into(),\n            data: None,\n        }\n    }\n}\n","traces":[{"line":113,"address":[3143552],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":114,"address":[3143574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[3143605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[3072207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[6657705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[6657731],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[6657754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[3143729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[6657800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[6657823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[3072374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[3072449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[3072528],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":131,"address":[3072535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[3072590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[3072601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[3072568],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[3072579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[3072612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[3072623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[3072634],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[3072645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[3072656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[6272752],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":147,"address":[6272763],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[6272776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[6273006,6272816],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":155,"address":[6272847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[6272852],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":29},{"path":["/","home","dane","Desktop","SOB","Floresta","florestad","src","json_rpc","server.rs"],"content":"use std::net::SocketAddr;\nuse std::sync::Arc;\n\nuse async_std::sync::RwLock;\nuse bitcoin::block::Header as BlockHeader;\nuse bitcoin::consensus::deserialize;\nuse bitcoin::consensus::encode::serialize_hex;\nuse bitcoin::consensus::serialize;\nuse bitcoin::constants::genesis_block;\nuse bitcoin::hashes::hex::FromHex;\nuse bitcoin::hashes::Hash;\nuse bitcoin::hex::DisplayHex;\nuse bitcoin::Address;\nuse bitcoin::Block;\nuse bitcoin::BlockHash;\nuse bitcoin::Network;\nuse bitcoin::OutPoint;\nuse bitcoin::ScriptBuf;\nuse bitcoin::TxIn;\nuse bitcoin::TxOut;\nuse bitcoin::Txid;\nuse floresta_chain::pruned_utreexo::BlockchainInterface;\nuse floresta_chain::pruned_utreexo::UpdatableChainstate;\nuse floresta_chain::ChainState;\nuse floresta_chain::KvChainStore;\nuse floresta_compact_filters::kv_filter_database::KvFilterStore;\nuse floresta_compact_filters::network_filters::NetworkFilters;\nuse floresta_watch_only::kv_database::KvDatabase;\nuse floresta_watch_only::AddressCache;\nuse floresta_watch_only::CachedTransaction;\nuse floresta_wire::node_interface::NodeInterface;\nuse floresta_wire::node_interface::NodeMethods;\nuse floresta_wire::node_interface::PeerInfo;\nuse futures::executor::block_on;\nuse jsonrpc_core::Result;\nuse jsonrpc_derive::rpc;\nuse jsonrpc_http_server::ServerBuilder;\nuse log::info;\nuse serde_json::json;\nuse serde_json::Value;\n\nuse super::res::BlockJson;\nuse super::res::Error;\nuse super::res::GetBlockchainInfoRes;\nuse super::res::RawTxJson;\nuse super::res::ScriptPubKeyJson;\nuse super::res::ScriptSigJson;\nuse super::res::TxInJson;\nuse super::res::TxOutJson;\n\n#[rpc]\npub trait Rpc {\n    #[rpc(name = \"getblockfilter\")]\n    fn get_block_filter(\u0026self, heigth: u32) -\u003e Result\u003cString\u003e;\n    #[rpc(name = \"getblockchaininfo\")]\n    fn get_blockchain_info(\u0026self) -\u003e Result\u003cGetBlockchainInfoRes\u003e;\n    #[rpc(name = \"getblockhash\")]\n    fn get_block_hash(\u0026self, height: u32) -\u003e Result\u003cBlockHash\u003e;\n    #[rpc(name = \"getblockheader\")]\n    fn get_block_header(\u0026self, hash: BlockHash) -\u003e Result\u003cBlockHeader\u003e;\n    #[rpc(name = \"gettransaction\")]\n    fn get_transaction(\u0026self, tx_id: Txid, verbosity: Option\u003cbool\u003e) -\u003e Result\u003cValue\u003e;\n    #[rpc(name = \"gettxproof\")]\n    fn get_tx_proof(\u0026self, tx_id: Txid) -\u003e Result\u003cVec\u003cString\u003e\u003e;\n    #[rpc(name = \"loaddescriptor\")]\n    fn load_descriptor(\u0026self, descriptor: String, rescan: Option\u003cu32\u003e) -\u003e Result\u003cbool\u003e;\n    #[rpc(name = \"rescan\")]\n    fn rescan(\u0026self, rescan: u32) -\u003e Result\u003cbool\u003e;\n    #[rpc(name = \"getheight\")]\n    fn get_height(\u0026self) -\u003e Result\u003cu32\u003e;\n    #[rpc(name = \"sendrawtransaction\")]\n    fn send_raw_transaction(\u0026self, tx: String) -\u003e Result\u003cTxid\u003e;\n    #[rpc(name = \"getroots\")]\n    fn get_roots(\u0026self) -\u003e Result\u003cVec\u003cString\u003e\u003e;\n    #[rpc(name = \"getpeerinfo\")]\n    fn get_peer_info(\u0026self) -\u003e Result\u003cVec\u003cPeerInfo\u003e\u003e;\n    #[rpc(name = \"getblock\")]\n    fn get_block(\u0026self, hash: BlockHash, verbosity: Option\u003cu8\u003e) -\u003e Result\u003cValue\u003e;\n    #[rpc(name = \"gettxout\", returns = \"TxOut\")]\n    fn get_tx_out(\u0026self, tx_id: Txid, outpoint: u32) -\u003e Result\u003cValue\u003e;\n    #[rpc(name = \"stop\")]\n    fn stop(\u0026self) -\u003e Result\u003cbool\u003e;\n    #[rpc(name = \"addnode\")]\n    fn add_node(\u0026self, node: String) -\u003e Result\u003cbool\u003e;\n}\n\npub struct RpcImpl {\n    block_filter_storage: Option\u003cArc\u003cNetworkFilters\u003cKvFilterStore\u003e\u003e\u003e,\n    network: Network,\n    chain: Arc\u003cChainState\u003cKvChainStore\u003e\u003e,\n    wallet: Arc\u003cRwLock\u003cAddressCache\u003cKvDatabase\u003e\u003e\u003e,\n    node: Arc\u003cNodeInterface\u003e,\n    kill_signal: Arc\u003cRwLock\u003cbool\u003e\u003e,\n}\n\nimpl Rpc for RpcImpl {\n    fn get_tx_out(\u0026self, tx_id: Txid, outpoint: u32) -\u003e Result\u003cValue\u003e {\n        fn has_input(block: \u0026Block, expected_input: OutPoint) -\u003e bool {\n            block.txdata.iter().any(|tx| {\n                tx.input\n                    .iter()\n                    .any(|input| input.previous_output == expected_input)\n            })\n        }\n        // can't proceed without block filters\n        if self.block_filter_storage.is_none() {\n            return Err(jsonrpc_core::Error {\n                code: Error::NoBlockFilters.into(),\n                message: Error::NoBlockFilters.to_string(),\n                data: None,\n            });\n        }\n        // this variable will be set to the UTXO iff (i) it have been created\n        // (ii) it haven't been spent\n        let mut txout = None;\n        let tip = self.chain.get_height().unwrap();\n\n        if let Some(ref cfilters) = self.block_filter_storage {\n            let vout = OutPoint {\n                txid: tx_id,\n                vout: outpoint,\n            };\n\n            let filter_outpoint = bitcoin::consensus::serialize(\u0026vout);\n            let filter_txid = bitcoin::consensus::serialize(\u0026tx_id);\n\n            let candidates = cfilters.match_any(\n                vec![filter_outpoint.as_slice(), filter_txid.as_slice()],\n                1,\n                tip,\n                self.chain.clone(),\n            );\n\n            let candidates = candidates.into_iter().map(|hash| self.node.get_block(hash));\n\n            for candidate in candidates {\n                let candidate = match candidate {\n                    Err(e) =\u003e {\n                        return Err(jsonrpc_core::Error {\n                            code: Error::Node.into(),\n                            message: format!(\"error while downloading block {candidate:?}\"),\n                            data: Some(jsonrpc_core::Value::String(e.to_string())),\n                        });\n                    }\n                    Ok(None) =\u003e {\n                        return Err(jsonrpc_core::Error {\n                            code: Error::Node.into(),\n                            message: format!(\"BUG: block {candidate:?} is a match in our filters, but we can't get it?\"),\n                            data: None,\n                        });\n                    }\n                    Ok(Some(candidate)) =\u003e candidate,\n                };\n\n                if let Some(tx) = candidate.txdata.iter().position(|tx| tx.txid() == tx_id) {\n                    txout = candidate.txdata[tx].output.get(outpoint as usize).cloned();\n                }\n\n                if has_input(\u0026candidate, vout) {\n                    txout = None;\n                }\n            }\n        }\n        match txout {\n            Some(txout) =\u003e Ok(json!({ \"txout\": txout })),\n            None =\u003e Ok(json!({})),\n        }\n    }\n    fn get_height(\u0026self) -\u003e Result\u003cu32\u003e {\n        Ok(self.chain.get_best_block().unwrap().0)\n    }\n\n    fn get_block_filter(\u0026self, heigth: u32) -\u003e Result\u003cString\u003e {\n        if let Some(ref cfilters) = self.block_filter_storage {\n            return Ok(serialize_hex(\n                \u0026cfilters\n                    .get_filter(heigth)\n                    .ok_or(Error::BlockNotFound)?\n                    .content,\n            ));\n        }\n        Err(jsonrpc_core::Error {\n            code: Error::NoBlockFilters.into(),\n            message: Error::NoBlockFilters.to_string(),\n            data: None,\n        })\n    }\n    fn add_node(\u0026self, node: String) -\u003e Result\u003cbool\u003e {\n        let node = node.split(':').collect::\u003cVec\u003c\u0026str\u003e\u003e();\n        let (ip, port) = if node.len() == 2 {\n            (node[0], node[1].parse().map_err(|_| Error::InvalidPort)?)\n        } else {\n            match self.network {\n                Network::Bitcoin =\u003e (node[0], 8333),\n                Network::Testnet =\u003e (node[0], 18333),\n                Network::Regtest =\u003e (node[0], 18444),\n                Network::Signet =\u003e (node[0], 38333),\n                _ =\u003e return Err(Error::InvalidNetwork.into()),\n            }\n        };\n        let node = ip.parse().map_err(|_| Error::InvalidAddress)?;\n        self.node.connect(node, port).unwrap();\n        Ok(true)\n    }\n\n    fn get_blockchain_info(\u0026self) -\u003e Result\u003cGetBlockchainInfoRes\u003e {\n        let (height, hash) = self.chain.get_best_block().unwrap();\n        let validated = self.chain.get_validation_index().unwrap();\n        let ibd = self.chain.is_in_idb();\n        let latest_header = self.chain.get_block_header(\u0026hash).unwrap();\n        let latest_work = latest_header.work();\n        let latest_block_time = latest_header.time;\n        let leaf_count = self.chain.acc().leaves as u32;\n        let root_count = self.chain.acc().roots.len() as u32;\n        let root_hashes = self\n            .chain\n            .acc()\n            .roots\n            .into_iter()\n            .map(|r| r.to_string())\n            .collect();\n        let validated_blocks = self.chain.get_validation_index().unwrap();\n        Ok(GetBlockchainInfoRes {\n            best_block: hash.to_string(),\n            height,\n            ibd,\n            validated,\n            latest_work: latest_work.to_string(),\n            latest_block_time,\n            leaf_count,\n            root_count,\n            root_hashes,\n            chain: self.network.to_string(),\n            difficulty: latest_header.difficulty() as u64,\n            progress: validated_blocks as f32 / height as f32,\n        })\n    }\n\n    fn get_roots(\u0026self) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        let hashes = self.chain.get_root_hashes();\n        return Ok(hashes.iter().map(|h| h.to_string()).collect());\n    }\n\n    fn get_block_hash(\u0026self, height: u32) -\u003e Result\u003cBlockHash\u003e {\n        if let Ok(hash) = self.chain.get_block_hash(height) {\n            return Ok(hash);\n        }\n        Err(Error::BlockNotFound.into())\n    }\n\n    fn get_block_header(\u0026self, hash: BlockHash) -\u003e Result\u003cBlockHeader\u003e {\n        if let Ok(header) = self.chain.get_block_header(\u0026hash) {\n            return Ok(header);\n        }\n        Err(Error::BlockNotFound.into())\n    }\n\n    fn get_transaction(\u0026self, tx_id: Txid, verbosity: Option\u003cbool\u003e) -\u003e Result\u003cValue\u003e {\n        let wallet = block_on(self.wallet.read());\n        if verbosity == Some(true) {\n            if let Some(tx) = wallet.get_transaction(\u0026tx_id) {\n                return Ok(serde_json::to_value(serialize(\u0026tx.tx)).unwrap());\n            }\n            return Err(Error::TxNotFound.into());\n        }\n        if let Some(tx) = wallet.get_transaction(\u0026tx_id) {\n            return Ok(serde_json::to_value(self.make_raw_transaction(tx)).unwrap());\n        }\n        Err(Error::TxNotFound.into())\n    }\n\n    fn load_descriptor(\u0026self, descriptor: String, rescan: Option\u003cu32\u003e) -\u003e Result\u003cbool\u003e {\n        let wallet = block_on(self.wallet.write());\n        let result = wallet.push_descriptor(\u0026descriptor);\n        if let Some(rescan) = rescan {\n            self.chain\n                .rescan(rescan)\n                .map_err(|_| jsonrpc_core::Error::internal_error())?;\n        }\n        if result.is_err() {\n            return Err(Error::InvalidDescriptor.into());\n        }\n        Ok(true)\n    }\n\n    fn rescan(\u0026self, rescan: u32) -\u003e Result\u003cbool\u003e {\n        let result = self.chain.rescan(rescan);\n        if result.is_err() {\n            return Err(Error::Chain.into());\n        }\n        Ok(true)\n    }\n\n    fn send_raw_transaction(\u0026self, tx: String) -\u003e Result\u003cTxid\u003e {\n        let tx_hex = Vec::from_hex(\u0026tx).map_err(|_| jsonrpc_core::Error {\n            code: 3.into(),\n            message: \"Invalid hex\".into(),\n            data: None,\n        })?;\n        let tx = deserialize(\u0026tx_hex).map_err(|e| jsonrpc_core::Error {\n            code: 2.into(),\n            message: format!(\"{:?}\", e),\n            data: None,\n        })?;\n        if self.chain.broadcast(\u0026tx).is_ok() {\n            return Ok(tx.txid());\n        }\n        Err(Error::Chain.into())\n    }\n\n    fn get_tx_proof(\u0026self, tx_id: Txid) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        if let Some((proof, _)) = block_on(self.wallet.read()).get_merkle_proof(\u0026tx_id) {\n            return Ok(proof);\n        }\n        Err(Error::TxNotFound.into())\n    }\n\n    fn get_block(\u0026self, hash: BlockHash, verbosity: Option\u003cu8\u003e) -\u003e Result\u003cValue\u003e {\n        let verbosity = verbosity.unwrap_or(1);\n\n        let block = if self.chain.get_block_hash(0).unwrap().eq(\u0026hash) {\n            Some(genesis_block(self.network))\n        } else {\n            self.node.get_block(hash).map_err(|_| Error::Chain)?\n        };\n\n        if let Some(block) = block {\n            if verbosity == 1 {\n                let tip = self.chain.get_height().map_err(|_| Error::Chain)?;\n                let height = self\n                    .chain\n                    .get_block_height(\u0026hash)\n                    .map_err(|_| Error::Chain)?\n                    .unwrap();\n\n                let median_time_past = if height \u003e 11 {\n                    let mut last_block_times: Vec\u003c_\u003e = ((height - 11)..height)\n                        .map(|h| {\n                            self.chain\n                                .get_block_header(\u0026self.chain.get_block_hash(h).unwrap())\n                                .unwrap()\n                                .time\n                        })\n                        .collect();\n                    last_block_times.sort();\n                    last_block_times[5]\n                } else {\n                    block.header.time\n                };\n\n                let block = BlockJson {\n                    bits: serialize_hex(\u0026block.header.bits),\n                    chainwork: block.header.work().to_string(),\n                    confirmations: (tip - height) + 1,\n                    difficulty: block.header.difficulty(),\n                    hash: block.header.block_hash().to_string(),\n                    height,\n                    merkleroot: block.header.merkle_root.to_string(),\n                    nonce: block.header.nonce,\n                    previousblockhash: block.header.prev_blockhash.to_string(),\n                    size: block.total_size(),\n                    time: block.header.time,\n                    tx: block\n                        .txdata\n                        .iter()\n                        .map(|tx| tx.txid().to_string())\n                        .collect(),\n                    version: block.header.version.to_consensus(),\n                    version_hex: serialize_hex(\u0026block.header.version),\n                    weight: block.weight().to_wu() as usize,\n                    mediantime: median_time_past,\n                    n_tx: block.txdata.len(),\n                    nextblockhash: self\n                        .chain\n                        .get_block_hash(height + 1)\n                        .ok()\n                        .map(|h| h.to_string()),\n                    strippedsize: block.strippedsize(),\n                };\n\n                return Ok(serde_json::to_value(block).unwrap());\n            }\n            return Ok(json!(serialize(\u0026block).to_vec()));\n        }\n        Err(Error::BlockNotFound.into())\n    }\n\n    fn get_peer_info(\u0026self) -\u003e Result\u003cVec\u003cPeerInfo\u003e\u003e {\n        let peers = self.node.get_peer_info();\n        if let Ok(peers) = peers {\n            return Ok(peers);\n        }\n        Err(Error::TxNotFound.into())\n    }\n\n    fn stop(\u0026self) -\u003e Result\u003cbool\u003e {\n        *async_std::task::block_on(self.kill_signal.write()) = true;\n        Ok(true)\n    }\n}\nimpl RpcImpl {\n    fn make_vin(\u0026self, input: TxIn) -\u003e TxInJson {\n        let txid = serialize_hex(\u0026input.previous_output.txid);\n        let vout = input.previous_output.vout;\n        let sequence = input.sequence.0;\n        TxInJson {\n            txid,\n            vout,\n            script_sig: ScriptSigJson {\n                asm: input.script_sig.to_asm_string(),\n                hex: input.script_sig.to_hex_string(),\n            },\n            witness: input\n                .witness\n                .iter()\n                .map(|w| w.to_hex_string(bitcoin::hex::Case::Upper))\n                .collect(),\n            sequence,\n        }\n    }\n    fn get_script_type(script: ScriptBuf) -\u003e Option\u003c\u0026'static str\u003e {\n        if script.is_p2pkh() {\n            return Some(\"p2pkh\");\n        }\n        if script.is_p2sh() {\n            return Some(\"p2sh\");\n        }\n        if script.is_p2wpkh() {\n            return Some(\"v0_p2wpkh\");\n        }\n        if script.is_p2wsh() {\n            return Some(\"v0_p2wsh\");\n        }\n        None\n    }\n    fn make_vout(\u0026self, output: TxOut, n: u32) -\u003e TxOutJson {\n        let value = output.value;\n        TxOutJson {\n            value: value.to_sat(),\n            n,\n            script_pub_key: ScriptPubKeyJson {\n                asm: output.script_pubkey.to_asm_string(),\n                hex: output.script_pubkey.to_hex_string(),\n                req_sigs: 0, // This field is deprecated\n                address: Address::from_script(\u0026output.script_pubkey, self.network)\n                    .map(|a| a.to_string())\n                    .unwrap(),\n                type_: Self::get_script_type(output.script_pubkey)\n                    .unwrap_or(\"nonstandard\")\n                    .to_string(),\n            },\n        }\n    }\n    fn make_raw_transaction(\u0026self, tx: CachedTransaction) -\u003e RawTxJson {\n        let raw_tx = tx.tx;\n        let in_active_chain = tx.height != 0;\n        let hex = serialize_hex(\u0026raw_tx);\n        let txid = serialize_hex(\u0026raw_tx.txid());\n        let block_hash = self\n            .chain\n            .get_block_hash(tx.height)\n            .unwrap_or(BlockHash::all_zeros());\n        let tip = self.chain.get_height().unwrap();\n        let confirmations = if in_active_chain {\n            tip - tx.height + 1\n        } else {\n            0\n        };\n\n        RawTxJson {\n            in_active_chain,\n            hex,\n            txid,\n            hash: serialize_hex(\u0026raw_tx.wtxid()),\n            size: raw_tx.total_size() as u32,\n            vsize: raw_tx.vsize() as u32,\n            weight: raw_tx.weight().to_wu() as u32,\n            version: raw_tx.version.0 as u32,\n            locktime: raw_tx.lock_time.to_consensus_u32(),\n            vin: raw_tx\n                .input\n                .iter()\n                .map(|input| self.make_vin(input.clone()))\n                .collect(),\n            vout: raw_tx\n                .output\n                .into_iter()\n                .enumerate()\n                .map(|(i, output)| self.make_vout(output, i as u32))\n                .collect(),\n            blockhash: serialize_hex(\u0026block_hash),\n            confirmations,\n            blocktime: self\n                .chain\n                .get_block_header(\u0026block_hash)\n                .map(|h| h.time)\n                .unwrap_or(0),\n            time: self\n                .chain\n                .get_block_header(\u0026block_hash)\n                .map(|h| h.time)\n                .unwrap_or(0),\n        }\n    }\n    fn get_port(net: \u0026Network) -\u003e u16 {\n        match net {\n            Network::Bitcoin =\u003e 8332,\n            Network::Testnet =\u003e 18332,\n            Network::Signet =\u003e 38332,\n            Network::Regtest =\u003e 18442,\n            _ =\u003e 8332,\n        }\n    }\n\n    #[allow(clippy::too_many_arguments)]\n    pub fn create(\n        chain: Arc\u003cChainState\u003cKvChainStore\u003e\u003e,\n        wallet: Arc\u003cRwLock\u003cAddressCache\u003cKvDatabase\u003e\u003e\u003e,\n        node: Arc\u003cNodeInterface\u003e,\n        kill_signal: Arc\u003cRwLock\u003cbool\u003e\u003e,\n        network: Network,\n        block_filter_storage: Option\u003cArc\u003cNetworkFilters\u003cKvFilterStore\u003e\u003e\u003e,\n        address: Option\u003cSocketAddr\u003e,\n    ) -\u003e jsonrpc_http_server::Server {\n        let mut io = jsonrpc_core::IoHandler::new();\n        let rpc_impl = RpcImpl {\n            network,\n            chain,\n            wallet,\n            node,\n            kill_signal,\n            block_filter_storage,\n        };\n        io.extend_with(rpc_impl.to_delegate());\n        let address = address.unwrap_or_else(|| {\n            format!(\"127.0.0.1:{}\", Self::get_port(\u0026network))\n                .parse()\n                .unwrap()\n        });\n        info!(\"Starting JSON-RPC server on {:?}\", address);\n        ServerBuilder::new(io)\n            .threads(1)\n            .start_http(\u0026address)\n            .unwrap()\n    }\n}\n","traces":[{"line":97,"address":[2703257,2699872,2704622],"length":1,"stats":{"Line":0},"fn_name":"get_tx_out"},{"line":98,"address":[2704656],"length":1,"stats":{"Line":0},"fn_name":"has_input"},{"line":99,"address":[2704669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[5427489,5427438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[5427520,5427481,5427545],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":106,"address":[2699944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[2700116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[2700027],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[2700064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[2700108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[2699989],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[2700017,2700327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[2700378],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[2700528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[2700589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[2700648,2701130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[2703958,2700714],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[2701050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[2701174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[2703853,2703252,2701276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[2701503,2701557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[2699929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[2703692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[2701588],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[2703377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[2703503,2703572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[2702236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[2701630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[2702082],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[2702228],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[2701672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[2702462,2702995,2701896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[2702611,2702723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[2703004,2703234,2702642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[2703032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[2700535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[2704168,2703978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[2704044,2703971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[2704752],"length":1,"stats":{"Line":0},"fn_name":"get_height"},{"line":170,"address":[2704770],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[2705465,2704832],"length":1,"stats":{"Line":0},"fn_name":"get_block_filter"},{"line":174,"address":[2704873],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[2705407,2705324],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[2705347,2705259,2704919,2704952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[2704944,2705336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[2705108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[2705034],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[2705065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[2705100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[2705504,2706897],"length":1,"stats":{"Line":0},"fn_name":"add_node"},{"line":189,"address":[2705559,2705642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[2705762,2706102,2706144,2705701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[2705843,2706239,2706215,2705768,2706112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[2705808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[2706389,2706241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[2706432,2706276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[2706346,2706518],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[2706311,2706475],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[2706686,2706876,2706572,2706205],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[2706662,2706731],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[2706816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[2708392,2708359,2706928],"length":1,"stats":{"Line":0},"fn_name":"get_blockchain_info"},{"line":207,"address":[2706958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[2707077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[2707117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[2707161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[2707201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[2707287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[2707305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[2707368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[2707509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[5427808,5427836],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":222,"address":[2707654,2707702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[2708062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[2707755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[2707778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[2707834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[2707874],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[2707937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[2708042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[2708432,2708682],"length":1,"stats":{"Line":0},"fn_name":"get_roots"},{"line":240,"address":[2708467],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[2708477,2708549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[2708720],"length":1,"stats":{"Line":0},"fn_name":"get_block_hash"},{"line":245,"address":[2708751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[2708827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[2708892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[2708960],"length":1,"stats":{"Line":0},"fn_name":"get_block_header"},{"line":252,"address":[2708985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[2709034],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[2709086],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[2709168,2709992,2710062],"length":1,"stats":{"Line":0},"fn_name":"get_transaction"},{"line":259,"address":[2709217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[2709332,2709264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[2709724,2709360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[2709897,2709796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[2710003],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[2709343,2709393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[2709520,2709478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[2709629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[2710827,2710080],"length":1,"stats":{"Line":0},"fn_name":"load_descriptor"},{"line":273,"address":[2710132,2710202],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[2710259,2710313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[2710360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[2710479,2710115,2710394,2710624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[2710544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[2710670,2710409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[2710707,2710779],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[2710681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[2710864,2711078],"length":1,"stats":{"Line":0},"fn_name":"rescan"},{"line":287,"address":[2710905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[2710971,2710915],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[2711005,2711050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[2710981],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[2712310,2711104,2712341],"length":1,"stats":{"Line":0},"fn_name":"send_raw_transaction"},{"line":295,"address":[2711463,2711215,2712339,2711147],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[5428046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[5428066],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[5428109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[2711878,2711539,2711355,2712321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[5428219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[5428377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[5428502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[2711955,2711783],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[2712212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[2712058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[2712368,2712746],"length":1,"stats":{"Line":0},"fn_name":"get_tx_proof"},{"line":312,"address":[2712525,2712410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[2712602],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[2712692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[2716595,2712784,2716170],"length":1,"stats":{"Line":0},"fn_name":"get_block"},{"line":319,"address":[2712861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[2713274,2713208,2712914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[2713156],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[2712994,2713284,2713210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[2713315,2713359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[2713400],"length":1,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[2713456,2713541,2713721,2716183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[2713706,2713764,2716181,2713969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[2713959],"length":1,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[2714019,2714000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[2714122,2714028,2714100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[2714114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[5428744,5428799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[5428751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[2714305,2714222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[2714312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[2714005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[2714052],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[2714390,2714557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[2714626,2714784],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[2714749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[2714817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[2714867],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[2714934],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[2714964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[2715012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[2715080],"length":1,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[2715091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[2715203],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[2715269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[2715292,2715362],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[2715389],"length":1,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[2715454,2715510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[2715540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[2716048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[2716185,2713479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[2713406,2716544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[2716640,2716905],"length":1,"stats":{"Line":0},"fn_name":"get_peer_info"},{"line":389,"address":[2716678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[2716701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[2716762],"length":1,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[2716798,2716878],"length":1,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[2716944,2717125],"length":1,"stats":{"Line":0},"fn_name":"stop"},{"line":397,"address":[2716980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[2717106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[2717797,2717152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[2717190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[2717252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[2717266],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[2717492],"length":1,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[2717556,2717635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[2717824,2718248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[2717836,2717905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[2717952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[2717931,2717988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[2718035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[2718014,2718071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[2718118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[2718097,2718151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[2718194],"length":1,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[2718177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[2718272,2719148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[2718318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[2718346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[2718907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[2721423,2721292,2719200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[2719248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[2719335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[2719428,2719377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[2719517,2719436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[2719562,2719668],"length":1,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[2719607,2719548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[2719623,2719715,2721333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[2719731],"length":1,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[2720028,2719788,2719803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[2719969,2720033,2719820],"length":1,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[2719792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[2719932,2720123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[2720138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[2720208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[2720237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[2720279],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[2720290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[2720401,2720315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[2720447,2720589,2720566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[2720659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[2720741,2720805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[2720857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[2721440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[2721445],"length":1,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[2721476],"length":1,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[2721485],"length":1,"stats":{"Line":0},"fn_name":null},{"line":509,"address":[2721494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[2721503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[2721474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[2722670,2721520,2722799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[2721585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[2721880,2721933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[2722042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[5429429,5429673,5429510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[2722104,2722293,2722426],"length":1,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[2722546,2722156],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":233},{"path":["/","home","dane","Desktop","SOB","Floresta","florestad","src","lib.rs"],"content":"mod cli;\nmod config_file;\nmod error;\nmod florestad;\n#[cfg(feature = \"json-rpc\")]\nmod json_rpc;\nmod slip132;\nmod wallet_input;\n\npub use cli::Network;\npub use florestad::Config;\npub use florestad::Florestad;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dane","Desktop","SOB","Floresta","florestad","src","main.rs"],"content":"// Written in 2022 by Davidson Souza.\n// SPDX-License-Identifier: CC0-1.0\n\n//! This is a modular-(ish) utreexo powered wallet backend and fully validating node, it's\n//! developed as an experiment to showcase utreexo. This wallet also comes with an Electrum\n//! server out-of-the-box, for people to try out with their favorite wallet.\n//! This codebase consists of three main parts: a blockchain backend, that gets all information\n//! we need from the network. An Electrum Server that talks full Electrum protocol and can be\n//! used with any wallet that understands this protocol. Finally, it has the `AddressCache`,\n//! a watch-only wallet that keeps track of your wallet's transactions.\n\n// Coding conventions (lexicographically sorted)\n#![deny(arithmetic_overflow)]\n#![deny(clippy::all)]\n#![deny(missing_docs)]\n#![deny(non_camel_case_types)]\n#![deny(non_snake_case)]\n#![deny(non_upper_case_globals)]\n\nmod cli;\nmod config_file;\nmod error;\nmod florestad;\n#[cfg(feature = \"json-rpc\")]\nmod json_rpc;\nmod slip132;\nmod wallet_input;\n#[cfg(feature = \"zmq-server\")]\nmod zmq;\n\nuse std::time::Duration;\n\nuse clap::Parser;\nuse cli::Cli;\nuse cli::Commands;\nuse florestad::Config;\nuse florestad::Florestad;\n#[cfg(feature = \"zmq-server\")]\nuse zmq::ZMQServer;\n\n#[async_std::main]\nasync fn main() {\n    let params = Cli::parse();\n\n    let config = match params.command {\n        #[cfg(feature = \"experimental-p2p\")]\n        Some(Commands::Run {\n            data_dir,\n            assume_valid,\n            wallet_xpub,\n            wallet_descriptor,\n            rescan,\n            proxy,\n            zmq_address: _zmq_address,\n            cfilters,\n            connect,\n            rpc_address,\n            electrum_address,\n        }) =\u003e Config {\n            data_dir,\n            assume_valid,\n            wallet_xpub,\n            wallet_descriptor,\n            rescan,\n            proxy,\n            config_file: params.config_file,\n            network: params.network,\n            cfilters,\n            #[cfg(feature = \"zmq-server\")]\n            zmq_address: _zmq_address,\n            connect,\n            #[cfg(feature = \"json-rpc\")]\n            json_rpc_address: rpc_address,\n            electrum_address,\n            log_to_file: true,\n            log_to_stdout: true,\n        },\n\n        // We may have more commands here, like setup and dump wallet\n        None =\u003e Config {\n            config_file: params.config_file,\n            network: params.network,\n            cfilters: true,\n            log_to_file: false,\n            log_to_stdout: true,\n            ..Default::default()\n        },\n    };\n\n    let florestad = Florestad::from(config);\n    florestad.start();\n\n    let stop_signal = florestad.get_stop_signal();\n    let _stop_signal = stop_signal.clone();\n\n    ctrlc::set_handler(move || {\n        async_std::task::block_on(async {\n            *(stop_signal.write().await) = true;\n        })\n    })\n    .expect(\"Could not setup ctr+c handler\");\n\n    loop {\n        if *_stop_signal.read().await {\n            florestad.wait_shutdown().await;\n            break;\n        }\n        async_std::task::sleep(Duration::from_secs(5)).await;\n    }\n}\n","traces":[{"line":43,"address":[3350240],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[3350455,3350222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[3350701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[3350984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[3351022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[3350502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[3350548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[3351853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[3351978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[3352030,3352113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[3352131,3352234],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[3352349,3352237,3353856],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":97,"address":[3354040,3353971,3353904,3353929,3354003,3354198,3353865,3354600],"length":1,"stats":{"Line":0},"fn_name":"{async_block#0}"},{"line":98,"address":[3354030,3354258,3353964,3354091,3353979],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[3352795,3350333,3352385,3352479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[3350354,3352527,3353362],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[3352575,3352620,3350375,3353257],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":17},{"path":["/","home","dane","Desktop","SOB","Floresta","florestad","src","slip132.rs"],"content":"// Based on slip132 from LNP/BP Descriptor Wallet library by:\n//     Dr. Maxim Orlovsky \u003corlovsky@lnp-bp.org\u003e\n//\n// Adapted for Floresta by:\n//     Davidson Sousa \u003cme@dlsouza.lol\u003e\n\n//! Bitcoin SLIP-132 standard implementation for parsing custom xpub/xpriv key\n//! formats\n\n#[cfg(feature = \"strict_encoding\")]\n#[macro_use]\nextern crate strict_encoding;\n\n#[cfg(feature = \"serde\")]\n#[macro_use]\nextern crate serde_crate as serde;\n\nuse std::fmt::Debug;\nuse std::str::FromStr;\n\nuse bitcoin::base58;\nuse bitcoin::bip32;\nuse bitcoin::bip32::Xpriv;\nuse bitcoin::bip32::Xpub;\n\n/// Magical version bytes for xpub: bitcoin mainnet public key for P2PKH or P2SH\npub const VERSION_MAGIC_XPUB: [u8; 4] = [0x04, 0x88, 0xB2, 0x1E];\n/// Magical version bytes for xprv: bitcoin mainnet private key for P2PKH or\n/// P2SH\npub const VERSION_MAGIC_XPRV: [u8; 4] = [0x04, 0x88, 0xAD, 0xE4];\n/// Magical version bytes for ypub: bitcoin mainnet public key for P2WPKH in\n/// P2SH\npub const VERSION_MAGIC_YPUB: [u8; 4] = [0x04, 0x9D, 0x7C, 0xB2];\n/// Magical version bytes for yprv: bitcoin mainnet private key for P2WPKH in\n/// P2SH\npub const VERSION_MAGIC_YPRV: [u8; 4] = [0x04, 0x9D, 0x78, 0x78];\n/// Magical version bytes for zpub: bitcoin mainnet public key for P2WPKH\npub const VERSION_MAGIC_ZPUB: [u8; 4] = [0x04, 0xB2, 0x47, 0x46];\n/// Magical version bytes for zprv: bitcoin mainnet private key for P2WPKH\npub const VERSION_MAGIC_ZPRV: [u8; 4] = [0x04, 0xB2, 0x43, 0x0C];\n/// Magical version bytes for Ypub: bitcoin mainnet public key for\n/// multi-signature P2WSH in P2SH\npub const VERSION_MAGIC_YPUB_MULTISIG: [u8; 4] = [0x02, 0x95, 0xb4, 0x3f];\n/// Magical version bytes for Yprv: bitcoin mainnet private key for\n/// multi-signature P2WSH in P2SH\npub const VERSION_MAGIC_YPRV_MULTISIG: [u8; 4] = [0x02, 0x95, 0xb0, 0x05];\n/// Magical version bytes for Zpub: bitcoin mainnet public key for\n/// multi-signature P2WSH\npub const VERSION_MAGIC_ZPUB_MULTISIG: [u8; 4] = [0x02, 0xaa, 0x7e, 0xd3];\n/// Magical version bytes for Zprv: bitcoin mainnet private key for\n/// multi-signature P2WSH\npub const VERSION_MAGIC_ZPRV_MULTISIG: [u8; 4] = [0x02, 0xaa, 0x7a, 0x99];\n\n/// Magical version bytes for tpub: bitcoin testnet/regtest public key for\n/// P2PKH or P2SH\npub const VERSION_MAGIC_TPUB: [u8; 4] = [0x04, 0x35, 0x87, 0xCF];\n/// Magical version bytes for tprv: bitcoin testnet/regtest private key for\n/// P2PKH or P2SH\npub const VERSION_MAGIC_TPRV: [u8; 4] = [0x04, 0x35, 0x83, 0x94];\n/// Magical version bytes for upub: bitcoin testnet/regtest public key for\n/// P2WPKH in P2SH\npub const VERSION_MAGIC_UPUB: [u8; 4] = [0x04, 0x4A, 0x52, 0x62];\n/// Magical version bytes for uprv: bitcoin testnet/regtest private key for\n/// P2WPKH in P2SH\npub const VERSION_MAGIC_UPRV: [u8; 4] = [0x04, 0x4A, 0x4E, 0x28];\n/// Magical version bytes for vpub: bitcoin testnet/regtest public key for\n/// P2WPKH\npub const VERSION_MAGIC_VPUB: [u8; 4] = [0x04, 0x5F, 0x1C, 0xF6];\n/// Magical version bytes for vprv: bitcoin testnet/regtest private key for\n/// P2WPKH\npub const VERSION_MAGIC_VPRV: [u8; 4] = [0x04, 0x5F, 0x18, 0xBC];\n/// Magical version bytes for Upub: bitcoin testnet/regtest public key for\n/// multi-signature P2WSH in P2SH\npub const VERSION_MAGIC_UPUB_MULTISIG: [u8; 4] = [0x02, 0x42, 0x89, 0xef];\n/// Magical version bytes for Uprv: bitcoin testnet/regtest private key for\n/// multi-signature P2WSH in P2SH\npub const VERSION_MAGIC_UPRV_MULTISIG: [u8; 4] = [0x02, 0x42, 0x85, 0xb5];\n/// Magical version bytes for Zpub: bitcoin testnet/regtest public key for\n/// multi-signature P2WSH\npub const VERSION_MAGIC_VPUB_MULTISIG: [u8; 4] = [0x02, 0x57, 0x54, 0x83];\n/// Magical version bytes for Zprv: bitcoin testnet/regtest private key for\n/// multi-signature P2WSH\npub const VERSION_MAGIC_VPRV_MULTISIG: [u8; 4] = [0x02, 0x57, 0x50, 0x48];\n\n/// Extended public and private key processing errors\n#[derive(Clone, PartialEq, Eq, Debug)]\npub enum Error {\n    /// error in BASE58 key encoding. Details: {0}\n    Base58(base58::Error),\n\n    /// error in hex key encoding. Details: {0}\n    Hex(bitcoin::hashes::hex::HexToArrayError),\n\n    /// pk-\u003epk derivation was attempted on a hardened key.\n    CannotDeriveFromHardenedKey,\n\n    /// child number {0} is out of range.\n    InvalidChildNumber(u32),\n\n    /// invalid child number format.\n    InvalidChildNumberFormat,\n\n    /// invalid derivation path format.\n    InvalidDerivationPathFormat,\n\n    /// unknown version magic bytes {0:#06X?}\n    UnknownVersion([u8; 4]),\n\n    /// encoded extended key data has wrong length {0}\n    WrongExtendedKeyLength(usize),\n\n    /// unrecognized or unsupported extended key prefix (please check SLIP 32\n    /// for possible values)\n    UnknownSlip32Prefix,\n\n    /// failure in rust bitcoin library\n    InternalFailure,\n}\n\n#[cfg(feature = \"strict_encoding\")]\nimpl strict_encoding::StrictEncode for Error {\n    fn strict_encode\u003cE: std::io::Write\u003e(\u0026self, _: E) -\u003e Result\u003cusize, strict_encoding::Error\u003e {\n        unreachable!(\"StrictEncode for slip132::Error is a dummy required by miniscript\")\n    }\n}\n\n#[cfg(feature = \"strict_encoding\")]\nimpl strict_encoding::StrictDecode for Error {\n    fn strict_decode\u003cD: std::io::Read\u003e(_: D) -\u003e Result\u003cSelf, strict_encoding::Error\u003e {\n        unreachable!(\"StrictDecode for slip132::Error is a dummy required by miniscript\")\n    }\n}\n\nimpl From\u003cbip32::Error\u003e for Error {\n    fn from(err: bip32::Error) -\u003e Self {\n        match err {\n            bip32::Error::CannotDeriveFromHardenedKey =\u003e Error::CannotDeriveFromHardenedKey,\n            bip32::Error::InvalidChildNumber(no) =\u003e Error::InvalidChildNumber(no),\n            bip32::Error::InvalidChildNumberFormat =\u003e Error::InvalidChildNumberFormat,\n            bip32::Error::InvalidDerivationPathFormat =\u003e Error::InvalidDerivationPathFormat,\n            bip32::Error::Secp256k1(_) =\u003e Error::InternalFailure,\n            bip32::Error::UnknownVersion(ver) =\u003e Error::UnknownVersion(ver),\n            bip32::Error::WrongExtendedKeyLength(len) =\u003e Error::WrongExtendedKeyLength(len),\n            bip32::Error::Base58(err) =\u003e Error::Base58(err),\n            bip32::Error::Hex(err) =\u003e Error::Hex(err),\n            _ =\u003e Error::InternalFailure,\n        }\n    }\n}\n\nimpl From\u003cbase58::Error\u003e for Error {\n    fn from(err: base58::Error) -\u003e Self {\n        Error::Base58(err)\n    }\n}\n\n/// Structure holding 4 version bytes with magical numbers representing\n/// different versions of extended public and private keys according to BIP-32.\n/// Key version stores raw bytes without their check, interpretation or\n/// verification; for these purposes special helpers structures implementing\n/// [`VersionResolver`] are used.\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\npub struct KeyVersion([u8; 4]);\n\n#[cfg(feature = \"strict_encoding\")]\nimpl strict_encoding::StrictEncode for KeyVersion {\n    fn strict_encode\u003cE: std::io::Write\u003e(\u0026self, mut e: E) -\u003e Result\u003cusize, strict_encoding::Error\u003e {\n        e.write_all(\u0026self.0)?;\n        Ok(4)\n    }\n}\n\n#[cfg(feature = \"strict_encoding\")]\nimpl strict_encoding::StrictDecode for KeyVersion {\n    fn strict_decode\u003cD: std::io::Read\u003e(mut d: D) -\u003e Result\u003cSelf, strict_encoding::Error\u003e {\n        let mut bytes = [0u8; 4];\n        d.read_exact(\u0026mut bytes)?;\n        Ok(Self(bytes))\n    }\n}\n\n/// Default resolver knowing native [`bitcoin::network::constants::Network`]\n/// and BIP 32 and SLIP 132-defined key applications with [`KeyApplication`]\n#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\npub struct DefaultResolver;\n\n/// SLIP 132-defined key applications defining types of scriptPubkey descriptors\n/// in which they can be used\n#[cfg_attr(\n    feature = \"serde\",\n    derive(Serialize, Deserialize),\n    serde(crate = \"serde_crate\")\n)]\n#[cfg_attr(feature = \"strict_encoding\", derive(StrictEncode, StrictDecode))]\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]\n#[non_exhaustive]\npub enum KeyApplication {\n    /// xprv/xpub: keys that can be used for P2PKH and multisig P2SH\n    /// scriptPubkey descriptors.\n    #[cfg_attr(feature = \"serde\", serde(rename = \"bip44\"))]\n    Hashed,\n\n    /// zprv/zpub: keys that can be used for P2WPKH scriptPubkey descriptors\n    #[cfg_attr(feature = \"serde\", serde(rename = \"bip84\"))]\n    SegWit,\n\n    /// Zprv/Zpub: keys that can be used for multisig P2WSH scriptPubkey\n    /// descriptors\n    #[cfg_attr(feature = \"serde\", serde(rename = \"bip48-native\"))]\n    SegWitMultisig,\n\n    /// yprv/ypub: keys that can be used for P2WPKH-in-P2SH scriptPubkey\n    /// descriptors\n    #[cfg_attr(feature = \"serde\", serde(rename = \"bip49\"))]\n    Nested,\n\n    /// Yprv/Ypub: keys that can be used for multisig P2WSH-in-P2SH\n    /// scriptPubkey descriptors\n    #[cfg_attr(feature = \"serde\", serde(rename = \"bip48-nested\"))]\n    NestedMultisig,\n}\n\n/// Unknown string representation of [`KeyApplication`] enum\n#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\npub struct UnknownKeyApplicationError;\n\nimpl FromStr for KeyApplication {\n    type Err = UnknownKeyApplicationError;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        Ok(match s.to_lowercase().as_str() {\n            \"bip44\" =\u003e KeyApplication::Hashed,\n            \"bip84\" =\u003e KeyApplication::SegWit,\n            \"bip48-native\" =\u003e KeyApplication::SegWitMultisig,\n            \"bip49\" =\u003e KeyApplication::Nested,\n            \"bip48-nested\" =\u003e KeyApplication::NestedMultisig,\n            _ =\u003e return Err(UnknownKeyApplicationError),\n        })\n    }\n}\n\n/// Trait for building standard BIP32 extended keys from SLIP132 variant.\npub trait FromSlip132 {\n    /// Constructs standard BIP32 extended key from SLIP132 string.\n    fn from_slip132_str(s: \u0026str) -\u003e Result\u003cSelf, Error\u003e\n    where\n        Self: Sized;\n}\n\nimpl FromSlip132 for Xpub {\n    fn from_slip132_str(s: \u0026str) -\u003e Result\u003cSelf, Error\u003e {\n        let mut data = base58::decode_check(s)?;\n\n        let mut prefix = [0u8; 4];\n        prefix.copy_from_slice(\u0026data[0..4]);\n        let slice = match prefix {\n            VERSION_MAGIC_XPUB\n            | VERSION_MAGIC_YPUB\n            | VERSION_MAGIC_ZPUB\n            | VERSION_MAGIC_YPUB_MULTISIG\n            | VERSION_MAGIC_ZPUB_MULTISIG =\u003e VERSION_MAGIC_XPUB,\n\n            VERSION_MAGIC_TPUB\n            | VERSION_MAGIC_UPUB\n            | VERSION_MAGIC_VPUB\n            | VERSION_MAGIC_UPUB_MULTISIG\n            | VERSION_MAGIC_VPUB_MULTISIG =\u003e VERSION_MAGIC_TPUB,\n\n            _ =\u003e return Err(Error::UnknownSlip32Prefix),\n        };\n        data[0..4].copy_from_slice(\u0026slice);\n\n        let xpub = Xpub::decode(\u0026data)?;\n\n        Ok(xpub)\n    }\n}\n\nimpl FromSlip132 for Xpriv {\n    fn from_slip132_str(s: \u0026str) -\u003e Result\u003cSelf, Error\u003e {\n        let mut data = base58::decode_check(s)?;\n\n        let mut prefix = [0u8; 4];\n        prefix.copy_from_slice(\u0026data[0..4]);\n        let slice = match prefix {\n            VERSION_MAGIC_XPRV\n            | VERSION_MAGIC_YPRV\n            | VERSION_MAGIC_ZPRV\n            | VERSION_MAGIC_YPRV_MULTISIG\n            | VERSION_MAGIC_ZPRV_MULTISIG =\u003e VERSION_MAGIC_XPRV,\n\n            VERSION_MAGIC_TPRV\n            | VERSION_MAGIC_UPRV\n            | VERSION_MAGIC_VPRV\n            | VERSION_MAGIC_UPRV_MULTISIG\n            | VERSION_MAGIC_VPRV_MULTISIG =\u003e VERSION_MAGIC_TPRV,\n\n            _ =\u003e return Err(Error::UnknownSlip32Prefix),\n        };\n        data[0..4].copy_from_slice(\u0026slice);\n\n        let xprv = Xpriv::decode(\u0026data)?;\n\n        Ok(xprv)\n    }\n}\n","traces":[{"line":135,"address":[3195744],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":136,"address":[3195759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[3195836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[3195875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[3195902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[3195919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[3195853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[3195941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[3195977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[3196009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[3196064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[3195819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[3196128],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":153,"address":[3196131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[3196160,3196576],"length":1,"stats":{"Line":0},"fn_name":"from_str"},{"line":231,"address":[3196555,3196180,3196266],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[3196348,3196282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[3196362,3196325,3196401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[3196454,3196378,3196415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[3196465,3196431,3196504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[3196481,3196515,3196539],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[3196521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[4663008,4664367],"length":1,"stats":{"Line":3},"fn_name":"from_slip132_str"},{"line":252,"address":[4663041,4663248],"length":1,"stats":{"Line":3},"fn_name":null},{"line":254,"address":[4663159],"length":1,"stats":{"Line":4},"fn_name":null},{"line":255,"address":[4663353,4663170],"length":1,"stats":{"Line":8},"fn_name":null},{"line":256,"address":[4663384,4663479,4663823,4664032,4663761],"length":1,"stats":{"Line":10},"fn_name":null},{"line":257,"address":[4663743],"length":1,"stats":{"Line":4},"fn_name":null},{"line":263,"address":[4663805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[4663420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[4664080,4663959],"length":1,"stats":{"Line":8},"fn_name":null},{"line":273,"address":[4664285,4664352,4664111],"length":1,"stats":{"Line":4},"fn_name":null},{"line":275,"address":[4664249],"length":1,"stats":{"Line":4},"fn_name":null},{"line":280,"address":[4664400,4665755],"length":1,"stats":{"Line":0},"fn_name":"from_slip132_str"},{"line":281,"address":[4664433,4664640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[4664551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[4664562,4664745],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[4664776,4665215,4664871,4665424,4665153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[4665135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[4665197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[4664812],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[4665472,4665351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[4665740,4665503,4665673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[4665637],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":9,"coverable":51},{"path":["/","home","dane","Desktop","SOB","Floresta","florestad","src","wallet_input.rs"],"content":"//!\n//! Handles different inputs, try to make sense out of it and store a sane descriptor at the end\n\nuse std::str::FromStr;\n\nuse bitcoin::Address;\nuse miniscript::Descriptor;\nuse miniscript::DescriptorPublicKey;\n\npub mod extended_pub_key {\n    use bitcoin::bip32::Xpub;\n\n    use crate::slip132;\n\n    pub fn from_str(s: \u0026str) -\u003e Result\u003cXpub, slip132::Error\u003e {\n        slip132::FromSlip132::from_slip132_str(s)\n    }\n}\n\nfn parse_xpubs(\n    xpubs: \u0026[String],\n) -\u003e Result\u003cVec\u003cDescriptor\u003cDescriptorPublicKey\u003e\u003e, crate::error::Error\u003e {\n    let mut descriptors = Vec::new();\n    for key in xpubs {\n        // Parses the descriptor and get an external and change descriptors\n        let xpub = extended_pub_key::from_str(key.as_str()).map_err(|e| {\n            log::error!(\"Invalid xpub provided: {key} \\nReason: {e:?}\");\n            e\n        })?;\n        let main_desc = format!(\"wpkh({xpub}/0/*)\");\n        let change_desc = format!(\"wpkh({xpub}/1/*)\");\n        descriptors.push(Descriptor::\u003cDescriptorPublicKey\u003e::from_str(\u0026main_desc)?);\n        descriptors.push(Descriptor::\u003cDescriptorPublicKey\u003e::from_str(\u0026change_desc)?);\n    }\n    Ok(descriptors)\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub(crate) struct InitialWalletSetup {\n    pub(crate) descriptors: Vec\u003cDescriptor\u003cDescriptorPublicKey\u003e\u003e,\n    pub(crate) addresses: Vec\u003cAddress\u003e,\n}\n\nimpl InitialWalletSetup {\n    pub(crate) fn build(\n        xpubs: \u0026[String],\n        initial_descriptors: \u0026[String],\n        addresses: \u0026[String],\n        network: bitcoin::Network,\n        addresses_per_descriptor: u32,\n    ) -\u003e Result\u003cSelf, crate::error::Error\u003e {\n        let mut descriptors = parse_xpubs(xpubs)?;\n        descriptors.extend(parse_descriptors(initial_descriptors)?);\n        descriptors.sort();\n        descriptors.dedup();\n        let mut addresses = addresses\n            .iter()\n            .flat_map(|address| match Address::from_str(address) {\n                Ok(address) =\u003e Ok(address.require_network(network)),\n                Err(e) =\u003e {\n                    log::error!(\"Invalid address provided: {address} \\nReason: {e:?}\");\n                    Err(e)\n                }\n            })\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n        addresses.extend(descriptors.iter().flat_map(|descriptor| {\n            (0..addresses_per_descriptor).map(|index| {\n                descriptor\n                    .at_derivation_index(index)\n                    .expect(\"Error while deriving address\")\n                    .address(network)\n                    .expect(\"Error while deriving address. Is this an active descriptor?\")\n            })\n        }));\n        addresses.sort();\n        addresses.dedup();\n        Ok(Self {\n            descriptors,\n            addresses,\n        })\n    }\n}\n\npub fn parse_descriptors(\n    descriptors: \u0026[String],\n) -\u003e Result\u003cVec\u003cDescriptor\u003cDescriptorPublicKey\u003e\u003e, crate::error::Error\u003e {\n    let descriptors = descriptors\n        .iter()\n        .map(|descriptor| {\n            let descriptor = Descriptor::\u003cDescriptorPublicKey\u003e::from_str(descriptor.as_str())?;\n            descriptor.sanity_check()?;\n            descriptor.into_single_descriptors()\n        })\n        .collect::\u003cResult\u003cVec\u003cVec\u003c_\u003e\u003e, _\u003e\u003e()?\n        .into_iter()\n        .flatten()\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    Ok(descriptors)\n}\n\n#[cfg(test)]\npub mod test {\n    use bitcoin::bip32::ChildNumber;\n    use bitcoin::secp256k1::Secp256k1;\n    use bitcoin::Network;\n\n    use super::*;\n\n    #[test]\n    fn test_xpub_parsing() {\n        // Test cases from https://github.com/satoshilabs/slips/blob/master/slip-0132.md\n        const XPUB: \u0026str = \"xpub6BosfCnifzxcFwrSzQiqu2DBVTshkCXacvNsWGYJVVhhawA7d4R5WSWGFNbi8Aw6ZRc1brxMyWMzG3DSSSSoekkudhUd9yLb6qx39T9nMdj\";\n        const YPUB: \u0026str = \"ypub6Ww3ibxVfGzLrAH1PNcjyAWenMTbbAosGNB6VvmSEgytSER9azLDWCxoJwW7Ke7icmizBMXrzBx9979FfaHxHcrArf3zbeJJJUZPf663zsP\";\n        const ZPUB: \u0026str = \"zpub6rFR7y4Q2AijBEqTUquhVz398htDFrtymD9xYYfG1m4wAcvPhXNfE3EfH1r1ADqtfSdVCToUG868RvUUkgDKf31mGDtKsAYz2oz2AGutZYs\";\n\n        let secp = Secp256k1::new();\n\n        let xpub: bitcoin::bip32::Xpub = super::extended_pub_key::from_str(XPUB)\n            .expect(\"Parsing failed\")\n            .ckd_pub(\u0026secp, ChildNumber::Normal { index: 0 })\n            .and_then(|key| key.ckd_pub(\u0026secp, ChildNumber::Normal { index: 0 }))\n            .unwrap();\n        let ypub = super::extended_pub_key::from_str(YPUB)\n            .expect(\"Parsing failed\")\n            .ckd_pub(\u0026secp, ChildNumber::Normal { index: 0 })\n            .and_then(|key| key.ckd_pub(\u0026secp, ChildNumber::Normal { index: 0 }))\n            .unwrap();\n        let zpub = super::extended_pub_key::from_str(ZPUB)\n            .expect(\"Parsing failed\")\n            .ckd_pub(\u0026secp, ChildNumber::Normal { index: 0 })\n            .and_then(|key| key.ckd_pub(\u0026secp, ChildNumber::Normal { index: 0 }))\n            .unwrap();\n        // Old p2pkh\n        assert_eq!(\n            Address::p2pkh(\u0026xpub.to_pub(), bitcoin::Network::Bitcoin)\n                .to_string()\n                .as_str(),\n            \"1LqBGSKuX5yYUonjxT5qGfpUsXKYYWeabA\"\n        );\n        // p2wpkh-p2pkh\n        let script = Address::p2wpkh(\u0026ypub.to_pub(), bitcoin::Network::Bitcoin)\n            .unwrap()\n            .script_pubkey();\n\n        assert_eq!(\n            Address::p2sh(\u0026script, Network::Bitcoin)\n                .unwrap()\n                .to_string()\n                .as_str(),\n            \"37VucYSaXLCAsxYyAPfbSi9eh4iEcbShgf\"\n        );\n\n        // p2wpkh\n        assert_eq!(\n            Address::p2wpkh(\u0026zpub.to_pub(), bitcoin::Network::Bitcoin)\n                .unwrap()\n                .to_string()\n                .as_str(),\n            \"bc1qcr8te4kr609gcawutmrza0j4xv80jy8z306fyu\"\n        )\n    }\n\n    #[test]\n    fn test_descriptor_parsing() {\n        // singlesig\n        assert_eq!(\n            parse_descriptors(\u0026[\n                \"wpkh([a5b13c0e/84h/0h/0h]xpub6CFy3kRXorC3NMTt8qrsY9ucUfxVLXyFQ49JSLm3iEG5gfAmWewYFzjNYFgRiCjoB9WWEuJQiyYGCdZvUTwPEUPL9pPabT8bkbiD9Po47XG/\u003c0;1\u003e/*)#n8sgapuv\".to_owned()\n            ]).unwrap(),\n            parse_descriptors(\u0026[\n                \"wpkh([a5b13c0e/84'/0'/0']xpub6CFy3kRXorC3NMTt8qrsY9ucUfxVLXyFQ49JSLm3iEG5gfAmWewYFzjNYFgRiCjoB9WWEuJQiyYGCdZvUTwPEUPL9pPabT8bkbiD9Po47XG/0/*)#wg8dh3s7\".to_owned(),\n                \"wpkh([a5b13c0e/84'/0'/0']xpub6CFy3kRXorC3NMTt8qrsY9ucUfxVLXyFQ49JSLm3iEG5gfAmWewYFzjNYFgRiCjoB9WWEuJQiyYGCdZvUTwPEUPL9pPabT8bkbiD9Po47XG/1/*)#luzv2yqx\".to_owned()\n            ]).unwrap()\n        );\n        // multisig\n        assert_eq!(\n            parse_descriptors(\u0026[\n                \"wsh(sortedmulti(1,[6f826a6a/48h/0h/0h/2h]xpub6DsY48BAsvEMTRPbeSTu9jZXqEsTKr5T86WbRbXHp2gEVCNR3hALnMorFawVwnnHMMfjbyY8We9B4beh1fxqhcv6kgSeLgQxeXDqv3DaW7m/\u003c0;1\u003e/*,[a5b13c0e/48h/0h/0h/2h]xpub6Eqj1Hj3RezebC6cKiYYN2sAc1Wu33BWoaafnNgAbQwDkJdy7aXCYCmaMzb8rCpmh919UsehyV5Ywjo62hG4R2G2PGv4uqEDTUhYQw26BDJ/\u003c0;1\u003e/*))#nykmcu2v\".to_owned()\n            ]).unwrap(),\n            parse_descriptors(\u0026[\n                \"wsh(sortedmulti(1,[6f826a6a/48'/0'/0'/2']xpub6DsY48BAsvEMTRPbeSTu9jZXqEsTKr5T86WbRbXHp2gEVCNR3hALnMorFawVwnnHMMfjbyY8We9B4beh1fxqhcv6kgSeLgQxeXDqv3DaW7m/0/*,[a5b13c0e/48'/0'/0'/2']xpub6Eqj1Hj3RezebC6cKiYYN2sAc1Wu33BWoaafnNgAbQwDkJdy7aXCYCmaMzb8rCpmh919UsehyV5Ywjo62hG4R2G2PGv4uqEDTUhYQw26BDJ/0/*))#sw68w95x\".to_owned(),\n                \"wsh(sortedmulti(1,[6f826a6a/48'/0'/0'/2']xpub6DsY48BAsvEMTRPbeSTu9jZXqEsTKr5T86WbRbXHp2gEVCNR3hALnMorFawVwnnHMMfjbyY8We9B4beh1fxqhcv6kgSeLgQxeXDqv3DaW7m/1/*,[a5b13c0e/48'/0'/0'/2']xpub6Eqj1Hj3RezebC6cKiYYN2sAc1Wu33BWoaafnNgAbQwDkJdy7aXCYCmaMzb8rCpmh919UsehyV5Ywjo62hG4R2G2PGv4uqEDTUhYQw26BDJ/1/*))#fafrqkpn\".to_owned()\n            ]).unwrap()\n        );\n    }\n\n    #[test]\n    fn test_initial_wallet_build() {\n        use pretty_assertions::assert_eq;\n        let addresses_per_descriptor = 1;\n        let network = Network::Bitcoin;\n        // Build wallet from xpub (in this case a zpub from slip132 standard)\n        let w1_xpub = InitialWalletSetup::build(\u0026[\n            \"zpub6qvVf5mN7DH14wr7oZS7xL6cpcFPDmxFEHBk18YpUF1qnroE1yGfW83eafbbi23dzRk7jrVXeJFMyCo3urmQpwkXtVnRmGmaJ3qVvdwx4mB\".to_owned()\n        ], \u0026[], \u0026[], network, addresses_per_descriptor).unwrap();\n        // Build same wallet from output descriptor\n        let w1_descriptor = InitialWalletSetup::build(\u0026[], \u0026[\n            \"wpkh(xpub6CFy3kRXorC3NMTt8qrsY9ucUfxVLXyFQ49JSLm3iEG5gfAmWewYFzjNYFgRiCjoB9WWEuJQiyYGCdZvUTwPEUPL9pPabT8bkbiD9Po47XG/\u003c0;1\u003e/*)\".to_owned()\n        ], \u0026[], network, addresses_per_descriptor).unwrap();\n        // Using both methods the result should be the same\n        assert_eq!(w1_xpub, w1_descriptor);\n        // Both normal receiving descriptor and change descriptor should be present\n        assert_eq!(\n            w1_descriptor.descriptors\n                .iter()\n                .map(ToString::to_string)\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\n                \"wpkh(xpub6CFy3kRXorC3NMTt8qrsY9ucUfxVLXyFQ49JSLm3iEG5gfAmWewYFzjNYFgRiCjoB9WWEuJQiyYGCdZvUTwPEUPL9pPabT8bkbiD9Po47XG/0/*)#qua4l7ct\",\n                \"wpkh(xpub6CFy3kRXorC3NMTt8qrsY9ucUfxVLXyFQ49JSLm3iEG5gfAmWewYFzjNYFgRiCjoB9WWEuJQiyYGCdZvUTwPEUPL9pPabT8bkbiD9Po47XG/1/*)#3gc5ztgn\"\n            ]\n        );\n        // Receiving and change addresses\n        let addresses = vec![\n            \"bc1q88guum89mxwszau37m3y4p24renwlwgtkscl6x\".to_owned(),\n            \"bc1q24629yendf7q0dxnw362dqccn52vuz9s0z59hr\".to_owned(),\n        ];\n        assert_eq!(\n            w1_descriptor\n                .addresses\n                .iter()\n                .map(ToString::to_string)\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            addresses\n        );\n        // We can build from these addresses\n        let w1_addresses =\n            InitialWalletSetup::build(\u0026[], \u0026[], \u0026addresses, network, addresses_per_descriptor)\n                .unwrap();\n        // And the result will be the same as from xpub/descriptor\n        assert_eq!(w1_descriptor.addresses, w1_addresses.addresses);\n        // We can also build from xpub, descriptor and addresses, at same time\n        let w1_all =\n            InitialWalletSetup::build(\u0026[\n                \"zpub6qvVf5mN7DH14wr7oZS7xL6cpcFPDmxFEHBk18YpUF1qnroE1yGfW83eafbbi23dzRk7jrVXeJFMyCo3urmQpwkXtVnRmGmaJ3qVvdwx4mB\".to_owned()\n            ], \u0026[\n                \"wpkh(xpub6CFy3kRXorC3NMTt8qrsY9ucUfxVLXyFQ49JSLm3iEG5gfAmWewYFzjNYFgRiCjoB9WWEuJQiyYGCdZvUTwPEUPL9pPabT8bkbiD9Po47XG/\u003c0;1\u003e/*)\".to_owned()\n            ], \u0026addresses, network, addresses_per_descriptor).unwrap();\n        // And the result should be the same, no duplication will happen\n        assert_eq!(w1_descriptor, w1_all);\n    }\n\n    #[test]\n    fn test_initial_wallet_build_multisig_testnet() {\n        use pretty_assertions::assert_eq;\n        let addresses_per_descriptor = 1;\n        let network = Network::Testnet;\n        let w1_descriptor = InitialWalletSetup::build(\u0026[], \u0026[\n            \"wsh(sortedmulti(1,[54ff5a12/48h/1h/0h/2h]tpubDDw6pwZA3hYxcSN32q7a5ynsKmWr4BbkBNHydHPKkM4BZwUfiK7tQ26h7USm8kA1E2FvCy7f7Er7QXKF8RNptATywydARtzgrxuPDwyYv4x/\u003c0;1\u003e/*,[bcf969c0/48h/1h/0h/2h]tpubDEFdgZdCPgQBTNtGj4h6AehK79Jm4LH54JrYBJjAtHMLEAth7LuY87awx9ZMiCURFzFWhxToRJK6xp39aqeJWrG5nuW3eBnXeMJcvDeDxfp/\u003c0;1\u003e/*))#fuw35j0q\".to_owned()\n        ], \u0026[], network, addresses_per_descriptor).unwrap();\n        let addresses = vec![\n            \"tb1q2eeqw57e7pmrh5w3wkrshctx2qk80vf4mu7l7ek3ne4hg3lmcrnqcwejgj\".to_owned(),\n            \"tb1q6dpyc3jyqelgfwksedef0k2244rcg4gf6wvqm463lk907es2m08qnrfky7\".to_owned(),\n        ];\n        assert_eq!(\n            w1_descriptor\n                .addresses\n                .iter()\n                .map(ToString::to_string)\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            addresses\n        );\n    }\n}\n","traces":[{"line":15,"address":[6877152],"length":1,"stats":{"Line":2},"fn_name":"from_str"},{"line":16,"address":[5768549],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[4244503,4242560,4244490],"length":1,"stats":{"Line":2},"fn_name":"parse_xpubs"},{"line":23,"address":[4242606],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[4242636,4242719,4242895],"length":1,"stats":{"Line":6},"fn_name":null},{"line":26,"address":[3180208],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":27,"address":[3180234,3180337,3180483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[3180279],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[4243444],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[4243685],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[4243805,4243876,4244450],"length":1,"stats":{"Line":4},"fn_name":null},{"line":33,"address":[4244125,4244429],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[4242806],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[4245933,4245964,4244528],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[4244783,4244635],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[4245962,4244899,4244776],"length":1,"stats":{"Line":5},"fn_name":null},{"line":54,"address":[4245096],"length":1,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[4245150],"length":1,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[4245167,4245214,4245450,4245944],"length":1,"stats":{"Line":6},"fn_name":null},{"line":58,"address":[3180611,3180576],"length":1,"stats":{"Line":7},"fn_name":"{closure#0}"},{"line":59,"address":[3180657],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[3180725],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[3180764,3180938,3181100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[3180821],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[3181216],"length":1,"stats":{"Line":12},"fn_name":"{closure#1}"},{"line":67,"address":[3181540,3181312,3181238],"length":1,"stats":{"Line":8},"fn_name":"{closure#0}"},{"line":68,"address":[3181427,3181485,3181349],"length":1,"stats":{"Line":12},"fn_name":null},{"line":71,"address":[3181423],"length":1,"stats":{"Line":4},"fn_name":null},{"line":75,"address":[4245646],"length":1,"stats":{"Line":4},"fn_name":null},{"line":76,"address":[4245686],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[4245794],"length":1,"stats":{"Line":3},"fn_name":null},{"line":78,"address":[4245698],"length":1,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[4245746],"length":1,"stats":{"Line":3},"fn_name":null},{"line":84,"address":[4245984],"length":1,"stats":{"Line":2},"fn_name":"parse_descriptors"},{"line":87,"address":[4246348,4246043],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[3182193,3182162,3181568],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":90,"address":[3181614,3181796],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[3182014,3181777,3181598,3181898],"length":1,"stats":{"Line":6},"fn_name":null},{"line":92,"address":[3181950],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[4246237],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":35,"coverable":40},{"path":["/","home","dane","Desktop","SOB","Floresta","florestad","src","zmq.rs"],"content":"use bitcoin::consensus::serialize;\n/// A small Zero Message Queue (ZMQ) implementation for floresta, that pushes new blocks\n/// as they are found.\n///\n/// # Examples\n/// Creating a server\n/// ```\n/// use florestad::zmq::ZMQServer;\n/// let _ = ZMQServer::new(\"tcp://127.0.0.1:5150\");\n/// ```\n///\n/// Listening for new blocks\n///\n/// ```!\n/// use zmq::{Context, Socket};\n/// let ctx =  Context::new();\n/// // The oposite of PUSH is PULL\n/// let socket = ctx.socket(zmq::SocketType::PULL).unwrap();\n///\n/// socket.connect(addr).unwrap();\n/// let block = socket.recv().unwrap();\n/// ```\nuse floresta_chain::BlockConsumer;\nuse zmq::Context;\nuse zmq::Socket;\n\n/// A 0MQ server that pushes blocks when we receive them\npub struct ZMQServer {\n    /// The ZMQ context that holds our socket. We don't really need it,\n    /// but if _ctx gets dropped, the socket is closed, so we keep it here.\n    _ctx: Context,\n    /// The actual socket where we'll send blocks\n    socket: Socket,\n}\n\n/// # Safety\n/// We only keep one reference of ZMQServer, usually inside an [std::sync::Arc], so it's ok\n/// to assume it can be [Sync].\nunsafe impl Sync for ZMQServer {}\n\nimpl ZMQServer {\n    /// Creates a new ZMQ server that listens on `addr` and pushes blocks\n    /// to connected peers as they are accepted\n    pub fn new(addr: \u0026str) -\u003e Result\u003cZMQServer, zmq::Error\u003e {\n        let ctx = Context::new();\n        let socket = ctx.socket(zmq::SocketType::PUSH)?;\n        socket.bind(addr)?;\n        Ok(ZMQServer { _ctx: ctx, socket })\n    }\n}\n\n// Implement BlockConsumer so we can subscribe on `ChainState`\nimpl BlockConsumer for ZMQServer {\n    fn consume_block(\u0026self, block: \u0026bitcoin::Block, _height: u32) {\n        let block = serialize(\u0026block);\n        if let Err(e) = self.socket.send(block, zmq::DONTWAIT) {\n            log::error!(\"while sending block over zmq: {e}\");\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta","examples","chainstate-builder.rs"],"content":"// SPDX-License-Identifier: MIT\n\n//! In node.rs we created a node that connects to the Bitcoin network and downloads the blockchain.\n//! We use the default chainstate, which starts at genesis and validates all blocks. This is\n//! the simplest way to create a node, but you can also create a node that starts at a given\n//! block, or that doesn't validate all signatures. All customizations are done through the\n//! ChainStateBuilder struct. This example shows how to use it.\nuse bitcoin::blockdata::constants::genesis_block;\nuse bitcoin::hashes::Hash;\nuse bitcoin::BlockHash;\nuse floresta::chain::ChainState;\nuse floresta::chain::KvChainStore;\nuse floresta::chain::Network;\nuse floresta_chain::pruned_utreexo::chain_state_builder::ChainStateBuilder;\nuse floresta_chain::ChainParams;\nuse rustreexo::accumulator::stump::Stump;\n\nconst DATA_DIR: \u0026str = \"./data\";\n\n#[async_std::main]\nasync fn main() {\n    // Create a new chain state, which will store the accumulator and the headers chain.\n    // It will be stored in the DATA_DIR directory. With this chain state, we don't keep\n    // the block data after we validated it. This saves a lot of space, but it means that\n    // we can't serve blocks to other nodes or rescan the blockchain without downloading\n    // it again.\n    let chain_store =\n        KvChainStore::new(DATA_DIR.into()).expect(\"failed to open the blockchain database\");\n\n    // Create a new chain state builder. We can use it to customize the chain state.\n    // Assume valid is the same as in node.rs, it's the block that we assume that all\n    // blocks before it have valid signatures.\n    //\n    // Tip is the block that we consider to be the tip of the chain. If you want to\n    // start the chainstate at a given block, you can use this. If you don't set it,\n    // it will start at genesis.\n    //\n    // We also set the chain params, which are the parameters of the network that we\n    // are connecting to. We use the Bitcoin network here, but you can also use\n    // Testnet, Signet or Regtest.\n    //\n    // Finally, we set the utreexo accumulator. This is the accumulator that we use\n    // to validate the blockchain. If you set the chain height, you should update\n    // the accumulator to the state of the blockchain at that height too.\n    let _chain: ChainState\u003cKvChainStore\u003e = ChainStateBuilder::new()\n        .with_assume_valid(BlockHash::all_zeros())\n        .with_chain_params(ChainParams::from(Network::Bitcoin))\n        .with_tip(\n            (genesis_block(bitcoin::Network::Bitcoin).block_hash(), 0),\n            genesis_block(bitcoin::Network::Bitcoin).header,\n        )\n        .assume_utreexo(Stump::new())\n        .with_chainstore(chain_store)\n        .build()\n        .unwrap();\n\n    // ... If you want to drive the chainstate, you can use the BlockchainInterface trait.\n    // See node.rs for an example on how to do it ...\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta","examples","node.rs"],"content":"// SPDX-License-Identifier: MIT\n\n//! A simple example of a Bitcoin node using the floresta crates. It connects to the Bitcoin\n//! network, downloads the blockchain, and prints the current state of the accumulator.\n//! This will validate all blocks from genesis to the current tip, so it will take a while\n//! to sync.\n\nuse std::str::FromStr;\nuse std::sync::Arc;\n\nuse async_std::sync::RwLock;\nuse bitcoin::BlockHash;\nuse floresta::chain::pruned_utreexo::BlockchainInterface;\nuse floresta::chain::ChainState;\nuse floresta::chain::KvChainStore;\nuse floresta::chain::Network;\nuse floresta::wire::mempool::Mempool;\nuse floresta::wire::node::UtreexoNode;\nuse floresta_chain::AssumeValidArg;\nuse floresta_wire::node_interface::NodeMethods;\nuse floresta_wire::running_node::RunningNode;\nuse floresta_wire::UtreexoNodeConfig;\n\nconst DATA_DIR: \u0026str = \"./data\";\n\n#[async_std::main]\nasync fn main() {\n    // Create a new chain state, which will store the accumulator and the headers chain.\n    // It will be stored in the DATA_DIR directory. With this chain state, we don't keep\n    // the block data after we validated it. This saves a lot of space, but it means that\n    // we can't serve blocks to other nodes or rescan the blockchain without downloading\n    // it again.\n    let chain_store =\n        KvChainStore::new(DATA_DIR.into()).expect(\"failed to open the blockchain database\");\n\n    // The actual chainstate. It will keep track of the current state of the accumulator\n    // and the headers chain. It will also validate new blocks and headers as we receive them.\n    // The last parameter is the assume valid block. We assume that all blocks before this\n    // one have valid signatures. This is a performance optimization, as we don't need to validate all\n    // signatures in the blockchain, just the ones after the assume valid block. We are giving a Disabled\n    // value, so we will validate all signatures regardless.\n    // We place the chain state in an Arc, so we can share it with other components.\n    let chain = Arc::new(ChainState::\u003cKvChainStore\u003e::new(\n        chain_store,\n        Network::Bitcoin,\n        AssumeValidArg::Disabled,\n    ));\n\n    // Create a new node. It will connect to the Bitcoin network and start downloading the blockchain.\n    // It will also start a mempool, which will keep track of the current mempool state, this\n    // particular mempool doesn't store other's transactions, it just keeps track of our own, to\n    // perform broadcast. We always rebroadcast our own transactions every hour.\n    // Note that we are using the RunningNode context, which is a state optimized for a node that\n    // already has the blockchain synced. You don't need to worry about this, because internally\n    // the node will automatically switch to the IBD context and back once it's finished.\n    // If you want a node to IBD only, you can use the IBDNode context.\n    // Finally, we are using the chain state created above, the node will use it to determine\n    // what blocks and headers to download, and hand them to it to validate.\n    let config = UtreexoNodeConfig::default();\n    let p2p: UtreexoNode\u003cRunningNode, Arc\u003cChainState\u003cKvChainStore\u003e\u003e\u003e = UtreexoNode::new(\n        config,\n        chain.clone(),\n        Arc::new(RwLock::new(Mempool::new())),\n        None,\n    );\n    // A handle is a simple way to interact with the node. It implements a queue of requests\n    // that will be processed by the node.\n    let handle = p2p.get_handle();\n\n    let (sender, _receiver) = futures::channel::oneshot::channel();\n\n    // Start the node. This will start the IBD process, and will return once the node is synced.\n    // It will also start the mempool, which will start rebroadcasting our transactions every hour.\n    // The node will keep running until the process is killed, by setting kill_signal to true. In\n    // this example, we don't kill the node, so it will keep running forever.\n    p2p.run(Arc::new(RwLock::new(false)), sender).await;\n\n    // That's it! The node is now running, and will keep running until the process is killed.\n    // You can now use the chain state to query the current state of the accumulator, or the\n    // mempool to query the current state of the mempool. You may also ask the node to grab some\n    // blocks or headers for you, or to send a transaction to the network, rescan the blockchain,\n    // etc. Check the documentation of the node for more information.\n\n    // You can't request blocks or headers from the node until it's synced. You can check if it's\n    // synced by calling the is_in_ibd method.\n    loop {\n        // Wait till the node is synced\n        if !chain.is_in_idb() {\n            break;\n        }\n        // Sleep for 10 seconds, and check again\n        std::thread::sleep(std::time::Duration::from_secs(10));\n    }\n\n    // Here we ask the node to grab the block with the given hash.\n    let block = handle\n        .get_block(\n            BlockHash::from_str(\"000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\")\n                .unwrap(),\n        )\n        .unwrap();\n    println!(\"Block: {:?}\", block);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta","examples","watch-only.rs"],"content":"// SPDX-License-Identifier: MIT\n\n//! This example shows how to create a watch-only wallet, and drive it.\n\nuse bitcoin::consensus::deserialize;\nuse bitcoin::hashes::hex::FromHex;\nuse bitcoin::ScriptBuf;\nuse floresta_common::get_spk_hash;\nuse floresta_watch_only::memory_database::MemoryDatabase;\nuse floresta_watch_only::AddressCache;\nuse miniscript::bitcoin::secp256k1::Secp256k1;\nuse miniscript::Descriptor;\n\nfn main() {\n    // First, we need some place to store the wallet data. Here, we use an in-memory database,\n    // that will be destroyed when the program exits. You can use any database that implements\n    // the `AddressCacheDatabase` trait.\n    let wallet_data = MemoryDatabase::new();\n    // Then, we create the wallet itself.\n    let mut wallet = AddressCache::new(wallet_data);\n    // Now, we need to add the addresses we want to watch. We can add them one by one, or\n    // we can add a descriptor that will generate the addresses for us. Here, we use a\n    // descriptor that generates P2WPKH addresses. The descriptor is parsed using the\n    // `miniscript` library. You can use any descriptor that `miniscript` supports.\n\n    // To parse a descriptor, we need a `Secp256k1` context. This is a wrapper around the\n    // secp256k1 library, that provides some additional functionality. We need it to parse\n    // the descriptor, and to derive the addresses.\n    let secp = Secp256k1::new();\n\n    // We can now parse the descriptor. The `parse_descriptor` function returns a tuple\n    // containing the parsed descriptor, and the map of the keys used in the descriptor.\n    // The keys are indexed by their fingerprint, and the index of the key in the descriptor.\n    let (descriptor, _) = Descriptor::parse_descriptor(\u0026secp, \"wpkh([18940c85/84'/1'/0']tpubDDgpGUUjzTqLqQL9WzPvMDTKyD95AUcwWohMWWoj5kqGU7VLSZ3ju9ZtHRN4ofK6KNaZsTSpB6yGrFuV1V4yVgcwksueuFW3YnKxwoNqb3V/0/*)#0vfhw5fe\").unwrap();\n\n    // We can now add the descriptor to the wallet. This will generate the first 100 addresses\n    // for us, and add them to the wallet.\n    for i in 0..100 {\n        wallet.cache_address(bitcoin::ScriptBuf::from(\n            descriptor\n                .at_derivation_index(i)\n                .unwrap()\n                .explicit_script()\n                .unwrap()\n                .as_bytes()\n                .to_vec(),\n        ));\n    }\n    // We can now process some blocks. Here, we process the first 11 blocks of a custom\n    // regtest network. Each coinbase some of the addresses derived above.\n    for block in BLOCKS.iter() {\n        let block = Vec::from_hex(block).unwrap();\n        let _ = wallet.block_process(\u0026deserialize(\u0026block).unwrap(), 1);\n    }\n    // We can now query the wallet for information about the addresses we added. For example,\n    // we can get the history of the second address, the balance, and the UTXOs. To fetch the\n    // history, we need to know the hash of the address. We can get it using the `get_spk_hash`\n    // function from the `floresta_common` crate. This hash is defined by the Electrum protocol.\n    let hash =\n        get_spk_hash(\u0026ScriptBuf::from_hex(\"00148dae58668d0c15f7ed4f430925634c9a2c666b84\").unwrap());\n\n    // We can now query the wallet for the information we want.\n\n    // Fetch all txids that involve the address.\n    let history = wallet\n        .get_address_history(\u0026hash)\n        .unwrap()\n        .iter()\n        .map(|tx| tx.hash)\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    // Fetch the balance of the address.\n    let balance = wallet.get_address_balance(\u0026hash);\n    // Fetch the UTXOs of the address.\n    let utxos = wallet.get_address_utxos(\u0026hash);\n\n    // We can now print the information we fetched.\n    println!(\"************** Wallet Summary *****************\\n\");\n    println!(\"Descriptor: {}\\n\", descriptor);\n    println!(\"Address #1 hash: {}\\n\", hash);\n    println!(\"History: {:#?}\\n\", history);\n    println!(\"Balance: {:?}\\n\", balance);\n    println!(\"UTXOs: {:#?}\", utxos);\n}\n\nconst BLOCKS: [\u0026str; 11] = [\n    \"0000002006226e46111a0b59caaf126043eb5bbf28c34f3a5e332a1fc7b2b73cf188910f05b917cfbd9c40358ff9a0e64f9da95fd676b8a02a42a32c1c192bd76db60eef20249364ffff7f200300000001020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff03510101ffffffff0200f2052a01000000160014b4ad0d1d8978f3680fa3fc2dfb81b1143a27d4a30000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000\",\n    \"000000201b0abeb75b806f29ee13248bf9c7892672cf80ded985f27fb2f5eb41108bca061e0d3a1c401b2cb5abdc7d1b45da6fa6eb23c7b2ceb82b3c501e15e33d8f30089b309364ffff7f200000000001020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff03520101ffffffff0200f2052a010000001600148dae58668d0c15f7ed4f430925634c9a2c666b840000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000\",\n    \"000000203ed220606ae32337ff45816054bb01a39bfd943ca84daa61c50ad173285f414df345b7d00a902077ef29be75ea0f7b6a4b816d6ad61112865273576fcd3e4b109b309364ffff7f200000000001020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff03530101ffffffff0200f2052a010000001600148dae58668d0c15f7ed4f430925634c9a2c666b840000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000\",\n    \"00000020ba4b379335f3896b025293e6ceeceb865a22093e8550adcca844adfd2afdb00c7482b91566cb4f5c26f917e121699d61bba1926b9dbf43e0fa85fae80649f6889c309364ffff7f200000000001020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff03540101ffffffff0200f2052a010000001600148dae58668d0c15f7ed4f430925634c9a2c666b840000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000\",\n    \"000000208297ce55eed31f7d3fb2cb5b1a5aaeddbc8b4b3133b5623502603a7c1b807477075cf1bb8f9e2f58c63c8ed8b3a085a52a5c982adc6a020994dd59cbe227832d9c309364ffff7f200000000001020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff03550101ffffffff0200f2052a010000001600148dae58668d0c15f7ed4f430925634c9a2c666b840000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000\",\n    \"00000020936b5320b7b346069715fd6ab491b8a29241b5c990b39f50a793c6329b7005671bf190dc397e976064eccff3eca995df63c3f49948fd2889355b935ff42c91de9c309364ffff7f200000000001020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff03560101ffffffff0200f2052a010000001600148dae58668d0c15f7ed4f430925634c9a2c666b840000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000\",\n    \"0000002058217e2ee8e6074c8b26d67b96c9130f0cb52adcced5ba67a30e53a7eacee37caaa4812183e293e93428161f6f89179066124152ca8b1658d66ace5b76aa61849c309364ffff7f200200000001020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff03570101ffffffff0200f2052a010000001600148dae58668d0c15f7ed4f430925634c9a2c666b840000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000\",\n    \"00000020e48e8d22a54e78018591d386fbe5b09d3588756cc541e514074f82aa2596a76400b239f668cb9c5c5809e206754c96a0215a5d7013405ac1b4ad37536400c3649d309364ffff7f200000000001020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff03580101ffffffff0200f2052a010000001600148dae58668d0c15f7ed4f430925634c9a2c666b840000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000\",\n    \"00000020c007dbdee745169560c57367725b69be705b2e2728c6da6313c722309d4a456bce0d0e66ddf0ad519cb91384f1e5038ee3765f31b57781f6eda08678e83e1fcc9f309364ffff7f200100000001020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff03590101ffffffff0200f2052a010000001600148dae58668d0c15f7ed4f430925634c9a2c666b840000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000\",\n    \"000000201096d0268755a324b6b9a1df531877b3f8e161c21261063ba1f1d79d5ba22e5bb386dd8071a9d2a62a2763cc64ceebe85535d4665d7a4f02f18408579874852e9f309364ffff7f200000000001020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff035a0101ffffffff0200f2052a010000001600148dae58668d0c15f7ed4f430925634c9a2c666b840000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000\",\n    \"00000020d0a457ae192831a9dcc1245ed7387c1efc3423bd09d5a306a02772f3ac16827c021a6dbe6981c7e57307533026dc972dd29e5b04d899ba13df355c87cd2797ed9f309364ffff7f200100000001020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff035b0101ffffffff0200f2052a010000001600148dae58668d0c15f7ed4f430925634c9a2c666b840000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000\",\n];\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta","src","lib.rs"],"content":"// SPDX-License-Identifier: MIT\n\n//! Floresta, a collection of crates to build lightweight, fast, and reliable\n//! Bitcoin nodes and wallets, powered by Utreexo, a novel accumulator to represent\n//! the Bitcoin UTXO set.\n//!\n//! This project is layed out as a collection of crates, each implementing one functionality.\n//! They are all named floresta-*. The main crate is floresta, which is a meta-crate\n//! that depends on all the others. It is meant to be used as a dependency in other projects.\n//!\n//! A Bitcoin node is composed of several components. You need some way to express the current\n//! network state, some way to communicate with other nodes, some way to store the blockchain,\n//! validate data you receive and interact with the user.\n//! The current network state (including the accumulator) is tracked by the floresta-chain crate.\n//! It doesn't know where data comes from, it just tracks the state, exposing a simple API to\n//! update it. The chain is reactive, meaning that it will only update when new data is received.\n//!\n//! The floresta-wire crate is responsible for communicating with other nodes. It is a simple\n//! node implementation that can connect to other nodes, send and receive messages, and\n//! handle the peer-to-peer protocol. It is not a full node, it doesn't store the blockchain\n//! or validate data, it just sends and receives messages.\n//!\n//! Floresta also provides a simple watch-only wallet and an electrum server implementation.\n//! They are meant to be used in `florestad`, a full node implementation that uses all the\n//! crates in this project.\n//!\n//! You can find examples of how to use the crates in the examples directory.\n//! # Name\n//! Floresta is the Portuguese word for forest. It is a reference to the Utreexo accumulator,\n//! which is a forest of Merkle trees. It's pronounced /floˈɾɛstɐ/.\n/// Components to build an utreexo-aware, consensus enforcing Bitcoin node.\npub use floresta_chain as chain;\n/// Useful data structures and traits used by the other crates.\npub use floresta_common as common;\n#[cfg(feature = \"electrum-server\")]\n/// An electrum server implementation\npub use floresta_electrum as electrum;\n#[cfg(feature = \"watch-only-wallet\")]\n/// A watch-only wallet implementation, optimized for electrum servers.\npub use floresta_watch_only as wallet;\n/// The transport used to fetch network data.\npub use floresta_wire as wire;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-chain","src","lib.rs"],"content":"// SPDX-License-Identifier: MIT\n//! # Floresta Chain\n//! This crate provides the core validation logic for a full node using libfloresta.\n//! It is maintained as a separate crate to allow other projects to build on it,\n//! independent of the libfloresta P2P network or libfloresta wallet.\n//! The main entry point is the [ChainState] struct, that keeps track of the current\n//! blockchain state, like headers and utreexo accumulator.\n//!\n//! All data is stored in a `ChainStore` implementation, which is generic over the\n//! underlying database. See the ChainStore trait for more information. For a\n//! ready-to-use implementation, see the [KvChainStore] struct.\n#![cfg_attr(any(feature = \"no-std\", not(test)), no_std)]\n\npub mod pruned_utreexo;\npub(crate) use floresta_common::prelude;\npub use pruned_utreexo::chain_state::*;\npub use pruned_utreexo::chainparams::*;\npub use pruned_utreexo::chainstore::*;\npub use pruned_utreexo::error::*;\npub use pruned_utreexo::udata::*;\npub use pruned_utreexo::Notification;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum Network {\n    Bitcoin,\n    Testnet,\n    Regtest,\n    Signet,\n}\nimpl From\u003cbitcoin::network::Network\u003e for Network {\n    fn from(network: bitcoin::network::Network) -\u003e Self {\n        match network {\n            bitcoin::network::Network::Bitcoin =\u003e Network::Bitcoin,\n            bitcoin::network::Network::Testnet =\u003e Network::Testnet,\n            bitcoin::network::Network::Regtest =\u003e Network::Regtest,\n            bitcoin::network::Network::Signet =\u003e Network::Signet,\n            _ =\u003e panic!(\"Unknown network\"),\n        }\n    }\n}\nimpl From\u003cNetwork\u003e for bitcoin::network::Network {\n    fn from(network: Network) -\u003e Self {\n        match network {\n            Network::Bitcoin =\u003e bitcoin::network::Network::Bitcoin,\n            Network::Testnet =\u003e bitcoin::network::Network::Testnet,\n            Network::Regtest =\u003e bitcoin::network::Network::Regtest,\n            Network::Signet =\u003e bitcoin::network::Network::Signet,\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use bitcoin::network::Network as BNetwork;\n\n    use super::*;\n    #[test]\n    fn test_network() {\n        assert_eq!(Network::Bitcoin, BNetwork::Bitcoin.into());\n        assert_eq!(Network::Testnet, BNetwork::Testnet.into());\n        assert_eq!(Network::Regtest, BNetwork::Regtest.into());\n        assert_eq!(Network::Signet, BNetwork::Signet.into());\n    }\n}\n","traces":[{"line":31,"address":[1188816],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":32,"address":[1188823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[22845592],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[1188863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[22845613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[22845606],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[22845590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[1032848],"length":1,"stats":{"Line":4},"fn_name":"from"},{"line":43,"address":[22988055],"length":1,"stats":{"Line":4},"fn_name":null},{"line":44,"address":[1471032],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[1032895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[1032902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[1032909],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":11,"coverable":13},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-chain","src","pruned_utreexo","chain_state.rs"],"content":"extern crate alloc;\n#[cfg(not(feature = \"no-std\"))]\nextern crate std;\n\nuse alloc::borrow::ToOwned;\nuse alloc::fmt::format;\nuse alloc::string::ToString;\nuse alloc::sync::Arc;\nuse alloc::vec::Vec;\nuse core::cell::UnsafeCell;\n#[cfg(feature = \"bitcoinconsensus\")]\nuse core::ffi::c_uint;\n\n#[cfg(feature = \"bitcoinconsensus\")]\nuse bitcoin::bitcoinconsensus;\nuse bitcoin::block::Header as BlockHeader;\nuse bitcoin::blockdata::constants::genesis_block;\nuse bitcoin::consensus::deserialize_partial;\nuse bitcoin::consensus::Decodable;\nuse bitcoin::consensus::Encodable;\nuse bitcoin::hashes::sha256;\nuse bitcoin::hashes::Hash;\nuse bitcoin::p2p::utreexo::UtreexoBlock;\nuse bitcoin::Block;\nuse bitcoin::BlockHash;\nuse bitcoin::OutPoint;\nuse bitcoin::Target;\nuse bitcoin::Transaction;\nuse bitcoin::TxOut;\nuse bitcoin::Work;\nuse floresta_common::Channel;\nuse log::info;\nuse log::trace;\nuse log::warn;\nuse rustreexo::accumulator::node_hash::NodeHash;\nuse rustreexo::accumulator::proof::Proof;\nuse rustreexo::accumulator::stump::Stump;\nuse spin::RwLock;\n\nuse super::chain_state_builder::ChainStateBuilder;\nuse super::chainparams::ChainParams;\nuse super::chainstore::DiskBlockHeader;\nuse super::chainstore::KvChainStore;\nuse super::consensus::Consensus;\nuse super::error::BlockValidationErrors;\nuse super::error::BlockchainError;\nuse super::partial_chain::PartialChainState;\nuse super::partial_chain::PartialChainStateInner;\nuse super::BlockchainInterface;\nuse super::ChainStore;\nuse super::UpdatableChainstate;\nuse crate::prelude::*;\nuse crate::read_lock;\nuse crate::write_lock;\nuse crate::Network;\n\npub trait BlockConsumer: Sync + Send + 'static {\n    fn consume_block(\u0026self, block: \u0026Block, height: u32);\n}\n\nimpl BlockConsumer for Channel\u003c(Block, u32)\u003e {\n    fn consume_block(\u0026self, block: \u0026Block, height: u32) {\n        self.send((block.to_owned(), height));\n    }\n}\n\npub struct ChainStateInner\u003cPersistedState: ChainStore\u003e {\n    /// The acc we use for validation.\n    acc: Stump,\n    /// All data is persisted here.\n    chainstore: PersistedState,\n    /// Best known block, cached in a specific field to faster access.\n    best_block: BestChain,\n    /// When one of our consumers tries to broadcast a transaction, this transaction gets\n    /// writen to broadcast_queue, and the ChainStateBackend can use it's own logic to actually\n    /// broadcast the tx.\n    broadcast_queue: Vec\u003cTransaction\u003e,\n    /// We may have multiple mudules that needs to receive and process blocks as they come, to\n    /// be notified of new blocks, a module should implement the [BlockConsumer] trait, and\n    /// subscribe by passing an [Arc] of itself to chainstate.\n    /// When a new block is accepted (as valid) we call `consume_block` from [BlockConsumer].\n    /// If a mudule just wants pass in a channel, [Sender] implements [BlockConsumer], and can\n    /// be used during subscription (just keep the [Receiver] side.\n    subscribers: Vec\u003cArc\u003cdyn BlockConsumer\u003e\u003e,\n    /// Fee estimation for 1, 10 and 20 blocks\n    fee_estimation: (f64, f64, f64),\n    /// Are we in Initial Block Download?\n    ibd: bool,\n    /// Parameters for the chain and functions that verify the chain.\n    consensus: Consensus,\n    /// Assume valid is a Core-specific config that tells the node to not validate signatures\n    /// in blocks before this one. Note that we only skip signature validation, everything else\n    /// is still validated.\n    assume_valid: Option\u003cBlockHash\u003e,\n}\npub struct ChainState\u003cPersistedState: ChainStore\u003e {\n    inner: RwLock\u003cChainStateInner\u003cPersistedState\u003e\u003e,\n}\n#[derive(Debug, Copy, Clone)]\npub enum AssumeValidArg {\n    Disabled,\n    Hardcoded,\n    UserInput(BlockHash),\n}\n\nimpl\u003cPersistedState: ChainStore\u003e ChainState\u003cPersistedState\u003e {\n    fn maybe_reindex(\u0026self, potential_tip: \u0026DiskBlockHeader) {\n        match potential_tip {\n            DiskBlockHeader::HeadersOnly(_, height) =\u003e {\n                if *height \u003e self.get_best_block().unwrap().0 {\n                    let best_chain = self.reindex_chain();\n                    write_lock!(self).best_block = best_chain;\n                }\n            }\n            DiskBlockHeader::FullyValid(header, _) =\u003e {\n                self.inner.write().best_block.validation_index = header.block_hash();\n            }\n            _ =\u003e {}\n        }\n    }\n\n    /// Just adds headers to the chainstate, without validating them.\n    pub fn push_headers(\n        \u0026self,\n        headers: Vec\u003cBlockHeader\u003e,\n        height: u32,\n    ) -\u003e Result\u003c(), BlockchainError\u003e {\n        let chainstore = \u0026read_lock!(self).chainstore;\n        for (offset, \u0026header) in headers.iter().enumerate() {\n            let block_hash = header.block_hash();\n            let disk_header = DiskBlockHeader::FullyValid(header, height + offset as u32);\n            chainstore.save_header(\u0026disk_header)?;\n            chainstore.update_block_index(height + offset as u32, block_hash)?;\n        }\n        Ok(())\n    }\n    #[cfg(feature = \"bitcoinconsensus\")]\n    /// Returns the validation flags, given the current block height\n    fn get_validation_flags(\u0026self, height: u32) -\u003e c_uint {\n        let chains_params = \u0026read_lock!(self).consensus.parameters;\n        let hash = read_lock!(self)\n            .chainstore\n            .get_block_hash(height)\n            .unwrap()\n            .unwrap();\n        if let Some(flag) = chains_params.exceptions.get(\u0026hash) {\n            return *flag;\n        }\n        // From Bitcoin Core:\n        // BIP16 didn't become active until Apr 1 2012 (on mainnet, and\n        // retroactively applied to testnet)\n        // However, only one historical block violated the P2SH rules (on both\n        // mainnet and testnet).\n        // Similarly, only one historical block violated the TAPROOT rules on\n        // mainnet.\n        // For simplicity, always leave P2SH+WITNESS+TAPROOT on except for the two\n        // violating blocks.\n        let mut flags = bitcoinconsensus::VERIFY_P2SH | bitcoinconsensus::VERIFY_WITNESS;\n\n        if height \u003e= chains_params.bip65_activation_height {\n            flags |= bitcoinconsensus::VERIFY_CHECKLOCKTIMEVERIFY;\n        }\n        if height \u003e= chains_params.bip66_activation_height {\n            flags |= bitcoinconsensus::VERIFY_DERSIG;\n        }\n        if height \u003e= chains_params.csv_activation_height {\n            flags |= bitcoinconsensus::VERIFY_CHECKSEQUENCEVERIFY;\n        }\n        if height \u003e= chains_params.segwit_activation_height {\n            flags |= bitcoinconsensus::VERIFY_NULLDUMMY;\n        }\n        flags\n    }\n\n    fn update_header(\u0026self, header: \u0026DiskBlockHeader) -\u003e Result\u003c(), BlockchainError\u003e {\n        Ok(read_lock!(self).chainstore.save_header(header)?)\n    }\n    fn validate_header(\u0026self, block_header: \u0026BlockHeader) -\u003e Result\u003cBlockHash, BlockchainError\u003e {\n        let prev_block = self.get_disk_block_header(\u0026block_header.prev_blockhash)?;\n        let prev_block_height = prev_block.height();\n        if prev_block_height.is_none() {\n            return Err(BlockValidationErrors::BlockExtendsAnOrphanChain.into());\n        }\n        let height = prev_block_height.unwrap() + 1;\n\n        // Check pow\n        let expected_target = self.get_next_required_work(\u0026prev_block, height, block_header);\n\n        let actual_target = block_header.target();\n        if actual_target \u003e expected_target {\n            return Err(BlockValidationErrors::NotEnoughPow.into());\n        }\n\n        let block_hash = block_header\n            .validate_pow(actual_target)\n            .map_err(|_| BlockchainError::BlockValidation(BlockValidationErrors::NotEnoughPow))?;\n        Ok(block_hash)\n    }\n\n    #[inline]\n    /// Whether a node is the genesis block for this net\n    fn is_genesis(\u0026self, header: \u0026BlockHeader) -\u003e bool {\n        header.block_hash() == self.chain_params().genesis.block_hash()\n    }\n    #[inline]\n    /// Returns the ancestor of a given block\n    fn get_ancestor(\u0026self, header: \u0026BlockHeader) -\u003e Result\u003cDiskBlockHeader, BlockchainError\u003e {\n        self.get_disk_block_header(\u0026header.prev_blockhash)\n    }\n    /// Returns the cumulative work in this branch\n    fn get_branch_work(\u0026self, header: \u0026BlockHeader) -\u003e Result\u003cWork, BlockchainError\u003e {\n        let mut header = *header;\n        let mut work = Work::from_be_bytes([0; 32]);\n        while !self.is_genesis(\u0026header) {\n            work = work + header.work();\n            header = *self.get_ancestor(\u0026header)?;\n        }\n\n        Ok(work)\n    }\n    /// Checks if a branch is valid (i.e. all ancestors are known)\n    fn check_branch(\u0026self, branch_tip: \u0026BlockHeader) -\u003e Result\u003c(), BlockchainError\u003e {\n        let mut header = *branch_tip;\n\n        while !self.is_genesis(\u0026header) {\n            let _header = self.get_ancestor(\u0026header)?;\n            if let DiskBlockHeader::Orphan(block) = _header {\n                return Err(BlockchainError::InvalidTip(format(format_args!(\n                    \"Block {} doesn't have a known ancestor (i.e an orphan block)\",\n                    block.block_hash()\n                ))));\n            }\n            header = *_header;\n        }\n\n        Ok(())\n    }\n    /// Returns the depth of a branch (i.e. how many blocks are in the branch)\n    fn get_chain_depth(\u0026self, branch_tip: \u0026BlockHeader) -\u003e Result\u003cu32, BlockchainError\u003e {\n        let mut header = *branch_tip;\n\n        let mut counter = 0;\n        while !self.is_genesis(\u0026header) {\n            header = *self.get_ancestor(\u0026header)?;\n            counter += 1;\n        }\n\n        Ok(counter)\n    }\n    /// Mark the current index as active, because we are in the middle of a reorg\n    fn mark_chain_as_active(\n        \u0026self,\n        new_tip: \u0026BlockHeader,\n        fork_point: BlockHash,\n    ) -\u003e Result\u003c(), BlockchainError\u003e {\n        let mut height = self.get_chain_depth(new_tip)?;\n        let mut header = DiskBlockHeader::HeadersOnly(*new_tip, height);\n\n        let inner = read_lock!(self);\n\n        while !self.is_genesis(\u0026header) || header.block_hash() == fork_point {\n            inner\n                .chainstore\n                .update_block_index(height, header.block_hash())?;\n            let new_header = DiskBlockHeader::HeadersOnly(*header, height);\n            inner.chainstore.save_header(\u0026new_header)?;\n            header = self.get_ancestor(\u0026header)?;\n            height -= 1;\n        }\n        Ok(())\n    }\n    /// Mark the current index as inactive, either because we found an invalid ancestor,\n    /// or we are in the middle of reorg\n    fn mark_chain_as_inactive(\n        \u0026self,\n        old_tip: \u0026BlockHeader,\n        fork_point: BlockHash,\n    ) -\u003e Result\u003c(), BlockchainError\u003e {\n        let mut header = *old_tip;\n        let mut height = self.get_chain_depth(old_tip)?;\n\n        let inner = read_lock!(self);\n        while !self.is_genesis(\u0026header) || header.block_hash() == fork_point {\n            let new_header = DiskBlockHeader::InFork(header, height);\n            inner.chainstore.save_header(\u0026new_header)?;\n            header = *self.get_ancestor(\u0026header)?;\n            height -= 1;\n        }\n\n        Ok(())\n    }\n    /// Finds where in the current index, a given branch forks out.\n    fn find_fork_point(\u0026self, header: \u0026BlockHeader) -\u003e Result\u003cBlockHeader, BlockchainError\u003e {\n        let mut header = *self.get_ancestor(header)?;\n        let inner = read_lock!(self);\n        while !self.is_genesis(\u0026header) {\n            match inner.chainstore.get_header(\u0026header.block_hash())? {\n                Some(DiskBlockHeader::HeadersOnly(block, _)) =\u003e {\n                    return Ok(block);\n                }\n                Some(DiskBlockHeader::FullyValid(block, _)) =\u003e {\n                    return Ok(block);\n                }\n                Some(DiskBlockHeader::InFork(block, _)) =\u003e {\n                    header = *self.get_ancestor(\u0026block)?;\n                    continue;\n                }\n                Some(DiskBlockHeader::AssumedValid(block, _)) =\u003e {\n                    return Ok(block);\n                }\n                Some(DiskBlockHeader::Orphan(header)) =\u003e {\n                    return Err(BlockchainError::InvalidTip(format(format_args!(\n                        \"Block {} doesn't have a known ancestor (i.e an orphan block)\",\n                        header.block_hash()\n                    ))));\n                }\n                Some(DiskBlockHeader::InvalidChain(header)) =\u003e {\n                    return Err(BlockchainError::InvalidTip(format(format_args!(\n                        \"Block {} is invalid\",\n                        header.block_hash()\n                    ))));\n                }\n                None =\u003e {\n                    return Err(BlockchainError::InvalidTip(format(format_args!(\n                        \"Block {} isn't in our storage\",\n                        header.block_hash()\n                    ))));\n                }\n            }\n        }\n        Err(BlockchainError::InvalidTip(\n            \"Couldn't find a fork point\".to_string(),\n        ))\n    }\n    // This method should only be called after we validate the new branch\n    fn reorg(\u0026self, new_tip: BlockHeader) -\u003e Result\u003c(), BlockchainError\u003e {\n        let current_best_block = self.get_best_block().unwrap().1;\n        let current_best_block = self.get_block_header(\u0026current_best_block)?;\n        let fork_point = self.find_fork_point(\u0026new_tip)?;\n\n        self.mark_chain_as_inactive(\u0026current_best_block, fork_point.block_hash())?;\n        self.mark_chain_as_active(\u0026new_tip, fork_point.block_hash())?;\n\n        let validation_index = self.get_last_valid_block(\u0026new_tip)?;\n        let depth = self.get_chain_depth(\u0026new_tip)?;\n        self.change_active_chain(\u0026new_tip, validation_index, depth);\n\n        Ok(())\n    }\n    /// Changes the active chain to the new branch during a reorg\n    fn change_active_chain(\u0026self, new_tip: \u0026BlockHeader, last_valid: BlockHash, depth: u32) {\n        let mut inner = self.inner.write();\n        inner.best_block.best_block = new_tip.block_hash();\n        inner.best_block.validation_index = last_valid;\n        inner.best_block.depth = depth;\n        inner.acc = Stump::new();\n    }\n    /// Grabs the last block we validated in this branch. We don't validate a fork, unless it\n    /// becomes the best chain. This function technically finds out what is the last common block\n    /// between two branches.\n    fn get_last_valid_block(\u0026self, header: \u0026BlockHeader) -\u003e Result\u003cBlockHash, BlockchainError\u003e {\n        let mut header = *header;\n\n        while !self.is_genesis(\u0026header) {\n            let _header = self.get_ancestor(\u0026header)?;\n            match _header {\n                DiskBlockHeader::FullyValid(_, _) | DiskBlockHeader::AssumedValid(_, _) =\u003e {\n                    return Ok(header.block_hash())\n                }\n                DiskBlockHeader::Orphan(_) =\u003e {\n                    return Err(BlockchainError::InvalidTip(format(format_args!(\n                        \"Block {} doesn't have a known ancestor (i.e an orphan block)\",\n                        header.block_hash()\n                    ))))\n                }\n                DiskBlockHeader::HeadersOnly(_, _) | DiskBlockHeader::InFork(_, _) =\u003e {}\n                DiskBlockHeader::InvalidChain(_) =\u003e {\n                    return Err(BlockchainError::InvalidTip(format(format_args!(\n                        \"Block {} is in an invalid chain\",\n                        header.block_hash()\n                    ))))\n                }\n            }\n\n            header = *_header;\n        }\n        Ok(header.block_hash())\n    }\n    /// If we get a header that doesn't build on top of our best chain, it may cause a reorganization.\n    /// We check this here.\n    fn maybe_reorg(\u0026self, branch_tip: BlockHeader) -\u003e Result\u003c(), BlockchainError\u003e {\n        let current_tip = self.get_block_header(\u0026self.get_best_block().unwrap().1)?;\n        self.check_branch(\u0026branch_tip)?;\n\n        let current_work = self.get_branch_work(\u0026current_tip)?;\n        let new_work = self.get_branch_work(\u0026branch_tip)?;\n        // If the new branch has more work, it becomes the new best chain\n        if new_work \u003e current_work {\n            self.reorg(branch_tip)?;\n            return Ok(());\n        }\n        // If the new branch has less work, we just store it as an alternative branch\n        // that might become the best chain in the future.\n        self.push_alt_tip(\u0026branch_tip)?;\n        let parent_height = self.get_ancestor(\u0026branch_tip)?.height().unwrap();\n        read_lock!(self)\n            .chainstore\n            .save_header(\u0026super::chainstore::DiskBlockHeader::InFork(\n                branch_tip,\n                parent_height + 1,\n            ))?;\n        Ok(())\n    }\n    /// Stores a new tip for a branch that is not the best one\n    fn push_alt_tip(\u0026self, branch_tip: \u0026BlockHeader) -\u003e Result\u003c(), BlockchainError\u003e {\n        let ancestor = self.get_ancestor(branch_tip);\n        let ancestor = match ancestor {\n            Ok(ancestor) =\u003e Some(ancestor),\n            Err(BlockchainError::BlockNotPresent) =\u003e None,\n            Err(e) =\u003e return Err(e),\n        };\n        let mut inner = write_lock!(self);\n        if let Some(ancestor) = ancestor {\n            let ancestor_hash = ancestor.block_hash();\n            if let Some(idx) = inner\n                .best_block\n                .alternative_tips\n                .iter()\n                .position(|hash| ancestor_hash == *hash)\n            {\n                inner.best_block.alternative_tips.remove(idx);\n            }\n        }\n        inner\n            .best_block\n            .alternative_tips\n            .push(branch_tip.block_hash());\n        Ok(())\n    }\n\n    /// Returns the chain_params struct for the current network\n    fn chain_params(\u0026self) -\u003e ChainParams {\n        let inner = read_lock!(self);\n        // We clone the parameters here, because we don't want to hold the lock for too long\n        inner.consensus.parameters.clone()\n    }\n    // This function should be only called if a block is guaranteed to be on chain\n    fn get_block_header_by_height(\u0026self, height: u32) -\u003e BlockHeader {\n        let block = self\n            .get_block_hash(height)\n            .expect(\"This block should be present\");\n        self.get_block_header(\u0026block)\n            .expect(\"This block should also be present\")\n    }\n    fn save_acc(\u0026self) -\u003e Result\u003c(), bitcoin::consensus::encode::Error\u003e {\n        let inner = read_lock!(self);\n        let mut ser_acc: Vec\u003cu8\u003e = Vec::new();\n        inner.acc.leaves.consensus_encode(\u0026mut ser_acc)?;\n        #[allow(clippy::significant_drop_in_scrutinee)]\n        for root in inner.acc.roots.iter() {\n            ser_acc\n                .write_all(\u0026**root)\n                .expect(\"String formatting should not err\");\n        }\n\n        inner\n            .chainstore\n            .save_roots(ser_acc)\n            .expect(\"Chain store is not working\");\n        Ok(())\n    }\n    #[allow(clippy::await_holding_lock)]\n    fn notify(\u0026self, block: \u0026Block, height: u32) {\n        let inner = self.inner.read();\n        let subs = inner.subscribers.iter();\n        for client in subs {\n            client.consume_block(block, height);\n        }\n    }\n\n    pub fn new(\n        chainstore: PersistedState,\n        network: Network,\n        assume_valid: AssumeValidArg,\n    ) -\u003e ChainState\u003cPersistedState\u003e {\n        let genesis = genesis_block(network.into());\n        chainstore\n            .save_header(\u0026super::chainstore::DiskBlockHeader::FullyValid(\n                genesis.header,\n                0,\n            ))\n            .expect(\"Error while saving genesis\");\n        chainstore\n            .update_block_index(0, genesis.block_hash())\n            .expect(\"Error updating index\");\n\n        let assume_valid = Self::get_assume_valid_value(network, assume_valid);\n        ChainState {\n            inner: RwLock::new(ChainStateInner {\n                chainstore,\n                acc: Stump::new(),\n                best_block: BestChain {\n                    best_block: genesis.block_hash(),\n                    depth: 0,\n                    validation_index: genesis.block_hash(),\n                    rescan_index: None,\n                    alternative_tips: Vec::new(),\n                    assume_valid_index: 0,\n                },\n                broadcast_queue: Vec::new(),\n                subscribers: Vec::new(),\n                fee_estimation: (1_f64, 1_f64, 1_f64),\n                ibd: true,\n                consensus: Consensus {\n                    parameters: network.into(),\n                },\n                assume_valid,\n            }),\n        }\n    }\n    fn get_assume_valid_value(network: Network, arg: AssumeValidArg) -\u003e Option\u003cBlockHash\u003e {\n        fn get_hash(hash: \u0026str) -\u003e BlockHash {\n            BlockHash::from_str(hash).expect(\"hardcoded hash should not fail\")\n        }\n        match arg {\n            AssumeValidArg::Disabled =\u003e None,\n            AssumeValidArg::UserInput(hash) =\u003e Some(hash),\n            AssumeValidArg::Hardcoded =\u003e match network {\n                Network::Bitcoin =\u003e {\n                    get_hash(\"00000000000000000009c97098b5295f7e5f183ac811fb5d1534040adb93cabd\")\n                        .into()\n                }\n                Network::Testnet =\u003e {\n                    get_hash(\"0000000000000004877fa2d36316398528de4f347df2f8a96f76613a298ce060\")\n                        .into()\n                }\n                Network::Signet =\u003e {\n                    get_hash(\"0000004f401bac79fe6cb3a10ef367b071e0fb51a1c9f4b3e8484e4dd03e1863\")\n                        .into()\n                }\n                Network::Regtest =\u003e {\n                    get_hash(\"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\")\n                        .into()\n                }\n            },\n        }\n    }\n    fn get_disk_block_header(\u0026self, hash: \u0026BlockHash) -\u003e Result\u003cDiskBlockHeader, BlockchainError\u003e {\n        let inner = read_lock!(self);\n        if let Some(header) = inner.chainstore.get_header(hash)? {\n            return Ok(header);\n        }\n        Err(BlockchainError::BlockNotPresent)\n    }\n    /// If we ever find ourselves in an undefined state, with one of our chain pointers\n    /// pointing to an invalid block, we'll find out what blocks do we have, and start from this\n    /// point.\n    fn reindex_chain(\u0026self) -\u003e BestChain {\n        let get_disk_block_hash =\n            |height: u32| -\u003e Result\u003cOption\u003cBlockHash\u003e, PersistedState::Error\u003e {\n                read_lock!(self).chainstore.get_block_hash(height)\n            };\n\n        warn!(\"reindexing our chain\");\n        let mut best_block = get_disk_block_hash(0).expect(\"No genesis block\").unwrap();\n        let mut depth = 0;\n        let mut validation_index = best_block;\n        let mut next_height = depth + 1;\n\n        // Iteratively fetch the disk header given the next height\n        while let Ok(Some(block_hash)) = get_disk_block_hash(next_height) {\n            match self.get_disk_block_header(\u0026block_hash) {\n                Ok(DiskBlockHeader::FullyValid(_, height)) =\u003e {\n                    assert_eq!(height, next_height);\n                    validation_index = block_hash;\n                }\n                Ok(DiskBlockHeader::HeadersOnly(_, height)) =\u003e {\n                    assert_eq!(height, next_height);\n                }\n                _ =\u003e break,\n            }\n            best_block = block_hash;\n            depth = next_height;\n            next_height += 1;\n        }\n        BestChain {\n            best_block,\n            depth,\n            validation_index,\n            rescan_index: None,\n            alternative_tips: Vec::new(),\n            assume_valid_index: 0,\n        }\n    }\n    pub fn load_chain_state(\n        chainstore: KvChainStore,\n        network: Network,\n        assume_valid: AssumeValidArg,\n    ) -\u003e Result\u003cChainState\u003cKvChainStore\u003e, BlockchainError\u003e {\n        let acc = Self::load_acc(\u0026chainstore);\n\n        let best_chain = chainstore.load_height()?;\n        if best_chain.is_none() {\n            return Err(BlockchainError::ChainNotInitialized);\n        }\n        let inner = ChainStateInner {\n            acc,\n            best_block: best_chain.unwrap(),\n            broadcast_queue: Vec::new(),\n            chainstore,\n            fee_estimation: (1_f64, 1_f64, 1_f64),\n            subscribers: Vec::new(),\n            ibd: true,\n            consensus: Consensus {\n                parameters: network.into(),\n            },\n            assume_valid: Self::get_assume_valid_value(network, assume_valid),\n        };\n        info!(\n            \"Chainstate loaded at height: {}, checking if we have all blocks\",\n            inner.best_block.best_block\n        );\n        let chainstate = ChainState {\n            inner: RwLock::new(inner),\n        };\n        // Check the integrity of our chain\n        chainstate.check_chain_integrity();\n        Ok(chainstate)\n    }\n\n    fn check_chain_integrity(\u0026self) {\n        let best_height = self.get_best_block().expect(\"should have this loaded\").0;\n        for height in 0..=best_height {\n            let Ok(hash) = self.get_block_hash(height) else {\n                self.reindex_chain();\n                return;\n            };\n            match self.get_disk_block_header(\u0026hash) {\n                Ok(DiskBlockHeader::FullyValid(_, _)) =\u003e continue,\n                Ok(DiskBlockHeader::HeadersOnly(_, _)) =\u003e continue,\n\n                _ =\u003e {\n                    warn!(\"our chain is corrupted, reindexing\");\n                    self.reindex_chain();\n                }\n            }\n        }\n    }\n    fn load_acc\u003cStorage: ChainStore\u003e(data_storage: \u0026Storage) -\u003e Stump {\n        let acc = data_storage\n            .load_roots()\n            .expect(\"load_acc: Could not read roots\");\n        if acc.is_none() {\n            return Stump::new();\n        }\n        let mut acc = acc.unwrap();\n        let leaves = acc.drain(0..8).collect::\u003cVec\u003cu8\u003e\u003e();\n        let (leaves, _) =\n            deserialize_partial::\u003cu64\u003e(\u0026leaves).expect(\"load_acc: Invalid num_leaves\");\n        let mut roots = Vec::new();\n        while acc.len() \u003e= 32 {\n            // Since we only expect hashes after the num_leaves, it should always align with 32 bytes\n            assert_eq!(acc.len() % 32, 0);\n            let root = acc.drain(0..32).collect::\u003cVec\u003cu8\u003e\u003e();\n            let root = NodeHash::from(\u0026*root);\n            roots.push(root);\n        }\n        Stump { leaves, roots }\n    }\n    fn update_view(\n        \u0026self,\n        height: u32,\n        block: \u0026BlockHeader,\n        acc: Stump,\n    ) -\u003e Result\u003c(), BlockchainError\u003e {\n        let mut inner = write_lock!(self);\n        inner\n            .chainstore\n            .save_header(\u0026super::chainstore::DiskBlockHeader::FullyValid(\n                *block, height,\n            ))?;\n        inner\n            .chainstore\n            .update_block_index(height, block.block_hash())?;\n        // Updates our local view of the network\n        inner.acc = acc;\n        inner.best_block.valid_block(block.block_hash());\n        Ok(())\n    }\n    fn update_tip(\u0026self, best_block: BlockHash, height: u32) {\n        let mut inner = write_lock!(self);\n        inner.best_block.best_block = best_block;\n        inner.best_block.depth = height;\n    }\n    fn verify_script(\u0026self, height: u32) -\u003e bool {\n        let inner = self.inner.read();\n\n        inner.assume_valid.map_or(true, |hash| {\n            match inner.chainstore.get_header(\u0026hash).unwrap() {\n                // If the assume-valid block is in the best chain, only verify scripts if we are higher\n                Some(DiskBlockHeader::HeadersOnly(_, assume_h))\n                | Some(DiskBlockHeader::FullyValid(_, assume_h)) =\u003e height \u003e assume_h,\n                // Assume-valid is not in the best chain, so verify all the scripts\n                _ =\u003e true,\n            }\n        })\n    }\n    pub fn acc(\u0026self) -\u003e Stump {\n        read_lock!(self).acc.to_owned()\n    }\n    /// Returns the next required work for the next block, usually it's just the last block's target\n    /// but if we are in a retarget period, it's calculated from the last 2016 blocks.\n    fn get_next_required_work(\n        \u0026self,\n        last_block: \u0026BlockHeader,\n        next_height: u32,\n        next_header: \u0026BlockHeader,\n    ) -\u003e Target {\n        let params: ChainParams = self.chain_params();\n        // Special testnet rule, if a block takes more than 20 minutes to mine, we can\n        // mine a block with diff 1\n        if params.pow_allow_min_diff\n            \u0026\u0026 last_block.time + params.pow_target_spacing as u32 * 2 \u003c next_header.time\n        {\n            return params.max_target;\n        }\n        // Regtest don't have retarget\n        if !params.pow_allow_no_retarget \u0026\u0026 (next_height) % 2016 == 0 {\n            // First block in this epoch\n            let first_block = self.get_block_header_by_height(next_height - 2016);\n            let last_block = self.get_block_header_by_height(next_height - 1);\n\n            let target =\n                Consensus::calc_next_work_required(\u0026last_block, \u0026first_block, self.chain_params());\n            if target \u003c params.max_target {\n                return target;\n            }\n            return params.max_target;\n        }\n        last_block.target()\n    }\n    fn validate_block(\n        \u0026self,\n        block: \u0026Block,\n        height: u32,\n        inputs: HashMap\u003cOutPoint, TxOut\u003e,\n    ) -\u003e Result\u003c(), BlockchainError\u003e {\n        if !block.check_merkle_root() {\n            return Err(BlockchainError::BlockValidation(\n                BlockValidationErrors::BadMerkleRoot,\n            ));\n        }\n        if height \u003e= self.chain_params().bip34_activation_height\n            \u0026\u0026 block.bip34_block_height() != Ok(height as u64)\n        {\n            return Err(BlockchainError::BlockValidation(\n                BlockValidationErrors::BadBip34,\n            ));\n        }\n        if !block.check_witness_commitment() {\n            return Err(BlockchainError::BlockValidation(\n                BlockValidationErrors::BadWitnessCommitment,\n            ));\n        }\n\n        // Validate block transactions\n        let subsidy = read_lock!(self).consensus.get_subsidy(height);\n        let verify_script = self.verify_script(height);\n        #[cfg(feature = \"bitcoinconsensus\")]\n        let flags = self.get_validation_flags(height);\n        #[cfg(not(feature = \"bitcoinconsensus\"))]\n        let flags = 0;\n        Consensus::verify_block_transactions(inputs, \u0026block.txdata, subsidy, verify_script, flags)?;\n        Ok(())\n    }\n}\n\nimpl\u003cPersistedState: ChainStore\u003e BlockchainInterface for ChainState\u003cPersistedState\u003e {\n    type Error = BlockchainError;\n\n    fn get_fork_point(\u0026self, block: BlockHash) -\u003e Result\u003cBlockHash, Self::Error\u003e {\n        let fork_point = self.find_fork_point(\u0026self.get_block_header(\u0026block)?)?;\n        Ok(fork_point.block_hash())\n    }\n\n    fn update_acc(\n        \u0026self,\n        acc: Stump,\n        block: UtreexoBlock,\n        height: u32,\n        proof: Proof,\n        del_hashes: Vec\u003csha256::Hash\u003e,\n    ) -\u003e Result\u003cStump, Self::Error\u003e {\n        Consensus::update_acc(\u0026acc, \u0026block.block, height, proof, del_hashes)\n    }\n\n    fn get_chain_tips(\u0026self) -\u003e Result\u003cVec\u003cBlockHash\u003e, Self::Error\u003e {\n        let inner = read_lock!(self);\n        let mut tips = Vec::new();\n\n        tips.push(inner.best_block.best_block);\n        tips.extend(inner.best_block.alternative_tips.iter());\n\n        Ok(tips)\n    }\n\n    fn validate_block(\n        \u0026self,\n        block: \u0026Block,\n        proof: Proof,\n        inputs: HashMap\u003cOutPoint, TxOut\u003e,\n        del_hashes: Vec\u003csha256::Hash\u003e,\n        acc: Stump,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        // verify the proof\n        let del_hashes = del_hashes\n            .iter()\n            .map(|hash| NodeHash::from(hash.as_byte_array()))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        if !acc.verify(\u0026proof, \u0026del_hashes)? {\n            return Err(BlockValidationErrors::InvalidProof.into());\n        }\n\n        let height = self\n            .get_block_height(\u0026block.block_hash())?\n            .ok_or(BlockchainError::BlockNotPresent)?;\n\n        self.validate_block(block, height, inputs)\n    }\n\n    fn get_block_locator_for_tip(\u0026self, tip: BlockHash) -\u003e Result\u003cVec\u003cBlockHash\u003e, BlockchainError\u003e {\n        let mut hashes = Vec::new();\n        let height = self\n            .get_disk_block_header(\u0026tip)?\n            .height()\n            .ok_or(BlockchainError::BlockNotPresent)?;\n\n        let mut index = height;\n        let mut current_height = height;\n        let mut current_header = self.get_disk_block_header(\u0026tip)?;\n        let mut step = 1;\n\n        while index \u003e 0 {\n            while current_height \u003e index {\n                current_header = self.get_ancestor(\u0026current_header)?;\n                current_height -= 1;\n            }\n\n            if hashes.len() \u003e= 10 {\n                step *= 2;\n            }\n\n            hashes.push(current_header.block_hash());\n\n            if index \u003e step {\n                index -= step;\n            } else {\n                break;\n            }\n        }\n\n        // genesis\n        hashes.push(self.get_block_hash(0).unwrap());\n        Ok(hashes)\n    }\n\n    fn is_in_idb(\u0026self) -\u003e bool {\n        self.inner.read().ibd\n    }\n\n    fn get_block_height(\u0026self, hash: \u0026BlockHash) -\u003e Result\u003cOption\u003cu32\u003e, Self::Error\u003e {\n        self.get_disk_block_header(hash)\n            .map(|header| header.height())\n    }\n\n    fn get_block_hash(\u0026self, height: u32) -\u003e Result\u003cbitcoin::BlockHash, Self::Error\u003e {\n        let inner = self.inner.read();\n        if let Some(hash) = inner.chainstore.get_block_hash(height)? {\n            return Ok(hash);\n        }\n        Err(BlockchainError::BlockNotPresent)\n    }\n\n    fn get_tx(\u0026self, _txid: \u0026bitcoin::Txid) -\u003e Result\u003cOption\u003cbitcoin::Transaction\u003e, Self::Error\u003e {\n        unimplemented!(\"This chainstate doesn't hold any tx\")\n    }\n\n    fn get_height(\u0026self) -\u003e Result\u003cu32, Self::Error\u003e {\n        let inner = read_lock!(self);\n        Ok(inner.best_block.depth)\n    }\n\n    fn broadcast(\u0026self, tx: \u0026bitcoin::Transaction) -\u003e Result\u003c(), Self::Error\u003e {\n        let mut inner = write_lock!(self);\n        inner.broadcast_queue.push(tx.clone());\n        Ok(())\n    }\n\n    fn estimate_fee(\u0026self, target: usize) -\u003e Result\u003cf64, Self::Error\u003e {\n        let inner = read_lock!(self);\n        if target == 1 {\n            Ok(inner.fee_estimation.0)\n        } else if target == 10 {\n            Ok(inner.fee_estimation.1)\n        } else {\n            Ok(inner.fee_estimation.2)\n        }\n    }\n\n    fn get_block(\u0026self, _hash: \u0026BlockHash) -\u003e Result\u003cbitcoin::Block, Self::Error\u003e {\n        unimplemented!(\"This chainstate doesn't hold full blocks\")\n    }\n\n    fn get_best_block(\u0026self) -\u003e Result\u003c(u32, BlockHash), Self::Error\u003e {\n        let inner = read_lock!(self);\n        Ok((inner.best_block.depth, inner.best_block.best_block))\n    }\n\n    fn get_block_header(\u0026self, hash: \u0026BlockHash) -\u003e Result\u003cbitcoin::block::Header, Self::Error\u003e {\n        let inner = read_lock!(self);\n        if let Some(header) = inner.chainstore.get_header(hash)? {\n            return Ok(*header);\n        }\n        Err(BlockchainError::BlockNotPresent)\n    }\n    fn get_rescan_index(\u0026self) -\u003e Option\u003cu32\u003e {\n        read_lock!(self).best_block.rescan_index\n    }\n    fn rescan(\u0026self, start_height: u32) -\u003e Result\u003c(), Self::Error\u003e {\n        let mut inner = write_lock!(self);\n        info!(\"Rescanning from block {start_height}\");\n        inner.best_block.rescan_index = Some(start_height);\n        Ok(())\n    }\n    fn subscribe(\u0026self, tx: Arc\u003cdyn BlockConsumer\u003e) {\n        let mut inner = self.inner.write();\n        inner.subscribers.push(tx);\n    }\n    fn get_block_locator(\u0026self) -\u003e Result\u003cVec\u003cBlockHash\u003e, BlockchainError\u003e {\n        let top_height = self.get_height()?;\n        let mut indexes = Vec::new();\n        let mut step = 1;\n        let mut index = top_height;\n        while index \u003e 0 {\n            if indexes.len() \u003e= 10 {\n                step *= 2;\n            }\n            indexes.push(index);\n            if index \u003e step {\n                index -= step;\n            } else {\n                break;\n            }\n        }\n        indexes.push(0);\n        let hashes = indexes\n            .iter()\n            .flat_map(|idx| self.get_block_hash(*idx))\n            .collect();\n\n        Ok(hashes)\n    }\n    fn get_validation_index(\u0026self) -\u003e Result\u003cu32, Self::Error\u003e {\n        let inner = self.inner.read();\n        let validation = inner.best_block.validation_index;\n        let header = self.get_disk_block_header(\u0026validation)?;\n        // The last validated disk header can only be FullyValid\n        if let DiskBlockHeader::FullyValid(_, height) = header {\n            Ok(height)\n        } else {\n            unreachable!(\"Validation index is in an invalid state, you should re-index your node\")\n        }\n    }\n\n    fn is_coinbase_mature(\u0026self, height: u32, block: BlockHash) -\u003e Result\u003cbool, Self::Error\u003e {\n        let chain_params = self.chain_params();\n        let current_height = self.get_disk_block_header(\u0026block)?.height().unwrap_or(0);\n\n        Ok(height + chain_params.coinbase_maturity \u003c= current_height)\n    }\n\n    fn get_unbroadcasted(\u0026self) -\u003e Vec\u003cTransaction\u003e {\n        let mut inner = write_lock!(self);\n        inner.broadcast_queue.drain(..).collect()\n    }\n}\nimpl\u003cPersistedState: ChainStore\u003e UpdatableChainstate for ChainState\u003cPersistedState\u003e {\n    fn switch_chain(\u0026self, new_tip: BlockHash) -\u003e Result\u003c(), BlockchainError\u003e {\n        let new_tip = self.get_block_header(\u0026new_tip)?;\n        self.reorg(new_tip)\n    }\n\n    fn mark_block_as_valid(\u0026self, block: BlockHash) -\u003e Result\u003c(), BlockchainError\u003e {\n        let header = self.get_disk_block_header(\u0026block)?;\n        let height = header.height().unwrap();\n        let new_header = DiskBlockHeader::FullyValid(*header, height);\n        self.update_header(\u0026new_header)\n    }\n\n    fn mark_chain_as_assumed(\u0026self, acc: Stump) -\u003e Result\u003cbool, BlockchainError\u003e {\n        let assumed_hash = self.get_best_block()?.1;\n\n        let mut curr_header = self.get_block_header(\u0026assumed_hash)?;\n\n        // The assumeutreexo value passed is inside our main chain, start from that point\n        while let Ok(header) = self.get_disk_block_header(\u0026curr_header.block_hash()) {\n            // We've reached genesis and didn't our block\n            if self.is_genesis(\u0026header) {\n                break;\n            }\n            self.update_header(\u0026DiskBlockHeader::FullyValid(\n                *header,\n                header.height().unwrap(),\n            ))?;\n            curr_header = *self.get_ancestor(\u0026header)?;\n        }\n\n        let mut guard = write_lock!(self);\n        guard.best_block.validation_index = assumed_hash;\n        guard.best_block.rescan_index = None;\n        info!(\"assuming chain with hash={assumed_hash}\");\n        guard.acc = acc;\n\n        Ok(true)\n    }\n\n    fn invalidate_block(\u0026self, block: BlockHash) -\u003e Result\u003c(), BlockchainError\u003e {\n        let height = self.get_disk_block_header(\u0026block)?.height();\n        if height.is_none() {\n            return Err(BlockchainError::BlockNotPresent);\n        }\n        let height = height.unwrap();\n        let current_height = self.get_height()?;\n        // Mark all blocks after this one as invalid\n        for h in height..=current_height {\n            let hash = self.get_block_hash(h)?;\n            let header = self.get_block_header(\u0026hash)?;\n            let new_header = DiskBlockHeader::InvalidChain(header);\n            self.update_header(\u0026new_header)?;\n        }\n        // Row back to our previous state. Note that acc doesn't actually change in this case\n        // only the currently best known block.\n        self.update_tip(\n            self.get_ancestor(\u0026self.get_block_header(\u0026block)?)?\n                .block_hash(),\n            height - 1,\n        );\n        Ok(())\n    }\n\n    fn toggle_ibd(\u0026self, is_ibd: bool) {\n        let mut inner = write_lock!(self);\n        inner.ibd = is_ibd;\n    }\n\n    fn process_rescan_block(\u0026self, block: \u0026Block) -\u003e Result\u003c(), BlockchainError\u003e {\n        let header = self.get_disk_block_header(\u0026block.block_hash())?;\n        let height = header.height().expect(\"Recaning in an invalid tip\");\n        self.notify(block, height);\n        if self.get_height().unwrap() == height {\n            info!(\"Rescan completed\");\n            write_lock!(self).best_block.rescan_index = None;\n            self.flush()?;\n            return Ok(());\n        }\n        if height % 10_000 == 0 {\n            info!(\"Rescanning at block height={height}\");\n            write_lock!(self).best_block.rescan_index = Some(height);\n            self.flush()?;\n        }\n        Ok(())\n    }\n\n    fn connect_block(\n        \u0026self,\n        block: \u0026Block,\n        proof: Proof,\n        inputs: HashMap\u003cOutPoint, TxOut\u003e,\n        del_hashes: Vec\u003csha256::Hash\u003e,\n    ) -\u003e Result\u003cu32, BlockchainError\u003e {\n        let header = self.get_disk_block_header(\u0026block.block_hash())?;\n        let height = match header {\n            DiskBlockHeader::FullyValid(_, height) =\u003e {\n                self.maybe_reindex(\u0026header);\n                return Ok(height);\n            }\n            // If it's valid or orphan, we don't validate\n            DiskBlockHeader::Orphan(_)\n            | DiskBlockHeader::AssumedValid(_, _) // this will be validated by a partial chain\n            | DiskBlockHeader::InFork(_, _)\n            | DiskBlockHeader::InvalidChain(_) =\u003e return Ok(0),\n            DiskBlockHeader::HeadersOnly(_, height) =\u003e height,\n        };\n\n        // Check if this block is the next one in our chain, if we try\n        // to add them out-of-order, we'll have consensus issues with our\n        // accumulator\n        let expected_height = self.get_validation_index()? + 1;\n        if height != expected_height {\n            return Ok(height);\n        }\n\n        self.validate_block(block, height, inputs)?;\n        let acc = Consensus::update_acc(\u0026self.acc(), block, height, proof, del_hashes)?;\n        let ibd = self.is_in_idb();\n        // ... If we came this far, we consider this block valid ...\n        if ibd \u0026\u0026 height % 10_000 == 0 {\n            info!(\n                \"Downloading blocks: height={height} hash={}\",\n                block.block_hash()\n            );\n            self.flush()?;\n        }\n\n        match ibd {\n            false =\u003e {\n                info!(\n                    \"New tip! hash={} height={height} tx_count={}\",\n                    block.block_hash(),\n                    block.txdata.len()\n                );\n                self.flush()?;\n            }\n            true =\u003e {\n                if block.block_hash() == self.get_best_block()?.1 {\n                    info!(\"Tip reached, toggle IBD off\");\n                    self.toggle_ibd(false);\n                }\n            }\n        }\n\n        self.update_view(height, \u0026block.header, acc)?;\n\n        // Notify others we have a new block\n        self.notify(block, height);\n        Ok(height)\n    }\n\n    fn handle_transaction(\u0026self) -\u003e Result\u003c(), BlockchainError\u003e {\n        unimplemented!(\"This chain_state has no mempool\")\n    }\n\n    fn flush(\u0026self) -\u003e Result\u003c(), BlockchainError\u003e {\n        self.save_acc()?;\n        let inner = read_lock!(self);\n        inner.chainstore.save_height(\u0026inner.best_block)?;\n        inner.chainstore.flush()?;\n        Ok(())\n    }\n\n    fn accept_header(\u0026self, header: BlockHeader) -\u003e Result\u003c(), BlockchainError\u003e {\n        trace!(\"Accepting header {header:?}\");\n        let disk_header = self.get_disk_block_header(\u0026header.block_hash());\n\n        match disk_header {\n            Err(BlockchainError::Database(_)) =\u003e {\n                // If there's a database error we don't know if we already\n                // have the header or not\n                return Err(disk_header.unwrap_err());\n            }\n            Ok(found) =\u003e {\n                // Possibly reindex to recompute the best_block field\n                self.maybe_reindex(\u0026found);\n                // We already have this header\n                return Ok(());\n            }\n            _ =\u003e (),\n        }\n        // The best block we know of\n        let best_block = self.get_best_block()?;\n\n        // Do validation in this header\n        let block_hash = self.validate_header(\u0026header)?;\n\n        // Update our current tip\n        if header.prev_blockhash == best_block.1 {\n            let height = best_block.0 + 1;\n            trace!(\"Header builds on top of our best chain\");\n\n            let mut inner = write_lock!(self);\n            inner.best_block.new_block(block_hash, height);\n            inner\n                .chainstore\n                .save_header(\u0026super::chainstore::DiskBlockHeader::HeadersOnly(\n                    header, height,\n                ))?;\n\n            inner.chainstore.update_block_index(height, block_hash)?;\n        } else {\n            trace!(\"Header not in the best chain\");\n            self.maybe_reorg(header)?;\n        }\n\n        Ok(())\n    }\n\n    fn get_root_hashes(\u0026self) -\u003e Vec\u003cNodeHash\u003e {\n        let inner = read_lock!(self);\n        inner.acc.roots.clone()\n    }\n\n    fn get_partial_chain(\n        \u0026self,\n        initial_height: u32,\n        final_height: u32,\n        acc: Stump,\n    ) -\u003e Result\u003csuper::partial_chain::PartialChainState, BlockchainError\u003e {\n        let blocks = (initial_height..=final_height)\n            .flat_map(|height| {\n                let hash = self\n                    .get_block_hash(height)\n                    .expect(\"Block should be present\");\n                self.get_disk_block_header(\u0026hash)\n            })\n            .filter_map(|header| match header {\n                DiskBlockHeader::FullyValid(header, _) =\u003e Some(header),\n                _ =\u003e None,\n            })\n            .collect();\n\n        let inner = PartialChainStateInner {\n            error: None,\n            blocks,\n            consensus: Consensus {\n                parameters: self.chain_params(),\n            },\n            current_acc: acc,\n            final_height,\n            assume_valid: false,\n            initial_height,\n            current_height: initial_height,\n        };\n\n        Ok(PartialChainState(UnsafeCell::new(inner)))\n    }\n}\n\nimpl\u003cT: ChainStore\u003e From\u003cChainStateBuilder\u003cT\u003e\u003e for ChainState\u003cT\u003e {\n    fn from(mut builder: ChainStateBuilder\u003cT\u003e) -\u003e Self {\n        let inner = ChainStateInner {\n            acc: builder.acc(),\n            chainstore: builder.chainstore(),\n            best_block: builder.best_block(),\n            assume_valid: builder.assume_valid(),\n            ibd: builder.ibd(),\n            broadcast_queue: Vec::new(),\n            subscribers: Vec::new(),\n            fee_estimation: (1_f64, 1_f64, 1_f64),\n            consensus: Consensus {\n                parameters: builder.chain_params(),\n            },\n        };\n\n        let inner = RwLock::new(inner);\n        Self { inner }\n    }\n}\n\n#[macro_export]\n/// Grabs a RwLock for reading\nmacro_rules! read_lock {\n    ($obj:ident) =\u003e {\n        $obj.inner.read()\n    };\n}\n#[macro_export]\n/// Grabs a RwLock for writing\nmacro_rules! write_lock {\n    ($obj:ident) =\u003e {\n        $obj.inner.write()\n    };\n}\n\n#[derive(Clone, Debug)]\n/// Internal representation of the chain we are in\npub struct BestChain {\n    /// Hash of the last block in the chain we believe has more work on\n    best_block: BlockHash,\n    /// How many blocks are pilled on this chain?\n    depth: u32,\n    /// We actually validated blocks up to this point\n    validation_index: BlockHash,\n    /// We may rescan even after we validate all blocks, this index saves the position\n    /// we are while re-scanning\n    rescan_index: Option\u003cu32\u003e,\n    /// Blockchains are not fast-forward only, they might have \"forks\", sometimes it's useful\n    /// to keep track of them, in case they become the best one. This keeps track of some\n    /// tips we know about, but are not the best one. We don't keep tips that are too deep\n    /// or has too little work if compared to our best one\n    alternative_tips: Vec\u003cBlockHash\u003e,\n    /// Saves the height occupied by the assume valid block\n    assume_valid_index: u32,\n}\nimpl BestChain {\n    fn new_block(\u0026mut self, block_hash: BlockHash, height: u32) {\n        self.best_block = block_hash;\n        self.depth = height;\n    }\n    fn valid_block(\u0026mut self, block_hash: BlockHash) {\n        self.validation_index = block_hash;\n    }\n}\nimpl Encodable for BestChain {\n    fn consensus_encode\u003cW: Write + ?Sized\u003e(\u0026self, writer: \u0026mut W) -\u003e Result\u003cusize, ioError\u003e {\n        let mut len = 0;\n        len += self.best_block.consensus_encode(writer)?;\n        len += self.depth.consensus_encode(writer)?;\n        len += self.validation_index.consensus_encode(writer)?;\n        len += self.assume_valid_index.consensus_encode(writer)?;\n\n        match self.rescan_index {\n            Some(height) =\u003e len += height.consensus_encode(writer)?,\n            None =\u003e len += 0_u32.consensus_encode(writer)?,\n        }\n        len += self.alternative_tips.consensus_encode(writer)?;\n        Ok(len)\n    }\n}\nimpl From\u003c(BlockHash, u32)\u003e for BestChain {\n    fn from((best_block, depth): (BlockHash, u32)) -\u003e Self {\n        Self {\n            best_block,\n            depth,\n            validation_index: best_block,\n            rescan_index: None,\n            assume_valid_index: 0,\n            alternative_tips: Vec::new(),\n        }\n    }\n}\nimpl Decodable for BestChain {\n    fn consensus_decode\u003cR: Read + ?Sized\u003e(\n        reader: \u0026mut R,\n    ) -\u003e Result\u003cSelf, bitcoin::consensus::encode::Error\u003e {\n        let best_block = BlockHash::consensus_decode(reader)?;\n        let depth = u32::consensus_decode(reader)?;\n        let validation_index = BlockHash::consensus_decode(reader)?;\n        let rescan_index = u32::consensus_decode(reader)?;\n        let assume_valid_index = u32::consensus_decode(reader)?;\n\n        let rescan_index = if rescan_index == 0 {\n            None\n        } else {\n            Some(rescan_index)\n        };\n        let alternative_tips = \u003cVec\u003cBlockHash\u003e\u003e::consensus_decode(reader)?;\n        Ok(Self {\n            alternative_tips,\n            best_block,\n            depth,\n            rescan_index,\n            validation_index,\n            assume_valid_index,\n        })\n    }\n}\n\n#[cfg(test)]\nmod test {\n    extern crate std;\n    use core::str::FromStr;\n    use std::format;\n    use std::io::Cursor;\n    use std::vec::Vec;\n\n    use bitcoin::block::Header as BlockHeader;\n    use bitcoin::consensus::deserialize;\n    use bitcoin::consensus::Decodable;\n    use bitcoin::hashes::hex::FromHex;\n    use bitcoin::Block;\n    use bitcoin::BlockHash;\n    use rand::Rng;\n    use rustreexo::accumulator::proof::Proof;\n\n    use super::BlockchainInterface;\n    use super::ChainParams;\n    use super::ChainState;\n    use super::DiskBlockHeader;\n    use super::UpdatableChainstate;\n    use crate::prelude::HashMap;\n    use crate::pruned_utreexo::consensus::Consensus;\n    use crate::AssumeValidArg;\n    use crate::KvChainStore;\n    use crate::Network;\n    #[test]\n    fn accept_mainnet_headers() {\n        // Accepts the first 10235 mainnet headers\n        let file = include_bytes!(\"./testdata/headers.zst\");\n        let uncompressed: Vec\u003cu8\u003e = zstd::decode_all(std::io::Cursor::new(file)).unwrap();\n        let mut cursor = Cursor::new(uncompressed);\n\n        let test_id = rand::random::\u003cu64\u003e();\n        let chainstore = KvChainStore::new(format!(\"./data/{test_id}/\")).unwrap();\n        let chain = ChainState::\u003cKvChainStore\u003e::new(\n            chainstore,\n            Network::Bitcoin,\n            AssumeValidArg::Hardcoded,\n        );\n        while let Ok(header) = BlockHeader::consensus_decode(\u0026mut cursor) {\n            chain.accept_header(header).unwrap();\n        }\n    }\n    #[test]\n    fn accept_first_signet_headers() {\n        // Accepts the first 2016 signet headers\n        let file = include_bytes!(\"./testdata/signet_headers.zst\");\n        let uncompressed: Vec\u003cu8\u003e = zstd::decode_all(std::io::Cursor::new(file)).unwrap();\n        let mut cursor = Cursor::new(uncompressed);\n\n        let test_id = rand::random::\u003cu64\u003e();\n        let chainstore = KvChainStore::new(format!(\"./data/{test_id}/\")).unwrap();\n        let chain =\n            ChainState::\u003cKvChainStore\u003e::new(chainstore, Network::Signet, AssumeValidArg::Hardcoded);\n        while let Ok(header) = BlockHeader::consensus_decode(\u0026mut cursor) {\n            chain.accept_header(header).unwrap();\n        }\n    }\n    #[test]\n    fn test_calc_next_work_required() {\n        let first_block = Vec::from_hex(\"0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a008f4d5fae77031e8ad22203\").unwrap();\n        let first_block: BlockHeader = deserialize(\u0026first_block).unwrap();\n\n        let last_block = Vec::from_hex(\"00000020dec6741f7dc5df6661bcb2d3ec2fceb14bd0e6def3db80da904ed1eeb8000000d1f308132e6a72852c04b059e92928ea891ae6d513cd3e67436f908c804ec7be51df535fae77031e4d00f800\").unwrap();\n        let last_block = deserialize(\u0026last_block).unwrap();\n\n        let next_target = Consensus::calc_next_work_required(\n            \u0026last_block,\n            \u0026first_block,\n            ChainParams::from(Network::Bitcoin),\n        );\n\n        assert_eq!(0x1e012fa7, next_target.to_compact_lossy().to_consensus());\n    }\n    #[test]\n    fn test_reorg() {\n        let test_id = rand::random::\u003cu64\u003e();\n        let chainstore = KvChainStore::new(format!(\"./data/{test_id}/\")).unwrap();\n        let chain = ChainState::\u003cKvChainStore\u003e::new(\n            chainstore,\n            Network::Regtest,\n            AssumeValidArg::Hardcoded,\n        );\n        let blocks = include_str!(\"./testdata/test_reorg.json\");\n        let blocks: Vec\u003cVec\u003c\u0026str\u003e\u003e = serde_json::from_str(blocks).unwrap();\n\n        for block in blocks[0].iter() {\n            let block = Vec::from_hex(block).unwrap();\n            let block: Block = deserialize(\u0026block).unwrap();\n            chain.accept_header(block.header).unwrap();\n            chain\n                .connect_block(\u0026block, Proof::default(), HashMap::new(), Vec::new())\n                .unwrap();\n        }\n        assert_eq!(\n            chain.get_best_block().unwrap(),\n            (\n                10,\n                BlockHash::from_str(\n                    \"6e9c49a19038f7db8d13f6c2e70566385536ea11975528b557799e08a014e784\"\n                )\n                .unwrap()\n            )\n        );\n\n        for fork in blocks[1].iter() {\n            let block = Vec::from_hex(fork).unwrap();\n            let block: Block = deserialize(\u0026block).unwrap();\n            chain.accept_header(block.header).unwrap();\n        }\n        let best_block = chain.get_best_block().unwrap();\n        assert_eq!(\n            best_block,\n            (\n                16,\n                BlockHash::from_str(\n                    \"4572ac401b94915dde6c4957b706abdb13b5824b000cad7f6065ebd9aea6dad1\"\n                )\n                .unwrap()\n            )\n        );\n        for i in 1..=chain.get_height().unwrap() {\n            if let Ok(DiskBlockHeader::HeadersOnly(_, _)) =\n                chain.get_disk_block_header(\u0026chain.get_block_hash(i).unwrap())\n            {\n                continue;\n            }\n            panic!(\"Block {} is not in the store\", i);\n        }\n    }\n    #[test]\n    fn test_get_block_header_by_height() {\n        let file = include_bytes!(\"./testdata/signet_headers.zst\");\n        let uncompressed: Vec\u003cu8\u003e = zstd::decode_all(std::io::Cursor::new(file)).unwrap();\n        let mut cursor = Cursor::new(uncompressed);\n\n        let test_id = rand::random::\u003cu64\u003e();\n        let chainstore = KvChainStore::new(format!(\"./data/{test_id}/\")).unwrap();\n        let chain =\n            ChainState::\u003cKvChainStore\u003e::new(chainstore, Network::Signet, AssumeValidArg::Hardcoded);\n        let mut headers: Vec\u003cBlockHeader\u003e = Vec::new();\n        while let Ok(header) = BlockHeader::consensus_decode(\u0026mut cursor) {\n            headers.push(header);\n        }\n        headers.remove(0);\n\n        assert!(chain.push_headers(headers.clone(), 1).is_ok());\n        assert_eq!(chain.get_block_header_by_height(1), headers[0]);\n    }\n    #[test]\n    fn test_reindex_chain() {\n        let file = include_bytes!(\"./testdata/signet_headers.zst\");\n        let uncompressed: Vec\u003cu8\u003e = zstd::decode_all(std::io::Cursor::new(file)).unwrap();\n        let mut cursor = Cursor::new(uncompressed);\n\n        let test_id = rand::random::\u003cu64\u003e();\n        let chainstore = KvChainStore::new(format!(\"./data/{test_id}/\")).unwrap();\n        let chain =\n            ChainState::\u003cKvChainStore\u003e::new(chainstore, Network::Signet, AssumeValidArg::Hardcoded);\n        let mut headers: Vec\u003cBlockHeader\u003e = Vec::new();\n        while let Ok(header) = BlockHeader::consensus_decode(\u0026mut cursor) {\n            headers.push(header);\n        }\n        headers.remove(0);\n        chain.push_headers(headers, 1).unwrap();\n\n        assert_eq!(chain.reindex_chain().depth, 2015);\n    }\n    #[test]\n    fn test_load_acc() {\n        let file = include_bytes!(\"./testdata/signet_headers.zst\");\n        let uncompressed: Vec\u003cu8\u003e = zstd::decode_all(std::io::Cursor::new(file)).unwrap();\n        let mut cursor = Cursor::new(uncompressed);\n\n        let test_id = rand::random::\u003cu64\u003e();\n        let chainstore = KvChainStore::new(format!(\"./data/{test_id}/\")).unwrap();\n        let chain =\n            ChainState::\u003cKvChainStore\u003e::new(chainstore, Network::Signet, AssumeValidArg::Hardcoded);\n        let mut headers: Vec\u003cBlockHeader\u003e = Vec::new();\n        while let Ok(header) = BlockHeader::consensus_decode(\u0026mut cursor) {\n            headers.push(header);\n        }\n        headers.remove(0);\n\n        chain.push_headers(headers, 1).unwrap();\n\n        write_lock!(chain).best_block = chain.reindex_chain();\n\n        assert_eq!(chain.get_validation_index().unwrap(), 2015);\n        let _ = ChainState::\u003cKvChainStore\u003e::load_acc(\u0026read_lock!(chain).chainstore);\n    }\n    #[test]\n    fn test_update_tip() {\n        let file = include_bytes!(\"./testdata/signet_headers.zst\");\n        let uncompressed: Vec\u003cu8\u003e = zstd::decode_all(std::io::Cursor::new(file)).unwrap();\n        let mut cursor = Cursor::new(uncompressed);\n\n        let test_id = rand::random::\u003cu64\u003e();\n        let chainstore = KvChainStore::new(format!(\"./data/{test_id}/\")).unwrap();\n        let chain =\n            ChainState::\u003cKvChainStore\u003e::new(chainstore, Network::Signet, AssumeValidArg::Hardcoded);\n        let mut headers: Vec\u003cBlockHeader\u003e = Vec::new();\n        while let Ok(header) = BlockHeader::consensus_decode(\u0026mut cursor) {\n            headers.push(header);\n        }\n        headers.remove(0);\n\n        chain.update_tip(headers[1].prev_blockhash, 1);\n        assert_eq!(\n            read_lock!(chain).best_block.best_block,\n            headers[1].prev_blockhash\n        );\n    }\n    #[test]\n    fn test_get_block_locator() {\n        let file = include_bytes!(\"./testdata/signet_headers.zst\");\n        let uncompressed: Vec\u003cu8\u003e = zstd::decode_all(std::io::Cursor::new(file)).unwrap();\n        let mut cursor = Cursor::new(uncompressed);\n\n        let test_id = rand::random::\u003cu64\u003e();\n        let chainstore = KvChainStore::new(format!(\"./data/{test_id}/\")).unwrap();\n        let chain =\n            ChainState::\u003cKvChainStore\u003e::new(chainstore, Network::Signet, AssumeValidArg::Hardcoded);\n        let mut headers: Vec\u003cBlockHeader\u003e = Vec::new();\n        while let Ok(header) = BlockHeader::consensus_decode(\u0026mut cursor) {\n            headers.push(header);\n        }\n        headers.remove(0);\n        chain.push_headers(headers, 1).unwrap();\n        write_lock!(chain).best_block = chain.reindex_chain();\n\n        assert!(chain.get_validation_index().is_ok());\n\n        assert!(!chain\n            .get_block_locator_for_tip(read_lock!(chain).best_block.best_block)\n            .unwrap()\n            .is_empty());\n\n        assert!(!chain.get_block_locator().unwrap().is_empty())\n    }\n\n    #[test]\n    fn test_invalidate_block() {\n        let file = include_bytes!(\"./testdata/signet_headers.zst\");\n        let uncompressed: Vec\u003cu8\u003e = zstd::decode_all(std::io::Cursor::new(file)).unwrap();\n        let mut cursor = Cursor::new(uncompressed);\n\n        let test_id = rand::random::\u003cu64\u003e();\n        let chainstore = KvChainStore::new(format!(\"./data/{test_id}/\")).unwrap();\n        let chain =\n            ChainState::\u003cKvChainStore\u003e::new(chainstore, Network::Signet, AssumeValidArg::Hardcoded);\n        let mut headers: Vec\u003cBlockHeader\u003e = Vec::new();\n        while let Ok(header) = BlockHeader::consensus_decode(\u0026mut cursor) {\n            headers.push(header);\n        }\n        headers.remove(0);\n        chain.push_headers(headers.clone(), 1).unwrap();\n        write_lock!(chain).best_block = chain.reindex_chain();\n\n        let random_height = rand::thread_rng().gen_range(1..=2014);\n\n        chain\n            .invalidate_block(headers[random_height].prev_blockhash)\n            .unwrap();\n\n        assert_eq!(chain.get_height().unwrap() as usize, random_height - 1);\n    }\n}\n","traces":[{"line":62,"address":[1165360],"length":1,"stats":{"Line":0},"fn_name":"consume_block"},{"line":63,"address":[1165399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[1247247,1245952],"length":1,"stats":{"Line":5},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[1251680,1253179],"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[1253216,1254523],"length":1,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[1267002,1265184],"length":1,"stats":{"Line":2},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":558,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":564,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":582,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":595,"address":[5102422,5102284,5099744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":612,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":614,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":617,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":619,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":627,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":628,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":631,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":632,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":635,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":636,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":643,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":650,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":653,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":656,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":657,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":659,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":660,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":661,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":665,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":670,"address":[1272466,1272506,1271248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":676,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":677,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":678,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":679,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":680,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":682,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":683,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":684,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":686,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":690,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":691,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":695,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":698,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":709,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":713,"address":[1274458,1273328],"length":1,"stats":{"Line":1},"fn_name":null},{"line":719,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":722,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":723,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":728,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":730,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":731,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":734,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":735,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":736,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":738,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":740,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":742,"address":[1275814,1275970,1274496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":748,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":749,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":753,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":754,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":756,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":757,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":761,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":762,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":767,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":768,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":770,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":772,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":773,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":774,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":781,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":782,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":783,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":786,"address":[5058208,5058394],"length":1,"stats":{"Line":0},"fn_name":"update_acc\u003cfloresta_chain::pruned_utreexo::chainstore::KvChainStore\u003e"},{"line":794,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":797,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":798,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":802,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":804,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":807,"address":[5061572,5061599,5060256],"length":1,"stats":{"Line":0},"fn_name":"validate_block\u003cfloresta_chain::pruned_utreexo::chainstore::KvChainStore\u003e"},{"line":816,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":818,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":821,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":822,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":825,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":826,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":827,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":829,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":832,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":833,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":834,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":835,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":837,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":839,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":840,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":841,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":842,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":844,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":845,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":846,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":847,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":850,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":851,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":854,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":856,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":857,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":859,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":864,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":865,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":868,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":869,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":872,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":873,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":874,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":877,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":878,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":879,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":880,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":882,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":885,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":889,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":890,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":891,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":894,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":895,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":896,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":897,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":900,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":901,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":902,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":903,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":904,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":905,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":907,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":911,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":915,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":916,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":917,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":920,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":921,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":922,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":923,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":925,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":927,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":928,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":930,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":931,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":932,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":933,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":934,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":936,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":937,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":938,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":940,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":941,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":942,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":943,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":944,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":945,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":946,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":947,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":949,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":950,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":951,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":953,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":956,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":957,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":959,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":962,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":976,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":977,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":978,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":980,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":983,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":984,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":985,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":989,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":990,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":991,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":994,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":995,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":996,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":997,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":998,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1001,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1002,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1004,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1007,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1009,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1010,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1012,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1013,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1014,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1016,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1019,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1020,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1021,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1022,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1023,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1025,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1028,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1029,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1030,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1031,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1033,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1034,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1036,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1037,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1038,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1039,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1040,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1044,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1045,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1046,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1047,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1049,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1052,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1053,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1054,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1057,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1058,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1059,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1060,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1061,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1062,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1063,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1064,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1065,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1067,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1068,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1069,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1070,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1072,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1075,"address":[1287320,1282752,1287086],"length":1,"stats":{"Line":1},"fn_name":"connect_block\u003cfloresta_chain::pruned_utreexo::chainstore::KvChainStore\u003e"},{"line":1082,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1083,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1084,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1085,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1086,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1089,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1091,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1092,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1093,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1099,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1104,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1105,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1106,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1108,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1118,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1123,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1126,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1127,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1128,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1133,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1136,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1137,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1144,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1145,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1146,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1147,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1148,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1149,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1152,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1153,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1154,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1156,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1162,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1164,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1166,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1171,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1174,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1177,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1178,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1179,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":1181,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1182,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1183,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1185,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1186,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1189,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1191,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1192,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1195,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1203,"address":[5076912,5077705,5077672],"length":1,"stats":{"Line":0},"fn_name":"get_partial_chain\u003cfloresta_chain::pruned_utreexo::chainstore::KvChainStore\u003e"},{"line":1209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1296,"address":[1187712],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1297,"address":[1187721],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1298,"address":[1187752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1300,"address":[1187760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1301,"address":[1187765],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1305,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1306,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1307,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1308,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1309,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1310,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1312,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1314,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1316,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":1317,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":1321,"address":[1187808,1187822],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":1328,"address":[1187876],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1333,"address":[1292432],"length":1,"stats":{"Line":0},"fn_name":"consensus_decode\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":1336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":377,"coverable":663},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-chain","src","pruned_utreexo","chain_state_builder.rs"],"content":"use bitcoin::block::Header as BlockHeader;\nuse bitcoin::hashes::Hash;\nuse bitcoin::BlockHash;\nuse rustreexo::accumulator::stump::Stump;\n\nuse super::chain_state::BestChain;\nuse super::chain_state::ChainState;\nuse super::chainparams::ChainParams;\nuse super::ChainStore;\n\n#[derive(Clone, Debug)]\npub enum BlockchainBuilderError {\n    MissingChainstore,\n    MissingChainParams,\n}\n#[derive(Clone, Debug, Default)]\npub struct ChainStateBuilder\u003cPersistedState: ChainStore\u003e {\n    acc: Option\u003cStump\u003e,\n    chainstore: Option\u003cPersistedState\u003e,\n    ibd: bool,\n    chain_params: Option\u003cChainParams\u003e,\n    assume_valid: Option\u003cBlockHash\u003e,\n    tip: Option\u003c(BlockHash, u32)\u003e,\n    first: Option\u003cBlockHeader\u003e,\n}\n\nimpl\u003cT: ChainStore\u003e ChainStateBuilder\u003cT\u003e {\n    pub fn new() -\u003e Self {\n        ChainStateBuilder {\n            acc: None,\n            chainstore: None,\n            ibd: true,\n            chain_params: None,\n            assume_valid: None,\n            tip: None,\n            first: None,\n        }\n    }\n    pub fn build(self) -\u003e Result\u003cChainState\u003cT\u003e, BlockchainBuilderError\u003e {\n        if self.chainstore.is_none() {\n            return Err(BlockchainBuilderError::MissingChainstore);\n        }\n        if self.chain_params.is_none() {\n            return Err(BlockchainBuilderError::MissingChainParams);\n        }\n        if let Some(first) = self.first {\n            self.chainstore\n                .as_ref()\n                .unwrap()\n                .save_header(\u0026crate::DiskBlockHeader::FullyValid(\n                    first,\n                    self.tip.unwrap().1,\n                ))\n                .unwrap();\n            self.chainstore\n                .as_ref()\n                .unwrap()\n                .update_block_index(self.tip.unwrap().1, self.tip.unwrap().0)\n                .unwrap();\n        }\n        Ok(ChainState::from(self))\n    }\n    pub fn with_chainstore(mut self, chainstore: T) -\u003e Self {\n        self.chainstore = Some(chainstore);\n        self\n    }\n\n    pub fn toggle_ibd(mut self, ibd: bool) -\u003e Self {\n        self.ibd = ibd;\n        self\n    }\n    pub fn with_chain_params(mut self, chain_params: ChainParams) -\u003e Self {\n        self.chain_params = Some(chain_params);\n        self\n    }\n    pub fn with_assume_valid(mut self, assume_valid: BlockHash) -\u003e Self {\n        self.assume_valid = Some(assume_valid);\n        self\n    }\n    pub fn assume_utreexo(mut self, acc: Stump) -\u003e Self {\n        self.acc = Some(acc);\n        self\n    }\n    pub fn with_tip(mut self, tip: (BlockHash, u32), header: BlockHeader) -\u003e Self {\n        self.tip = Some(tip);\n        self.first = Some(header);\n        self\n    }\n    pub fn acc(\u0026self) -\u003e Stump {\n        self.acc.clone().unwrap_or_default()\n    }\n    pub fn chainstore(\u0026mut self) -\u003e T {\n        self.chainstore.take().unwrap()\n    }\n    pub fn ibd(\u0026self) -\u003e bool {\n        self.ibd\n    }\n    pub fn chain_params(\u0026self) -\u003e ChainParams {\n        self.chain_params.clone().unwrap()\n    }\n    pub fn best_block(\u0026self) -\u003e BestChain {\n        let block = self.tip.unwrap_or((BlockHash::all_zeros(), 0));\n        BestChain::from(block)\n    }\n    pub fn assume_valid(\u0026self) -\u003e Option\u003cBlockHash\u003e {\n        self.assume_valid\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":46},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-chain","src","pruned_utreexo","chainparams.rs"],"content":"extern crate alloc;\nuse alloc::vec::Vec;\nuse core::ffi::c_uint;\n\n#[cfg(feature = \"bitcoinconsensus\")]\nuse bitcoin::bitcoinconsensus::VERIFY_NONE;\n#[cfg(feature = \"bitcoinconsensus\")]\nuse bitcoin::bitcoinconsensus::VERIFY_P2SH;\n#[cfg(feature = \"bitcoinconsensus\")]\nuse bitcoin::bitcoinconsensus::VERIFY_WITNESS;\nuse bitcoin::blockdata::constants::genesis_block;\nuse bitcoin::Block;\nuse bitcoin::BlockHash;\nuse bitcoin::Target;\nuse rustreexo::accumulator::node_hash::NodeHash;\nuse rustreexo::accumulator::stump::Stump;\n\nuse crate::prelude::*;\nuse crate::Network;\n#[derive(Clone, Debug)]\npub struct ChainParams {\n    /// The network's first block, also called genesis block.\n    pub genesis: Block,\n    /// Whether or not we are allowed to mine blocks with the network's smallest diff, this\n    /// is used in testnet, if a block takes more than 20 minutes to be mined\n    pub pow_allow_min_diff: bool,\n    /// Whether or not we are allowed to mine without retargets, this is used in regtests\n    pub pow_allow_no_retarget: bool,\n    /// This is the maximum possible target (i.e, minimum possible difficulty), and in mainnet\n    /// it's defined as ~((uint256)0 \u003e\u003e 32).\n    pub max_target: Target,\n    /// Interval of blocks until the block reward halves\n    pub subsidy_halving_interval: u64,\n    /// We expect blocks to take this many seconds to be found, on average\n    pub pow_target_spacing: u64,\n    /// When we retarget we expect this many seconds to be elapsed since last time. If\n    /// it's more, we decrease difficulty, if it's less we increase difficulty\n    pub pow_target_timespan: u64,\n    /// We wait this many blocks before a coinbase output can be spent\n    pub coinbase_maturity: u32,\n    /// The height at which bip32 is activated\n    pub bip34_activation_height: u32,\n    /// The height at which bip65 is activated\n    pub bip65_activation_height: u32,\n    /// The height at which bip66 is activated\n    pub bip66_activation_height: u32,\n    /// The height at which segwit is activated\n    pub segwit_activation_height: u32,\n    /// The height at which csv(CHECK_SEQUENCE_VERIFY) is activated\n    pub csv_activation_height: u32,\n    /// A list of exceptions to the rules, where the key is the block hash and the value is the\n    /// verification flags\n    pub exceptions: HashMap\u003cBlockHash, c_uint\u003e,\n    pub network_roots: Stump,\n    pub assumeutreexo_index: (BlockHash, u32),\n}\n\nimpl ChainParams {\n    fn max_target(net: Network) -\u003e Target {\n        match net {\n            Network::Bitcoin =\u003e Target::MAX_ATTAINABLE_MAINNET,\n            Network::Testnet =\u003e Target::MAX_ATTAINABLE_TESTNET,\n            Network::Signet =\u003e Target::MAX_ATTAINABLE_SIGNET,\n            Network::Regtest =\u003e Target::MAX_ATTAINABLE_REGTEST,\n        }\n    }\n}\n\nfn get_signet_roots() -\u003e Stump {\n    let roots: Vec\u003cNodeHash\u003e = [\n        \"8e6fcdcf05020fa1f7131a59a7050b33ca74852f5e82a5fbe236402bc4c8a928\",\n        \"f4c92949c71be7613699977eebf6d3bd5c8fd3e538a01380583e5aba14273425\",\n        \"d73ceb2748d342b14a269d7c0feb34aca1341a6367cc75cff6db8422eb01916d\",\n        \"a012e516784ccb7af26d7b356bf645e6a167cce5b48b9368c58c523acd25f6bf\",\n        \"e6e74ebc1d01ac47541c90afaac208c9b0f16226d2d046742032374e925a79ae\",\n        \"235b255558e994e6c5b6011469e891436cbf18107a939847e6e5df4cb939a96b\",\n        \"a9f45482564f0cb103067636c39fe30df1fa04b6b04d438c655530d991432761\",\n        \"d46716b7ccaf8d9eff11557527056f6100e016126df369eef95b9c9874467d40\",\n        \"7039b9053ef819d35c079eb4dcdd37029653a325bf416768e7de16bacf2c90af\",\n        \"f7a626339303030fc1b71d228e74aebdc2126cb7a2c5e01eb036225ea9dd41c2\",\n        \"b21123705cb4cef5a104705037ccd80ae7281789aa07cd468d5949c7e62df37b\",\n        \"ca931559f3ad9c91b9510f5dbfa42467e40ad8a0069d8f273de6079e9b115232\",\n        \"954ca698b58b6e6cdcc89948c841059d892578b7d67a249965fff83de5aaa7e3\",\n    ]\n    .iter()\n    .map(|hash| NodeHash::from_str(hash).unwrap())\n    .collect();\n\n    Stump {\n        roots,\n        leaves: 1477499,\n    }\n}\n\n#[cfg(feature = \"bitcoinconsensus\")]\nfn get_exceptions() -\u003e HashMap\u003cBlockHash, c_uint\u003e {\n    // For some reason, some blocks in the mainnet and testnet have different rules than it should\n    // be, so we need to keep a list of exceptions and treat them differently\n    let mut exceptions = HashMap::new();\n    exceptions.insert(\n        BlockHash::from_str(\"00000000000002dc756eebf4f49723ed8d30cc28a5f108eb94b1ba88ac4f9c22\")\n            .unwrap(),\n        VERIFY_NONE,\n    ); // BIP16 exception on main net\n    exceptions.insert(\n        BlockHash::from_str(\"0000000000000000000f14c35b2d841e986ab5441de8c585d5ffe55ea1e395ad\")\n            .unwrap(),\n        VERIFY_P2SH | VERIFY_WITNESS,\n    ); // Taproot exception on main net\n    exceptions.insert(\n        BlockHash::from_str(\"00000000dd30457c001f4095d208cc1296b0eed002427aa599874af7a432b105\")\n            .unwrap(),\n        VERIFY_NONE,\n    ); // BIP16 exception on test net\n    exceptions\n}\n\n#[cfg(not(feature = \"bitcoinconsensus\"))]\nfn get_exceptions() -\u003e HashMap\u003cBlockHash, c_uint\u003e {\n    HashMap::new()\n}\n\nimpl From\u003cNetwork\u003e for ChainParams {\n    fn from(net: Network) -\u003e Self {\n        let genesis = genesis_block(net.into());\n        let max_target = ChainParams::max_target(net);\n        let exceptions = get_exceptions();\n        match net {\n            Network::Bitcoin =\u003e ChainParams {\n                assumeutreexo_index: (genesis.block_hash(), 0),\n                genesis,\n                max_target,\n                pow_allow_min_diff: false,\n                pow_allow_no_retarget: false,\n                pow_target_spacing: 10 * 60, // One block every 600 seconds (10 minutes)\n                pow_target_timespan: 14 * 24 * 60 * 60, // two weeks\n                subsidy_halving_interval: 210_000,\n                coinbase_maturity: 100,\n                bip34_activation_height: 227931,\n                bip65_activation_height: 388381,\n                bip66_activation_height: 363725,\n                segwit_activation_height: 481824,\n                csv_activation_height: 419328,\n                exceptions,\n                network_roots: Stump::default(),\n            },\n            Network::Testnet =\u003e ChainParams {\n                assumeutreexo_index: (genesis.block_hash(), 0),\n                genesis,\n                max_target,\n                pow_allow_min_diff: true,\n                pow_allow_no_retarget: false,\n                pow_target_spacing: 10 * 60, // One block every 600 seconds (10 minutes)\n                pow_target_timespan: 14 * 24 * 60 * 60, // two weeks\n                subsidy_halving_interval: 210_000,\n                coinbase_maturity: 100,\n                bip34_activation_height: 211_111,\n                bip65_activation_height: 581_885,\n                bip66_activation_height: 330_776,\n                segwit_activation_height: 834_624,\n                csv_activation_height: 770_112,\n                exceptions,\n                network_roots: Stump::default(),\n            },\n            Network::Signet =\u003e ChainParams {\n                genesis,\n                max_target,\n                pow_allow_min_diff: false,\n                pow_allow_no_retarget: false,\n                pow_target_spacing: 10 * 60, // One block every 600 seconds (10 minutes)\n                pow_target_timespan: 14 * 24 * 60 * 60, // two weeks\n                subsidy_halving_interval: 210_000,\n                coinbase_maturity: 100,\n                bip34_activation_height: 500,\n                csv_activation_height: 1,\n                bip65_activation_height: 1,\n                bip66_activation_height: 1,\n                segwit_activation_height: 1,\n                exceptions,\n                network_roots: get_signet_roots(),\n                assumeutreexo_index: (\n                    BlockHash::from_str(\n                        \"0000001321625245a27e0be82a640106d019e35e48a024a17df1ceeb9b1f2131\",\n                    )\n                    .unwrap(),\n                    74551,\n                ),\n            },\n            Network::Regtest =\u003e ChainParams {\n                assumeutreexo_index: (genesis.block_hash(), 0),\n                genesis,\n                max_target,\n                pow_allow_min_diff: false,\n                pow_allow_no_retarget: true,\n                pow_target_spacing: 10 * 60, // One block every 600 seconds (10 minutes)\n                pow_target_timespan: 14 * 24 * 60 * 60, // two weeks\n                subsidy_halving_interval: 150,\n                coinbase_maturity: 100,\n                bip34_activation_height: 500,\n                csv_activation_height: 0,\n                bip65_activation_height: 0,\n                bip66_activation_height: 0,\n                segwit_activation_height: 0,\n                exceptions,\n                network_roots: Stump::default(),\n            },\n        }\n    }\n}\n\npub fn get_chain_dns_seeds(network: Network) -\u003e Vec\u003c\u0026'static str\u003e {\n    let mut seeds = Vec::new();\n    // DNS seeds taken from Bitcoin Core at commit 382b692a503355df7347efd9c128aff465b5583e\n    match network {\n        Network::Bitcoin =\u003e {\n            seeds.push(\"seed.bitcoin.sipa.be.\"); // Pieter Wuille\n            seeds.push(\"dnsseed.bluematt.me.\"); // Matt Corallo\n            seeds.push(\"dnsseed.bitcoin.dashjr.org.\"); // Luke Dashjr\n            seeds.push(\"seed.bitcoinstats.com.\"); // Christian Decker\n            seeds.push(\"seed.bitcoin.jonasschnelli.ch.\"); // Jonas Schnelli\n            seeds.push(\"seed.btc.petertodd.org.\"); // Peter Todd\n            seeds.push(\"seed.bitcoin.sprovoost.nl.\"); // Sjors Provoost\n            seeds.push(\"dnsseed.emzy.de.\"); // Stephan Oeste\n            seeds.push(\"seed.bitcoin.wiz.biz.\"); // Jason Maurice\n        }\n        Network::Testnet =\u003e {\n            seeds.push(\"testnet-seed.bitcoin.jonasschnelli.ch.\");\n            seeds.push(\"seed.tbtc.petertodd.org.\");\n            seeds.push(\"seed.testnet.bitcoin.sprovoost.nl.\");\n            seeds.push(\"testnet-seed.bluematt.me.\");\n        }\n        Network::Signet =\u003e {\n            seeds.push(\"seed.signet.bitcoin.sprovoost.nl.\");\n            seeds.push(\"x1000000.seed.dlsouza.lol.\"); // Davidson Souza, returns utreexo peers\n        }\n        Network::Regtest =\u003e {\n            // no seeds for regtest\n        }\n    }\n    seeds\n}\n","traces":[{"line":59,"address":[1034928],"length":1,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[1034948],"length":1,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[1034986],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[1035025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[1035113],"length":1,"stats":{"Line":7},"fn_name":null},{"line":64,"address":[1035069],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[1035200],"length":1,"stats":{"Line":7},"fn_name":"get_signet_roots"},{"line":70,"address":[1035214],"length":1,"stats":{"Line":7},"fn_name":null},{"line":86,"address":[1185408,1185431],"length":1,"stats":{"Line":14},"fn_name":"{closure#0}"},{"line":96,"address":[1035679,1035344],"length":1,"stats":{"Line":3},"fn_name":"get_exceptions"},{"line":99,"address":[1035365],"length":1,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[1035471],"length":1,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[1035435,1035370],"length":1,"stats":{"Line":6},"fn_name":null},{"line":105,"address":[1035557],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[1035478],"length":1,"stats":{"Line":3},"fn_name":null},{"line":110,"address":[1035640],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[1035564],"length":1,"stats":{"Line":3},"fn_name":null},{"line":115,"address":[1035651],"length":1,"stats":{"Line":3},"fn_name":null},{"line":124,"address":[1039860,1037198,1035712],"length":1,"stats":{"Line":4},"fn_name":"from"},{"line":125,"address":[1035745],"length":1,"stats":{"Line":4},"fn_name":null},{"line":126,"address":[1035802,1035962],"length":1,"stats":{"Line":5},"fn_name":null},{"line":127,"address":[1036046],"length":1,"stats":{"Line":3},"fn_name":null},{"line":128,"address":[1036053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[1036305,1036103],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[1036466,1036414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[1036439,1036547,1036727],"length":1,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[1036720],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[1036133,1037209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[1037370,1037318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[1037343,1037452,1037638],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[1037631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[1038982,1036227],"length":1,"stats":{"Line":7},"fn_name":null},{"line":171,"address":[1039064,1039250,1038955],"length":1,"stats":{"Line":14},"fn_name":null},{"line":180,"address":[1039243],"length":1,"stats":{"Line":7},"fn_name":null},{"line":181,"address":[1039478],"length":1,"stats":{"Line":7},"fn_name":null},{"line":190,"address":[1038082,1036163],"length":1,"stats":{"Line":3},"fn_name":null},{"line":195,"address":[1038243,1038191],"length":1,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[1038216,1038325,1038511],"length":1,"stats":{"Line":3},"fn_name":null},{"line":205,"address":[1038504],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[1040419,1039904],"length":1,"stats":{"Line":1},"fn_name":"get_chain_dns_seeds"},{"line":212,"address":[1039929],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[1039934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[1039967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[1040116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[1040140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[1040164],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[1040188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[1040212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[1040236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[1040260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[1040284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[1039991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[1040313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[1040337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[1040361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[1040058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[1040390],"length":1,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[1040027],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":40,"coverable":58},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-chain","src","pruned_utreexo","chainstore.rs"],"content":"// Written in 2022 by Davidson Souza\n\n//! This is a basic kv database that stores all metadata about our blockchain and utreexo\n//! state.\nuse bitcoin::block::Header as BlockHeader;\nuse bitcoin::consensus::deserialize;\nuse bitcoin::consensus::serialize;\nuse bitcoin::consensus::Decodable;\nuse bitcoin::consensus::Encodable;\nuse bitcoin::BlockHash;\n\nuse crate::prelude::*;\n#[derive(Debug)]\npub enum DiskBlockHeader {\n    FullyValid(BlockHeader, u32),\n    AssumedValid(BlockHeader, u32),\n    Orphan(BlockHeader),\n    HeadersOnly(BlockHeader, u32),\n    InFork(BlockHeader, u32),\n    InvalidChain(BlockHeader),\n}\nimpl DiskBlockHeader {\n    pub fn block_hash(\u0026self) -\u003e BlockHash {\n        self.deref().block_hash()\n    }\n    pub fn height(\u0026self) -\u003e Option\u003cu32\u003e {\n        match self {\n            DiskBlockHeader::FullyValid(_, height) =\u003e Some(*height),\n            DiskBlockHeader::Orphan(_) =\u003e None,\n            DiskBlockHeader::HeadersOnly(_, height) =\u003e Some(*height),\n            DiskBlockHeader::InFork(_, height) =\u003e Some(*height),\n            DiskBlockHeader::InvalidChain(_) =\u003e None,\n            DiskBlockHeader::AssumedValid(_, height) =\u003e Some(*height),\n        }\n    }\n}\nimpl Deref for DiskBlockHeader {\n    type Target = BlockHeader;\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        match self {\n            DiskBlockHeader::FullyValid(header, _) =\u003e header,\n            DiskBlockHeader::Orphan(header) =\u003e header,\n            DiskBlockHeader::HeadersOnly(header, _) =\u003e header,\n            DiskBlockHeader::InFork(header, _) =\u003e header,\n            DiskBlockHeader::InvalidChain(header) =\u003e header,\n            DiskBlockHeader::AssumedValid(header, _) =\u003e header,\n        }\n    }\n}\nimpl Decodable for DiskBlockHeader {\n    fn consensus_decode\u003cR: Read + ?Sized\u003e(\n        reader: \u0026mut R,\n    ) -\u003e core::result::Result\u003cSelf, bitcoin::consensus::encode::Error\u003e {\n        let tag = u8::consensus_decode(reader)?;\n        let header = BlockHeader::consensus_decode(reader)?;\n\n        match tag {\n            0x00 =\u003e {\n                let height = u32::consensus_decode(reader)?;\n                Ok(Self::FullyValid(header, height))\n            }\n            0x01 =\u003e Ok(Self::Orphan(header)),\n            0x02 =\u003e {\n                let height = u32::consensus_decode(reader)?;\n                Ok(Self::HeadersOnly(header, height))\n            }\n            0x03 =\u003e {\n                let height = u32::consensus_decode(reader)?;\n\n                Ok(Self::InFork(header, height))\n            }\n            0x04 =\u003e Ok(Self::InvalidChain(header)),\n            0x05 =\u003e {\n                let height = u32::consensus_decode(reader)?;\n                Ok(Self::AssumedValid(header, height))\n            }\n            _ =\u003e unreachable!(),\n        }\n    }\n}\nimpl Encodable for DiskBlockHeader {\n    fn consensus_encode\u003cW: Write + ?Sized\u003e(\n        \u0026self,\n        writer: \u0026mut W,\n    ) -\u003e core::result::Result\u003cusize, ioError\u003e {\n        let mut len = 80 + 1; // Header + tag\n        match self {\n            DiskBlockHeader::FullyValid(header, height) =\u003e {\n                0x00_u8.consensus_encode(writer)?;\n                header.consensus_encode(writer)?;\n                height.consensus_encode(writer)?;\n                len += 4;\n            }\n            DiskBlockHeader::Orphan(header) =\u003e {\n                0x01_u8.consensus_encode(writer)?;\n                header.consensus_encode(writer)?;\n            }\n            DiskBlockHeader::HeadersOnly(header, height) =\u003e {\n                0x02_u8.consensus_encode(writer)?;\n                header.consensus_encode(writer)?;\n                height.consensus_encode(writer)?;\n                len += 4;\n            }\n            DiskBlockHeader::InFork(header, height) =\u003e {\n                0x03_u8.consensus_encode(writer)?;\n                header.consensus_encode(writer)?;\n                height.consensus_encode(writer)?;\n                len += 4;\n            }\n            DiskBlockHeader::InvalidChain(header) =\u003e {\n                0x04_u8.consensus_encode(writer)?;\n                header.consensus_encode(writer)?;\n            }\n            DiskBlockHeader::AssumedValid(header, height) =\u003e {\n                0x05_u8.consensus_encode(writer)?;\n                header.consensus_encode(writer)?;\n                height.consensus_encode(writer)?;\n                len += 4;\n            }\n        };\n        Ok(len)\n    }\n}\nuse kv::Config;\nuse kv::Integer;\nuse kv::Store;\n\nuse super::chain_state::BestChain;\nuse super::ChainStore;\npub struct KvChainStore(Store);\nimpl KvChainStore {\n    pub fn new(datadir: String) -\u003e Result\u003cKvChainStore, kv::Error\u003e {\n        // Configure the database\n        let cfg = Config::new(datadir + \"/chain_data\").cache_capacity(100_000_000);\n\n        // Open the key/value store\n        let store = Store::new(cfg)?;\n\n        Ok(KvChainStore(store))\n    }\n}\nimpl ChainStore for KvChainStore {\n    type Error = kv::Error;\n    fn load_roots(\u0026self) -\u003e Result\u003cOption\u003cVec\u003cu8\u003e\u003e, Self::Error\u003e {\n        let bucket = self.0.bucket::\u003c\u0026str, Vec\u003cu8\u003e\u003e(None)?;\n        bucket.get(\u0026\"roots\")\n    }\n    fn save_roots(\u0026self, roots: Vec\u003cu8\u003e) -\u003e Result\u003c(), Self::Error\u003e {\n        let bucket = self.0.bucket::\u003c\u0026str, Vec\u003cu8\u003e\u003e(None)?;\n\n        bucket.set(\u0026\"roots\", \u0026roots)?;\n        Ok(())\n    }\n\n    fn load_height(\u0026self) -\u003e Result\u003cOption\u003cBestChain\u003e, Self::Error\u003e {\n        let bucket = self.0.bucket::\u003c\u0026str, Vec\u003cu8\u003e\u003e(None)?;\n        let height = bucket.get(\u0026\"height\")?;\n\n        if let Some(height) = height {\n            return Ok(Some(deserialize(\u0026height).unwrap()));\n        }\n        Ok(None)\n    }\n\n    fn save_height(\u0026self, height: \u0026BestChain) -\u003e Result\u003c(), Self::Error\u003e {\n        let bucket = self.0.bucket::\u003c\u0026str, Vec\u003cu8\u003e\u003e(None)?;\n        let height = serialize(height);\n        bucket.set(\u0026\"height\", \u0026height)?;\n        Ok(())\n    }\n    fn get_header(\u0026self, block_hash: \u0026BlockHash) -\u003e Result\u003cOption\u003cDiskBlockHeader\u003e, Self::Error\u003e {\n        let bucket = self.0.bucket::\u003c\u0026[u8], Vec\u003cu8\u003e\u003e(Some(\"header\"))?;\n        let block_hash = serialize(\u0026block_hash);\n\n        let header = bucket.get(\u0026\u0026*block_hash)?;\n        if let Some(header) = header {\n            return Ok(Some(deserialize(\u0026header).unwrap()));\n        }\n        Ok(None)\n    }\n    fn flush(\u0026self) -\u003e Result\u003c(), Self::Error\u003e {\n        // Flush the header bucket\n        let bucket = self.0.bucket::\u003c\u0026[u8], Vec\u003cu8\u003e\u003e(Some(\"header\"))?;\n        bucket.flush()?;\n        // Flush the block index\n        let bucket = self.0.bucket::\u003c\u0026[u8], Vec\u003cu8\u003e\u003e(Some(\"index\"))?;\n        bucket.flush()?;\n        // Flush the default bucket with meta-info\n        let bucket = self.0.bucket::\u003c\u0026[u8], Vec\u003cu8\u003e\u003e(None)?;\n        bucket.flush()?;\n        Ok(())\n    }\n    fn save_header(\u0026self, header: \u0026DiskBlockHeader) -\u003e Result\u003c(), Self::Error\u003e {\n        let ser_header = serialize(header);\n        let block_hash = serialize(\u0026header.block_hash());\n        let bucket = self.0.bucket::\u003c\u0026[u8], Vec\u003cu8\u003e\u003e(Some(\"header\"))?;\n        bucket.set(\u0026\u0026*block_hash, \u0026ser_header)?;\n        Ok(())\n    }\n\n    fn get_block_hash(\u0026self, height: u32) -\u003e Result\u003cOption\u003cBlockHash\u003e, Self::Error\u003e {\n        let bucket = self.0.bucket::\u003cInteger, Vec\u003cu8\u003e\u003e(Some(\"index\"))?;\n        let block = bucket.get(\u0026Integer::from(height))?;\n        if let Some(block) = block {\n            return Ok(Some(deserialize(\u0026block).unwrap()));\n        }\n        Ok(None)\n    }\n\n    fn update_block_index(\u0026self, height: u32, hash: BlockHash) -\u003e Result\u003c(), Self::Error\u003e {\n        let bucket = self.0.bucket::\u003cInteger, Vec\u003cu8\u003e\u003e(Some(\"index\"))?;\n        let block_hash = serialize(\u0026hash);\n\n        bucket.set(\u0026Integer::from(height), \u0026block_hash)?;\n        Ok(())\n    }\n}\n","traces":[{"line":23,"address":[1313872],"length":1,"stats":{"Line":9},"fn_name":null},{"line":24,"address":[1313904],"length":1,"stats":{"Line":9},"fn_name":null},{"line":26,"address":[1313936],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[1313946],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[1313981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[1314044],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[1314059],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[1314093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[1314122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[1314015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[1314144],"length":1,"stats":{"Line":9},"fn_name":"deref"},{"line":40,"address":[1314154,1314308],"length":1,"stats":{"Line":18},"fn_name":null},{"line":41,"address":[1314189],"length":1,"stats":{"Line":9},"fn_name":null},{"line":42,"address":[1314231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[1314252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[1314273],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[1314294],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[1314210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[1141136],"length":1,"stats":{"Line":2},"fn_name":"consensus_decode\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[1142720],"length":1,"stats":{"Line":3},"fn_name":"consensus_encode\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":86,"address":[1142772,1142848],"length":1,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":132,"address":[1314320],"length":1,"stats":{"Line":8},"fn_name":null},{"line":134,"address":[1314336],"length":1,"stats":{"Line":8},"fn_name":null},{"line":137,"address":[1314568,1314400],"length":1,"stats":{"Line":8},"fn_name":null},{"line":139,"address":[1314518],"length":1,"stats":{"Line":9},"fn_name":null},{"line":144,"address":[1314886,1314640],"length":1,"stats":{"Line":1},"fn_name":"load_roots"},{"line":145,"address":[1314780,1314664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[1314761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[1315562,1314912,1315549],"length":1,"stats":{"Line":1},"fn_name":"save_roots"},{"line":149,"address":[1314941,1315560,1315031,1315117],"length":1,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[1315260,1315082],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[1315487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[1316792,1315584,1316712],"length":1,"stats":{"Line":0},"fn_name":"load_height"},{"line":156,"address":[1315737,1315609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[1316790,1315710,1316022,1315843],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[1315983,1316127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[1316380,1316167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[1316203],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[1317452,1316816],"length":1,"stats":{"Line":1},"fn_name":"save_height"},{"line":166,"address":[1316967,1316854],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[1316960],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[1317057,1317149],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[1317376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[1318837,1318726,1317488],"length":1,"stats":{"Line":3},"fn_name":"get_header"},{"line":172,"address":[1317518,1317660],"length":1,"stats":{"Line":3},"fn_name":null},{"line":173,"address":[1317653],"length":1,"stats":{"Line":3},"fn_name":null},{"line":175,"address":[1317830,1318823,1317750,1318069],"length":1,"stats":{"Line":6},"fn_name":null},{"line":176,"address":[1318174,1318030],"length":1,"stats":{"Line":5},"fn_name":null},{"line":177,"address":[1318415,1318214],"length":1,"stats":{"Line":4},"fn_name":null},{"line":179,"address":[1318250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[1318864,1320357,1320326],"length":1,"stats":{"Line":1},"fn_name":"flush"},{"line":183,"address":[1319021,1318893],"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[1319242,1320355,1319014,1319127],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[1319450,1320353,1319363,1319179],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[1319711,1319611,1319435,1320339],"length":1,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[1320337,1319832,1319663,1319919],"length":1,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[1320156,1319904,1320080],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[1320133],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[1320384,1321295,1321269],"length":1,"stats":{"Line":3},"fn_name":"save_header"},{"line":194,"address":[1320440],"length":1,"stats":{"Line":3},"fn_name":null},{"line":195,"address":[1320455,1320513],"length":1,"stats":{"Line":18},"fn_name":null},{"line":196,"address":[1320730,1321280,1320525,1320640],"length":1,"stats":{"Line":18},"fn_name":null},{"line":197,"address":[1320696,1320885],"length":1,"stats":{"Line":18},"fn_name":null},{"line":198,"address":[1321180],"length":1,"stats":{"Line":9},"fn_name":null},{"line":201,"address":[1322408,1322328,1321312],"length":1,"stats":{"Line":1},"fn_name":"get_block_hash"},{"line":202,"address":[1321493,1321348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[1321806,1321474,1322406,1321604],"length":1,"stats":{"Line":2},"fn_name":null},{"line":204,"address":[1321767,1321911],"length":1,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[1321951,1322114],"length":1,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[1321985],"length":1,"stats":{"Line":2},"fn_name":null},{"line":210,"address":[1322432,1323108],"length":1,"stats":{"Line":9},"fn_name":"update_block_index"},{"line":211,"address":[1322599,1322472],"length":1,"stats":{"Line":9},"fn_name":null},{"line":212,"address":[1322592],"length":1,"stats":{"Line":9},"fn_name":null},{"line":214,"address":[1322782,1322693],"length":1,"stats":{"Line":18},"fn_name":null},{"line":215,"address":[1323032],"length":1,"stats":{"Line":9},"fn_name":null}],"covered":94,"coverable":120},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-chain","src","pruned_utreexo","consensus.rs"],"content":"//! A collection of functions that implement the consensus rules for the Bitcoin Network.\n//! This module contains functions that are used to verify blocks and transactions, and doesn't\n//! assume anything about the chainstate, so it can be used in any context.\n//! We use this to avoid code reuse among the different implementations of the chainstate.\n\nextern crate alloc;\n\nuse core::ffi::c_uint;\nuse core::ops::Mul;\n\nuse bitcoin::block::Header as BlockHeader;\nuse bitcoin::consensus::Encodable;\nuse bitcoin::hashes::sha256;\nuse bitcoin::hashes::Hash;\nuse bitcoin::pow::U256;\nuse bitcoin::Block;\nuse bitcoin::BlockHash;\nuse bitcoin::OutPoint;\nuse bitcoin::Target;\nuse bitcoin::Transaction;\nuse bitcoin::TxOut;\nuse floresta_common::prelude::*;\nuse rustreexo::accumulator::node_hash::NodeHash;\nuse rustreexo::accumulator::proof::Proof;\nuse rustreexo::accumulator::stump::Stump;\nuse sha2::Digest;\nuse sha2::Sha512_256;\n\nuse super::chainparams::ChainParams;\nuse super::error::BlockValidationErrors;\nuse super::error::BlockchainError;\n\n/// The value of a single coin in satoshis.\npub const COIN_VALUE: u64 = 100_000_000;\n\n/// The version tag to be prepended to the leafhash. It's just the sha512 hash of the string\n/// `UtreexoV1` represented as a vector of [u8] ([85 116 114 101 101 120 111 86 49]).\n/// The same tag is \"5574726565786f5631\" as a hex string.\npub const UTREEXO_TAG_V1: [u8; 64] = [\n    0x5b, 0x83, 0x2d, 0xb8, 0xca, 0x26, 0xc2, 0x5b, 0xe1, 0xc5, 0x42, 0xd6, 0xcc, 0xed, 0xdd, 0xa8,\n    0xc1, 0x45, 0x61, 0x5c, 0xff, 0x5c, 0x35, 0x72, 0x7f, 0xb3, 0x46, 0x26, 0x10, 0x80, 0x7e, 0x20,\n    0xae, 0x53, 0x4d, 0xc3, 0xf6, 0x42, 0x99, 0x19, 0x99, 0x31, 0x77, 0x2e, 0x03, 0x78, 0x7d, 0x18,\n    0x15, 0x6e, 0xb3, 0x15, 0x1e, 0x0e, 0xd1, 0xb3, 0x09, 0x8b, 0xdc, 0x84, 0x45, 0x86, 0x18, 0x85,\n];\n\n/// This struct contains all the information and methods needed to validate a block,\n/// it is used by the [ChainState] to validate blocks and transactions.\n#[derive(Debug, Clone)]\npub struct Consensus {\n    /// The parameters of the chain we are validating, it is usually hardcoded\n    /// constants. See [ChainParams] for more information.\n    pub parameters: ChainParams,\n}\n\nimpl Consensus {\n    /// Returns the amount of block subsidy to be paid in a block, given it's height.\n    /// Bitcoin Core source: https://github.com/bitcoin/bitcoin/blob/2b211b41e36f914b8d0487e698b619039cc3c8e2/src/validation.cpp#L1501-L1512\n    pub fn get_subsidy(\u0026self, height: u32) -\u003e u64 {\n        let halvings = height / self.parameters.subsidy_halving_interval as u32;\n        // Force block reward to zero when right shift is undefined.\n        if halvings \u003e= 64 {\n            return 0;\n        }\n        let mut subsidy = 50 * COIN_VALUE;\n        // Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years.\n        subsidy \u003e\u003e= halvings;\n        subsidy\n    }\n\n    /// Returns the hash of a leaf node in the utreexo accumulator.\n    #[inline]\n    fn get_leaf_hashes(\n        transaction: \u0026Transaction,\n        vout: u32,\n        height: u32,\n        block_hash: BlockHash,\n    ) -\u003e sha256::Hash {\n        let header_code = height \u003c\u003c 1;\n\n        let mut ser_utxo = Vec::new();\n        let utxo = transaction.output.get(vout as usize).unwrap();\n        utxo.consensus_encode(\u0026mut ser_utxo).unwrap();\n        let header_code = if transaction.is_coinbase() {\n            header_code | 1\n        } else {\n            header_code\n        };\n\n        let leaf_hash = Sha512_256::new()\n            .chain_update(UTREEXO_TAG_V1)\n            .chain_update(UTREEXO_TAG_V1)\n            .chain_update(block_hash)\n            .chain_update(transaction.txid())\n            .chain_update(vout.to_le_bytes())\n            .chain_update(header_code.to_le_bytes())\n            .chain_update(ser_utxo)\n            .finalize();\n        sha256::Hash::from_slice(leaf_hash.as_slice())\n            .expect(\"parent_hash: Engines shouldn't be Err\")\n    }\n    /// Verify if all transactions in a block are valid. Here we check the following:\n    /// - The block must contain at least one transaction, and this transaction must be coinbase\n    /// - The first transaction in the block must be coinbase\n    /// - The coinbase transaction must have the correct value (subsidy + fees)\n    /// - The block must not create more coins than allowed\n    /// - All transactions must be valid:\n    ///     - The transaction must not be coinbase (already checked)\n    ///     - The transaction must not have duplicate inputs\n    ///     - The transaction must not spend more coins than it claims in the inputs\n    ///     - The transaction must have valid scripts\n    #[allow(unused)]\n    pub fn verify_block_transactions(\n        mut utxos: HashMap\u003cOutPoint, TxOut\u003e,\n        transactions: \u0026[Transaction],\n        subsidy: u64,\n        verify_script: bool,\n        flags: c_uint,\n    ) -\u003e Result\u003c(), BlockchainError\u003e {\n        // Blocks must contain at least one transaction\n        if transactions.is_empty() {\n            return Err(BlockValidationErrors::EmptyBlock.into());\n        }\n        let mut fee = 0;\n        // Skip the coinbase tx\n        for (n, transaction) in transactions.iter().enumerate() {\n            // We don't need to verify the coinbase inputs, as it spends newly generated coins\n            if transaction.is_coinbase() {\n                if n == 0 {\n                    continue;\n                }\n                // A block must contain only one coinbase, and it should be the fist thing inside it\n                return Err(BlockValidationErrors::FirstTxIsnNotCoinbase.into());\n            }\n            // Amount of all outputs\n            let output_value = transaction\n                .output\n                .iter()\n                .fold(0, |acc, tx| acc + tx.value.to_sat());\n            // Amount of all inputs\n            let in_value = transaction.input.iter().fold(0, |acc, input| {\n                acc + utxos\n                    .get(\u0026input.previous_output)\n                    .expect(\"We have all prevouts here\")\n                    .value\n                    .to_sat()\n            });\n            // Value in should be greater or equal to value out. Otherwise, inflation.\n            if output_value \u003e in_value {\n                return Err(BlockValidationErrors::NotEnoughMoney.into());\n            }\n            // Fee is the difference between inputs and outputs\n            fee += in_value - output_value;\n            // Verify the tx script\n            #[cfg(feature = \"bitcoinconsensus\")]\n            if verify_script {\n                transaction\n                    .verify_with_flags(|outpoint| utxos.remove(outpoint), flags)\n                    .map_err(|err| BlockValidationErrors::InvalidTx(alloc::format!(\"{:?}\", err)))?;\n            }\n        }\n        // In each block, the first transaction, and only the first, should be coinbase\n        if !transactions[0].is_coinbase() {\n            return Err(BlockValidationErrors::FirstTxIsnNotCoinbase.into());\n        }\n        // Checks if the miner isn't trying to create inflation\n        if fee + subsidy\n            \u003c transactions[0]\n                .output\n                .iter()\n                .fold(0, |acc, out| acc + out.value.to_sat())\n        {\n            return Err(BlockValidationErrors::BadCoinbaseOutValue.into());\n        }\n        Ok(())\n    }\n    /// Calculates the next target for the proof of work algorithm, given the\n    /// current target and the time it took to mine the last 2016 blocks.\n    pub fn calc_next_work_required(\n        last_block: \u0026BlockHeader,\n        first_block: \u0026BlockHeader,\n        params: ChainParams,\n    ) -\u003e Target {\n        let cur_target = last_block.target().0;\n\n        let expected_timespan = U256::from(params.pow_target_timespan);\n        let mut actual_timespan = last_block.time - first_block.time;\n\n        // Difficulty adjustments are limited, to prevent large swings in difficulty\n        // caused by malicious miners.\n        if actual_timespan \u003c params.pow_target_timespan as u32 / 4 {\n            actual_timespan = params.pow_target_timespan as u32 / 4;\n        }\n        if actual_timespan \u003e params.pow_target_timespan as u32 * 4 {\n            actual_timespan = params.pow_target_timespan as u32 * 4;\n        }\n\n        let new_target = cur_target.mul(actual_timespan.into());\n        let new_target = new_target / expected_timespan;\n        Target(new_target)\n    }\n    /// Updates our accumulator with the new block. This is done by calculating the new\n    /// root hash of the accumulator, and then verifying the proof of inclusion of the\n    /// deleted nodes. If the proof is valid, we return the new accumulator. Otherwise,\n    /// we return an error.\n    /// This function is pure, it doesn't modify the accumulator, but returns a new one.\n    pub fn update_acc(\n        acc: \u0026Stump,\n        block: \u0026Block,\n        height: u32,\n        proof: Proof,\n        del_hashes: Vec\u003csha256::Hash\u003e,\n    ) -\u003e Result\u003cStump, BlockchainError\u003e {\n        let block_hash = block.block_hash();\n        let mut leaf_hashes = Vec::new();\n        let del_hashes = del_hashes\n            .iter()\n            .map(|hash| NodeHash::from(hash.as_byte_array()))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        // Verify the proof of inclusion of the deleted nodes\n        if !acc.verify(\u0026proof, \u0026del_hashes)? {\n            return Err(BlockValidationErrors::InvalidProof.into());\n        }\n        // Get inputs from the block, we'll need this HashSet to check if an output is spent\n        // in the same block. If it is, we don't need to add it to the accumulator.\n        let mut block_inputs = HashSet::new();\n        for transaction in block.txdata.iter() {\n            for input in transaction.input.iter() {\n                block_inputs.insert((input.previous_output.txid, input.previous_output.vout));\n            }\n        }\n        // Get all leaf hashes that will be added to the accumulator\n        for transaction in block.txdata.iter() {\n            for (i, output) in transaction.output.iter().enumerate() {\n                if !output.script_pubkey.is_provably_unspendable()\n                    \u0026\u0026 !block_inputs.contains(\u0026(transaction.txid(), i as u32))\n                {\n                    leaf_hashes.push(Self::get_leaf_hashes(\n                        transaction,\n                        i as u32,\n                        height,\n                        block_hash,\n                    ))\n                }\n            }\n        }\n        // Convert the leaf hashes to NodeHashes used in Rustreexo\n        let hashes: Vec\u003cNodeHash\u003e = leaf_hashes\n            .iter()\n            .map(|\u0026hash| NodeHash::from(hash.as_byte_array()))\n            .collect();\n        // Update the accumulator\n        let acc = acc.modify(\u0026hashes, \u0026del_hashes, \u0026proof)?.0;\n        Ok(acc)\n    }\n}\n","traces":[{"line":58,"address":[1067760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[1067777,1067822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[1067815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[1067878],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[1067914,1067852,1067897],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[1067902,1067948,1067979],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[1067967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[1069044,1068032,1069075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[1068085],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[1068106],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[1070967,1069088],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[1069222,1069283],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[1070944,1069344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[1069305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[1069317,1069398,1069610],"length":1,"stats":{"Line":3},"fn_name":null},{"line":127,"address":[1070182,1069658],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[1070229],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[1070870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[1070254,1070196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[1189671,1189648],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":140,"address":[1070322],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[1189781,1189860,1189788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[1189784],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[1070446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[1070847,1070484],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[1070609,1070527,1070461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[1070600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[1070812,1069189,1070673],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[1070665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[1070780],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[1069596,1069687],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[1069750,1069826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[1069884,1069793,1070059],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[1069870,1069925],"length":1,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[1190160,1190183],"length":1,"stats":{"Line":2},"fn_name":"{closure#4}"},{"line":172,"address":[1070152,1070093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[1070080],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[1071008,1072433],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[1071237,1071074],"length":1,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[1071313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[1071523,1071601],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[1071571,1071745,1071647],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[1071714],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[1071921,1071662,1071761],"length":1,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[1071923,1071885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[1072011,1071800],"length":1,"stats":{"Line":2},"fn_name":null},{"line":198,"address":[1072180],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[1072325],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[1072464,1075728,1074813],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[1072560],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[1072631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[1072646,1072726],"length":1,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[1190291,1190256],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":220,"address":[1072930,1075666,1072819],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[1073153,1073095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[1073138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[1073201,1073284,1073493],"length":1,"stats":{"Line":3},"fn_name":null},{"line":227,"address":[1075408,1073509],"length":1,"stats":{"Line":2},"fn_name":null},{"line":228,"address":[1075572],"length":1,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[1073466,1073559,1073764],"length":1,"stats":{"Line":3},"fn_name":null},{"line":233,"address":[1073788,1074877],"length":1,"stats":{"Line":2},"fn_name":null},{"line":234,"address":[1075119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":235,"address":[1075183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[1075357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[1075307],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[1075309],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[1073838,1073741],"length":1,"stats":{"Line":4},"fn_name":null},{"line":249,"address":[1190336,1190360],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}"},{"line":252,"address":[1073931,1074036],"length":1,"stats":{"Line":4},"fn_name":null},{"line":253,"address":[1074586],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":60,"coverable":84},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-chain","src","pruned_utreexo","error.rs"],"content":"use core::fmt::Debug;\n\nuse bitcoin::blockdata::script;\n#[cfg(feature = \"cli-blockchain\")]\nuse btcd_rpc::error::UtreexodError;\nuse floresta_common::impl_error_from;\n\nuse crate::prelude::*;\npub trait DatabaseError: Debug + Send + Sync + 'static {}\n#[derive(Debug)]\npub enum BlockchainError {\n    BlockNotPresent,\n    #[cfg(feature = \"cli-blockchain\")]\n    #[error(\"Json-Rpc error\")]\n    JsonRpcError(#[from] UtreexodError),\n    Parsing(String),\n    BlockValidation(BlockValidationErrors),\n    InvalidProof,\n    UtreexoError(String),\n    Database(Box\u003cdyn DatabaseError\u003e),\n    ConsensusDecode(bitcoin::consensus::encode::Error),\n    ChainNotInitialized,\n    InvalidTip(String),\n    ScriptValidationFailed(script::Error),\n    Io(ioError),\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum BlockValidationErrors {\n    InvalidTx(String),\n    NotEnoughPow,\n    BadMerkleRoot,\n    BadWitnessCommitment,\n    NotEnoughMoney,\n    FirstTxIsnNotCoinbase,\n    BadCoinbaseOutValue,\n    EmptyBlock,\n    BlockExtendsAnOrphanChain,\n    BadBip34,\n    InvalidProof,\n    CoinbaseNotMatured,\n}\n\nimpl Display for BlockValidationErrors {\n    fn fmt(\u0026self, f: \u0026mut core::fmt::Formatter\u003c'_\u003e) -\u003e core::fmt::Result {\n        match self {\n            BlockValidationErrors::InvalidTx(e) =\u003e {\n                write!(f, \"This block contains an invalid transaction {}\", e)\n            }\n            BlockValidationErrors::NotEnoughPow =\u003e {\n                write!(f, \"This block doesn't have enough proof-of-work\")\n            }\n            BlockValidationErrors::BadMerkleRoot =\u003e write!(f, \"Wrong merkle root\"),\n            BlockValidationErrors::BadWitnessCommitment =\u003e write!(f, \"Wrong witness commitment\"),\n            BlockValidationErrors::NotEnoughMoney =\u003e {\n                write!(f, \"A transaction spends more than it should\")\n            }\n            BlockValidationErrors::FirstTxIsnNotCoinbase =\u003e {\n                write!(f, \"The first transaction in a block isn't a coinbase\")\n            }\n            BlockValidationErrors::BadCoinbaseOutValue =\u003e {\n                write!(f, \"Coinbase claims more bitcoins than it should\")\n            }\n            BlockValidationErrors::EmptyBlock =\u003e {\n                write!(f, \"This block is empty (doesn't have a coinbase tx)\")\n            }\n            BlockValidationErrors::BlockExtendsAnOrphanChain =\u003e {\n                write!(f, \"This block extends a chain we don't have the ancestors\")\n            }\n            BlockValidationErrors::BadBip34 =\u003e write!(f, \"BIP34 commitment mismatch\"),\n            BlockValidationErrors::InvalidProof =\u003e write!(f, \"Invalid proof\"),\n            BlockValidationErrors::CoinbaseNotMatured =\u003e {\n                write!(f, \"Coinbase not matured yet\")\n            }\n        }\n    }\n}\n\nimpl\u003cT: DatabaseError\u003e From\u003cT\u003e for BlockchainError {\n    fn from(value: T) -\u003e Self {\n        BlockchainError::Database(Box::new(value))\n    }\n}\n\nimpl_error_from!(BlockchainError, ioError, Io);\nimpl_error_from!(\n    BlockchainError,\n    bitcoin::consensus::encode::Error,\n    ConsensusDecode\n);\nimpl_error_from!(BlockchainError, BlockValidationErrors, BlockValidation);\nimpl_error_from!(BlockchainError, String, UtreexoError);\nimpl_error_from!(BlockchainError, script::Error, ScriptValidationFailed);\n\nimpl Display for BlockchainError {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{:?}\", self)\n    }\n}\n\nimpl DatabaseError for kv::Error {}\nimpl core2::error::Error for BlockchainError {}\n","traces":[{"line":45,"address":[3276976],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":46,"address":[1363952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[1363987],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[1304744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[3277180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[1364173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[3277284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[1304971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[3277394],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[3277449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[1305136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[1305191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[1305246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[1305298],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[1305350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[1305424],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":97,"address":[1305484],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":19},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-chain","src","pruned_utreexo","mod.rs"],"content":"extern crate alloc;\n\npub mod chain_state;\npub mod chain_state_builder;\npub mod chainparams;\npub mod chainstore;\npub mod consensus;\npub mod error;\npub mod partial_chain;\npub mod udata;\n\nuse alloc::sync::Arc;\n\nuse bitcoin::block::Header as BlockHeader;\nuse bitcoin::hashes::sha256;\nuse bitcoin::p2p::utreexo::UtreexoBlock;\nuse bitcoin::Block;\nuse bitcoin::BlockHash;\nuse bitcoin::OutPoint;\nuse bitcoin::Transaction;\nuse bitcoin::TxOut;\nuse rustreexo::accumulator::node_hash::NodeHash;\nuse rustreexo::accumulator::proof::Proof;\nuse rustreexo::accumulator::stump::Stump;\n\nuse self::partial_chain::PartialChainState;\nuse crate::prelude::*;\nuse crate::BestChain;\nuse crate::BlockConsumer;\nuse crate::BlockchainError;\nuse crate::DatabaseError;\nuse crate::DiskBlockHeader;\n\n/// This trait is the main interface between our blockchain backend and other services.\n/// It'll be useful for transitioning from rpc to a p2p based node\npub trait BlockchainInterface {\n    type Error: core2::error::Error + Send + Sync + 'static;\n    /// Returns the block with a given height in our current tip.\n    fn get_block_hash(\u0026self, height: u32) -\u003e Result\u003cbitcoin::BlockHash, Self::Error\u003e;\n    /// Returns a bitcoin [Transaction] given it's txid.\n    fn get_tx(\u0026self, txid: \u0026bitcoin::Txid) -\u003e Result\u003cOption\u003cbitcoin::Transaction\u003e, Self::Error\u003e;\n    /// Get the height of our best know chain.\n    fn get_height(\u0026self) -\u003e Result\u003cu32, Self::Error\u003e;\n    /// Broadcasts a transaction to the network.\n    fn broadcast(\u0026self, tx: \u0026bitcoin::Transaction) -\u003e Result\u003c(), Self::Error\u003e;\n    /// Returns fee estimation for inclusion in `target` blocks.\n    fn estimate_fee(\u0026self, target: usize) -\u003e Result\u003cf64, Self::Error\u003e;\n    /// Returns a block with a given `hash` if any.\n    fn get_block(\u0026self, hash: \u0026BlockHash) -\u003e Result\u003cBlock, Self::Error\u003e;\n    /// Returns the best known block\n    fn get_best_block(\u0026self) -\u003e Result\u003c(u32, BlockHash), Self::Error\u003e;\n    /// Returns associated header for block with `hash`\n    fn get_block_header(\u0026self, hash: \u0026BlockHash) -\u003e Result\u003cBlockHeader, Self::Error\u003e;\n    /// Register for receiving notifications for some event. Right now it only works for\n    /// new blocks, but may work with transactions in the future too.\n    /// if a module performs some heavy-lifting on the block's data, it should pass in a\n    /// vector or a channel where data can be  transfered to the atual worker, otherwise\n    /// chainstate will be stuck for as long as you have work to do.\n    fn subscribe(\u0026self, tx: Arc\u003cdyn BlockConsumer\u003e);\n    /// Tells whether or not we are on ibd\n    fn is_in_idb(\u0026self) -\u003e bool;\n    /// Returns the list of unbroadcasted transactions.\n    fn get_unbroadcasted(\u0026self) -\u003e Vec\u003cTransaction\u003e;\n    /// Checks if a coinbase is mature\n    fn is_coinbase_mature(\u0026self, height: u32, block: BlockHash) -\u003e Result\u003cbool, Self::Error\u003e;\n    /// Returns a block locator\n    fn get_block_locator(\u0026self) -\u003e Result\u003cVec\u003cBlockHash\u003e, Self::Error\u003e;\n    /// Returns a block locator from a given tip\n    ///\n    /// This method may be used to get the locator from a tip that's not the best one\n    fn get_block_locator_for_tip(\u0026self, tip: BlockHash) -\u003e Result\u003cVec\u003cBlockHash\u003e, BlockchainError\u003e;\n    /// Returns the last block we validated\n    fn get_validation_index(\u0026self) -\u003e Result\u003cu32, Self::Error\u003e;\n    /// Triggers a rescan, downloading (but not validating) all blocks in [start_height:tip]\n    fn rescan(\u0026self, start_height: u32) -\u003e Result\u003c(), Self::Error\u003e;\n    /// Returns where we are in the rescan\n    fn get_rescan_index(\u0026self) -\u003e Option\u003cu32\u003e;\n    /// Returns the height of a block, given it's hash\n    fn get_block_height(\u0026self, hash: \u0026BlockHash) -\u003e Result\u003cOption\u003cu32\u003e, Self::Error\u003e;\n    fn update_acc(\n        \u0026self,\n        acc: Stump,\n        block: UtreexoBlock,\n        height: u32,\n        proof: Proof,\n        del_hashes: Vec\u003csha256::Hash\u003e,\n    ) -\u003e Result\u003cStump, Self::Error\u003e;\n\n    fn get_chain_tips(\u0026self) -\u003e Result\u003cVec\u003cBlockHash\u003e, Self::Error\u003e;\n\n    fn validate_block(\n        \u0026self,\n        block: \u0026Block,\n        proof: Proof,\n        inputs: HashMap\u003cOutPoint, TxOut\u003e,\n        del_hashes: Vec\u003csha256::Hash\u003e,\n        acc: Stump,\n    ) -\u003e Result\u003c(), Self::Error\u003e;\n\n    fn get_fork_point(\u0026self, block: BlockHash) -\u003e Result\u003cBlockHash, Self::Error\u003e;\n}\n/// [UpdatableChainstate] is a contract that a is expected from a chainstate\n/// implementation, that wishes to be updated. Using those methods, a backend like the p2p-node,\n/// can notify new blocks and transactions to a chainstate, allowing it to update it's state.\npub trait UpdatableChainstate {\n    /// This is one of the most important methods for a ChainState,\n    /// it gets a block and some utreexo data, validates this block and\n    /// connects to our chain of blocks. This function is meant to be atomic\n    /// and prone of running in parallel.\n    fn connect_block(\n        \u0026self,\n        block: \u0026Block,\n        proof: Proof,\n        inputs: HashMap\u003cOutPoint, TxOut\u003e,\n        del_hashes: Vec\u003csha256::Hash\u003e,\n    ) -\u003e Result\u003cu32, BlockchainError\u003e;\n\n    fn switch_chain(\u0026self, new_tip: BlockHash) -\u003e Result\u003c(), BlockchainError\u003e;\n    /// Accepts a new header to our chain. This method is called before connect_block, and\n    /// makes some basic checks on a header and saves it on disk. We only accept a block as\n    /// valid after calling connect_block.\n    ///\n    /// This function returns whether this block is on our best-known chain, or in a fork\n    fn accept_header(\u0026self, header: BlockHeader) -\u003e Result\u003c(), BlockchainError\u003e;\n    /// Not used for now, but in a future blockchain with mempool, we can process transactions\n    /// that are not in a block yet.\n    fn handle_transaction(\u0026self) -\u003e Result\u003c(), BlockchainError\u003e;\n    /// Persists our data. Should be invoked periodically.\n    fn flush(\u0026self) -\u003e Result\u003c(), BlockchainError\u003e;\n    /// Toggle ibd on/off\n    fn toggle_ibd(\u0026self, is_ibd: bool);\n    /// Tells this blockchain to consider this block invalid, and not build on top of it\n    fn invalidate_block(\u0026self, block: BlockHash) -\u003e Result\u003c(), BlockchainError\u003e;\n    /// Marks one block as being fully validated, this overrides a block that was explicitly\n    /// marked as invalid.\n    fn mark_block_as_valid(\u0026self, block: BlockHash) -\u003e Result\u003c(), BlockchainError\u003e;\n    /// Gives a requested block for rescan\n    fn process_rescan_block(\u0026self, block: \u0026Block) -\u003e Result\u003c(), BlockchainError\u003e;\n    /// Returns the root hashes of our utreexo forest\n    fn get_root_hashes(\u0026self) -\u003e Vec\u003cNodeHash\u003e;\n    /// Returns a partial chainstate from a range of blocks.\n    ///\n    /// [PartialChainState] is a simplified version of `ChainState` that is used during IBD.\n    /// It doesn't suport reorgs, only hold headers for a subset of blocks and isn't [Sync].\n    /// The idea here is that you take a OS thread or some async task that will drive one\n    /// [PartialChainState] to completion by downloading blocks inside that chainstate's range.\n    /// If all goes right, it'll end without error, and you should mark blocks in this range as\n    /// valid.\n    ///\n    /// Since this chainstate may start from a height with an existing UTXO set, you need to\n    /// provide a [Stump] for that block.\n    fn get_partial_chain(\n        \u0026self,\n        initial_height: u32,\n        final_height: u32,\n        acc: Stump,\n    ) -\u003e Result\u003cPartialChainState, BlockchainError\u003e;\n    /// Marks a chain as fully-valid\n    ///\n    /// This mimics the behavour of checking every block before this block, and continues\n    /// from this point\n    fn mark_chain_as_assumed(\u0026self, acc: Stump) -\u003e Result\u003cbool, BlockchainError\u003e;\n}\n\n/// [ChainStore] is a trait defining how we interact with our chain database. This definitions\n/// will be used by the [ChainState] to save and retrieve data about the blockchain, likely\n/// on disk.\n/// Right now, you can use the [KvChainStore] in your code, it implements this trait and\n/// uses a key-value store to save data.\n/// The [DatabaseError] is a simple trait that can be implemented by any error type that\n/// implements [std::error::Error] and [std::fmt::Display]. This is useful to abstract\n/// the database implementation from the blockchain.\n/// See the documentation of [DatabaseError] for more info.\npub trait ChainStore {\n    type Error: DatabaseError;\n    /// Saves the current state of our accumulator.\n    fn save_roots(\u0026self, roots: Vec\u003cu8\u003e) -\u003e Result\u003c(), Self::Error\u003e;\n    /// Loads the state of our accumulator.\n    fn load_roots(\u0026self) -\u003e Result\u003cOption\u003cVec\u003cu8\u003e\u003e, Self::Error\u003e;\n    /// Loads the blockchain height\n    fn load_height(\u0026self) -\u003e Result\u003cOption\u003cBestChain\u003e, Self::Error\u003e;\n    /// Saves the blockchain height.\n    fn save_height(\u0026self, height: \u0026BestChain) -\u003e Result\u003c(), Self::Error\u003e;\n    /// Get a block header from our database. See [DiskBlockHeader] for more info about\n    /// the data we save.\n    fn get_header(\u0026self, block_hash: \u0026BlockHash) -\u003e Result\u003cOption\u003cDiskBlockHeader\u003e, Self::Error\u003e;\n    /// Saves a block header to our database. See [DiskBlockHeader] for more info about\n    /// the data we save.\n    fn save_header(\u0026self, header: \u0026DiskBlockHeader) -\u003e Result\u003c(), Self::Error\u003e;\n    /// Returns the block hash for a given height.\n    fn get_block_hash(\u0026self, height: u32) -\u003e Result\u003cOption\u003cBlockHash\u003e, Self::Error\u003e;\n    /// Flushes write buffers to disk, this is called periodically by the [ChainState],\n    /// so in case of a crash, we don't lose too much data. If the database doesn't support\n    /// write buffers, this method can be a no-op.\n    fn flush(\u0026self) -\u003e Result\u003c(), Self::Error\u003e;\n    /// Associates a block hash with a given height, so we can retrieve it later.\n    fn update_block_index(\u0026self, height: u32, hash: BlockHash) -\u003e Result\u003c(), Self::Error\u003e;\n}\n\n#[derive(Debug, Clone)]\n/// A notification is a hook that a type implementing [BlockchainInterface] sends each\n/// time the given event happens. This is use to notify new blocks to the Electrum server.\n/// In the future, it can be expanded to send more data, like transactions.\npub enum Notification {\n    NewBlock((Block, u32)),\n}\n\nimpl\u003cT: UpdatableChainstate\u003e UpdatableChainstate for Arc\u003cT\u003e {\n    fn flush(\u0026self) -\u003e Result\u003c(), BlockchainError\u003e {\n        T::flush(self)\n    }\n\n    fn toggle_ibd(\u0026self, is_ibd: bool) {\n        T::toggle_ibd(self, is_ibd)\n    }\n\n    fn connect_block(\n        \u0026self,\n        block: \u0026Block,\n        proof: Proof,\n        inputs: HashMap\u003cOutPoint, TxOut\u003e,\n        del_hashes: Vec\u003csha256::Hash\u003e,\n    ) -\u003e Result\u003cu32, BlockchainError\u003e {\n        T::connect_block(self, block, proof, inputs, del_hashes)\n    }\n\n    fn accept_header(\u0026self, header: BlockHeader) -\u003e Result\u003c(), BlockchainError\u003e {\n        T::accept_header(self, header)\n    }\n\n    fn get_root_hashes(\u0026self) -\u003e Vec\u003cNodeHash\u003e {\n        T::get_root_hashes(self)\n    }\n\n    fn invalidate_block(\u0026self, block: BlockHash) -\u003e Result\u003c(), BlockchainError\u003e {\n        T::invalidate_block(self, block)\n    }\n\n    fn get_partial_chain(\n        \u0026self,\n        initial_height: u32,\n        final_height: u32,\n        acc: Stump,\n    ) -\u003e Result\u003cPartialChainState, BlockchainError\u003e {\n        T::get_partial_chain(self, initial_height, final_height, acc)\n    }\n\n    fn handle_transaction(\u0026self) -\u003e Result\u003c(), BlockchainError\u003e {\n        T::handle_transaction(self)\n    }\n\n    fn switch_chain(\u0026self, new_tip: BlockHash) -\u003e Result\u003c(), BlockchainError\u003e {\n        T::switch_chain(self, new_tip)\n    }\n\n    fn process_rescan_block(\u0026self, block: \u0026Block) -\u003e Result\u003c(), BlockchainError\u003e {\n        T::process_rescan_block(self, block)\n    }\n\n    fn mark_block_as_valid(\u0026self, block: BlockHash) -\u003e Result\u003c(), BlockchainError\u003e {\n        T::mark_block_as_valid(self, block)\n    }\n\n    fn mark_chain_as_assumed(\u0026self, acc: Stump) -\u003e Result\u003cbool, BlockchainError\u003e {\n        T::mark_chain_as_assumed(self, acc)\n    }\n}\n\nimpl\u003cT: BlockchainInterface\u003e BlockchainInterface for Arc\u003cT\u003e {\n    type Error = \u003cT as BlockchainInterface\u003e::Error;\n\n    fn get_tx(\u0026self, txid: \u0026bitcoin::Txid) -\u003e Result\u003cOption\u003cbitcoin::Transaction\u003e, Self::Error\u003e {\n        T::get_tx(self, txid)\n    }\n\n    fn rescan(\u0026self, start_height: u32) -\u003e Result\u003c(), Self::Error\u003e {\n        T::rescan(self, start_height)\n    }\n\n    fn broadcast(\u0026self, tx: \u0026bitcoin::Transaction) -\u003e Result\u003c(), Self::Error\u003e {\n        T::broadcast(self, tx)\n    }\n\n    fn get_block(\u0026self, hash: \u0026BlockHash) -\u003e Result\u003cBlock, Self::Error\u003e {\n        T::get_block(self, hash)\n    }\n\n    fn subscribe(\u0026self, tx: Arc\u003cdyn BlockConsumer\u003e) {\n        T::subscribe(self, tx)\n    }\n\n    fn is_in_idb(\u0026self) -\u003e bool {\n        T::is_in_idb(self)\n    }\n\n    fn get_height(\u0026self) -\u003e Result\u003cu32, Self::Error\u003e {\n        T::get_height(self)\n    }\n\n    fn estimate_fee(\u0026self, target: usize) -\u003e Result\u003cf64, Self::Error\u003e {\n        T::estimate_fee(self, target)\n    }\n\n    fn get_block_hash(\u0026self, height: u32) -\u003e Result\u003cbitcoin::BlockHash, Self::Error\u003e {\n        T::get_block_hash(self, height)\n    }\n\n    fn get_best_block(\u0026self) -\u003e Result\u003c(u32, BlockHash), Self::Error\u003e {\n        T::get_best_block(self)\n    }\n\n    fn get_block_header(\u0026self, hash: \u0026BlockHash) -\u003e Result\u003cBlockHeader, Self::Error\u003e {\n        T::get_block_header(self, hash)\n    }\n\n    fn get_rescan_index(\u0026self) -\u003e Option\u003cu32\u003e {\n        T::get_rescan_index(self)\n    }\n\n    fn get_block_height(\u0026self, hash: \u0026BlockHash) -\u003e Result\u003cOption\u003cu32\u003e, Self::Error\u003e {\n        T::get_block_height(self, hash)\n    }\n\n    fn get_unbroadcasted(\u0026self) -\u003e Vec\u003cTransaction\u003e {\n        T::get_unbroadcasted(self)\n    }\n\n    fn get_block_locator(\u0026self) -\u003e Result\u003cVec\u003cBlockHash\u003e, Self::Error\u003e {\n        T::get_block_locator(self)\n    }\n\n    fn is_coinbase_mature(\u0026self, height: u32, block: BlockHash) -\u003e Result\u003cbool, Self::Error\u003e {\n        T::is_coinbase_mature(self, height, block)\n    }\n\n    fn get_validation_index(\u0026self) -\u003e Result\u003cu32, Self::Error\u003e {\n        T::get_validation_index(self)\n    }\n\n    fn get_block_locator_for_tip(\u0026self, tip: BlockHash) -\u003e Result\u003cVec\u003cBlockHash\u003e, BlockchainError\u003e {\n        T::get_block_locator_for_tip(self, tip)\n    }\n\n    fn update_acc(\n        \u0026self,\n        acc: Stump,\n        block: UtreexoBlock,\n        height: u32,\n        proof: Proof,\n        del_hashes: Vec\u003csha256::Hash\u003e,\n    ) -\u003e Result\u003cStump, Self::Error\u003e {\n        T::update_acc(self, acc, block, height, proof, del_hashes)\n    }\n\n    fn get_chain_tips(\u0026self) -\u003e Result\u003cVec\u003cBlockHash\u003e, Self::Error\u003e {\n        T::get_chain_tips(self)\n    }\n\n    fn validate_block(\n        \u0026self,\n        block: \u0026Block,\n        proof: Proof,\n        inputs: HashMap\u003cOutPoint, TxOut\u003e,\n        del_hashes: Vec\u003csha256::Hash\u003e,\n        acc: Stump,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        T::validate_block(self, block, proof, inputs, del_hashes, acc)\n    }\n\n    fn get_fork_point(\u0026self, block: BlockHash) -\u003e Result\u003cBlockHash, Self::Error\u003e {\n        T::get_fork_point(self, block)\n    }\n}\n","traces":[{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[4726800,4726839,4726432],"length":1,"stats":{"Line":0},"fn_name":"connect_block\u003cfloresta_chain::pruned_utreexo::chain_state::ChainState\u003cfloresta_chain::pruned_utreexo::chainstore::KvChainStore\u003e\u003e"},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[4727221,4727056,4727248],"length":1,"stats":{"Line":0},"fn_name":"get_partial_chain\u003cfloresta_chain::pruned_utreexo::chain_state::ChainState\u003cfloresta_chain::pruned_utreexo::chainstore::KvChainStore\u003e\u003e"},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[4724333,4723888,4724400],"length":1,"stats":{"Line":0},"fn_name":"update_acc\u003cfloresta_chain::pruned_utreexo::chain_state::ChainState\u003cfloresta_chain::pruned_utreexo::chainstore::KvChainStore\u003e\u003e"},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[4725278,4724752,4725211],"length":1,"stats":{"Line":0},"fn_name":"validate_block\u003cfloresta_chain::pruned_utreexo::chain_state::ChainState\u003cfloresta_chain::pruned_utreexo::chainstore::KvChainStore\u003e\u003e"},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":68},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-chain","src","pruned_utreexo","partial_chain.rs"],"content":"//! A partial chain is a chain that only contains a subset of the blocks in the\n//! full chain. We use multiple partial chains to sync up with the full chain,\n//! and then merge them together to get the full chain. This allows us to make\n//! Initial Block Download in parallel.\n//!\n//! We use a [PartialChainState] insted of the useal ChainState, mainly for\n//! performance. Because we assume that only one worker will hold a [PartialChainState]\n//! at a given time, we can drop all syncronization primitives and make a really performatic\n//! ChainState that will consume and validate blocks as fast as we possibly can.\n//!\n//! This choice removes the use of costly atomic operations, but opens space for design flaws\n//! and memory unsoundness, so here are some tips about this module and how people looking for\n//! extend or use this code should proceed:\n//!   \n//!   - Shared ownership is forbidden: if you have two threads or tasks owning this, you'll have\n//!     data race. If you want to hold shared ownership for this module, you need to place a\n//!     [PartialChainState] inside an `Arc\u003cMutex\u003e` yourself. Don't just Arc this and expect it to\n//!     work, as you are garanteed to have data races.\n//!   - The interior is toxic, so no peeking: no references, mutable or not, to any field should\n//!     leak through the API, as we are not enforcing lifetime or borrowing rules at compile time.\n//!   - Sending is fine: There's nothing in this module that makes it not sendable to between\n//!     threads, as long as the origin thread gives away the ownership.\nuse bitcoin::BlockHash;\nuse floresta_common::prelude::*;\nextern crate alloc;\n\nuse core::cell::UnsafeCell;\n#[cfg(feature = \"bitcoinconsensus\")]\nuse core::ffi::c_uint;\n\n#[cfg(feature = \"bitcoinconsensus\")]\nuse bitcoin::bitcoinconsensus;\nuse bitcoin::block::Header as BlockHeader;\nuse log::info;\nuse rustreexo::accumulator::stump::Stump;\n\nuse super::chainparams::ChainParams;\nuse super::consensus::Consensus;\nuse super::error::BlockValidationErrors;\nuse super::error::BlockchainError;\nuse super::BlockchainInterface;\nuse super::UpdatableChainstate;\n\n#[doc(hidden)]\n#[derive(Debug)]\npub(crate) struct PartialChainStateInner {\n    /// The current accumulator state, it starts with a hardcoded value and\n    /// gets checked against the result of the previous partial chainstate.\n    pub(crate) current_acc: Stump,\n    /// The block headers in this interval, we need this to verify the blocks\n    /// and to build the accumulator. We assume this is sorted by height, and\n    /// should contains all blocks in this interval.\n    pub(crate) blocks: Vec\u003cBlockHeader\u003e,\n    /// The height this interval starts at. This [initial_height, final_height), so\n    /// if we break the interval at height 100, the first interval will be [0, 100)\n    /// and the second interval will be [100, 200). And the initial height of the\n    /// second interval will be 99.\n    pub(crate) initial_height: u32,\n    /// The height we are on right now, this is used to keep track of the progress\n    /// of the sync.\n    pub(crate) current_height: u32,\n    /// The height we are syncing up to, trying to push more blocks than this will\n    /// result in an error.\n    pub(crate) final_height: u32,\n    /// The error that occurred during validation, if any. It is here so we can\n    /// pull that afterwords.\n    pub(crate) error: Option\u003cBlockValidationErrors\u003e,\n    /// The consensus parameters, we need this to validate the blocks.\n    pub(crate) consensus: Consensus,\n    /// Whether we assume the signatures in this interval as valid, this is used to\n    /// speed up syncing, by assuming signatures in old blocks are valid.\n    pub(crate) assume_valid: bool,\n}\n\n/// A partial chain is a chain that only contains a subset of the blocks in the\n/// full chain. We use multiple partial chains to sync up with the full chain,\n/// and then merge them together to get the full chain. This allows us to conduct\n/// the sync in parallel. To build one, we need to know the initial\n/// height, the final height, and the block headers in between.\n///\n/// We need to modify our current state as-we-go, but we also need to use the main\n/// traits that define a chainstate. Most cruccially, both crates don't take a mutable\n/// reference in any method, so we need some form of interior mutability.\n/// We could just use a mutex, but this is not required and very wateful. Partial chains\n/// differ from the normal chain because they only have one owner, the worker responsible\n/// for driving this chain to it's completion. Because of that, we can simply use a UnsafeCell\n/// and forbit shared access between threads by not implementing [Clone].\npub struct PartialChainState(pub(crate) UnsafeCell\u003cPartialChainStateInner\u003e);\n\n/// We need to send [PartialChainState] between threads/tasks, because the worker thread, once it\n/// finishes, needs to notify the main task and pass the final partial chain.\n/// # Safety\n///\n/// All itens inside the [UnsafeCell] are [Send], most importantly, there are no references or\n/// smart pointers inside it, so sending shouldn't be a problem.\nunsafe impl Send for PartialChainState {}\nunsafe impl Sync for PartialChainState {}\n\nimpl PartialChainStateInner {\n    /// Returns the height we have synced up to so far\n    pub fn current_height(\u0026self) -\u003e u32 {\n        self.current_height\n    }\n\n    /// Whether or not we have synced up to the final height\n    pub fn is_sync(\u0026self) -\u003e bool {\n        self.current_height == self.final_height\n    }\n\n    pub fn get_block(\u0026self, height: u32) -\u003e Option\u003c\u0026BlockHeader\u003e {\n        let index = height - self.initial_height;\n        self.blocks.get(index as usize)\n    }\n\n    #[cfg(feature = \"bitcoinconsensus\")]\n    /// Returns the validation flags, given the current block height\n    fn get_validation_flags(\u0026self, height: u32) -\u003e c_uint {\n        let chains_params = \u0026self.consensus.parameters;\n        let hash = self.get_block(height).unwrap().block_hash();\n        if let Some(flag) = chains_params.exceptions.get(\u0026hash) {\n            return *flag;\n        }\n        // From Bitcoin Core:\n        // BIP16 didn't become active until Apr 1 2012 (on mainnet, and\n        // retroactively applied to testnet)\n        // However, only one historical block violated the P2SH rules (on both\n        // mainnet and testnet).\n        // Similarly, only one historical block violated the TAPROOT rules on\n        // mainnet.\n        // For simplicity, always leave P2SH+WITNESS+TAPROOT on except for the two\n        // violating blocks.\n        let mut flags = bitcoinconsensus::VERIFY_P2SH | bitcoinconsensus::VERIFY_WITNESS;\n\n        if height \u003e= chains_params.bip65_activation_height {\n            flags |= bitcoinconsensus::VERIFY_CHECKLOCKTIMEVERIFY;\n        }\n        if height \u003e= chains_params.bip66_activation_height {\n            flags |= bitcoinconsensus::VERIFY_DERSIG;\n        }\n        if height \u003e= chains_params.csv_activation_height {\n            flags |= bitcoinconsensus::VERIFY_CHECKSEQUENCEVERIFY;\n        }\n        if height \u003e= chains_params.segwit_activation_height {\n            flags |= bitcoinconsensus::VERIFY_NULLDUMMY;\n        }\n        flags\n    }\n\n    #[inline]\n    /// Update our internal state, given a new height and accumulator\n    fn update_state(\u0026mut self, height: u32, acc: Stump) {\n        self.current_height = height;\n        self.current_acc = acc;\n    }\n\n    #[inline]\n    /// Returns the parameters for this chain\n    fn chain_params(\u0026self) -\u003e ChainParams {\n        self.consensus.parameters.clone()\n    }\n\n    #[inline]\n    /// Returns the ancestor for a given block header\n    fn get_ancestor(\u0026self, height: u32) -\u003e Result\u003cBlockHeader, BlockchainError\u003e {\n        let prev = self.get_block(height - 1).unwrap();\n        Ok(*prev)\n    }\n\n    /// Process a block, given the proof, inputs, and deleted hashes. If we find an error,\n    /// we save it.\n    pub fn process_block(\n        \u0026mut self,\n        block: \u0026bitcoin::Block,\n        proof: rustreexo::accumulator::proof::Proof,\n        inputs: HashMap\u003cbitcoin::OutPoint, bitcoin::TxOut\u003e,\n        del_hashes: Vec\u003cbitcoin::hashes::sha256::Hash\u003e,\n    ) -\u003e Result\u003cu32, BlockchainError\u003e {\n        let height = self.current_height + 1;\n\n        if let Err(BlockchainError::BlockValidation(e)) = self.validate_block(block, height, inputs)\n        {\n            self.error = Some(e.clone());\n            return Err(BlockchainError::BlockValidation(e));\n        }\n\n        let acc = match Consensus::update_acc(\u0026self.current_acc, block, height, proof, del_hashes) {\n            Ok(acc) =\u003e acc,\n            Err(_) =\u003e {\n                self.error = Some(BlockValidationErrors::InvalidProof);\n                return Err(BlockchainError::InvalidProof);\n            }\n        };\n\n        // ... If we came this far, we consider this block valid ...\n\n        if height % 10_000 == 0 {\n            info!(\n                \"Downloading blocks: height={height} hash={}\",\n                block.block_hash()\n            );\n        }\n        self.update_state(height, acc);\n\n        Ok(height)\n    }\n\n    /// Check whether a block is valid\n    fn validate_block(\n        \u0026self,\n        block: \u0026bitcoin::Block,\n        height: u32,\n        inputs: HashMap\u003cbitcoin::OutPoint, bitcoin::TxOut\u003e,\n    ) -\u003e Result\u003c(), BlockchainError\u003e {\n        if !block.check_merkle_root() {\n            return Err(BlockchainError::BlockValidation(\n                BlockValidationErrors::BadMerkleRoot,\n            ));\n        }\n        if height \u003e= self.chain_params().bip34_activation_height\n            \u0026\u0026 block.bip34_block_height() != Ok(height as u64)\n        {\n            return Err(BlockchainError::BlockValidation(\n                BlockValidationErrors::BadBip34,\n            ));\n        }\n        if !block.check_witness_commitment() {\n            return Err(BlockchainError::BlockValidation(\n                BlockValidationErrors::BadWitnessCommitment,\n            ));\n        }\n        let prev_block = self.get_ancestor(height)?;\n        if block.header.prev_blockhash != prev_block.block_hash() {\n            return Err(BlockchainError::BlockValidation(\n                BlockValidationErrors::BlockExtendsAnOrphanChain,\n            ));\n        }\n        // Validate block transactions\n        let subsidy = self.consensus.get_subsidy(height);\n        let verify_script = self.assume_valid;\n        #[cfg(feature = \"bitcoinconsensus\")]\n        let flags = self.get_validation_flags(height);\n        #[cfg(not(feature = \"bitcoinconsensus\"))]\n        let flags = 0;\n        Consensus::verify_block_transactions(inputs, \u0026block.txdata, subsidy, verify_script, flags)?;\n        Ok(())\n    }\n}\n\nimpl PartialChainState {\n    /// Borrows the inner content as immutable referece.\n    ///\n    /// # Safety\n    /// We can assume this [UnsafeCell] is initialized because the only way to get a\n    /// [PartialChainState] is through our APIs, and we make sure this [UnsafeCell] is\n    /// always valid.\n    /// The reference returned here **should not** leak through the API, as there's no\n    /// syncronization mechanims for it.\n    #[inline(always)]\n    #[must_use]\n    #[doc(hidden)]\n    fn inner(\u0026self) -\u003e \u0026PartialChainStateInner {\n        unsafe { self.0.get().as_ref().expect(\"this pointer is valid\") }\n    }\n\n    /// Borrows the inner content as a mutable referece.\n    ///\n    /// # Safety\n    /// We can assume this [UnsafeCell] is initialized because the only way to get a\n    /// [PartialChainState] is through our APIs, and we make sure this [UnsafeCell] is\n    /// always valid.\n    /// The reference returned here **should not** leak through the API, as there's no\n    /// syncronization mechanims for it.\n    #[inline(always)]\n    #[allow(clippy::mut_from_ref)]\n    #[must_use]\n    #[doc(hidden)]\n    fn inner_mut(\u0026self) -\u003e \u0026mut PartialChainStateInner {\n        unsafe { self.0.get().as_mut().expect(\"this pointer is valid\") }\n    }\n\n    /// Returns all blocks in this partial chain\n    pub fn list_blocks(\u0026self) -\u003e \u0026[BlockHeader] {\n        \u0026self.inner().blocks\n    }\n\n    /// Returns all block we have validated so far in this chain\n    pub fn list_valid_blocks(\u0026self) -\u003e Vec\u003c\u0026BlockHeader\u003e {\n        self.inner()\n            .blocks\n            .iter()\n            .take(self.inner().current_height as usize)\n            .collect()\n    }\n\n    /// Returns whether any block inside this interval is invalid\n    pub fn has_invalid_blocks(\u0026self) -\u003e bool {\n        self.inner().error.is_some()\n    }\n}\n\nimpl UpdatableChainstate for PartialChainState {\n    fn connect_block(\n        \u0026self,\n        block: \u0026bitcoin::Block,\n        proof: rustreexo::accumulator::proof::Proof,\n        inputs: HashMap\u003cbitcoin::OutPoint, bitcoin::TxOut\u003e,\n        del_hashes: Vec\u003cbitcoin::hashes::sha256::Hash\u003e,\n    ) -\u003e Result\u003cu32, BlockchainError\u003e {\n        self.inner_mut()\n            .process_block(block, proof, inputs, del_hashes)\n    }\n\n    fn get_root_hashes(\u0026self) -\u003e Vec\u003crustreexo::accumulator::node_hash::NodeHash\u003e {\n        self.inner().current_acc.roots.clone()\n    }\n\n    //these are no-ops, you can call them, but they won't do anything\n\n    fn flush(\u0026self) -\u003e Result\u003c(), BlockchainError\u003e {\n        // no-op: we keep everything on memory\n        Ok(())\n    }\n\n    fn toggle_ibd(\u0026self, _is_ibd: bool) {\n        // no-op: we know if we finished by looking at our current and end height\n    }\n\n    // these are unimplemented, and will panic if called\n\n    fn accept_header(\u0026self, _header: BlockHeader) -\u003e Result\u003c(), BlockchainError\u003e {\n        unimplemented!(\"partialChainState shouldn't be used to accept new headers\")\n    }\n\n    fn switch_chain(\u0026self, _new_tip: BlockHash) -\u003e Result\u003c(), BlockchainError\u003e {\n        unimplemented!(\"partialChainState shouldn't be used to switch chains\")\n    }\n\n    fn get_partial_chain(\n        \u0026self,\n        _initial_height: u32,\n        _final_height: u32,\n        _acc: Stump,\n    ) -\u003e Result\u003cPartialChainState, BlockchainError\u003e {\n        unimplemented!(\"We are a partial chain\")\n    }\n\n    fn invalidate_block(\u0026self, _block: BlockHash) -\u003e Result\u003c(), BlockchainError\u003e {\n        unimplemented!(\"we know if a block is invalid, just break out of your loop and use the is_valid() method\")\n    }\n\n    fn handle_transaction(\u0026self) -\u003e Result\u003c(), BlockchainError\u003e {\n        unimplemented!(\"we don't do transactions\")\n    }\n\n    fn process_rescan_block(\u0026self, _block: \u0026bitcoin::Block) -\u003e Result\u003c(), BlockchainError\u003e {\n        unimplemented!(\"we don't do rescan\")\n    }\n\n    fn mark_chain_as_assumed(\u0026self, _acc: Stump) -\u003e Result\u003cbool, BlockchainError\u003e {\n        unimplemented!(\"no need to mark as valid\")\n    }\n\n    fn mark_block_as_valid(\u0026self, _block: BlockHash) -\u003e Result\u003c(), BlockchainError\u003e {\n        unimplemented!(\"no need to mark as valid\")\n    }\n}\n\nimpl BlockchainInterface for PartialChainState {\n    type Error = BlockchainError;\n\n    fn get_height(\u0026self) -\u003e Result\u003cu32, Self::Error\u003e {\n        Ok(self.inner().current_height)\n    }\n\n    fn get_block_hash(\u0026self, height: u32) -\u003e Result\u003cbitcoin::BlockHash, BlockchainError\u003e {\n        let height = height - self.inner().initial_height;\n        self.inner()\n            .blocks\n            .get(height as usize)\n            .map(|b| b.block_hash())\n            .ok_or(BlockchainError::BlockNotPresent)\n    }\n\n    fn get_best_block(\u0026self) -\u003e Result\u003c(u32, bitcoin::BlockHash), Self::Error\u003e {\n        Ok((\n            self.inner().current_height(),\n            self.get_block_hash(self.inner().current_height())?,\n        ))\n    }\n\n    fn is_coinbase_mature(\n        \u0026self,\n        height: u32,\n        _block: bitcoin::BlockHash,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        let current_height = self.inner().current_height;\n        let coinbase_maturity = self.inner().chain_params().coinbase_maturity;\n\n        Ok(height + coinbase_maturity \u003e current_height)\n    }\n\n    fn get_validation_index(\u0026self) -\u003e Result\u003cu32, Self::Error\u003e {\n        Ok(self.inner().current_height)\n    }\n\n    fn is_in_idb(\u0026self) -\u003e bool {\n        !self.inner().is_sync()\n    }\n\n    // partial chain states are only used for IBD, so we don't need to implement these\n\n    fn get_block_header(\u0026self, _height: \u0026BlockHash) -\u003e Result\u003cBlockHeader, Self::Error\u003e {\n        unimplemented!(\"PartialChainState::get_block_header\")\n    }\n\n    fn get_chain_tips(\u0026self) -\u003e Result\u003cVec\u003cBlockHash\u003e, Self::Error\u003e {\n        unimplemented!(\"PartialChainState::get_chain_tips\")\n    }\n\n    fn validate_block(\n        \u0026self,\n        _block: \u0026bitcoin::Block,\n        _proof: rustreexo::accumulator::proof::Proof,\n        _inputs: HashMap\u003cbitcoin::OutPoint, bitcoin::TxOut\u003e,\n        _del_hashes: Vec\u003cbitcoin::hashes::sha256::Hash\u003e,\n        _acc: Stump,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        unimplemented!(\"PartialChainState::validate_block\")\n    }\n\n    fn get_fork_point(\u0026self, _block: BlockHash) -\u003e Result\u003cBlockHash, Self::Error\u003e {\n        unimplemented!(\"PartialChainState::get_fork_point\")\n    }\n\n    fn update_acc(\n        \u0026self,\n        _acc: Stump,\n        _block: bitcoin::p2p::utreexo::UtreexoBlock,\n        _height: u32,\n        _proof: rustreexo::accumulator::proof::Proof,\n        _del_hashes: Vec\u003cbitcoin::hashes::sha256::Hash\u003e,\n    ) -\u003e Result\u003cStump, Self::Error\u003e {\n        unimplemented!(\"PartialChainState::update_acc\")\n    }\n\n    fn get_block_locator_for_tip(\n        \u0026self,\n        _tip: BlockHash,\n    ) -\u003e Result\u003cVec\u003cBlockHash\u003e, BlockchainError\u003e {\n        unimplemented!(\"PartialChainState::get_block_locator_for_tip\")\n    }\n\n    fn get_block(\u0026self, _hash: \u0026bitcoin::BlockHash) -\u003e Result\u003cbitcoin::Block, Self::Error\u003e {\n        unimplemented!(\"PartialChainState::get_block\")\n    }\n\n    fn get_tx(\u0026self, _txid: \u0026bitcoin::Txid) -\u003e Result\u003cOption\u003cbitcoin::Transaction\u003e, Self::Error\u003e {\n        unimplemented!(\"partialChainState::get_tx\")\n    }\n\n    fn rescan(\u0026self, _start_height: u32) -\u003e Result\u003c(), Self::Error\u003e {\n        unimplemented!(\"partialChainState::rescan\")\n    }\n\n    fn broadcast(\u0026self, _tx: \u0026bitcoin::Transaction) -\u003e Result\u003c(), Self::Error\u003e {\n        unimplemented!(\"partialChainState::broadcast\")\n    }\n\n    fn subscribe(\u0026self, _tx: sync::Arc\u003cdyn crate::BlockConsumer\u003e) {\n        unimplemented!(\"partialChainState::subscibe\")\n    }\n\n    fn estimate_fee(\u0026self, _target: usize) -\u003e Result\u003cf64, Self::Error\u003e {\n        unimplemented!(\"partialChainState::estimate_fee\")\n    }\n\n    fn get_rescan_index(\u0026self) -\u003e Option\u003cu32\u003e {\n        unimplemented!(\"partialChainState::get_rescan_index\")\n    }\n\n    fn get_block_height(\u0026self, _hash: \u0026bitcoin::BlockHash) -\u003e Result\u003cOption\u003cu32\u003e, Self::Error\u003e {\n        unimplemented!(\"partialChainState::get_block_height\")\n    }\n\n    fn get_unbroadcasted(\u0026self) -\u003e Vec\u003cbitcoin::Transaction\u003e {\n        unimplemented!(\"partialChainState::get_unbroadcasted\")\n    }\n\n    fn get_block_locator(\u0026self) -\u003e Result\u003cVec\u003cbitcoin::BlockHash\u003e, Self::Error\u003e {\n        unimplemented!(\"partialChainState::get_block_locator\")\n    }\n}\n\n// mainly for tests\nimpl From\u003cPartialChainStateInner\u003e for PartialChainState {\n    fn from(value: PartialChainStateInner) -\u003e Self {\n        PartialChainState(UnsafeCell::new(value))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use core::str::FromStr;\n    use std::collections::HashMap;\n\n    use bitcoin::block::Header;\n    use bitcoin::consensus::deserialize;\n    use bitcoin::Block;\n    use rustreexo::accumulator::node_hash::NodeHash;\n    use rustreexo::accumulator::proof::Proof;\n    use rustreexo::accumulator::stump::Stump;\n\n    use super::PartialChainState;\n    use crate::pruned_utreexo::chainparams::ChainParams;\n    use crate::pruned_utreexo::consensus::Consensus;\n    use crate::pruned_utreexo::error::BlockValidationErrors;\n    use crate::pruned_utreexo::partial_chain::PartialChainStateInner;\n    use crate::pruned_utreexo::UpdatableChainstate;\n    use crate::BlockchainError;\n    use crate::Network;\n\n    #[test]\n    fn test_with_invalid_block() {\n        fn run(block: \u0026str, reason: BlockValidationErrors) {\n            let genesis = parse_block(\"0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4adae5494dffff7f20020000000101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000\");\n            let block = parse_block(block);\n\n            let chainstate = get_empty_pchain(vec![genesis.header, block.header]);\n            let res = chainstate.connect_block(\u0026block, Proof::default(), HashMap::new(), vec![]);\n\n            match res {\n                Err(BlockchainError::BlockValidation(_e)) if matches!(reason, _e) =\u003e {}\n                _ =\u003e panic!(\"unexpected {res:?}\"),\n            };\n        }\n        run(\"0000002000226e46111a0b59caaf126043eb5bbf28c34f3a5e332a1fc7b2b73cf188910f39adbcd7823048d34357bdca86cd47172afe2a4af8366b5b34db36df89386d49b23ec964ffff7f20000000000101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff165108feddb99c6b8435060b2f503253482f627463642fffffffff0100f2052a01000000160014806cef41295922d32ddfca09c26cc4acd36c3ed000000000\",super::BlockValidationErrors::BlockExtendsAnOrphanChain);\n        run(\"0000002000226e46111a0b59caaf126043eb5bbf28c34f3a5e332a1fc7b2b73cf188910f40adbcd7823048d34357bdca86cd47172afe2a4af8366b5b34db36df89386d49b23ec964ffff7f20000000000101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff165108feddb99c6b8435060b2f503253482f627463642fffffffff0100f2052a01000000160014806cef41295922d32ddfca09c26cc4acd36c3ed000000000\", BlockValidationErrors::BadMerkleRoot);\n    }\n    fn parse_block(hex: \u0026str) -\u003e Block {\n        let block = hex::decode(hex).unwrap();\n        deserialize(\u0026block).unwrap()\n    }\n    fn get_empty_pchain(blocks: Vec\u003cHeader\u003e) -\u003e PartialChainState {\n        PartialChainStateInner {\n            assume_valid: true,\n            consensus: Consensus {\n                parameters: ChainParams::from(Network::Regtest),\n            },\n            current_height: 0,\n            current_acc: Stump::default(),\n            final_height: 1,\n            blocks,\n            error: None,\n            initial_height: 0,\n        }\n        .into()\n    }\n\n    #[test]\n    fn test_updating_single_chain() {\n        let blocks = include_str!(\"./testdata/blocks.txt\");\n        let mut parsed_blocks = vec![];\n        for (i, block) in blocks.lines().enumerate() {\n            if i \u003e 100 {\n                break;\n            }\n            let block: Block = deserialize(\u0026hex::decode(block).unwrap()).unwrap();\n            parsed_blocks.push(block);\n        }\n        let chainstate: PartialChainState = PartialChainStateInner {\n            assume_valid: true,\n            consensus: Consensus {\n                parameters: ChainParams::from(Network::Regtest),\n            },\n            current_height: 0,\n            current_acc: Stump::default(),\n            final_height: 100,\n            blocks: parsed_blocks.iter().map(|block| block.header).collect(),\n            error: None,\n            initial_height: 0,\n        }\n        .into();\n        parsed_blocks.remove(0);\n        for block in parsed_blocks {\n            let proof = Proof::default();\n            let inputs = HashMap::new();\n            let del_hashes = vec![];\n            chainstate\n                .connect_block(\u0026block, proof, inputs, del_hashes)\n                .unwrap();\n        }\n        assert_eq!(chainstate.inner().current_height, 100);\n    }\n\n    #[test]\n    fn test_updating_multiple_chains() {\n        // We have two chains, one with 100 blocks, one with 50 blocks. We expect the\n        // accumulator to be what we expect after 100 blocks and after 150 blocks.\n        let blocks = include_str!(\"./testdata/blocks.txt\");\n        let mut parsed_blocks = vec![];\n        for block in blocks.lines() {\n            let block: Block = deserialize(\u0026hex::decode(block).unwrap()).unwrap();\n            parsed_blocks.push(block);\n        }\n        // The file contains 150 blocks, we split them into two chains.\n        let (blocks1, blocks2) = parsed_blocks.split_at(101);\n        let mut chainstate1 = PartialChainStateInner {\n            assume_valid: true,\n            consensus: Consensus {\n                parameters: ChainParams::from(Network::Regtest),\n            },\n            current_height: 0,\n            current_acc: Stump::default(),\n            final_height: 100,\n            blocks: blocks1.iter().map(|block| block.header).collect(),\n            error: None,\n            initial_height: 0,\n        };\n        // We need to add the last block of the first chain to the second chain, so that\n        // the second chain can validate all its blocks.\n        let mut blocks2_headers = vec![blocks1.last().unwrap()];\n        blocks2_headers.extend(blocks2);\n\n        let blocks2_headers = blocks2_headers.iter().map(|block| block.header).collect();\n\n        let mut blocks1 = blocks1.iter();\n        blocks1.next();\n\n        for block in blocks1 {\n            let proof = Proof::default();\n            let inputs = HashMap::new();\n            let del_hashes = vec![];\n            chainstate1\n                .process_block(block, proof, inputs, del_hashes)\n                .unwrap();\n        }\n        // The state after 100 blocks, computed ahead of time.\n        let roots = [\n            \"a2f1e6db842e13c7480c8d80f29ca2db5f9b96e1b428ebfdbd389676d7619081\",\n            \"b21aae30bc74e9aef600a5d507ef27d799b9b6ba08e514656d34d717bdb569d2\",\n            \"bedb648c9a3c5741660f926c1552d83ebb4cb1842cca6855b6d1089bb4951ce1\",\n        ]\n        .iter()\n        .map(|hash| NodeHash::from_str(hash).unwrap())\n        .collect();\n\n        let acc2 = Stump { roots, leaves: 100 };\n\n        // acc2 is hard-coded, while chainstate1.current_acc is calculated.\n        // after catching up in the first half, the accumulator should be the same.\n        // We can have the speedup of doing it in parallel, without needing to trust\n        // the hard-coded values.\n        assert_eq!(chainstate1.current_acc, acc2);\n\n        let chainstate2: PartialChainState = PartialChainStateInner {\n            assume_valid: true,\n            consensus: Consensus {\n                parameters: ChainParams::from(Network::Regtest),\n            },\n            current_height: 100,\n            current_acc: acc2,\n            final_height: 150,\n            blocks: blocks2_headers,\n            error: None,\n            initial_height: 100,\n        }\n        .into();\n\n        for block in blocks2 {\n            let proof = Proof::default();\n            let inputs = HashMap::new();\n            let del_hashes = vec![];\n            chainstate2\n                .connect_block(block, proof, inputs, del_hashes)\n                .unwrap();\n        }\n\n        let roots = [\n            \"e00b4ecc7c30865af0ac3b0c7c1b996015f51d6a6577ee6f52cc04b55933eb91\",\n            \"9bf9659f93e246e0431e228032cd4b3a4d8a13e57f3e08a221e61f3e0bae657f\",\n            \"e329a7ddcc888130bb6e4f82ce9f5cf5a712a7b0ae05a1aaf21b363866a9b05e\",\n            \"1864a4982532447dcb3d9a5d2fea9f8ed4e3b1e759d55b8a427fb599fed0c302\",\n        ]\n        .iter()\n        .map(|x| NodeHash::from(hex::decode(x).unwrap().as_slice()))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let expected_acc: Stump = Stump { leaves: 150, roots };\n\n        assert_eq!(chainstate2.inner().current_height, 150);\n        assert_eq!(chainstate2.inner().current_acc, expected_acc);\n    }\n}\n","traces":[{"line":101,"address":[1293920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[1293925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[1293936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[1293941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[1293968],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[1293986,1294059],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[1294022],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[1294096],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[1294113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[1294130],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[1294169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[1294224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[1294241],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[1294249,1294300],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[1294287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[1294277,1294332],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[1294321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[1294311,1294366],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[1294353],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[1294343,1294389],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[1294378],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[1294368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[1294624],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[1294712],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[1295726,1294816,1297318],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[1294874,1295055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[1295128,1294982,1295203],"length":1,"stats":{"Line":3},"fn_name":null},{"line":182,"address":[1295303,1295251],"length":1,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[1295478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[1295840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[1295988],"length":1,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[1297050,1296156,1296937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[1297097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[1296210,1296283],"length":1,"stats":{"Line":4},"fn_name":null},{"line":197,"address":[1296413,1296545,1296661,1296461,1296297,1296753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[1296518],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[1296344],"length":1,"stats":{"Line":2},"fn_name":null},{"line":204,"address":[1296873],"length":1,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[1297360,1299020,1299181],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[1297427,1297511],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[1297534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[1297522],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[1297666,1297636],"length":1,"stats":{"Line":3},"fn_name":null},{"line":220,"address":[1299044,1297733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[1299068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[1299056],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[1297710,1297947],"length":1,"stats":{"Line":3},"fn_name":null},{"line":227,"address":[1297970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[1297958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[1298085,1298338,1299031],"length":1,"stats":{"Line":2},"fn_name":null},{"line":232,"address":[1298297,1298416],"length":1,"stats":{"Line":3},"fn_name":null},{"line":233,"address":[1298491],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[1298479],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[1298458,1298603],"length":1,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[1298611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[1298628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[1298997,1298660,1298914,1297404],"length":1,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[1298901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":282,"address":[1299216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[1299269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[1299296],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[1299371,1299470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[1299462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[1299520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[1299573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[1299600,1300031,1300066],"length":1,"stats":{"Line":2},"fn_name":"connect_block"},{"line":309,"address":[1299983,1299666],"length":1,"stats":{"Line":4},"fn_name":null},{"line":310,"address":[1299851],"length":1,"stats":{"Line":2},"fn_name":null},{"line":313,"address":[1300112],"length":1,"stats":{"Line":0},"fn_name":"get_root_hashes"},{"line":314,"address":[1300194],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[1300224],"length":1,"stats":{"Line":0},"fn_name":"flush"},{"line":321,"address":[1300232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[1300240],"length":1,"stats":{"Line":0},"fn_name":"toggle_ibd"},{"line":330,"address":[1300256],"length":1,"stats":{"Line":0},"fn_name":"accept_header"},{"line":334,"address":[1300336],"length":1,"stats":{"Line":0},"fn_name":"switch_chain"},{"line":338,"address":[1300416,1300531],"length":1,"stats":{"Line":0},"fn_name":"get_partial_chain"},{"line":347,"address":[1300560],"length":1,"stats":{"Line":0},"fn_name":"invalidate_block"},{"line":351,"address":[1300640],"length":1,"stats":{"Line":0},"fn_name":"handle_transaction"},{"line":355,"address":[1300720],"length":1,"stats":{"Line":0},"fn_name":"process_rescan_block"},{"line":359,"address":[1300800,1300905],"length":1,"stats":{"Line":0},"fn_name":"mark_chain_as_assumed"},{"line":363,"address":[1300928],"length":1,"stats":{"Line":0},"fn_name":"mark_block_as_valid"},{"line":371,"address":[1301008],"length":1,"stats":{"Line":0},"fn_name":"get_height"},{"line":372,"address":[1301095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[1301120],"length":1,"stats":{"Line":0},"fn_name":"get_block_hash"},{"line":376,"address":[1301218,1301398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[1301339,1301370,1301312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[1301335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[1186016,1186032],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":381,"address":[1301362],"length":1,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[1301440],"length":1,"stats":{"Line":0},"fn_name":"get_best_block"},{"line":385,"address":[1301716],"length":1,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[1301528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[1301593,1301803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[1301872],"length":1,"stats":{"Line":0},"fn_name":"is_coinbase_mature"},{"line":396,"address":[1301974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[1302042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[1302088,1302144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[1302176],"length":1,"stats":{"Line":0},"fn_name":"get_validation_index"},{"line":403,"address":[1302263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[1302288],"length":1,"stats":{"Line":0},"fn_name":"is_in_idb"},{"line":407,"address":[1302341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[1302368],"length":1,"stats":{"Line":0},"fn_name":"get_block_header"},{"line":416,"address":[1302448],"length":1,"stats":{"Line":0},"fn_name":"get_chain_tips"},{"line":420,"address":[1302528,1302662,1302716],"length":1,"stats":{"Line":0},"fn_name":"validate_block"},{"line":431,"address":[1302736],"length":1,"stats":{"Line":0},"fn_name":"get_fork_point"},{"line":435,"address":[1303008,1302816,1302950],"length":1,"stats":{"Line":0},"fn_name":"update_acc"},{"line":446,"address":[1303024],"length":1,"stats":{"Line":0},"fn_name":"get_block_locator_for_tip"},{"line":453,"address":[1303104],"length":1,"stats":{"Line":0},"fn_name":"get_block"},{"line":457,"address":[1303184],"length":1,"stats":{"Line":0},"fn_name":"get_tx"},{"line":461,"address":[1303264],"length":1,"stats":{"Line":0},"fn_name":"rescan"},{"line":465,"address":[1303344],"length":1,"stats":{"Line":0},"fn_name":"broadcast"},{"line":469,"address":[1303532,1303424],"length":1,"stats":{"Line":0},"fn_name":"subscribe"},{"line":473,"address":[1303568],"length":1,"stats":{"Line":0},"fn_name":"estimate_fee"},{"line":477,"address":[1303648],"length":1,"stats":{"Line":0},"fn_name":"get_rescan_index"},{"line":481,"address":[1303728],"length":1,"stats":{"Line":0},"fn_name":"get_block_height"},{"line":485,"address":[1303808],"length":1,"stats":{"Line":0},"fn_name":"get_unbroadcasted"},{"line":489,"address":[1303888],"length":1,"stats":{"Line":0},"fn_name":"get_block_locator"},{"line":496,"address":[1303968],"length":1,"stats":{"Line":2},"fn_name":"from"},{"line":497,"address":[1304003],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":57,"coverable":129},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-chain","src","pruned_utreexo","udata.rs"],"content":"//! UData is the serialized data used for proof propagation in utreexo. It contains all\n//! data needed for validating some piece of information, like a transaction and a block.\n\nuse bitcoin::consensus::Decodable;\nuse bitcoin::consensus::Encodable;\nuse bitcoin::hashes::sha256;\nuse bitcoin::hashes::Hash;\nuse bitcoin::BlockHash;\nuse bitcoin::OutPoint;\nuse bitcoin::TxOut;\nuse sha2::Digest;\nuse sha2::Sha512_256;\n\nuse crate::prelude::*;\nuse crate::pruned_utreexo::consensus::UTREEXO_TAG_V1;\n\n/// Leaf data is the data that is hashed when adding to utreexo state. It contains validation\n/// data and some commitments to make it harder to attack an utreexo-only node.\n#[derive(Debug, PartialEq)]\npub struct LeafData {\n    /// A commitment to the block creating this utxo\n    pub block_hash: BlockHash,\n    /// The utxo's outpoint\n    pub prevout: OutPoint,\n    /// Header code is a compact commitment to the block height and whether or not this\n    /// transaction is coinbase. It's defined as\n    ///\n    /// ```ignore\n    /// header_code: u32 = if transaction.is_coinbase() {\n    ///     (block_height \u003c\u003c 1 ) | 1\n    /// } else {\n    ///     block_height \u003c\u003c 1\n    /// };\n    /// ```\n    pub header_code: u32,\n    /// The actual utxo\n    pub utxo: TxOut,\n}\n\nimpl LeafData {\n    pub fn _get_leaf_hashes(\u0026self) -\u003e sha256::Hash {\n        let mut ser_utxo = Vec::new();\n        let _ = self.utxo.consensus_encode(\u0026mut ser_utxo);\n        let leaf_hash = Sha512_256::new()\n            .chain_update(UTREEXO_TAG_V1)\n            .chain_update(UTREEXO_TAG_V1)\n            .chain_update(self.block_hash)\n            .chain_update(self.prevout.txid)\n            .chain_update(self.prevout.vout.to_le_bytes())\n            .chain_update(self.header_code.to_le_bytes())\n            .chain_update(ser_utxo)\n            .finalize();\n        sha256::Hash::from_slice(leaf_hash.as_slice())\n            .expect(\"parent_hash: Engines shouldn't be Err\")\n    }\n}\n\nimpl Decodable for LeafData {\n    fn consensus_decode\u003cR: Read + ?Sized\u003e(\n        reader: \u0026mut R,\n    ) -\u003e Result\u003cSelf, bitcoin::consensus::encode::Error\u003e {\n        Self::consensus_decode_from_finite_reader(reader)\n    }\n    fn consensus_decode_from_finite_reader\u003cR: Read + ?Sized\u003e(\n        reader: \u0026mut R,\n    ) -\u003e Result\u003cSelf, bitcoin::consensus::encode::Error\u003e {\n        let block_hash = BlockHash::consensus_decode(reader)?;\n        let prevout = OutPoint::consensus_decode(reader)?;\n        let header_code = u32::consensus_decode(reader)?;\n        let utxo = TxOut::consensus_decode(reader)?;\n        Ok(LeafData {\n            block_hash,\n            prevout,\n            header_code,\n            utxo,\n        })\n    }\n}\n\npub mod proof_util {\n    use bitcoin::blockdata::script::Instruction;\n    use bitcoin::hashes::sha256;\n    use bitcoin::hashes::Hash;\n    use bitcoin::p2p::utreexo::CompactLeafData;\n    use bitcoin::p2p::utreexo::UData;\n    use bitcoin::Amount;\n    use bitcoin::OutPoint;\n    use bitcoin::PubkeyHash;\n    use bitcoin::ScriptBuf;\n    use bitcoin::ScriptHash;\n    use bitcoin::Transaction;\n    use bitcoin::TxIn;\n    use bitcoin::TxOut;\n    use bitcoin::WPubkeyHash;\n    use bitcoin::WScriptHash;\n    use rustreexo::accumulator::node_hash::NodeHash;\n    use rustreexo::accumulator::proof::Proof;\n\n    use super::LeafData;\n    use crate::prelude::*;\n    use crate::pruned_utreexo::BlockchainInterface;\n\n    #[derive(Debug)]\n    pub enum Error {\n        EmptyStack,\n    }\n\n    pub fn reconstruct_leaf_data(\n        leaf: \u0026CompactLeafData,\n        input: \u0026TxIn,\n        block_hash: bitcoin::BlockHash,\n    ) -\u003e Result\u003cLeafData, Error\u003e {\n        let spk = reconstruct_script_pubkey(leaf, input)?;\n\n        Ok(LeafData {\n            block_hash,\n            header_code: leaf.header_code,\n            prevout: input.previous_output,\n            utxo: TxOut {\n                script_pubkey: spk,\n                value: Amount::from_sat(leaf.amount),\n            },\n        })\n    }\n\n    #[allow(clippy::type_complexity)]\n    pub fn process_proof\u003cChain: BlockchainInterface\u003e(\n        udata: \u0026UData,\n        transactions: \u0026[Transaction],\n        chain: \u0026Chain,\n    ) -\u003e Result\u003c(Proof, Vec\u003csha256::Hash\u003e, HashMap\u003cOutPoint, TxOut\u003e), Chain::Error\u003e {\n        let targets = udata.proof.targets.iter().map(|target| target.0).collect();\n        let hashes = udata\n            .proof\n            .hashes\n            .iter()\n            .map(|hash| NodeHash::Some(*hash.as_byte_array()))\n            .collect();\n        let proof = Proof::new(targets, hashes);\n        let mut hashes = Vec::new();\n        let mut leaves_iter = udata.leaves.iter().cloned();\n        let mut tx_iter = transactions.iter();\n\n        let mut inputs = HashMap::new();\n        tx_iter.next(); // Skip coinbase\n\n        for tx in tx_iter {\n            let txid = tx.txid();\n            for (vout, out) in tx.output.iter().enumerate() {\n                inputs.insert(\n                    OutPoint {\n                        txid,\n                        vout: vout as u32,\n                    },\n                    out.clone(),\n                );\n            }\n\n            for input in tx.input.iter() {\n                if !inputs.contains_key(\u0026input.previous_output) {\n                    if let Some(leaf) = leaves_iter.next() {\n                        let height = leaf.header_code \u003e\u003e 1;\n                        let hash = chain.get_block_hash(height)?;\n                        let leaf =\n                            reconstruct_leaf_data(\u0026leaf, input, hash).expect(\"Invalid proof\");\n                        hashes.push(leaf._get_leaf_hashes());\n                        inputs.insert(leaf.prevout, leaf.utxo);\n                    }\n                }\n            }\n        }\n\n        Ok((proof, hashes, inputs))\n    }\n\n    fn reconstruct_script_pubkey(leaf: \u0026CompactLeafData, input: \u0026TxIn) -\u003e Result\u003cScriptBuf, Error\u003e {\n        match \u0026leaf.spk_ty {\n            bitcoin::p2p::utreexo::ScriptPubkeyType::Other(spk) =\u003e {\n                Ok(ScriptBuf::from(spk.clone().into_vec()))\n            }\n            bitcoin::p2p::utreexo::ScriptPubkeyType::PubKeyHash =\u003e {\n                let pkhash = get_pk_hash(input)?;\n                Ok(ScriptBuf::new_p2pkh(\u0026pkhash))\n            }\n            bitcoin::p2p::utreexo::ScriptPubkeyType::WitnessV0PubKeyHash =\u003e {\n                let pk_hash = get_witness_pk_hash(input)?;\n                Ok(ScriptBuf::new_p2wpkh(\u0026pk_hash))\n            }\n            bitcoin::p2p::utreexo::ScriptPubkeyType::ScriptHash =\u003e {\n                let script_hash = get_script_hash(input)?;\n                Ok(ScriptBuf::new_p2sh(\u0026script_hash))\n            }\n            bitcoin::p2p::utreexo::ScriptPubkeyType::WitnessV0ScriptHash =\u003e {\n                let witness_program_hash = get_witness_script_hash(input)?;\n                Ok(ScriptBuf::new_p2wsh(\u0026witness_program_hash))\n            }\n        }\n    }\n    fn get_pk_hash(input: \u0026TxIn) -\u003e Result\u003cPubkeyHash, Error\u003e {\n        let script_sig = \u0026input.script_sig;\n        let inst = script_sig.instructions().last();\n        if let Some(Ok(bitcoin::blockdata::script::Instruction::PushBytes(bytes))) = inst {\n            return Ok(PubkeyHash::hash(bytes.as_bytes()));\n        }\n        Err(Error::EmptyStack)\n    }\n    fn get_script_hash(input: \u0026TxIn) -\u003e Result\u003cScriptHash, Error\u003e {\n        let script_sig = \u0026input.script_sig;\n        let inst = script_sig.instructions().last();\n        if let Some(Ok(Instruction::PushBytes(bytes))) = inst {\n            return Ok(ScriptBuf::from_bytes(bytes.as_bytes().to_vec()).script_hash());\n        }\n        Err(Error::EmptyStack)\n    }\n    fn get_witness_pk_hash(input: \u0026TxIn) -\u003e Result\u003cWPubkeyHash, Error\u003e {\n        let witness = \u0026input.witness;\n        let pk = witness.last();\n        if let Some(pk) = pk {\n            return Ok(WPubkeyHash::hash(pk));\n        }\n        Err(Error::EmptyStack)\n    }\n    fn get_witness_script_hash(input: \u0026TxIn) -\u003e Result\u003cWScriptHash, Error\u003e {\n        let witness = \u0026input.witness;\n        let script = witness.last();\n        if let Some(script) = script {\n            return Ok(WScriptHash::hash(script));\n        }\n        Err(Error::EmptyStack)\n    }\n}\n#[cfg(test)]\nmod test {\n    extern crate std;\n    use std::str::FromStr;\n    use std::vec::Vec;\n\n    use bitcoin::consensus::deserialize;\n    use bitcoin::hashes::hex::FromHex;\n    use bitcoin::p2p::utreexo::CompactLeafData;\n    use bitcoin::Amount;\n    use bitcoin::BlockHash;\n    use bitcoin::ScriptBuf;\n    use bitcoin::Transaction;\n\n    use super::proof_util::reconstruct_leaf_data;\n    use super::LeafData;\n    macro_rules! test_recover_spk {\n        (\n            $tx_hex:literal,\n            $height:literal,\n            $index:literal,\n            $amount:literal,\n            $block_hash:literal,\n            $spk_type:ident,\n            $expected_spk:literal\n        ) =\u003e {\n            let hex = Vec::from_hex($tx_hex).unwrap();\n            let s: Transaction = deserialize(\u0026hex).unwrap();\n            let leaf = CompactLeafData {\n                amount: Amount::from_btc($amount).unwrap().to_sat(),\n                header_code: $height,\n                spk_ty: bitcoin::p2p::utreexo::ScriptPubkeyType::$spk_type,\n            };\n            let spk = super::proof_util::reconstruct_leaf_data(\n                \u0026leaf,\n                \u0026s.input[0],\n                BlockHash::from_str($block_hash).unwrap(),\n            )\n            .unwrap();\n            assert_eq!(\n                spk.utxo.script_pubkey,\n                ScriptBuf::from_hex($expected_spk).unwrap()\n            )\n        };\n    }\n    #[test]\n    fn test_spk_recovery() {\n        // p2pkh\n        test_recover_spk!(\n            \"010000000114baa734ec1a75e84726af2da3abcd41fe9d96f3f8b7e99bcefdfc040cffc2ba030000006a47304402202f89e2deb17f0c2c5732d6f7791a2731703cb128dc86ae0bf288e55a3d7ce9d6022051c2242ca0885a4a2054391385eda03132616fb0c2daa61d6823eff7a21b5d0c01210395c223fbf96e49e5b9e06a236ca7ef95b10bf18c074bd91a5942fc40360d0b68fdffffff04b400000000000000536a4c5058325bc5b3f7d4e7acf388d63ab92d14d7f8f8bcdff384bddd4668f283df0bfe1c2f7728ec1e550ca841794fa28e16e154c5b92b5a1d1d98db4e89f15726bf75e352fe000bddf10068000bd72600012bc20000000000000017a914352481ec2fecfde0c5cdc635a383c4ac27b9f71e87c20000000000000017a9144890aae025c84cb72a9730b49ca12595d6f6088d8772aa0900000000001976a914bf2646b8ba8b4a143220528bde9c306dac44a01c88ac00000000\",\n            0,\n            777548,\n            0.03956721,\n            \"000000000000000000066caa76847c109010eb58402d7a5bf05cc201a011071d\",\n            PubKeyHash,\n            \"76a914bf2646b8ba8b4a143220528bde9c306dac44a01c88ac\"\n        );\n        // p2sh\n        test_recover_spk!(\n            \"0200000001ff1ba24eb11f1290b293b2c5520e4863ffedcc4a4ed9e4933334639ecbcc946500000000fc00473044022001460e6d06dc44e163ef1f692d275a1e357d086d0361fbe5012dbf18cbf2617202207f9e8fb54e776d7e98a6425da2be15e2ffca2e623b7617234226eafe77c70eaa01473044022076d756a250ad4044e2b4a0049112d87367b2f0ce80253e400f3ba09d620cbbdd022020f67b65f7cb5e109b8ccbc852e30b4e84b0b682136a5e72f679bd581b271ea8014c695221021c04b91bffe90c3e4defd021a4b6da4983b97e13c772bf15009f1661480658832102be11f7f0d9696ef731c13ed8b6e955df43cd4238d694a1698b02fcb3c2d275322102e0ad7274a4e93b3b30793ff7a04a31d2792ed22a563fe5ea0095af844c10c9c453aefdffffff02fd5403000000000017a914351bb17d072fff46336baec11a6a8d13ab6b590e87305837000000000017a9147b8d77369df3d2172b0d56792308d7f2635ca79087f1dd0b00\",\n            0,\n            777548,\n            0.03956721,\n            \"00000000000000000005a784e2b5006b34ff63644408df00bfc1a0b1b9507021\",\n            ScriptHash,\n            \"a914ed9371b30de550c0617cd0c4b2c0c0dc5e88c65487\"\n        );\n        //p2wpkh\n        test_recover_spk!(\n            \"01000000000101a742910d02da84259631288eab229ca2bdd39ed7edc8811ca125dc0bcf2b654c0100000000ffffffff02ba150a000000000016001406a9852b7c9f4ff9993b5d2192ac42a5df54828e34c812000000000016001486bdf86c7cbce4841f95b4d8ef101ce8a306e6ad0247304402202936300c12249c8696bb90addcc9482995429d7be0418260178ddc0c630c10ed02206128cac337841b171d15d9aadc2af77d280da7cd85c049149c8134ddb5adc8a10121038adb3497e025c0ff14521a789af4f10d526ec4c95348e708ebdc4d5ac58228e500000000\",\n            1,\n            777716,\n            0.01893642,\n            \"00000000000000000002264d1e3f90280ededd1587c7af932480dac3e2480048\",\n            WitnessV0PubKeyHash,\n            \"001406a9852b7c9f4ff9993b5d2192ac42a5df54828e\"\n        );\n        //p2wsh\n        test_recover_spk!(\n            \"01000000000101cacacdfdc79620cac8bc463cdac9864f557fdb73b6ef0dea8e0d74297d2e4c1a0100000000ffffffff0280841e000000000017a914cef5ab6252860ada719556abebe952c79c466f86878af74e0c00000000220020701a8d401c84fb13e6baf169d59684e17abd9fa216c8cc5b9fc63d622ff8c58d04004730440220289b2e0b6aec5a8f43d283edef0757206de77e3f3acdb322ade452a0468764db02201c332ec46a2ed3614fe392c4011063f39e77def57d89991ccbb99b6c7de2491901473044022044eaf71bdb4b3f0b0ba2f1eec82cad412729a1a4d5fc3b2fa251fecb73c56c0502201579c9e13b4d7595f9c6036a612828eac4796902c248131a7f25a117a0c68ca8016952210375e00eb72e29da82b89367947f29ef34afb75e8654f6ea368e0acdfd92976b7c2103a1b26313f430c4b15bb1fdce663207659d8cac749a0e53d70eff01874496feff2103c96d495bfdd5ba4145e3e046fee45e84a8a48ad05bd8dbb395c011a32cf9f88053ae00000000\",\n            0,\n            487740,\n            2.08551770,\n            \"0000000000000000004fce5d650f72e8f288e8c81b36377c3c7de3d2bc5b3118\",\n            WitnessV0ScriptHash,\n            \"0020701a8d401c84fb13e6baf169d59684e17abd9fa216c8cc5b9fc63d622ff8c58d\"\n        );\n        test_recover_spk!(\n            \"020000000001018f97e04dd76eec325c149ad417175f01f71b45523d8df79d2745cfee110eabf20000000000ffffffff015cddc71d000000002200204ae81572f06e1b88fd5ced7a1a000945432e83e1551e6f721ee9c00b8cc3326001015100000000\",\n            0,\n            27366,\n            4.99637721,\n            \"000000069585e4b2517a8862d527558ff18df7d4b8c2795b249c116aba9c6c98\",\n            WitnessV0ScriptHash,\n            \"00204ae81572f06e1b88fd5ced7a1a000945432e83e1551e6f721ee9c00b8cc33260\"\n        );\n    }\n    #[test]\n    fn test_reconstruct_leaf_data() {\n        let leaf = Vec::from_hex(\"f99e24b9e96a3c6220449b2bf520d6a9562237e2f4fc6f6b2ba57a71de000000e6f50efb6747f836ca3510df3da120fdb2ae4cf62893cc014e08c25dab70248b01000000cc000400b429653b4f0600001600142b91c8f80b071c5f60e1a512d49a6a544e51165b\").unwrap();\n        let leaf: LeafData = deserialize(\u0026leaf).unwrap();\n        let spending_tx = Vec::from_hex(\"02000000000101e6f50efb6747f836ca3510df3da120fdb2ae4cf62893cc014e08c25dab70248b0100000000feffffff02dbe6553b4f0600001600148d57f8da7fc15371dc14d35e97850ab564a17b1240420f0000000000220020ed59bf193c5197a5b1dbbbc723ddeca82cdfbb188218b3ede50150e1890fc55202473044022024979ec4bda473b71288b2c15390418d7d300551aa5e463cc6b64acd5c3070b50220444c94242aff2ba1bd966308d60f537524b0755931d545d98e1fc45239ff6b08012103de7c420624c009d6a5761871e78b39ff864887f885ed313e27f778b3772e74916a000200\").unwrap();\n        let spending_tx: Transaction = deserialize(\u0026spending_tx).unwrap();\n\n        let compact = CompactLeafData {\n            amount: Amount::from_btc(69373.68668596).unwrap().to_sat(),\n            header_code: 262348,\n            spk_ty: bitcoin::p2p::utreexo::ScriptPubkeyType::WitnessV0PubKeyHash,\n        };\n        let reconstructed = reconstruct_leaf_data(\n            \u0026compact,\n            \u0026spending_tx.input[0],\n            BlockHash::from_str(\"000000de717aa52b6b6ffcf4e2372256a9d620f52b9b4420623c6ae9b9249ef9\")\n                .unwrap(),\n        )\n        .unwrap();\n        assert_eq!(leaf, reconstructed);\n    }\n}\n","traces":[{"line":41,"address":[1378734,1377888,1378703],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[1377918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[1377963,1378020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[1378044,1378559,1378397,1378286,1378471,1378346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[1378238],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[1378298],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[1378358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[1378432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[1378501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[1378586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[1201776],"length":1,"stats":{"Line":1},"fn_name":"consensus_decode_from_finite_reader\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[1326841,1326208,1326820],"length":1,"stats":{"Line":1},"fn_name":"reconstruct_leaf_data"},{"line":113,"address":[1326489,1326240],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[1326624],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[1326389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[1326396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[1326568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[1326430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[1326464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[3330752,3333723,3336735,3336524,3333760,3333512],"length":1,"stats":{"Line":0},"fn_name":"process_proof\u003calloc::sync::Arc\u003cfloresta_chain::pruned_utreexo::chain_state::ChainState\u003cfloresta_chain::pruned_utreexo::chainstore::KvChainStore\u003e, alloc::alloc::Global\u003e\u003e"},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[3331584,3334592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[1326880],"length":1,"stats":{"Line":1},"fn_name":"reconstruct_script_pubkey"},{"line":177,"address":[1326922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[1326958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[1326970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[1327309,1327458,1327046],"length":1,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[1327389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[1327105,1327475,1327639],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[1327567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[1327170,1327820,1327656],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[1327748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[1327235,1326906,1328037,1327837],"length":1,"stats":{"Line":3},"fn_name":null},{"line":195,"address":[1327965],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[1328064],"length":1,"stats":{"Line":1},"fn_name":"get_pk_hash"},{"line":200,"address":[1328099],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[1328107],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[1328196,1328142],"length":1,"stats":{"Line":2},"fn_name":null},{"line":203,"address":[1328248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[1328191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[1328320,1328732],"length":1,"stats":{"Line":1},"fn_name":"get_script_hash"},{"line":208,"address":[1328358],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[1328366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[1328401,1328458],"length":1,"stats":{"Line":2},"fn_name":null},{"line":211,"address":[1328510],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[1328450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[1328768],"length":1,"stats":{"Line":1},"fn_name":"get_witness_pk_hash"},{"line":216,"address":[1328800],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[1328809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[1328828],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[1328874],"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[1328925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[1328944],"length":1,"stats":{"Line":1},"fn_name":"get_witness_script_hash"},{"line":224,"address":[1328974],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[1328983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[1329002],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[1329048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[1329110],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":44,"coverable":95},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-cli","src","lib.rs"],"content":"// SPDX license specifier: MIT\n\n//! # floresta-cli - A command line interface for florestad\n//!\n//! Florestad is a lightweight Bitcoin full node, built with libfloresta. It gives\n//! you complete control over your Bitcoin node with a simple json-rpc interface that\n//! may be used either from command line or programmatically. This crate provides a\n//! ready-to-use library for interacting with florestad's json-rpc interface in your rust\n//! application.\n\n#[cfg(feature = \"with-reqwest\")]\npub mod reqwest_client;\n\npub mod rpc;\npub mod rpc_types;\n\n// Those tests doesn't work on windowns\n// TODO (Davidson): work on windows?\n\n#[cfg(all(test, not(target_os = \"windows\")))]\nmod tests {\n    use std::fs;\n    use std::process::Child;\n    use std::process::Command;\n    use std::process::Stdio;\n    use std::str::FromStr;\n    use std::thread::sleep;\n    use std::time::Duration;\n\n    use bitcoin::BlockHash;\n    use bitcoin::Txid;\n\n    use crate::reqwest_client::ReqwestClient;\n    use crate::rpc::FlorestaRPC;\n\n    struct Florestad {\n        proc: Child,\n    }\n\n    impl Drop for Florestad {\n        fn drop(\u0026mut self) {\n            self.proc.kill().unwrap();\n        }\n    }\n\n    /// A helper function for tests.\n    ///\n    /// This function will start a florestad process and return a client that can be used to\n    /// interact with it through RPC. It also returns a handle to the process itself, so that\n    /// you can poke at the stdin and out for this process. You don't have to kill it though,\n    /// once the handle goes out of scope, the process will be killed.\n    ///\n    /// The process created by this method will run in a random datadir and use random ports\n    /// for both RPC and Electrum. The datadir will be in the current dir, under a `tmp` subdir.\n    /// If you're at $HOME/floresta it will run on $HOME/floresta/tmp/\u003crandom_name\u003e/\n    fn start_florestad() -\u003e (Florestad, ReqwestClient) {\n        let here = env!(\"PWD\");\n        let port = rand::random::\u003cu16\u003e() % 1000 + 18443;\n\n        // makes a temporary directory\n        let test_code = rand::random::\u003cu64\u003e();\n        let dirname = format!(\"{here}/tmp/floresta.{test_code}\");\n        fs::DirBuilder::new()\n            .recursive(true)\n            .create(dirname.clone())\n            .unwrap();\n\n        let fld = Command::new(format!(\"{here}/target/debug/florestad\"))\n            .args([\"-n\", \"regtest\"])\n            .args([\"run\"])\n            .args([\"--data-dir\", \u0026dirname])\n            .args([\"--rpc-address\", \u0026format!(\"127.0.0.1:{}\", port)])\n            .args([\"--electrum-address\", \u0026format!(\"127.0.0.1:{}\", port + 1)])\n            .stdout(Stdio::null())\n            .stderr(Stdio::null())\n            .spawn()\n            .unwrap();\n\n        let client = ReqwestClient::new(format!(\"http://127.0.0.1:{port}\"));\n\n        let mut retries = 10;\n\n        loop {\n            sleep(Duration::from_secs(1));\n            retries -= 1;\n            if retries == 0 {\n                panic!(\"florestad didn't start {:?}\", fld.stdout);\n            }\n            match client.get_blockchain_info() {\n                Ok(_) =\u003e break,\n                Err(_) =\u003e continue,\n            }\n        }\n\n        (Florestad { proc: fld }, client)\n    }\n\n    #[test]\n    #[ignore = \"tarpaulin\"]\n    fn test_rescan() {\n        let (_proc, client) = start_florestad();\n\n        let rescan = client.rescan(0).expect(\"rpc not working\");\n        assert!(rescan);\n    }\n\n    #[test]\n    #[ignore = \"tarpaulin\"]\n    fn test_stop() {\n        let (mut _proc, client) = start_florestad();\n\n        let stop = client.stop().expect(\"rpc not working\");\n        assert!(stop);\n    }\n\n    #[test]\n    #[ignore = \"tarpaulin\"]\n    fn test_get_blockchaininfo() {\n        let (_proc, client) = start_florestad();\n\n        let gbi = client.get_blockchain_info().expect(\"rpc not working\");\n\n        assert_eq!(gbi.height, 0);\n        assert_eq!(gbi.chain, \"regtest\".to_owned());\n        assert!(gbi.ibd);\n        assert_eq!(gbi.leaf_count, 0);\n        assert_eq!(gbi.root_hashes, Vec::\u003cString\u003e::new());\n    }\n\n    #[test]\n    #[ignore = \"tarpaulin\"]\n    fn test_get_roots() {\n        let (_proc, client) = start_florestad();\n\n        let gbi = client.get_blockchain_info().expect(\"rpc not working\");\n\n        assert_eq!(gbi.root_hashes, Vec::\u003cString\u003e::new());\n    }\n\n    #[test]\n    #[ignore = \"tarpaulin\"]\n    fn test_get_block() {\n        let (_proc, client) = start_florestad();\n\n        let block_hash: BlockHash =\n            \"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\"\n                .parse()\n                .unwrap();\n        let block = client.get_block(block_hash).unwrap();\n\n        assert_eq!(\n            block.hash,\n            \"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\".to_owned()\n        );\n    }\n\n    #[test]\n    #[ignore = \"tarpaulin\"]\n    fn test_get_block_hash() {\n        let (_proc, client) = start_florestad();\n\n        let blockhash = client.get_block_hash(0).expect(\"rpc not working\");\n\n        assert_eq!(\n            blockhash,\n            \"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\"\n                .parse()\n                .unwrap()\n        );\n    }\n\n    #[test]\n    #[ignore = \"tarpaulin\"]\n    fn test_get_block_header() {\n        let (_proc, client) = start_florestad();\n\n        let blockhash = client.get_block_hash(0).expect(\"rpc not working\");\n        let block_header = client.get_block_header(blockhash).expect(\"rpc not working\");\n\n        assert_eq!(block_header.block_hash(), blockhash);\n    }\n\n    #[test]\n    #[ignore = \"tarpaulin\"]\n    fn test_get_block_filter() {\n        let (_proc, client) = start_florestad();\n\n        let block_filter = client.get_block_filter(0);\n\n        // this should err, because there is no filter for genesis block\n        assert!(block_filter.is_err());\n    }\n\n    #[test]\n    #[ignore = \"tarpaulin\"]\n    fn test_load_descriptor() {\n        let (_proc, client) = start_florestad();\n\n        let desc = \"\n            wsh(sortedmulti(1,[54ff5a12/48h/1h/0h/2h]tpubDDw6pwZA3hYxcSN32q7a5ynsKmWr4BbkBNHydHPKkM4BZwUfiK7tQ26h7USm8kA1E2FvCy7f7Er7QXKF8RNptATywydARtzgrxuPDwyYv4x/\u003c0;1\u003e/*,[bcf969c0/48h/1h/0h/2h]tpubDEFdgZdCPgQBTNtGj4h6AehK79Jm4LH54JrYBJjAtHMLEAth7LuY87awx9ZMiCURFzFWhxToRJK6xp39aqeJWrG5nuW3eBnXeMJcvDeDxfp/\u003c0;1\u003e/*))#fuw35j0q\";\n\n        let res = client.load_descriptor(desc.to_string(), Some(0)).unwrap();\n\n        assert!(res)\n    }\n\n    #[test]\n    #[ignore = \"tarpaulin\"]\n    fn test_get_height() {\n        let (_proc, client) = start_florestad();\n\n        let height = client.get_height().unwrap();\n        assert_eq!(height, 0);\n    }\n\n    #[test]\n    #[ignore = \"tarpaulin\"]\n    fn test_send_raw_transaction() {\n        let (_proc, client) = start_florestad();\n\n        let tx = \"01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000\".to_string();\n\n        let res = client.send_raw_transaction(tx).unwrap();\n        assert_eq!(\n            res,\n            Txid::from_str(\"4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\")\n                .unwrap()\n        );\n    }\n}\n","traces":[{"line":41,"address":[1516848],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":42,"address":[1516853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[1594208,1597397],"length":1,"stats":{"Line":0},"fn_name":"start_florestad"},{"line":57,"address":[1594231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[1594633,1594285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[1594339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[1594478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[1594608,1594721,1594810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[1594767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[1596207,1595249,1596163,1595147,1596255,1595740,1594942,1595370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[1595077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[1595214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[1595272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[1595689,1595480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[1595873,1596112,1595755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[1596175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[1596223],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[1596591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[1596724],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[1596740,1596805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[1596859,1596816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[1596847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[1596892,1597000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[1596983,1597084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[1597142],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":25},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-cli","src","main.rs"],"content":"use std::fmt::Debug;\n\nuse anyhow::Ok;\nuse bitcoin::BlockHash;\nuse bitcoin::Network;\nuse bitcoin::Txid;\nuse clap::Parser;\nuse clap::Subcommand;\nuse floresta_cli::reqwest_client::ReqwestClient;\nuse floresta_cli::rpc::FlorestaRPC;\n\nmod reqwest_client;\nmod rpc;\nmod rpc_types;\n\nfn main() -\u003e anyhow::Result\u003c()\u003e {\n    let cli = Cli::parse();\n\n    let client = ReqwestClient::new(get_host(\u0026cli));\n    let res = do_request(\u0026cli, client)?;\n\n    println!(\"{}\", res);\n\n    anyhow::Ok(())\n}\n\nfn get_host(cmd: \u0026Cli) -\u003e String {\n    if let Some(host) = cmd.rpc_host.clone() {\n        return host;\n    }\n\n    match cmd.network {\n        Network::Bitcoin =\u003e \"http://127.0.0.1:8332\".into(),\n        Network::Testnet =\u003e \"http://127.0.0.1:18332\".into(),\n        Network::Signet =\u003e \"http://127.0.0.1:38332\".into(),\n        Network::Regtest =\u003e \"http://127.0.0.1:18442\".into(),\n        _ =\u003e \"http://127.0.0.1:8332\".into(),\n    }\n}\n\nfn do_request(cmd: \u0026Cli, client: ReqwestClient) -\u003e anyhow::Result\u003cString\u003e {\n    Ok(match cmd.methods.clone() {\n        Methods::GetBlockchainInfo =\u003e serde_json::to_string_pretty(\u0026client.get_blockchain_info()?)?,\n        Methods::GetBlockHash { height } =\u003e {\n            serde_json::to_string_pretty(\u0026client.get_block_hash(height)?)?\n        }\n        Methods::GetTxOut { txid, vout } =\u003e {\n            serde_json::to_string_pretty(\u0026client.get_tx_out(txid, vout)?)?\n        }\n        Methods::GetTxProof { txids, .. } =\u003e {\n            serde_json::to_string_pretty(\u0026client.get_tx_proof(txids)?)?\n        }\n        Methods::GetRawTransaction { txid, .. } =\u003e {\n            serde_json::to_string_pretty(\u0026client.get_transaction(txid, Some(true))?)?\n        }\n        Methods::RescanBlockchain { start_height } =\u003e {\n            serde_json::to_string_pretty(\u0026client.rescan(start_height)?)?\n        }\n        Methods::SendRawTransaction { tx } =\u003e {\n            serde_json::to_string_pretty(\u0026client.send_raw_transaction(tx)?)?\n        }\n        Methods::GetBlockHeader { hash } =\u003e {\n            serde_json::to_string_pretty(\u0026client.get_block_header(hash)?)?\n        }\n        Methods::LoadDescriptor { desc, rescan } =\u003e {\n            serde_json::to_string_pretty(\u0026client.load_descriptor(desc, rescan)?)?\n        }\n        Methods::GetRoots =\u003e serde_json::to_string_pretty(\u0026client.get_roots()?)?,\n        Methods::GetBlock { hash, .. } =\u003e serde_json::to_string_pretty(\u0026client.get_block(hash)?)?,\n        Methods::GetPeerInfo =\u003e serde_json::to_string_pretty(\u0026client.get_peer_info()?)?,\n        Methods::Stop =\u003e serde_json::to_string_pretty(\u0026client.stop()?)?,\n        Methods::AddNode { node } =\u003e serde_json::to_string_pretty(\u0026client.add_node(node)?)?,\n        Methods::GetFilters { height } =\u003e {\n            serde_json::to_string_pretty(\u0026client.get_block_filter(height)?)?\n        }\n    })\n}\n\n#[derive(Debug, Parser)]\n#[command(author = \"Davidson Souza\", version = \"0.1.0\", about = r#\"\n    A simple command line interface to the Floresta JSON RPC interface.\n\"#, long_about = None)]\npub struct Cli {\n    /// Sets a custom config file\n    #[arg(short, long, value_name = \"FILE\")]\n    pub config_file: Option\u003cString\u003e,\n    /// Which network should we use\n    #[arg(short, long, default_value_t=Network::Bitcoin)]\n    pub network: Network,\n    /// Turn debugging information on\n    #[arg(short, long, action = clap::ArgAction::Count)]\n    pub debug: u8,\n    /// The RPC host to connect to\n    #[arg(short = 'H', long, value_name = \"URL\")]\n    pub rpc_host: Option\u003cString\u003e,\n    /// The RPC username to use\n    #[arg(short = 'u', long, value_name = \"USERNAME\")]\n    pub rpc_user: Option\u003cString\u003e,\n    /// The RPC password to use\n    #[arg(short = 'P', long, value_name = \"PASSWORD\")]\n    pub rpc_password: Option\u003cString\u003e,\n    /// An actual RPC command to run\n    #[command(subcommand)]\n    pub methods: Methods,\n}\n\n#[derive(Debug, Clone, Subcommand)]\npub enum Methods {\n    /// Returns information about the current state of the blockchain\n    #[command(name = \"getblockchaininfo\")]\n    GetBlockchainInfo,\n    /// Returns the hash of the block associated with height\n    #[command(name = \"getblockhash\")]\n    GetBlockHash { height: u32 },\n    /// Returns the proof that one or more transactions were included in a block\n    #[command(name = \"gettxproof\")]\n    GetTxProof {\n        txids: Txid,\n        blockhash: Option\u003cBlockHash\u003e,\n    },\n    /// Returns the raw transaction, assuming it is cached by our watch only wallet\n    #[command(name = \"getrawtransaction\")]\n    GetRawTransaction { txid: Txid, verbose: Option\u003cbool\u003e },\n    /// Ask the node to rescan the blockchain for transactions\n    #[command(name = \"rescan\")]\n    RescanBlockchain { start_height: u32 },\n    /// Submits a raw transaction to the network\n    #[command(name = \"sendrawtransaction\")]\n    SendRawTransaction { tx: String },\n    /// Returns the block header for the given block hash\n    #[command(name = \"getblockheader\")]\n    GetBlockHeader { hash: BlockHash },\n    /// Loads a new descriptor to the watch only wallet\n    #[command(name = \"loaddescriptor\")]\n    LoadDescriptor { desc: String, rescan: Option\u003cu32\u003e },\n    /// Returns the roots of the current utreexo forest\n    #[command(name = \"getroots\")]\n    GetRoots,\n    /// Returns a block\n    #[command(name = \"getblock\")]\n    GetBlock { hash: BlockHash, verbosity: u32 },\n    /// Returns information about the peers we are connected to\n    #[command(name = \"getpeerinfo\")]\n    GetPeerInfo,\n    /// Returns the value associated with a UTXO, if it's still not spent.\n    /// This function only works properly if we have the compact block filters\n    /// feature enabled\n    #[command(name = \"gettxout\")]\n    GetTxOut { txid: Txid, vout: u32 },\n    /// Stops the node\n    #[command(name = \"stop\")]\n    Stop,\n    /// Connects with a peer, given its address and port\n    /// Usage: addnode \u003cip:[port]\u003e\n    #[command(name = \"addnode\")]\n    AddNode { node: String },\n    /// Returns the filters for a given block\n    #[command(name = \"getfilter\")]\n    GetFilters { height: u32 },\n}\n","traces":[{"line":16,"address":[1990881,1990914,1990224],"length":1,"stats":{"Line":0},"fn_name":"main"},{"line":17,"address":[1990241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[1990259,1990303],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[1990330,1990897,1990649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[1990741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[1990817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[1990944],"length":1,"stats":{"Line":0},"fn_name":"get_host"},{"line":28,"address":[1990968],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[1991044],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[1991091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[1991139],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[1991164],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[1991189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[1991214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[1991132],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[1991248,1992784,1998440],"length":1,"stats":{"Line":0},"fn_name":"do_request"},{"line":42,"address":[1991293,1992739,1991353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[1992332,1992749,1992795,1991402],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[1991417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[1993136,1992813,1991439],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[1992089],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[1997290,1992135,1996890,1997238,1997117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[1991454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[1993606,1991486,1993192,1993433,1993554],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[1991549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[1991581,1993975,1993627,1993854,1994027],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[1991660],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[1994335,1994048,1991682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[1991697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[1994391,1991745,1994714],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[1991760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[1991792,1994770,1995188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[1991855],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[1991933,1995244,1995531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[1991956,1995587],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[1991971,1996022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[1992074,1996467],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[1992206,1997311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[1992221,1997654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[1992284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[1998435,1998238,1992306,1998359,1997997],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":41},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-cli","src","reqwest_client.rs"],"content":"use std::fmt::Debug;\n\nuse serde::Deserialize;\nuse serde_json::json;\n\nuse crate::rpc::JsonRPCClient;\n\n#[derive(Debug, Default, Clone)]\npub struct ReqwestClient {\n    client: reqwest::blocking::Client,\n    url: String,\n    auth: Option\u003c(String, String)\u003e,\n}\n\npub struct ReqwestConfig {\n    pub url: String,\n    pub proxy: Option\u003creqwest::Proxy\u003e,\n    pub auth: Option\u003c(String, String)\u003e,\n    pub timeout: Option\u003cstd::time::Duration\u003e,\n    pub headers: Option\u003creqwest::header::HeaderMap\u003e,\n}\n\nimpl ReqwestClient {\n    pub fn new(url: String) -\u003e Self {\n        Self {\n            url,\n            ..Default::default()\n        }\n    }\n\n    pub fn new_with_config(config: ReqwestConfig) -\u003e Self {\n        let mut client_builder = reqwest::blocking::Client::builder();\n\n        if let Some(proxy) = config.proxy {\n            client_builder = client_builder.proxy(proxy);\n        }\n\n        if let Some(timeout) = config.timeout {\n            client_builder = client_builder.timeout(timeout);\n        }\n\n        if let Some(headers) = config.headers {\n            client_builder = client_builder.default_headers(headers);\n        }\n\n        let client = client_builder.build().unwrap();\n        Self {\n            url: config.url,\n            auth: config.auth,\n            client,\n        }\n    }\n\n    pub fn rpc_call\u003cResponse\u003e(\n        \u0026self,\n        method: \u0026str,\n        params: \u0026[serde_json::Value],\n    ) -\u003e Result\u003cResponse, crate::rpc_types::Error\u003e\n    where\n        Response: for\u003c'a\u003e serde::de::Deserialize\u003c'a\u003e + Debug,\n    {\n        let mut req = self\n            .client\n            .post(\u0026self.url)\n            .body(\n                json!({\n                    \"jsonrpc\": \"2.0\",\n                    \"id\": 0,\n                    \"method\": method,\n                    \"params\": params,\n                })\n                .to_string(),\n            )\n            .header(\"Content-Type\", \"application/json\");\n\n        if let Some((user, pass)) = \u0026self.auth {\n            req = req.basic_auth(user, Some(pass));\n        }\n\n        let resp = req.send()?;\n        let resp = serde_json::from_str::\u003cJsonRpcResponse\u003cResponse\u003e\u003e(\u0026resp.text()?)?;\n        match resp.result {\n            Some(resp) =\u003e Ok(resp),\n            None if resp.error.is_some() =\u003e Err(crate::rpc_types::Error::Api(resp.error.unwrap())),\n            None =\u003e Err(crate::rpc_types::Error::EmtpyResponse),\n        }\n    }\n}\n\nimpl JsonRPCClient for ReqwestClient {\n    fn call\u003cT: for\u003c'a\u003e serde::de::Deserialize\u003c'a\u003e + Debug\u003e(\n        \u0026self,\n        method: \u0026str,\n        params: \u0026[serde_json::Value],\n    ) -\u003e Result\u003cT, crate::rpc_types::Error\u003e {\n        self.rpc_call(method, params)\n    }\n}\n\n#[derive(Debug, Deserialize)]\npub struct JsonRpcResponse\u003cRes\u003e {\n    pub jsonrpc: String,\n    pub id: u64,\n    pub result: Option\u003cRes\u003e,\n    pub error: Option\u003cserde_json::Value\u003e,\n}\n","traces":[{"line":24,"address":[1723776,1723966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[1725138,1724000,1725107],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[1724022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[1724123,1724313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[1724290,1724222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[1724320,1724258,1724476],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[1724453,1724387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[2496513,2496235,2496291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[1792294,1792204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[1792319,1792268],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[1792354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[1792399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[1715820,1729536,1726160,1729680,1719122,1736528,1722816,1719312,1733056,1736218,1722659,1722473,1739756,1719456,1726005,1732894,1715663,1736375,1725823,1739587,1729374,1712624,1733200,1715968],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[1712704,1717205,1727444,1720702,1730964,1727397,1736608,1734446,1716048,1733286,1729760,1737812,1734493,1724062,1722985,1713908,1722902,1717252,1726323,1716131,1726240,1713861,1720749,1737765,1719625,1719542,1724109,1729843,1730917,1733369,1712787,1736691],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[1719621,1726319,1716127,1729839,1722981,1733365,1712783,1736687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[1726403,1712867,1729592,1712816,1733398,1716211,1729923,1736771,1723014,1715876,1723065,1719654,1722715,1716160,1726061,1729872,1733112,1736720,1733449,1719368,1739812,1719705,1736431,1726352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[1731373,1714317,1724518,1734902,1727609,1737977,1731129,1724274,1738221,1727853,1714073,1717661,1717417,1721158,1734658,1720914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[1724484,1734868,1717471,1731183,1720968,1727819,1714283,1724328,1714127,1738031,1717627,1734712,1721124,1738187,1731339,1727663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[1714216,1733054,1724723,1727871,1734801,1714522,1721176,1721363,1717560,1714335,1722657,1729534,1717866,1735107,1738120,1717679,1731578,1724417,1726003,1727752,1731272,1719310,1721057,1731391,1738239,1724536,1734920,1736373,1738426,1715818,1728058,1739754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[1725958,1717956,1735055,1722575,1731526,1731668,1732972,1721453,1729489,1714612,1715736,1721311,1739709,1719228,1722612,1724671,1738374,1728148,1736328,1719265,1738516,1728006,1729452,1715773,1725921,1733009,1724813,1735197,1736291,1739672,1717814,1714470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[1739077,1718549,1728773,1732293,1725280,1735664,1715173,1721920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[1725324,1721968,1718602,1739126,1715210,1735696,1732338,1728818],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[1735957,1739171,1735685,1729022,1725305,1732639,1728950,1739336,1735785,1715315,1739110,1725465,1715186,1722038,1735860,1728799,1722211,1732470,1718774,1718586,1715247,1718706,1739239,1721957,1729119,1725390,1732319,1715412,1732542,1722114,1725562,1718871],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[1728961,1735796,1732481,1725401,1715258,1718717,1722049,1739182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[1740352,1740224,1740032,1740160,1740096,1739904,1740288,1739968],"length":1,"stats":{"Line":0},"fn_name":"call\u003cfloresta_cli::rpc_types::GetBlockchainInfoRes\u003e"},{"line":96,"address":[1740261,1740069,1740389,1740133,1740325,1740197,1740005,1739941],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":32},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-cli","src","rpc.rs"],"content":"use std::fmt::Debug;\n\nuse bitcoin::block::Header as BlockHeader;\nuse bitcoin::BlockHash;\nuse bitcoin::Txid;\nuse serde_json::Number;\nuse serde_json::Value;\n\nuse crate::rpc_types;\nuse crate::rpc_types::*;\n\ntype Result\u003cT\u003e = std::result::Result\u003cT, rpc_types::Error\u003e;\n\n/// A trait specifying all possible methods for floresta's json-rpc\npub trait FlorestaRPC {\n    /// Get the BIP158 filter for a given block height\n    ///\n    /// BIP158 filters are a compact representation of the set of transactions in a block,\n    /// designed for efficient light client synchronization. This method returns the filter\n    /// for a given block height, encoded as a hexadecimal string.\n    /// You need to have enabled block filters by setting the `blockfilters=1` option\n    fn get_block_filter(\u0026self, heigth: u32) -\u003e Result\u003cString\u003e;\n    /// Returns general information about the chain we are on\n    ///\n    /// This method returns a bunch of information about the chain we are on, including\n    /// the current height, the best block hash, the difficulty, and whether we are\n    /// currently in IBD (Initial Block Download) mode.\n    fn get_blockchain_info(\u0026self) -\u003e Result\u003cGetBlockchainInfoRes\u003e;\n    /// Returns the hash of the block at the given height\n    ///\n    /// This method returns the hash of the block at the given height. If the height is\n    /// invalid, an error is returned.\n    fn get_block_hash(\u0026self, height: u32) -\u003e Result\u003cBlockHash\u003e;\n    /// Returns the block header for the given block hash\n    ///\n    /// This method returns the block header for the given block hash, as defined\n    /// in the Bitcoin protocol specification. A header contains the block's version,\n    /// the previous block hash, the merkle root, the timestamp, the difficulty target,\n    /// and the nonce.\n    fn get_block_header(\u0026self, hash: BlockHash) -\u003e Result\u003cBlockHeader\u003e;\n    /// Gets a transaction from the blockchain\n    ///\n    /// This method returns a transaction that's cached in our wallet. If the verbosity flag is\n    /// set to false, the transaction is returned as a hexadecimal string. If the verbosity\n    /// flag is set to true, the transaction is returned as a json object.\n    fn get_transaction(\u0026self, tx_id: Txid, verbosity: Option\u003cbool\u003e) -\u003e Result\u003cValue\u003e;\n    /// Returns the proof that one or more transactions were included in a block\n    ///\n    /// This method returns the Merkle proof, showing that a transaction was included in a block.\n    /// The pooof is returned as a vector hexadecimal string.\n    fn get_tx_proof(\u0026self, tx_id: Txid) -\u003e Result\u003cVec\u003cString\u003e\u003e;\n    /// Loads up a descriptor into the wallet\n    ///\n    /// This method loads up a descriptor into the wallet. If the rescan option is not None,\n    /// the wallet will be rescanned for transactions matching the descriptor. If you have\n    /// compact block filters enabled, this process will be much faster and use less bandwidth.\n    /// The rescan parameter is the height at which to start the rescan, and should be at least\n    /// as old as the oldest transaction this descriptor could have been used in.\n    fn load_descriptor(\u0026self, descriptor: String, rescan: Option\u003cu32\u003e) -\u003e Result\u003cbool\u003e;\n    /// Trigger a rescan of the wallet\n    ///\n    /// This method triggers a rescan of the wallet. If you have compact block filters enabled,\n    /// this process will be much faster and use less bandwidth. If you don't have compact block\n    /// filters, we'll need to download the entire blockchain again, which will take a while.\n    /// The rescan parameter is the height at which to start the rescan, and should be at least\n    /// as old as the oldest transaction this descriptor could have been used in.\n    fn rescan(\u0026self, rescan: u32) -\u003e Result\u003cbool\u003e;\n    /// Returns the current height of the blockchain\n    fn get_height(\u0026self) -\u003e Result\u003cu32\u003e;\n    /// Sends a hex-encoded transaction to the network\n    ///\n    /// This method sends a transaction to the network. The transaction should be encoded as a\n    /// hexadecimal string. If the transaction is valid, it will be broadcast to the network, and\n    /// return the transaction id. If the transaction is invalid, an error will be returned.\n    fn send_raw_transaction(\u0026self, tx: String) -\u003e Result\u003cTxid\u003e;\n    /// Gets the current accumulator for the chain we're on\n    ///\n    /// This method returns the current accumulator for the chain we're on. The accumulator is\n    /// a set of roots, that let's us prove that a UTXO exists in the chain. This method returns\n    /// a vector of hexadecimal strings, each of which is a root in the accumulator.\n    fn get_roots(\u0026self) -\u003e Result\u003cVec\u003cString\u003e\u003e;\n    /// Gets information about the peers we're connected with\n    ///\n    /// This method returns information about the peers we're connected with. This includes\n    /// the peer's IP address, the peer's version, the peer's user agent, and the peer's\n    /// current height.\n    fn get_peer_info(\u0026self) -\u003e Result\u003cVec\u003cPeerInfo\u003e\u003e;\n    /// Returns a block, given a block hash\n    ///\n    /// This method returns a block, given a block hash. If the verbosity flag is 0, the block\n    /// is returned as a hexadecimal string. If the verbosity flag is 1, the block is returned\n    /// as a json object.\n    fn get_block(\u0026self, hash: BlockHash) -\u003e Result\u003cGetBlockRes\u003e;\n    /// Finds an specific utxo in the chain\n    ///\n    /// You can use this to look for a utxo. If it exists, it will return the amount and\n    /// scriptPubKey of this utxo. It returns an empty object if the utxo doesn't exist.\n    /// You must have enabled block filters by setting the `blockfilters=1` option.\n    fn get_tx_out(\u0026self, tx_id: Txid, outpoint: u32) -\u003e Result\u003cValue\u003e;\n    /// Stops the florestad process\n    ///\n    /// This can be used to gracefully stop the florestad process.\n    fn stop(\u0026self) -\u003e Result\u003cbool\u003e;\n    /// Tells florestad to connect with a peer\n    ///\n    /// You can use this to connect with a given node, providing it's IP address and port.\n    fn add_node(\u0026self, node: String) -\u003e Result\u003cbool\u003e;\n}\n\n/// Since the workflow for jsonrpc is the same for all methods, we can implement a trait\n/// that will let us call any method on the client, and then implement the methods on any\n/// client that implements this trait.\npub trait JsonRPCClient: Sized {\n    /// Calls a method on the client\n    ///\n    /// This should call the appropriated rpc method and return a parsed response or error.\n    fn call\u003cT\u003e(\u0026self, method: \u0026str, params: \u0026[Value]) -\u003e Result\u003cT\u003e\n    where\n        T: for\u003c'a\u003e serde::de::Deserialize\u003c'a\u003e + serde::de::DeserializeOwned + Debug;\n}\n\nimpl\u003cT: JsonRPCClient\u003e FlorestaRPC for T {\n    fn add_node(\u0026self, node: String) -\u003e Result\u003cbool\u003e {\n        self.call(\"addnode\", \u0026[Value::String(node)])\n    }\n\n    fn stop(\u0026self) -\u003e Result\u003cbool\u003e {\n        self.call(\"stop\", \u0026[])\n    }\n\n    fn rescan(\u0026self, rescan: u32) -\u003e Result\u003cbool\u003e {\n        self.call(\"rescan\", \u0026[Value::Number(Number::from(rescan))])\n    }\n\n    fn get_roots(\u0026self) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        self.call(\"getroots\", \u0026[])\n    }\n\n    fn get_block(\u0026self, hash: BlockHash) -\u003e Result\u003cGetBlockRes\u003e {\n        let verbosity = 1; // Return the block in json format\n        self.call(\n            \"getblock\",\n            \u0026[\n                Value::String(hash.to_string()),\n                Value::Number(Number::from(verbosity)),\n            ],\n        )\n    }\n\n    fn get_height(\u0026self) -\u003e Result\u003cu32\u003e {\n        self.call(\"getheight\", \u0026[])\n    }\n\n    fn get_tx_out(\u0026self, tx_id: Txid, outpoint: u32) -\u003e Result\u003cValue\u003e {\n        self.call(\n            \"gettxout\",\n            \u0026[\n                Value::String(tx_id.to_string()),\n                Value::Number(Number::from(outpoint)),\n            ],\n        )\n    }\n\n    fn get_tx_proof(\u0026self, tx_id: Txid) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        self.call(\"gettxoutproof\", \u0026[Value::String(tx_id.to_string())])\n    }\n\n    fn get_peer_info(\u0026self) -\u003e Result\u003cVec\u003cPeerInfo\u003e\u003e {\n        self.call(\"getpeerinfo\", \u0026[])\n    }\n\n    fn get_block_hash(\u0026self, height: u32) -\u003e Result\u003cBlockHash\u003e {\n        self.call(\"getblockhash\", \u0026[Value::Number(Number::from(height))])\n    }\n\n    fn get_transaction(\u0026self, tx_id: Txid, verbosity: Option\u003cbool\u003e) -\u003e Result\u003cValue\u003e {\n        let verbosity = verbosity.unwrap_or(false);\n        self.call(\n            \"getrawtransaction\",\n            \u0026[Value::String(tx_id.to_string()), Value::Bool(verbosity)],\n        )\n    }\n\n    fn load_descriptor(\u0026self, descriptor: String, rescan: Option\u003cu32\u003e) -\u003e Result\u003cbool\u003e {\n        let rescan = rescan.unwrap_or(0);\n        self.call(\n            \"loaddescriptor\",\n            \u0026[\n                Value::String(descriptor),\n                Value::Number(Number::from(rescan)),\n            ],\n        )\n    }\n\n    fn get_block_filter(\u0026self, heigth: u32) -\u003e Result\u003cString\u003e {\n        self.call(\"getblockfilter\", \u0026[Value::Number(Number::from(heigth))])\n    }\n\n    fn get_block_header(\u0026self, hash: BlockHash) -\u003e Result\u003cBlockHeader\u003e {\n        self.call(\"getblockheader\", \u0026[Value::String(hash.to_string())])\n    }\n\n    fn get_blockchain_info(\u0026self) -\u003e Result\u003cGetBlockchainInfoRes\u003e {\n        self.call(\"getblockchaininfo\", \u0026[])\n    }\n\n    fn send_raw_transaction(\u0026self, tx: String) -\u003e Result\u003cTxid\u003e {\n        self.call(\"sendrawtransaction\", \u0026[Value::String(tx)])\n    }\n}\n","traces":[{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[1740416],"length":1,"stats":{"Line":0},"fn_name":"stop\u003cfloresta_cli::reqwest_client::ReqwestClient\u003e"},{"line":128,"address":[1740433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[1740480,1740667],"length":1,"stats":{"Line":0},"fn_name":"rescan\u003cfloresta_cli::reqwest_client::ReqwestClient\u003e"},{"line":132,"address":[1740530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[1741036,1740704],"length":1,"stats":{"Line":0},"fn_name":"get_block\u003cfloresta_cli::reqwest_client::ReqwestClient\u003e"},{"line":140,"address":[1740739],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[1740949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[1740900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[1740763],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[1740876,1740818],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[1741072],"length":1,"stats":{"Line":0},"fn_name":"get_height\u003cfloresta_cli::reqwest_client::ReqwestClient\u003e"},{"line":151,"address":[1741089],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[1741136,1741323],"length":1,"stats":{"Line":0},"fn_name":"get_block_hash\u003cfloresta_cli::reqwest_client::ReqwestClient\u003e"},{"line":173,"address":[1741186],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[1741360,1741830],"length":1,"stats":{"Line":0},"fn_name":"load_descriptor\u003cfloresta_cli::reqwest_client::ReqwestClient\u003e"},{"line":185,"address":[1741432,1741515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[1741738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[1741686],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[1741522],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[1741601,1741662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[1742059,1741872],"length":1,"stats":{"Line":0},"fn_name":"get_block_filter\u003cfloresta_cli::reqwest_client::ReqwestClient\u003e"},{"line":196,"address":[1741922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[1742289,1742096],"length":1,"stats":{"Line":0},"fn_name":"get_block_header\u003cfloresta_cli::reqwest_client::ReqwestClient\u003e"},{"line":200,"address":[1742142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[1742320],"length":1,"stats":{"Line":0},"fn_name":"get_blockchain_info\u003cfloresta_cli::reqwest_client::ReqwestClient\u003e"},{"line":204,"address":[1742337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[1742521,1742384],"length":1,"stats":{"Line":0},"fn_name":"send_raw_transaction\u003cfloresta_cli::reqwest_client::ReqwestClient\u003e"},{"line":208,"address":[1742401],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":45},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-cli","src","rpc_types.rs"],"content":"use std::fmt::Display;\n\nuse serde::Deserialize;\nuse serde::Serialize;\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct GetBlockchainInfoRes {\n    /// The best block we know about\n    ///\n    /// This should be the hash of the latest block in the most PoW chain we know about. We may\n    /// or may not have fully-validated it yet\n    pub best_block: String,\n    /// The depth of the most-PoW chain we know about\n    pub height: u32,\n    /// Whether we are on Initial Block Download\n    pub ibd: bool,\n    /// How many blocks we have fully-validated so far? This number will be smaller than\n    /// height during IBD, and should be equal to height otherwise\n    pub validated: u32,\n    /// The work performed by the last block\n    ///\n    /// This is the estimated amount of hashes the miner of this block had to perform\n    /// before mining that block, on average\n    pub latest_work: String,\n    /// The UNIX timestamp for the latest block, as reported by the block's header\n    pub latest_block_time: u32,\n    /// How many leaves we have in the utreexo accumulator so far\n    ///\n    /// This should be equal to the number of UTXOs returned by core's `gettxoutsetinfo`\n    pub leaf_count: u32,\n    /// How many roots we have in the acc\n    pub root_count: u32,\n    /// The actual hex-encoded roots\n    pub root_hashes: Vec\u003cString\u003e,\n    /// A short string representing the chain we're in\n    pub chain: String,\n    /// The validation progress\n    ///\n    /// 0% means we didn't validate any block. 100% means we've validated all blocks, so\n    /// validated == height\n    pub progress: Option\u003cf32\u003e,\n    /// Current network \"difficulty\"\n    ///\n    /// On average, miners needs to make `difficulty` hashes before finding one that\n    /// solves a block's PoW\n    pub difficulty: u64,\n}\n\n/// The information returned by a get_raw_tx\n#[derive(Deserialize, Serialize)]\npub struct RawTx {\n    /// Whether this tx is in our best known chain\n    pub in_active_chain: bool,\n    /// The hex-encoded tx\n    pub hex: String,\n    /// Tha sha256d of the serialized transaction without witness\n    pub txid: String,\n    /// The sha256d of the serialized transaction including witness\n    pub hash: String,\n    /// The size this transaction occupies on disk\n    pub size: u32,\n    /// The virtual size of this transaction, as define by the segwit soft-fork\n    pub vsize: u32,\n    /// The weight of this transacion, as defined by the segwit soft-fork\n    pub weight: u32,\n    /// This transaction's version. The current bigger version is 2\n    pub version: u32,\n    /// This transaction's locktime\n    pub locktime: u32,\n    /// A list of inputs being spent by this transaction\n    ///\n    /// See [TxIn] for more information about the contents of this\n    pub vin: Vec\u003cTxIn\u003e,\n    /// A list of outputs being created by this tx\n    ///\n    /// Se [TxOut] for more information\n    pub vout: Vec\u003cTxOut\u003e,\n    /// The hash of the block that included this tx, if any\n    pub blockhash: String,\n    /// How many blocks have been mined after this transaction's confirmation\n    /// including the block that confirms it. A zero value means this tx is unconfirmed\n    pub confirmations: u32,\n    /// The timestamp for the block confirming this tx, if confirmed\n    pub blocktime: u32,\n    /// Same as blocktime\n    pub time: u32,\n}\n\n/// A transaction output returned by some RPCs like getrawtransaction and getblock\n#[derive(Deserialize, Serialize)]\npub struct TxOut {\n    /// The amount in sats locked in this UTXO\n    pub value: u64,\n    /// This utxo's index inside the transaction\n    pub n: u32,\n    /// The loking script of this utxo\n    pub script_pub_key: ScriptPubKey,\n}\n\n/// The locking script inside a txout\n#[derive(Deserialize, Serialize)]\npub struct ScriptPubKey {\n    /// A ASM representation for this script\n    ///\n    /// Assembly is a high-level representation of a lower level code. Instructions\n    /// are turned into OP_XXXXX and data is hex-encoded.\n    /// E.g: OP_DUP OP_HASH160 \u003c0000000000000000000000000000000000000000\u003e OP_EQUALVERIFY OP_CHECKSIG\n    pub asm: String,\n    /// The hex-encoded raw script\n    pub hex: String,\n    /// How many signatures are required to spend this UTXO.\n    ///\n    /// This field is deprecated and is here for compatibility with Core\n    pub req_sigs: u32,\n    #[serde(rename = \"type\")]\n    /// The type of this spk. E.g: PKH, SH, WSH, WPKH, TR, non-standard...\n    pub type_: String,\n    /// Encode this script using one of the standard address types, if possible\n    pub address: String,\n}\n\n/// A transaction input returned by some rpcs, like getrawtransaction and getblock\n#[derive(Deserialize, Serialize)]\npub struct TxIn {\n    /// The txid that created this UTXO\n    pub txid: String,\n    /// The index of this UTXO inside the tx that created it\n    pub vout: u32,\n    /// Unlocking script that should solve the challenge and prove ownership over\n    /// that UTXO\n    pub script_sig: ScriptSigJson,\n    /// The nSequence field, used in relative and absolute lock-times\n    pub sequence: u32,\n    /// A vector of witness elements for this input\n    pub witness: Vec\u003cString\u003e,\n}\n\n/// A representation for the transaction ScriptSig, returned by some rpcs\n/// like getrawtransaction and getblock\n#[derive(Deserialize, Serialize)]\npub struct ScriptSigJson {\n    /// A ASM representation for this scriptSig\n    ///\n    /// Assembly is a high-level representation of a lower level code. Instructions\n    /// are turned into OP_XXXXX and data is hex-encoded.\n    /// E.g: OP_PUSHBYTES32 \u003c000000000000000000000000000000000000000000000000000000000000000000\u003e\n    pub asm: String,\n    /// The hex-encoded script sig\n    pub hex: String,\n}\n\n/// General information about our peers. Returned by get_peer_info\n#[derive(Debug, Deserialize, Serialize)]\npub struct PeerInfo {\n    /// The network address for this peer.\n    pub address: String,\n    /// A string with the services this peer advertises. E.g. NODE_NETWORK, UTREEXO, WITNESS...\n    pub services: String,\n    /// User agent is a string that represents the client being used by our peer. E.g.\n    /// /Satoshi-26.0/ for bitcoin core version 26\n    pub user_agent: String,\n    /// This peer's height at the time we've openned a connection with them\n    pub initial_height: u32,\n}\n\n/// A full bitcoin block, returned by get_block\n#[derive(Debug, Deserialize, Serialize)]\npub struct GetBlockRes {\n    /// This block's hash.\n    pub hash: String,\n    /// How many blocks have been added to the chain, after this one have been found. This is\n    /// inclusive, so it starts with one when this block is the latest. If another one is found,\n    /// then it increments to 2 and so on...\n    pub confirmations: u32,\n    /// The size of this block, without the witness\n    pub strippedsize: usize,\n    /// This block's size, with the witness\n    pub size: usize,\n    /// This block's weight.\n    ///\n    /// Data inside a segwit block is counted differently, 'base data' has a weight of 4, while\n    /// witness only counts 1. This is (3 * base_size) + size\n    pub weight: usize,\n    /// How many blocks there are before this block\n    pub height: u32,\n    /// This block's version field\n    ///\n    /// Currently, blocks have version 2 (see BIP34), but it may also flip some of the LSB for\n    /// either consensus reason (see BIPs 8 and 9) or for version rolling mining, usually bits\n    /// after the 24th are not touched. Therefore, the actual version is likelly the result of\n    /// version \u0026 ~(1 \u003c\u003c 24).\n    /// This is encoded as a number, see `version_hex` for a hex-encoded version\n    pub version: i32,\n    #[serde(rename = \"versionHex\")]\n    /// Same as `version` by hex-encoded\n    pub version_hex: String,\n    /// This block's merkle root\n    ///\n    /// A Merkle Tree is a binary tree where every leaf is some data, and the branches are pairwise\n    /// hashes util reaching the root. This allows for compact proof of inclusion in the original\n    /// set. This merkle tree commits to the txid of all transactions in a block, and is used by\n    /// some light clients to determine whether a transaction is in a given block\n    pub merkleroot: String,\n    /// A list of hex-encoded transaction id for the tx's in this block\n    pub tx: Vec\u003cString\u003e,\n    /// The timestamp commited to in this block's header\n    ///\n    /// Since there's no central clock that can tell time precisely in Bitcoin, this value is\n    /// reported by miners and only constrained by a couple of consensus rules. More sensibly, it\n    /// is **not** garanteed to be monotonical. So a block n might have a lower timestamp than\n    /// block `n - 1`.\n    /// If you need it to be monotonical, see `mediantime` insted\n    pub time: u32,\n    /// The meadian of the last 11 blocktimes.\n    ///\n    /// This is a monotonically increasing number that bounds how old a block can be. Blocks may\n    /// not have a timestamp less than the current `mediantime`. This is also used in relative\n    /// timelocks.\n    pub mediantime: u32,\n    /// The nonce used to mine this block.\n    ///\n    /// Blocks are mined by increasing this value until you find a hash that is less than a network\n    /// defined target. This number has no meaning in itself and is just a random u32.\n    pub nonce: u32,\n    /// Bits is a compact representation for the target.\n    ///\n    /// This is a exponential format (with well-define rouding) used by openssl that Satoshi\n    /// decided to make consensus critical :/\n    pub bits: String,\n    /// The difficulty is derived from the current target and is defined as how many hashes, on\n    /// average, one has to make before finding a valid block\n    ///\n    /// This is computed as 1 / (target / 2 ^ 256). In most softwares (this one inclued) the\n    /// difficulty is a multiple of the smallest possible difficulty. So to find the actual\n    /// difficulty you have to multiply this by the min_diff.\n    /// For mainnet, mindiff is 2 ^ 32\n    pub difficulty: u128,\n    /// Commullative work in this network\n    ///\n    /// This is a estimate of how many hashes the network has ever made to produce this chain\n    pub chainwork: String,\n    /// How many transactions in this block\n    pub n_tx: usize,\n    /// The hash of the block comming before this one\n    pub previousblockhash: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    /// The hash of the block comming after this one, if any\n    pub nextblockhash: Option\u003cString\u003e,\n}\n\n#[derive(Debug)]\n/// All possible errors returned by the jsonrpc\npub enum Error {\n    /// An error while deserializing our response\n    Serde(serde_json::Error),\n    #[cfg(feature = \"with-reqwest\")]\n    /// An internal reqwest error\n    Reqwest(reqwest::Error),\n    /// An error internal to our jsonrpc server\n    Api(serde_json::Value),\n    /// The server sent an empty response\n    EmtpyResponse,\n}\n\nimpl From\u003cserde_json::Error\u003e for Error {\n    fn from(value: serde_json::Error) -\u003e Self {\n        Error::Serde(value)\n    }\n}\n\nimpl From\u003creqwest::Error\u003e for Error {\n    fn from(value: reqwest::Error) -\u003e Self {\n        Error::Reqwest(value)\n    }\n}\n\nimpl Display for Error {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Error::Reqwest(e) =\u003e write!(f, \"reqwest returned an error {e}\"),\n            Error::Api(e) =\u003e write!(f, \"general jsonrpc error: {e}\"),\n            Error::Serde(e) =\u003e write!(f, \"error while deserializing the response: {e}\"),\n            Error::EmtpyResponse =\u003e write!(f, \"got an empty response from server\"),\n        }\n    }\n}\n\nimpl std::error::Error for Error {}\n","traces":[{"line":266,"address":[1604704],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":267,"address":[1604712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[1604720],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":273,"address":[1660296],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[2502720],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":279,"address":[1604768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[1604980,1605049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[1605186,1605121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[1604893,1604818],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[1605260],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-common","src","constants.rs"],"content":"//! This module contains some common strings for versioning\n\n/// The default name of our data dir\npub const DIR_NAME: \u0026str = \".floresta\";\n/// Version of rust-bitcoin we are using. If we bump it on Cargo.toml, should change here too\npub const RUST_BITCOIN_VERSION: \u0026str = \"0.29.3\";\n/// Version of rustreexo we use\npub const RUSTREEXO_VERSION: \u0026str = \"0.1.0\";\n/// Our own version\npub const FLORESTA_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-common","src","lib.rs"],"content":"#![no_std]\nuse bitcoin::hashes::sha256;\nuse bitcoin::hashes::Hash;\nuse bitcoin::ScriptBuf;\n#[cfg(feature = \"descriptors\")]\nuse miniscript::Descriptor;\n#[cfg(feature = \"descriptors\")]\nuse miniscript::DescriptorPublicKey;\nuse sha2::Digest;\npub mod constants;\npub mod spsc;\n\nuse prelude::*;\npub use spsc::Channel;\n\npub fn get_hash_from_u8(data: \u0026[u8]) -\u003e sha256::Hash {\n    let hash = sha2::Sha256::new().chain_update(data).finalize();\n    sha256::Hash::from_slice(hash.as_slice()).expect(\"Engines shouldn't be Err\")\n}\n\npub fn get_spk_hash(spk: \u0026ScriptBuf) -\u003e sha256::Hash {\n    let script_hash = spk.as_bytes();\n    let mut hash = sha2::Sha256::new().chain_update(script_hash).finalize();\n    hash.reverse();\n    sha256::Hash::from_slice(hash.as_slice()).expect(\"Engines shouldn't be Err\")\n}\n\n#[cfg(feature = \"descriptors\")]\npub fn parse_descriptors(\n    descriptors: \u0026[String],\n) -\u003e Result\u003cVec\u003cDescriptor\u003cDescriptorPublicKey\u003e\u003e, miniscript::Error\u003e {\n    let descriptors = descriptors\n        .iter()\n        .map(|descriptor| {\n            let descriptor = Descriptor::\u003cDescriptorPublicKey\u003e::from_str(descriptor.as_str())?;\n            descriptor.sanity_check()?;\n            descriptor.into_single_descriptors()\n        })\n        .collect::\u003cResult\u003cVec\u003cVec\u003c_\u003e\u003e, _\u003e\u003e()?\n        .into_iter()\n        .flatten()\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    Ok(descriptors)\n}\n#[cfg(feature = \"no-std\")]\npub mod prelude {\n    extern crate alloc;\n    pub use alloc::borrow::ToOwned;\n    pub use alloc::boxed::Box;\n    pub use alloc::string::String;\n    pub use alloc::string::ToString;\n    pub use alloc::vec;\n    pub use alloc::vec::Vec;\n    pub use core::cmp;\n    pub use core::convert;\n    pub use core::core::str::FromStr;\n    pub use core::fmt;\n    pub use core::fmt::Display;\n    pub use core::iter;\n    pub use core::mem;\n    pub use core::ops;\n    pub use core::ops::Deref;\n    pub use core::ops::DerefMut;\n    pub use core::option;\n    pub use core::result;\n    pub use core::slice;\n    pub use core::str;\n\n    pub use core2::error::Error;\n    pub use core2::io::Error as ioError;\n    pub use core2::io::Read;\n    pub use core2::io::Write;\n    pub use hashbrown::HashMap;\n    pub use hashbrown::HashSet;\n}\n#[cfg(not(feature = \"no-std\"))]\npub mod prelude {\n    extern crate alloc;\n    extern crate std;\n    pub use alloc::string::ToString;\n    pub use std::borrow::ToOwned;\n    pub use std::boxed::Box;\n    pub use std::collections::hash_map::Entry;\n    pub use std::collections::HashMap;\n    pub use std::collections::HashSet;\n    pub use std::error::Error;\n    pub use std::fmt::Display;\n    pub use std::fmt::Formatter;\n    pub use std::fmt::{self};\n    pub use std::io::Error as ioError;\n    pub use std::io::Read;\n    pub use std::io::Write;\n    pub use std::ops::Deref;\n    pub use std::ops::DerefMut;\n    pub use std::result::Result;\n    pub use std::str::FromStr;\n    pub use std::string::String;\n    pub use std::sync;\n    pub use std::vec::Vec;\n    pub use std::vec::{self};\n}\n#[macro_export]\nmacro_rules! impl_error_from {\n    ($thing:ty, $from_thing:ty, $field:ident) =\u003e {\n        impl From\u003c$from_thing\u003e for $thing {\n            fn from(e: $from_thing) -\u003e Self {\n                \u003c$thing\u003e::$field(e)\n            }\n        }\n    };\n}\n","traces":[{"line":16,"address":[5082960],"length":1,"stats":{"Line":0},"fn_name":"get_hash_from_u8"},{"line":17,"address":[914810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[914865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[4976912],"length":1,"stats":{"Line":3},"fn_name":"get_spk_hash"},{"line":22,"address":[5083190],"length":1,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[915025],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[5083327],"length":1,"stats":{"Line":4},"fn_name":null},{"line":25,"address":[915122],"length":1,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[5083424],"length":1,"stats":{"Line":0},"fn_name":"parse_descriptors"},{"line":32,"address":[5083790,5083483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[818544,819133,819164],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":35,"address":[818767,818590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[8094042,8093921,8093742,8094158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[818921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[915449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[992800,992784,992832],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":107,"address":[992808,992792,992835],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":5,"coverable":17},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-common","src","spsc.rs"],"content":"//! A no-std Single Producer, Single Consumer channel for unidirectional message exchange between\n//! modules. This module don't use anything from the standard lib and can be easily used in no-std\n//! enviroments. We only use mem::take from [core].\n\nuse core::mem::take;\n\nuse crate::prelude::Vec;\n\n/// A (Send + Sync) single producer, single consumer channel to notify modules about things.\n/// The api is super minimalistic to reduce external dependecies, including from the std-lib\n///\n/// One notable difference from the standard mspc channel is that this channel's ends are't\n/// two different types, while this is possible, there's no reason to do that. Specially\n/// considering that to get a good compile-time asurance that both ends will not be shared, the\n/// channel must not be [Send], but this is one of the main requirements to use this channel in\n/// async code. Moreover, if two worker threads are meant to be identical threads balancing their\n/// work, it might be beneficial to use this same channel as a de-facto single producer, multiple\n/// consumer channel for work distribution.\n/// # Example\n/// ```\n/// use floresta_common::spsc;\n/// let channel = spsc::Channel::new();\n///\n/// // Send something\n/// channel.send(1);\n/// // Read the same thing back\n/// assert_eq!(channel.recv().next(), Some(1));\n/// ```\n#[derive(Debug, Default)]\npub struct Channel\u003cT\u003e {\n    /// The data pending for read\n    content: spin::Mutex\u003cVec\u003cT\u003e\u003e,\n}\n\nimpl\u003cT\u003e Channel\u003cT\u003e {\n    /// Creates a new channel\n    ///\n    /// # Example\n    /// ```\n    /// use floresta_common::spsc;\n    /// let channel = spsc::Channel::new();\n    ///\n    /// channel.send(1);\n    /// assert_eq!(channel.recv().next(), Some(1));\n    /// ```\n    pub fn new() -\u003e Self {\n        Channel {\n            content: spin::Mutex::new(Vec::new()),\n        }\n    }\n    /// Sends some data through a channel\n    ///\n    /// # Example\n    /// ```\n    /// use floresta_common::spsc;\n    /// let channel = spsc::Channel::new();\n    ///\n    /// channel.send(1);\n    /// assert_eq!(channel.recv().next(), Some(1));\n    /// ```\n    pub fn send(\u0026self, data: T) {\n        self.content.lock().push(data);\n    }\n    /// Reads from a channel\n    ///\n    /// This method returns an iterator over all alements inside a [Channel]\n    pub fn recv(\u0026self) -\u003e RecvIter\u003cT\u003e {\n        let inner = take(\u0026mut *self.content.lock());\n        RecvIter { inner }\n    }\n}\n\n/// An iterator issued every time someone calls `recv`.\n///\n/// This iterator takes all itens available for reading in a channel\n/// and lets the consumer iterate over them, without acquiring the lock\n/// every time (the mutex is only locked when `recv` is called).\n///\n/// # Example\n/// ```\n/// use floresta_common::spsc;\n/// let channel = spsc::Channel::new();\n///\n/// channel.send(0);\n/// channel.send(1);\n///\n/// for (i, el) in channel.recv().enumerate() {\n///     assert_eq!(i, el);\n/// }\n/// // A second read should create an empty iterator\n/// assert_eq!(channel.recv().next(), None);\n/// ```\npub struct RecvIter\u003cT\u003e {\n    inner: Vec\u003cT\u003e,\n}\n\nimpl\u003cT\u003e Iterator for RecvIter\u003cT\u003e {\n    type Item = T;\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        if self.inner.is_empty() {\n            return None;\n        }\n        Some(self.inner.remove(0))\n    }\n}\n","traces":[{"line":46,"address":[4814864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[24220304,24220908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[4815248,4815699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-compact-filters","src","bip158.rs"],"content":"// SPDX-License-Identifier: CC0-1.0\n\n// This module was largely copied from https://github.com/rust-bitcoin/murmel/blob/master/src/blockfilter.rs\n// on 11. June 2019 which is licensed under Apache, that file specifically\n// was written entirely by Tamas Blummer, who is re-licensing its contents here as CC0.\n\n//! BIP158 Compact Block Filters for light clients.\n//!\n//! This module implements a structure for compact filters on block data, for\n//! use in the BIP 157 light client protocol. The filter construction proposed\n//! is an alternative to Bloom filters, as used in BIP 37, that minimizes filter\n//! size by using Golomb-Rice coding for compression.\n//!\n//! ## Example\n//!\n//! ```ignore\n//! fn get_script_for_coin(coin: \u0026OutPoint) -\u003e Result\u003cScript, BlockFilterError\u003e {\n//!   // get utxo ...\n//! }\n//!\n//! // create a block filter for a block (server side)\n//! let filter = BlockFilter::new_script_filter(\u0026block, get_script_for_coin)?;\n//!\n//! // or create a filter from known raw data\n//! let filter = BlockFilter::new(content);\n//!\n//! // read and evaluate a filter\n//!\n//! let query: Iterator\u003cItem=Script\u003e = // .. some scripts you care about\n//! if filter.match_any(\u0026block_hash, \u0026mut query.map(|s| s.as_bytes())) {\n//!   // get this block\n//! }\n//!  ```\n\nuse std::cmp::Ordering;\nuse std::cmp::{self};\nuse std::collections::HashSet;\nuse std::fmt::Display;\nuse std::fmt::Formatter;\nuse std::fmt::{self};\nuse std::io::Cursor;\nuse std::io::{self};\n\nuse bitcoin::consensus::Decodable;\nuse bitcoin::consensus::Encodable;\nuse bitcoin::hashes::siphash24;\nuse bitcoin::hashes::Hash;\nuse bitcoin::hex::write_err;\nuse bitcoin::BlockHash;\nuse bitcoin::OutPoint;\nuse bitcoin::VarInt;\n\n/// Golomb encoding parameter as in BIP-158, see also https://gist.github.com/sipa/576d5f09c3b86c3b1b75598d799fc845\nconst P: u8 = 19;\nconst M: u64 = 784931;\n\n/// Errors for blockfilter\n#[derive(Debug)]\npub enum Error {\n    /// missing UTXO, can not calculate script filter\n    UtxoMissing(OutPoint),\n    /// some IO error reading or writing binary serialization of the filter\n    Io(io::Error),\n}\n\nimpl Display for Error {\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e Result\u003c(), fmt::Error\u003e {\n        match *self {\n            Error::UtxoMissing(ref coin) =\u003e write!(f, \"unresolved UTXO {}\", coin),\n            Error::Io(ref e) =\u003e write_err!(f, \"IO error\"; e),\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"std\")))]\nimpl std::error::Error for Error {\n    fn source(\u0026self) -\u003e Option\u003c\u0026(dyn std::error::Error + 'static)\u003e {\n        use self::Error::*;\n\n        match self {\n            UtxoMissing(_) =\u003e None,\n            Io(e) =\u003e Some(e),\n        }\n    }\n}\n\nimpl From\u003cio::Error\u003e for Error {\n    fn from(io: io::Error) -\u003e Self {\n        Error::Io(io)\n    }\n}\n\n/// a computed or read block filter\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct BlockFilter {\n    /// Golomb encoded filter\n    pub content: Vec\u003cu8\u003e,\n}\n\nimpl BlockFilter {\n    /// create a new filter from pre-computed data\n    pub fn new(content: \u0026[u8]) -\u003e BlockFilter {\n        BlockFilter {\n            content: content.to_vec(),\n        }\n    }\n\n    /// match any query pattern\n    pub fn match_any(\n        \u0026self,\n        block_hash: \u0026BlockHash,\n        query: \u0026mut dyn Iterator\u003cItem = \u0026[u8]\u003e,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        let filter_reader = BlockFilterReader::new(block_hash);\n        filter_reader.match_any(\u0026mut Cursor::new(self.content.as_slice()), query)\n    }\n\n    /// match all query pattern\n    pub fn match_all(\n        \u0026self,\n        block_hash: \u0026BlockHash,\n        query: \u0026mut dyn Iterator\u003cItem = \u0026[u8]\u003e,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        let filter_reader = BlockFilterReader::new(block_hash);\n        filter_reader.match_all(\u0026mut Cursor::new(self.content.as_slice()), query)\n    }\n}\n\n/// Reads and interpret a block filter\npub struct BlockFilterReader {\n    reader: GCSFilterReader,\n}\n\nimpl BlockFilterReader {\n    /// Create a block filter reader\n    pub fn new(block_hash: \u0026BlockHash) -\u003e BlockFilterReader {\n        let block_hash_as_int = block_hash.to_byte_array();\n        let mut k0 = [0; 8];\n        let mut k1 = [0; 8];\n\n        k0.clone_from_slice(\u0026block_hash_as_int[0..8]);\n        k1.clone_from_slice(\u0026block_hash_as_int[8..16]);\n\n        let k0 = u64::from_le_bytes(k0);\n        let k1 = u64::from_le_bytes(k1);\n        BlockFilterReader {\n            reader: GCSFilterReader::new(k0, k1, M, P),\n        }\n    }\n\n    /// match any query pattern\n    pub fn match_any(\n        \u0026self,\n        reader: \u0026mut dyn io::Read,\n        query: \u0026mut dyn Iterator\u003cItem = \u0026[u8]\u003e,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        self.reader.match_any(reader, query)\n    }\n\n    /// match all query pattern\n    pub fn match_all(\n        \u0026self,\n        reader: \u0026mut dyn io::Read,\n        query: \u0026mut dyn Iterator\u003cItem = \u0026[u8]\u003e,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        self.reader.match_all(reader, query)\n    }\n}\n\n/// Golomb-Rice encoded filter reader\npub struct GCSFilterReader {\n    filter: GCSFilter,\n    m: u64,\n}\n\nimpl GCSFilterReader {\n    /// Create a new filter reader with specific seed to siphash\n    pub fn new(k0: u64, k1: u64, m: u64, p: u8) -\u003e GCSFilterReader {\n        GCSFilterReader {\n            filter: GCSFilter::new(k0, k1, p),\n            m,\n        }\n    }\n\n    /// match any query pattern\n    pub fn match_any(\n        \u0026self,\n        reader: \u0026mut dyn io::Read,\n        query: \u0026mut dyn Iterator\u003cItem = \u0026[u8]\u003e,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        let mut decoder = reader;\n        let n_elements: VarInt = Decodable::consensus_decode(\u0026mut decoder).unwrap_or(VarInt(0));\n        let reader = \u0026mut decoder;\n        // map hashes to [0, n_elements \u003c\u003c grp]\n        let nm = n_elements.0 * self.m;\n        let mut mapped = query\n            .map(|e| map_to_range(self.filter.hash(e), nm))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        // sort\n        mapped.sort_unstable();\n        if mapped.is_empty() {\n            return Ok(true);\n        }\n        if n_elements.0 == 0 {\n            return Ok(false);\n        }\n\n        // find first match in two sorted arrays in one read pass\n        let mut reader = BitStreamReader::new(reader);\n        let mut data = self.filter.golomb_rice_decode(\u0026mut reader)?;\n        let mut remaining = n_elements.0 - 1;\n        for p in mapped {\n            loop {\n                match data.cmp(\u0026p) {\n                    Ordering::Equal =\u003e return Ok(true),\n                    Ordering::Less =\u003e {\n                        if remaining \u003e 0 {\n                            data += self.filter.golomb_rice_decode(\u0026mut reader)?;\n                            remaining -= 1;\n                        } else {\n                            return Ok(false);\n                        }\n                    }\n                    Ordering::Greater =\u003e break,\n                }\n            }\n        }\n        Ok(false)\n    }\n\n    /// match all query pattern\n    pub fn match_all(\n        \u0026self,\n        reader: \u0026mut dyn io::Read,\n        query: \u0026mut dyn Iterator\u003cItem = \u0026[u8]\u003e,\n    ) -\u003e Result\u003cbool, Error\u003e {\n        let mut decoder = reader;\n        let n_elements: VarInt = Decodable::consensus_decode(\u0026mut decoder).unwrap_or(VarInt(0));\n        let reader = \u0026mut decoder;\n        // map hashes to [0, n_elements \u003c\u003c grp]\n        let nm = n_elements.0 * self.m;\n        let mut mapped = query\n            .map(|e| map_to_range(self.filter.hash(e), nm))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        // sort\n        mapped.sort_unstable();\n        mapped.dedup();\n        if mapped.is_empty() {\n            return Ok(true);\n        }\n        if n_elements.0 == 0 {\n            return Ok(false);\n        }\n\n        // figure if all mapped are there in one read pass\n        let mut reader = BitStreamReader::new(reader);\n        let mut data = self.filter.golomb_rice_decode(\u0026mut reader)?;\n        let mut remaining = n_elements.0 - 1;\n        for p in mapped {\n            loop {\n                match data.cmp(\u0026p) {\n                    Ordering::Equal =\u003e break,\n                    Ordering::Less =\u003e {\n                        if remaining \u003e 0 {\n                            data += self.filter.golomb_rice_decode(\u0026mut reader)?;\n                            remaining -= 1;\n                        } else {\n                            return Ok(false);\n                        }\n                    }\n                    Ordering::Greater =\u003e return Ok(false),\n                }\n            }\n        }\n        Ok(true)\n    }\n}\n\n// fast reduction of hash to [0, nm) range\nfn map_to_range(hash: u64, nm: u64) -\u003e u64 {\n    ((hash as u128 * nm as u128) \u003e\u003e 64) as u64\n}\n\n/// Colomb-Rice encoded filter writer\npub struct GCSFilterWriter\u003c'a\u003e {\n    filter: GCSFilter,\n    writer: \u0026'a mut dyn io::Write,\n    elements: HashSet\u003cVec\u003cu8\u003e\u003e,\n    m: u64,\n}\n\nimpl\u003c'a\u003e GCSFilterWriter\u003c'a\u003e {\n    /// Create a new GCS writer wrapping a generic writer, with specific seed to siphash\n    pub fn new(\n        writer: \u0026'a mut dyn io::Write,\n        k0: u64,\n        k1: u64,\n        m: u64,\n        p: u8,\n    ) -\u003e GCSFilterWriter\u003c'a\u003e {\n        GCSFilterWriter {\n            filter: GCSFilter::new(k0, k1, p),\n            writer,\n            elements: HashSet::new(),\n            m,\n        }\n    }\n\n    /// Add some data to the filter\n    pub fn add_element(\u0026mut self, element: \u0026[u8]) {\n        if !element.is_empty() {\n            self.elements.insert(element.to_vec());\n        }\n    }\n\n    /// write the filter to the wrapped writer\n    pub fn finish(\u0026mut self) -\u003e Result\u003cusize, io::Error\u003e {\n        let nm = self.elements.len() as u64 * self.m;\n\n        // map hashes to [0, n_elements * M)\n        let mut mapped: Vec\u003c_\u003e = self\n            .elements\n            .iter()\n            .map(|e| map_to_range(self.filter.hash(e.as_slice()), nm))\n            .collect();\n        mapped.sort_unstable();\n\n        // write number of elements as varint\n        let mut wrote = VarInt(mapped.len() as u64).consensus_encode(\u0026mut self.writer)?;\n\n        // write out deltas of sorted values into a Golonb-Rice coded bit stream\n        let mut writer = BitStreamWriter::new(self.writer);\n        let mut last = 0;\n        for data in mapped {\n            wrote += self.filter.golomb_rice_encode(\u0026mut writer, data - last)?;\n            last = data;\n        }\n        wrote += writer.flush()?;\n        Ok(wrote)\n    }\n}\n\n/// Golomb Coded Set Filter\nstruct GCSFilter {\n    k0: u64, // sip hash key\n    k1: u64, // sip hash key\n    p: u8,\n}\n\nimpl GCSFilter {\n    /// Create a new filter\n    fn new(k0: u64, k1: u64, p: u8) -\u003e GCSFilter {\n        GCSFilter { k0, k1, p }\n    }\n\n    /// Golomb-Rice encode a number n to a bit stream (Parameter 2^k)\n    fn golomb_rice_encode(\u0026self, writer: \u0026mut BitStreamWriter, n: u64) -\u003e Result\u003cusize, io::Error\u003e {\n        let mut wrote = 0;\n        let mut q = n \u003e\u003e self.p;\n        while q \u003e 0 {\n            let nbits = cmp::min(q, 64);\n            wrote += writer.write(!0u64, nbits as u8)?;\n            q -= nbits;\n        }\n        wrote += writer.write(0, 1)?;\n        wrote += writer.write(n, self.p)?;\n        Ok(wrote)\n    }\n\n    /// Golomb-Rice decode a number from a bit stream (Parameter 2^k)\n    fn golomb_rice_decode(\u0026self, reader: \u0026mut BitStreamReader) -\u003e Result\u003cu64, io::Error\u003e {\n        let mut q = 0u64;\n        while reader.read(1)? == 1 {\n            q += 1;\n        }\n        let r = reader.read(self.p)?;\n        Ok((q \u003c\u003c self.p) + r)\n    }\n\n    /// Hash an arbitrary slice with siphash using parameters of this filter\n    fn hash(\u0026self, element: \u0026[u8]) -\u003e u64 {\n        siphash24::Hash::hash_to_u64_with_keys(self.k0, self.k1, element)\n    }\n}\n\n/// Bitwise stream reader\npub struct BitStreamReader\u003c'a\u003e {\n    buffer: [u8; 1],\n    offset: u8,\n    reader: \u0026'a mut dyn io::Read,\n}\n\nimpl\u003c'a\u003e BitStreamReader\u003c'a\u003e {\n    /// Create a new BitStreamReader that reads bitwise from a given reader\n    pub fn new(reader: \u0026'a mut dyn io::Read) -\u003e BitStreamReader {\n        BitStreamReader {\n            buffer: [0u8],\n            reader,\n            offset: 8,\n        }\n    }\n\n    /// Read nbit bits\n    pub fn read(\u0026mut self, mut nbits: u8) -\u003e Result\u003cu64, io::Error\u003e {\n        if nbits \u003e 64 {\n            return Err(io::Error::new(\n                io::ErrorKind::Other,\n                \"can not read more than 64 bits at once\",\n            ));\n        }\n        let mut data = 0u64;\n        while nbits \u003e 0 {\n            if self.offset == 8 {\n                self.reader.read_exact(\u0026mut self.buffer)?;\n                self.offset = 0;\n            }\n            let bits = cmp::min(8 - self.offset, nbits);\n            data \u003c\u003c= bits;\n            data |= ((self.buffer[0] \u003c\u003c self.offset) \u003e\u003e (8 - bits)) as u64;\n            self.offset += bits;\n            nbits -= bits;\n        }\n        Ok(data)\n    }\n}\n\n/// Bitwise stream writer\npub struct BitStreamWriter\u003c'a\u003e {\n    buffer: [u8; 1],\n    offset: u8,\n    writer: \u0026'a mut dyn io::Write,\n}\n\nimpl\u003c'a\u003e BitStreamWriter\u003c'a\u003e {\n    /// Create a new BitStreamWriter that writes bitwise to a given writer\n    pub fn new(writer: \u0026'a mut dyn io::Write) -\u003e BitStreamWriter {\n        BitStreamWriter {\n            buffer: [0u8],\n            writer,\n            offset: 0,\n        }\n    }\n\n    /// Write nbits bits from data\n    pub fn write(\u0026mut self, data: u64, mut nbits: u8) -\u003e Result\u003cusize, io::Error\u003e {\n        if nbits \u003e 64 {\n            return Err(io::Error::new(\n                io::ErrorKind::Other,\n                \"can not write more than 64 bits at once\",\n            ));\n        }\n        let mut wrote = 0;\n        while nbits \u003e 0 {\n            let bits = cmp::min(8 - self.offset, nbits);\n            self.buffer[0] |= ((data \u003c\u003c (64 - nbits)) \u003e\u003e (64 - 8 + self.offset)) as u8;\n            self.offset += bits;\n            nbits -= bits;\n            if self.offset == 8 {\n                wrote += self.flush()?;\n            }\n        }\n        Ok(wrote)\n    }\n\n    /// flush bits not yet written\n    pub fn flush(\u0026mut self) -\u003e Result\u003cusize, io::Error\u003e {\n        if self.offset \u003e 0 {\n            self.writer.write_all(\u0026self.buffer)?;\n            self.buffer[0] = 0u8;\n            self.offset = 0;\n            Ok(1)\n        } else {\n            Ok(0)\n        }\n    }\n}\n","traces":[{"line":67,"address":[981792],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":68,"address":[981824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[981840,981909],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[982050,981981],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[982144],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":90,"address":[982152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[982176],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[982199],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[982256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[982322],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[982337],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[982416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[982482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[982497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[982576],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[982601],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[982646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[982658],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[982670],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[982793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[982885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[982930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[982975],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[983072],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[983109],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[983136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[983173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[983200],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[983241],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[983312,984878,984833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[983379],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[983403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[983473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[983489,983669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[983578],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[983554],"length":1,"stats":{"Line":3},"fn_name":null},{"line":201,"address":[983750,983648],"length":1,"stats":{"Line":2},"fn_name":null},{"line":202,"address":[984482,983757],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[983811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[983798],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[983828],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[983840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[984844,984020,983889],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[984058,984133,983990],"length":1,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[984165,984066,984562],"length":1,"stats":{"Line":3},"fn_name":null},{"line":214,"address":[984374,984790],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[984428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[984502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[984484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[984531,984828,984744,984584],"length":1,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[984795,984782,984711],"length":1,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[984519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[984381],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[986494,986449,984912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[984979],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[985003],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[985073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[985089,985269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[985178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[985154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[985248,985350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[985365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[985372,986098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[985426],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[985413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[985443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[985455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[985635,986460,985504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[985605,985673,985748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[985780,986178,985681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[986406,985989],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[986043],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[986100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[986147,986200,986360,986444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[986398,986411,986327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[986135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[986118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[985996],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[986528],"length":1,"stats":{"Line":1},"fn_name":"map_to_range"},{"line":282,"address":[986570,986545],"length":1,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[986608],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":353,"address":[988464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":358,"address":[988496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":359,"address":[988552],"length":1,"stats":{"Line":1},"fn_name":null},{"line":360,"address":[988561,988605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":361,"address":[988603,989266,988635],"length":1,"stats":{"Line":3},"fn_name":null},{"line":362,"address":[988705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":363,"address":[989227,988739,989120],"length":1,"stats":{"Line":2},"fn_name":null},{"line":364,"address":[989271,989200,989261],"length":1,"stats":{"Line":2},"fn_name":null},{"line":366,"address":[988648,988792,988943],"length":1,"stats":{"Line":2},"fn_name":null},{"line":367,"address":[989077,988973,988891],"length":1,"stats":{"Line":2},"fn_name":null},{"line":368,"address":[989059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":372,"address":[989312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[989355],"length":1,"stats":{"Line":1},"fn_name":null},{"line":374,"address":[989369,989553],"length":1,"stats":{"Line":2},"fn_name":null},{"line":375,"address":[989464,989548,989558],"length":1,"stats":{"Line":2},"fn_name":null},{"line":377,"address":[989593,989647,989497],"length":1,"stats":{"Line":2},"fn_name":null},{"line":378,"address":[989686,989771,989614],"length":1,"stats":{"Line":2},"fn_name":null},{"line":382,"address":[989824],"length":1,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[989851],"length":1,"stats":{"Line":1},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":113,"coverable":160},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-compact-filters","src","kv_filter_database.rs"],"content":"use core::fmt;\nuse std::fmt::Debug;\nuse std::fmt::Formatter;\nuse std::path::PathBuf;\n\nuse kv::Bucket;\nuse kv::Config;\nuse kv::Integer;\n\nuse crate::BlockFilter;\nuse crate::BlockFilterStore;\n\n/// Stores the block filters insinde a kv database\n#[derive(Clone)]\npub struct KvFilterStore {\n    bucket: Bucket\u003c'static, Integer, Vec\u003cu8\u003e\u003e,\n}\n\nimpl Debug for KvFilterStore {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.debug_struct(\"KvFilterStore\").finish()\n    }\n}\n\nimpl KvFilterStore {\n    /// Creates a new [KvFilterStore] that stores it's content in `datadir`.\n    ///\n    /// If the path does't exist it'll be created. This store uses compression by default, if you\n    /// want to make more granular configuration over the underlying Kv database, use `with_config`\n    /// instead.\n    pub fn new(datadir: \u0026PathBuf) -\u003e Self {\n        let store = kv::Store::new(kv::Config {\n            path: datadir.to_owned(),\n            temporary: false,\n            use_compression: false,\n            flush_every_ms: None,\n            cache_capacity: None,\n            segment_size: None,\n        })\n        .expect(\"Could not open store\");\n\n        let bucket = store.bucket(Some(\"cfilters\")).unwrap();\n        KvFilterStore { bucket }\n    }\n\n    /// Creates a new [KvFilterStore] that stores it's content with a given config\n    pub fn with_config(config: Config) -\u003e Self {\n        let store = kv::Store::new(config).expect(\"Could not open database\");\n        let bucket = store.bucket(Some(\"cffilters\")).unwrap();\n        KvFilterStore { bucket }\n    }\n}\n\nimpl BlockFilterStore for KvFilterStore {\n    fn get_filter(\u0026self, block_height: u64) -\u003e Option\u003cBlockFilter\u003e {\n        let value = self\n            .bucket\n            .get(\u0026Integer::from(block_height))\n            .ok()\n            .flatten()?;\n        Some(BlockFilter::new(\u0026value))\n    }\n    fn put_filter(\u0026self, block_height: u64, block_filter: BlockFilter) {\n        self.bucket\n            .set(\u0026Integer::from(block_height), \u0026block_filter.content)\n            .expect(\"Bucket should be open\");\n    }\n}\n","traces":[{"line":20,"address":[19488928],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":21,"address":[18256030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[18256080,18256544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[973571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[19489010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[18256115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[19489039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[973559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[19489385,19489285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[19489739,19489488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[973994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[974060,974160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[974646,974256],"length":1,"stats":{"Line":0},"fn_name":"get_filter"},{"line":56,"address":[974512,974326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[974307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[974481,974575],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[974672,974857],"length":1,"stats":{"Line":0},"fn_name":"put_filter"},{"line":64,"address":[974766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[974704],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":19},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-compact-filters","src","lib.rs"],"content":"// SPDX-License-Identifier: MIT\n\n//! A library for building and querying BIP-158 compact block filters locally\n//!\n//! This lib implements BIP-158 client-side Galomb-Rice block filters, without\n//! relaying on p2p connections to retrieve them. We use this to speedup wallet\n//! resyncs and allow arbitrary UTXO retrieving for lightning nodes.\n//!\n//! This module should receive blocks as we download them, it'll create a filter\n//! for it. Therefore, you can't use this to speedup wallet sync **before** IBD,\n//! since we wouldn't have the filter for all blocks yet.\nuse core::fmt::Debug;\nuse core::ops::BitAnd;\nuse std::io::Write;\n\nuse bitcoin::hashes::Hash;\nuse bitcoin::Block;\nuse bitcoin::BlockHash;\nuse bitcoin::OutPoint;\nuse bitcoin::Transaction;\nuse bitcoin::Txid;\nuse floresta_chain::BlockConsumer;\nuse log::error;\n\nmod bip158;\npub mod kv_filter_database;\npub mod network_filters;\n\npub use bip158::BlockFilter;\nuse bip158::*;\n\n/// A database that stores our compact filters\npub trait BlockFilterStore: Send + Sync {\n    /// Fetches a block filter\n    fn get_filter(\u0026self, block_height: u64) -\u003e Option\u003cbip158::BlockFilter\u003e;\n    /// Stores a new filter\n    fn put_filter(\u0026self, block_height: u64, block_filter: bip158::BlockFilter);\n}\n\n/// All standard outputs type define in the Bitcoin network\n#[derive(Debug, Hash)]\npub enum OutputTypes {\n    /// public key hash\n    PKH,\n    /// script hash\n    SH,\n    /// witness public key hash\n    WPKH,\n    /// witness script hash\n    WSH,\n    /// Taproot (witness v1)\n    TR,\n}\n\n/// This means we track all suported address types\nconst ALL_OUTPUTS: u8 = 0x1f; // 00011111\n/// The `M` parameter from BIP-158\nconst FILTER_M: u64 = 784931;\n/// The `P` parameter form BIP-158\nconst FILTER_P: u8 = 19;\n\nimpl BitAnd\u003cu8\u003e for OutputTypes {\n    type Output = bool;\n    fn bitand(self, rhs: u8) -\u003e Self::Output {\n        let is_set = match self {\n            Self::PKH =\u003e rhs \u0026 1,\n            Self::SH =\u003e rhs \u0026 2,\n            Self::WPKH =\u003e rhs \u0026 4,\n            Self::WSH =\u003e rhs \u0026 16,\n            Self::TR =\u003e rhs \u0026 32,\n        };\n        is_set != 0\n    }\n}\n\n/// A backend capable of holding multiple BIP158 compact block filters\npub struct BlockFilterBackend {\n    /// Which outputs types we index\n    whitelisted_outputs: u8,\n    /// Whether we index inputs (if true, all outpoints being spent are added to the filter)\n    index_inputs: bool,\n    /// Whether we index txids. If true, all txids are added to the filter. This is useful for\n    /// using floresta as a lightning node backend\n    index_txids: bool,\n    /// A persistence engine for our filters\n    storage: Box\u003cdyn BlockFilterStore\u003e,\n    /// The first half of the siphash key\n    k0: u64,\n    /// The second half of the siphash key\n    k1: u64,\n    /// A block hash used to salt the siphash, we use a random hash instead of\n    /// an actual block hash\n    key: [u8; 32],\n}\n\n/// Keeps track of a unfinnished BIP-158 block filter. We use this to add new elements\n/// to the filter, until there's nothing more to add\nstruct FilterBuilder\u003c'a\u003e {\n    writer: GCSFilterWriter\u003c'a\u003e,\n}\n\nimpl\u003c'a\u003e FilterBuilder\u003c'a\u003e {\n    #[allow(non_snake_case)]\n    pub fn new(writer: \u0026'a mut dyn Write, M: u64, P: u8, k0: u64, k1: u64) -\u003e FilterBuilder {\n        let writer = GCSFilterWriter::new(writer, k0, k1, M, P);\n        FilterBuilder { writer }\n    }\n    /// Add a new slice to the filter\n    pub fn put(\u0026mut self, el: \u0026[u8]) {\n        self.writer.add_element(el);\n    }\n    /// Mark a filter as finished, writing the filter content into the internal buffer\n    ///\n    /// This method should be called only once, and no more elements should be added after\n    /// calling this method.\n    pub fn finish(\u0026mut self) -\u003e Result\u003cusize, bip158::Error\u003e {\n        Ok(self.writer.finish()?)\n    }\n}\n\nimpl BlockFilterBackend {\n    /// Creates a new [BlockFilterBackend].\n    ///\n    /// Storage is a database used for storing and retrieving filters. May be anything\n    /// that implements [BlockFilterStore].\n    /// Key is a 256-bytes element that'll be used as key for the siphash iside our filters.\n    /// BIP-158 defines this key as the hash of each block, since they need a public parameter,\n    /// and a fixed one may be exploited by bad actors trying to trick a wallet into having many\n    /// false-positives. Since we don' need a public parameter here, a once-initialized random\n    /// slice is enought.\n    pub fn new(storage: Box\u003cdyn BlockFilterStore\u003e, key: [u8; 32]) -\u003e BlockFilterBackend {\n        let mut k0 = [0_u8; 8];\n        let mut k1 = [0_u8; 8];\n\n        k0.copy_from_slice(\u0026key[0..8]);\n        k1.copy_from_slice(\u0026key[8..16]);\n\n        BlockFilterBackend {\n            whitelisted_outputs: ALL_OUTPUTS,\n            index_inputs: true,\n            index_txids: true,\n            storage,\n            key,\n            k0: u64::from_le_bytes(k0),\n            k1: u64::from_le_bytes(k1),\n        }\n    }\n    /// Returns a given filter\n    pub fn get_filter(\u0026self, block_height: u32) -\u003e Option\u003cbip158::BlockFilter\u003e {\n        self.storage.get_filter(block_height as u64)\n    }\n\n    /// Build and index a given block height\n    pub fn filter_block(\u0026self, block: \u0026Block, block_height: u64) -\u003e Result\u003c(), bip158::Error\u003e {\n        let mut writer = Vec::new();\n        let mut filter = FilterBuilder::new(\u0026mut writer, FILTER_M, FILTER_P, self.k0, self.k1);\n\n        if self.index_inputs {\n            self.write_inputs(\u0026block.txdata, \u0026mut filter);\n        }\n\n        if self.index_txids {\n            self.write_txids(\u0026block.txdata, \u0026mut filter);\n        }\n\n        self.write_outputs(\u0026block.txdata, \u0026mut filter);\n        filter.finish()?;\n\n        let filter = BlockFilter::new(writer.as_slice());\n\n        self.storage.put_filter(block_height, filter);\n        Ok(())\n    }\n\n    /// Maches a set of filters against out current set of filters\n    ///\n    /// This function will run over each filter inside the range `[start, end]` and sees\n    /// if at least one query mathes. It'll return a vector of block heights where it matches.\n    /// you should download those blocks and see what if there's anything interesting.\n    pub fn match_any(\u0026self, start: u64, end: u64, query: \u0026[QueryType]) -\u003e Option\u003cVec\u003cu64\u003e\u003e {\n        let mut blocks = Vec::new();\n        let key = BlockHash::from_byte_array(self.key);\n        let values = query\n            .iter()\n            .map(|filter| filter.as_slice())\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        for i in start..=end {\n            if let Some(result) = self.storage.get_filter(i) {\n                let result = result.match_any(\u0026key, \u0026mut values.iter().copied()).ok()?;\n                if result {\n                    blocks.push(i);\n                }\n            }\n        }\n        Some(blocks)\n    }\n\n    fn write_txids(\u0026self, txs: \u0026Vec\u003cTransaction\u003e, filter: \u0026mut FilterBuilder) {\n        for tx in txs {\n            filter.put(tx.txid().as_byte_array());\n        }\n    }\n\n    fn write_inputs(\u0026self, txs: \u0026Vec\u003cTransaction\u003e, filter: \u0026mut FilterBuilder) {\n        for tx in txs {\n            tx.input.iter().for_each(|input| {\n                let mut ser_input = [0; 36];\n                ser_input[0..32].clone_from_slice(input.previous_output.txid.as_byte_array());\n                ser_input[32..].clone_from_slice(\u0026input.previous_output.vout.to_be_bytes());\n                filter.put(\u0026ser_input);\n            })\n        }\n    }\n\n    fn write_tx_outs(\u0026self, tx: \u0026Transaction, filter: \u0026mut FilterBuilder) {\n        for output in tx.output.iter() {\n            let hash = floresta_common::get_spk_hash(\u0026output.script_pubkey);\n            if OutputTypes::PKH \u0026 self.whitelisted_outputs \u0026\u0026 output.script_pubkey.is_p2pkh() {\n                filter.put(hash.as_byte_array());\n            }\n            if OutputTypes::SH \u0026 self.whitelisted_outputs \u0026\u0026 output.script_pubkey.is_p2sh() {\n                filter.put(hash.as_byte_array());\n            }\n            if OutputTypes::WPKH \u0026 self.whitelisted_outputs \u0026\u0026 output.script_pubkey.is_p2wpkh() {\n                filter.put(hash.as_byte_array());\n            }\n            if OutputTypes::WSH \u0026 self.whitelisted_outputs \u0026\u0026 output.script_pubkey.is_p2wsh() {\n                filter.put(hash.as_byte_array());\n            }\n            if OutputTypes::TR \u0026 self.whitelisted_outputs \u0026\u0026 output.script_pubkey.is_p2tr() {\n                filter.put(hash.as_byte_array());\n            }\n        }\n    }\n\n    fn write_outputs(\u0026self, txs: \u0026Vec\u003cTransaction\u003e, filter: \u0026mut FilterBuilder) {\n        for tx in txs {\n            self.write_tx_outs(tx, filter);\n        }\n    }\n}\n\nimpl BlockConsumer for BlockFilterBackend {\n    fn consume_block(\u0026self, block: \u0026Block, height: u32) {\n        if let Err(e) = self.filter_block(block, height as u64) {\n            error!(\"while creating filter for block {height}: {e}\");\n        }\n    }\n}\n/// Builds a block filter backend with an interactive builder.\n///\n/// The only thing required is a database to save the filters.\n/// Fields have the same meaning as in the backend itself.\n#[derive(Default)]\npub struct FilterBackendBuilder {\n    /// Where we should store our filter.\n    storage: Option\u003cBox\u003cdyn BlockFilterStore\u003e\u003e,\n    /// What types of outputs should we store.\n    whitelisted_outputs: u8,\n    /// Whether we should save outpoints being spent to the filter\n    index_input: bool,\n    /// Whether we should save the id for transactions in this block\n    index_txids: bool,\n    /// The siphash key we should use\n    key: [u8; 32],\n}\n\nimpl FilterBackendBuilder {\n    /// Which storage we should use for our filters\n    ///\n    /// This is the only required field.\n    pub fn use_storage(mut self, s: Box\u003cdyn BlockFilterStore\u003e) -\u003e Self {\n        self.storage.replace(s);\n        self\n    }\n    /// Add one address type to the set of outputs we follow\n    ///\n    /// You can use whatever number of types, including all. But any new type\n    /// makes the filter larger.\n    pub fn add_address_type(mut self, out_type: OutputTypes) -\u003e Self {\n        match out_type {\n            OutputTypes::PKH =\u003e self.whitelisted_outputs |= 1,\n            OutputTypes::SH =\u003e self.whitelisted_outputs |= 2,\n            OutputTypes::WPKH =\u003e self.whitelisted_outputs |= 4,\n            OutputTypes::WSH =\u003e self.whitelisted_outputs |= 16,\n            OutputTypes::TR =\u003e self.whitelisted_outputs |= 32,\n        };\n        self\n    }\n    /// Whether we should index txids\n    ///\n    /// You can use this index to fetch arbitrary outpoints, like a lightning\n    /// channel. In general, this should be used in combination with index_input,\n    /// or you can't be sure whether the outpoint is spent or not.\n    pub fn index_txids(mut self, index: bool) -\u003e Self {\n        self.index_txids = index;\n        self\n    }\n    /// Whether we index inputs\n    ///\n    /// If true, we add the prevout, but not the previous spk or scriptSig\n    pub fn index_input(mut self, index: bool) -\u003e Self {\n        self.index_input = index;\n        self\n    }\n    /// A key used by siphash\n    ///\n    /// BIP-158 uses the block hash, but we use a fixed by here, so we don't\n    /// need to access chaindata on query\n    pub fn key_hash(mut self, key: [u8; 32]) -\u003e Self {\n        self.key = key;\n        self\n    }\n    /// Builds the final backend\n    ///\n    /// # Panics\n    /// Panics if we don't have a storage\n    pub fn build(self) -\u003e BlockFilterBackend {\n        let mut k0 = [0_u8; 8];\n        let mut k1 = [0_u8; 8];\n\n        k0.copy_from_slice(\u0026self.key[0..8]);\n        k1.copy_from_slice(\u0026self.key[8..16]);\n\n        BlockFilterBackend {\n            key: self.key,\n            whitelisted_outputs: self.whitelisted_outputs,\n            index_inputs: self.index_input,\n            index_txids: self.index_txids,\n            storage: self.storage.expect(\"No filter storage specified\"),\n            k0: u64::from_le_bytes(k0),\n            k1: u64::from_le_bytes(k1),\n        }\n    }\n}\n\n/// A serialized output that can be queried against our filter\n#[derive(Debug)]\npub struct QueriableOutpoint(pub(crate) [u8; 36]);\n\nimpl From\u003cOutPoint\u003e for QueriableOutpoint {\n    fn from(value: OutPoint) -\u003e Self {\n        let mut ser_input = [0; 36];\n        ser_input[0..32].clone_from_slice(value.txid.as_byte_array());\n        ser_input[32..].clone_from_slice(\u0026value.vout.to_be_bytes());\n        QueriableOutpoint(ser_input)\n    }\n}\n\n/// The type of value we are looking for in a filter.\n#[derive(Debug)]\npub enum QueryType {\n    /// We are looking for a specific outpoint being spent\n    Input(QueriableOutpoint),\n    /// We're looking for a script hash receiving money (not spending)\n    ScriptHash([u8; 32]),\n    /// A transaction with a specific it\n    Txid(Txid),\n}\n\nimpl QueryType {\n    pub(crate) fn as_slice(\u0026self) -\u003e \u0026[u8] {\n        match self {\n            QueryType::Txid(txid) =\u003e txid.as_byte_array().as_slice(),\n            QueryType::Input(outpoint) =\u003e \u0026outpoint.0,\n            QueryType::ScriptHash(script) =\u003e script,\n        }\n    }\n}\n\n#[doc(hidden)]\n#[cfg(test)]\nuse std::cell::RefCell;\n\n/// A volatile block filters store used for tests\n#[cfg(test)]\n#[doc(hidden)]\n#[derive(Debug, Default)]\npub struct MemoryBlockFilterStorage {\n    filters: RefCell\u003cVec\u003cbip158::BlockFilter\u003e\u003e,\n}\n\n#[cfg(test)]\n#[doc(hidden)]\nunsafe impl Sync for MemoryBlockFilterStorage {}\n\n#[doc(hidden)]\n#[cfg(test)]\nimpl BlockFilterStore for MemoryBlockFilterStorage {\n    fn get_filter(\u0026self, block_height: u64) -\u003e Option\u003cbip158::BlockFilter\u003e {\n        self.filters.borrow().get(block_height as usize).cloned()\n    }\n    fn put_filter(\u0026self, _block_height: u64, block_filter: bip158::BlockFilter) {\n        self.filters.borrow_mut().push(block_filter);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::str::FromStr;\n\n    use bitcoin::consensus::deserialize;\n    use bitcoin::hashes::hex::FromHex;\n    use bitcoin::hashes::Hash;\n    use bitcoin::Block;\n    use bitcoin::BlockHash;\n    use bitcoin::OutPoint;\n    use bitcoin::ScriptBuf;\n    use bitcoin::Txid;\n\n    use super::BlockFilterBackend;\n    use super::FilterBuilder;\n    use super::MemoryBlockFilterStorage;\n    use crate::bip158;\n    use crate::QueryType;\n    #[test]\n    fn test_filter() {\n        let mut writer = Vec::new();\n        let value = [10_u8; 42].as_slice();\n        let mut filters = FilterBuilder::new(\u0026mut writer, 784931, 19, 0, 0);\n\n        filters.put(value);\n        filters.finish().unwrap();\n\n        let filter = bip158::BlockFilter::new(\u0026writer);\n        let res = filter\n            .match_any(\n                \u0026BlockHash::from_byte_array([0; 32]),\n                \u0026mut [value].iter().copied(),\n            )\n            .unwrap();\n        assert!(res);\n\n        let value = [11_u8; 42].as_slice();\n        let res = filter\n            .match_any(\n                \u0026BlockHash::from_byte_array([0; 32]),\n                \u0026mut [value].iter().copied(),\n            )\n            .unwrap();\n        assert!(!res);\n    }\n\n    #[test]\n    fn test_filter_block() {\n        let block = Vec::from_hex(\"000000204cc1f0cc52950600bc94fc482713c1f10174c85f20290168832552c1b900000039d96a9dbab5998c344c092583552e6ed5e2884c8a52a95b482f59413f39e8d55cf03f654454011e7d45dc0003020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff0f030b8d020a2f7369676e65743a332ffeffffff025503062a010000002251207099e4b23427fc40ba4777bbf52cfd0b7444d69a3e21ef281270723f54c0c14b0000000000000000776a24aa21a9edfb6e452f1cccc00da281067a88bed1d9ec6e02361d424dfd46dc46972b6c22284c4fecc7daa249004730440220435eaca92f93497d07825fe4587183272084e257c61cccab15a1dbc37a946699022000c18b0cba4f96ab5f741478da264b361ba95523a486126657b6f9e1045126a20100012000000000000000000000000000000000000000000000000000000000000000000000000002000000000101125b54a68d9a39561dd268e020e3f26dd900ded46a3dfdbae7ea95797022a0a80100000000fdffffff027082030000000000160014fabea557d8541249533fe281aac45c37b2dbf3422dab090000000000220020dfcc1d4c1fef729015420efed6202f7d1fd1a74813f7875fa235413bd36f73d20800483045022100dce01d603f84de4faeacd7bcdf1bc93fdc3cb7a28eff0544d88c1b64fa07f8d602206aefc00419126035222e5138b07b40d77c71feba78c26d4febd51f10f814dff101483045022100bf7c25066c5c4abb2d2733cf04c700b175d5e92d09e5931313adaef05e062758022001cf4bb4437a0a20b6ff9277c29a2b28259c1a6143fd4938920cae7a8a3658350147304402206f3d38a3f4db843a41f22583cfd344b935156fa0e82afe7212f8861fc04d979c0220726324a84cb6906df296416a00032e0c8238df0f4cf8e7204385f2cdd359056301483045022100fb3a30dc1103ba0b865d96bd9097a264c0e18aeffb2a4ee0875c0edea356cb6c022070e47aac3b0ed218a9afbc7f70d42935084a80f47af44941a6712314b3391b50010000fdea016376a914a2c0c43c1cbc4c3d1f5d197000414de73e76456388ac6b76a914bf51072415ece1527ac34d955924be96d07cbde788ac6c936b76a91425fb796fb6194fe09ab2b06344bace2b9320d45c88ac6c936b76a914a6cb8313859649a1b83dc9b77c3afe7671affe0b88ac6c93518803ffff00b2676376a914c209f7a523ffa69a7226c5a5167b2b37ddec58eb88ac6b76a914d61ff559b874d8833b75b7d6939b0df3e68b583d88ac6c936b76a91444b6c96c823cb70c130bd12ee39b5504d6be84cc88ac6c936b76a914f086890b09e618632f45a3511c5983dafb2e714a88ac6c93528854b267542102a31ccbcc7262f1cf9ee85bf04723d28d5cdebdaa98fa0b972fd5210610c6aaba2102a9b90ff89fa8a411c7e8f1af247ba6e32c6d4d4e682d643eb30a02841dae2a962103b8c2b5e5db7603cb0b3a5280941988588af0f71362321442f228fb2b4a38cbd921022da633f9e545cc1029055cafa583b4cd99b7a4bcfb1ea2a388fbefb11e0c8b9054ae736476a91443948748fc4e5a8300ea3eee7feafad9cdd4a3c588ac6b76a91447f5b0296d7b9dd38b64d45b3ef88490847d17ad88ac6c936b76a914f2b7716f6e11b214457c38c501b7a0f7706e06aa88ac6c936b76a91443587cfdb6e2bace0de537152e1ffa8e8d77d91a88ac6c93538852b268686800000000020000000001013b12458f060f8df025c0ab068695384bcc6c846aefed31b0d203122ee09c71100100000000feffffff02ef8b64d04a0600001600147f5eeef1c2a1c5c81ee1545876c8f8fc93d0c1e6a086010000000000160014a9c03ef086c4d0c9fe2d093a4e1f28dff63c0f700247304402205e1935e762a89e99b9185e540ad0a1800d26a9643599d28c4e8619432f04abc802200a3fedf0746f127884b74087561d3190c408afda770bd5aeb3928bb7a4d61832012103b5746579fa0f79ed83dfd6a2142d957156a89690fcb76ed90debdf287b9bc94bb98c0200\").unwrap();\n\n        let block: Block = deserialize(\u0026block).unwrap();\n        let storage = MemoryBlockFilterStorage::default();\n        let backend =\n            BlockFilterBackend::new(Box::new(storage), block.block_hash().to_byte_array());\n\n        backend.filter_block(\u0026block, 0).unwrap();\n\n        // One txid from this block\n        let txid =\n            Txid::from_str(\"7e0ce903920704a79beb99beb05c6d5a01852907dccc0973f96eb295d1ad0557\")\n                .unwrap();\n        let txid = QueryType::Txid(txid);\n\n        // One output being spent in this block\n        let prev_txid =\n            Txid::from_str(\"a8a022707995eae7bafd3d6ad4de00d96df2e320e068d21d56399a8da6545b12\")\n                .unwrap();\n        let prev_vout: u32 = 1;\n\n        let prevout = QueryType::Input(\n            OutPoint {\n                txid: prev_txid,\n                vout: prev_vout,\n            }\n            .into(),\n        );\n        // One spk from this block\n        let spck = ScriptBuf::from_hex(\"0014fabea557d8541249533fe281aac45c37b2dbf342\").unwrap();\n        let spck = QueryType::ScriptHash(floresta_common::get_spk_hash(\u0026spck).to_byte_array());\n\n        let expected = Some(vec![0]);\n\n        assert_eq!(backend.match_any(0, 0, \u0026[txid]), expected);\n        assert_eq!(backend.match_any(0, 0, \u0026[prevout]), expected);\n        assert_eq!(backend.match_any(0, 0, \u0026[spck]), expected);\n    }\n}\n","traces":[{"line":64,"address":[1013872],"length":1,"stats":{"Line":1},"fn_name":"bitand"},{"line":65,"address":[1013890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[1013927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[1013939],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[1013951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[1013963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[1013975],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[1013981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[1014903,1014320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[1014360],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[1014385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[1014394,1014501],"length":1,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[1014534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[1014702],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[1014775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[1014944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[1014967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[1014992,1015641],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[1015048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[1015077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[1015167],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[1015242,1015201],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[1015178],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[1015281],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[1015259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[1015303,1015405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[1015374,1015496],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[1015513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[1015574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[1016907,1015680,1016956],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[1015777],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[1015826],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[1015923],"length":1,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[1030393,1030368],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":188,"address":[1016936,1016016,1016083,1016298],"length":1,"stats":{"Line":4},"fn_name":null},{"line":189,"address":[1016319,1016367],"length":1,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[1016561,1015737,1016444,1016787],"length":1,"stats":{"Line":3},"fn_name":null},{"line":191,"address":[1016773],"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[1016817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[1016208],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[1016992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[1017089,1017027],"length":1,"stats":{"Line":2},"fn_name":null},{"line":201,"address":[1017099],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[1017152],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[1017244,1017182],"length":1,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[1017254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[1030449],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[1030466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[1030566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[1030676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[1017312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[1017451,1017357],"length":1,"stats":{"Line":2},"fn_name":null},{"line":218,"address":[1017469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[1017485,1017547],"length":1,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[1017570],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[1017515,1017638],"length":1,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[1017661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[1017606,1017729],"length":1,"stats":{"Line":2},"fn_name":null},{"line":226,"address":[1017752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[1017697,1017823],"length":1,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[1017846],"length":1,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[1017882,1017788],"length":1,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[1017908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[1017952],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[1017994,1018066],"length":1,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[1018076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[1018096,1018745],"length":1,"stats":{"Line":0},"fn_name":"consume_block"},{"line":246,"address":[1018131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[1018630,1018403,1018343,1018229],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[1018988,1018816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[1018877,1018936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[1018968],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[1019024],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[1019048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[1019085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[1019100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[1019115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[1019130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[1019145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[1019163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[1019184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[1019207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[1019212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[1019232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[1019255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[1019260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[1019280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[1019288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[1019302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[1019328,1019987],"length":1,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[1019358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[1019383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[1019499,1019392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[1019532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[1019643],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[1019666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[1019673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[1019680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[1019687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[1019765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[1019838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[1020032],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":344,"address":[1020054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":345,"address":[1020071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":346,"address":[1020165],"length":1,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[1020270],"length":1,"stats":{"Line":1},"fn_name":null},{"line":363,"address":[1020336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":364,"address":[1020479,1020350],"length":1,"stats":{"Line":2},"fn_name":null},{"line":365,"address":[1020447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[1020387],"length":1,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[1020417],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":77,"coverable":117},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-compact-filters","src","network_filters.rs"],"content":"use std::sync::PoisonError;\nuse std::sync::RwLock;\nuse std::sync::RwLockWriteGuard;\n\nuse bitcoin::BlockHash;\nuse floresta_chain::pruned_utreexo::BlockchainInterface;\n\nuse crate::BlockFilterStore;\n\n#[derive(Debug)]\npub struct NetworkFilters\u003cStorage: BlockFilterStore + Send + Sync\u003e {\n    filters: Storage,\n    height: RwLock\u003cu32\u003e,\n}\n\nimpl\u003cStorage: BlockFilterStore + Send + Sync\u003e NetworkFilters\u003cStorage\u003e {\n    pub fn new(filters: Storage, height: u32) -\u003e Self {\n        Self {\n            filters,\n            height: RwLock::new(height),\n        }\n    }\n\n    pub fn get_filter(\u0026self, height: u32) -\u003e Option\u003ccrate::BlockFilter\u003e {\n        self.filters.get_filter(height as u64)\n    }\n\n    pub fn match_any(\n        \u0026self,\n        query: Vec\u003c\u0026[u8]\u003e,\n        start_height: u32,\n        end_height: u32,\n        chain: impl BlockchainInterface,\n    ) -\u003e Vec\u003cBlockHash\u003e {\n        let mut blocks = Vec::new();\n        for height in start_height..end_height {\n            let Some(filter) = self.filters.get_filter(height as u64) else {\n                continue;\n            };\n\n            let mut query = query.clone().into_iter();\n            let hash = chain.get_block_hash(height).unwrap();\n\n            if filter.match_any(\u0026hash, \u0026mut query).unwrap() {\n                let block_hash = chain.get_block_hash(height).unwrap();\n                blocks.push(block_hash);\n            }\n        }\n\n        blocks\n    }\n\n    pub fn push_filter(\n        \u0026self,\n        height: u32,\n        filter: crate::BlockFilter,\n    ) -\u003e Result\u003c(), PoisonError\u003cRwLockWriteGuard\u003cu32\u003e\u003e\u003e {\n        self.filters.put_filter(height as u64, filter);\n        self.height.write().map(|mut self_height| {\n            *self_height = height;\n        })\n    }\n\n    pub fn get_height(\u0026self) -\u003e u32 {\n        self.height.read().map(|height| *height).unwrap_or(0)\n    }\n}\n","traces":[{"line":17,"address":[3901488,3901616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[5038380],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[5037888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[5037908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[3901648,3902668,3902622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[5038560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[3902617,3901785,3901866,3901967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[3901982,3902072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[5039076,5038994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[3902259,3902324],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[5038112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":21},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-electrum","src","electrum_protocol.rs"],"content":"use std::borrow::Borrow;\nuse std::collections::HashMap;\nuse std::collections::HashSet;\nuse std::sync::Arc;\n\nuse async_std::channel::unbounded;\nuse async_std::channel::Receiver;\nuse async_std::channel::Sender;\nuse async_std::io::BufReader;\nuse async_std::net::TcpListener;\nuse async_std::net::TcpStream;\nuse async_std::prelude::*;\nuse async_std::sync::RwLock;\nuse bitcoin::consensus::deserialize;\nuse bitcoin::consensus::encode::serialize_hex;\nuse bitcoin::hashes::hex::FromHex;\nuse bitcoin::hashes::sha256;\nuse bitcoin::ScriptBuf;\nuse bitcoin::Transaction;\nuse bitcoin::TxOut;\nuse bitcoin::Txid;\nuse floresta_chain::pruned_utreexo::BlockchainInterface;\nuse floresta_common::get_hash_from_u8;\nuse floresta_common::get_spk_hash;\nuse floresta_common::spsc::Channel;\nuse floresta_compact_filters::kv_filter_database::KvFilterStore;\nuse floresta_compact_filters::network_filters::NetworkFilters;\nuse floresta_watch_only::kv_database::KvDatabase;\nuse floresta_watch_only::AddressCache;\nuse floresta_watch_only::CachedTransaction;\nuse floresta_wire::node_interface::NodeInterface;\nuse floresta_wire::node_interface::NodeMethods;\nuse log::error;\nuse log::info;\nuse log::trace;\nuse serde_json::json;\nuse serde_json::Value;\n\nuse crate::get_arg;\nuse crate::json_rpc_res;\nuse crate::request::Request;\n\n/// Type alias for u32 representing a ClientId\ntype ClientId = u32;\n\n/// A client connected to the server\n#[derive(Debug, Clone)]\npub struct Client {\n    client_id: ClientId,\n    _addresses: HashSet\u003cScriptBuf\u003e,\n    stream: Arc\u003cTcpStream\u003e,\n}\n\nimpl Client {\n    /// Send a message to the client, should be a serialized JSON\n    pub async fn write(\u0026self, data: \u0026[u8]) -\u003e Result\u003c(), std::io::Error\u003e {\n        let mut stream = self.stream.as_ref();\n        let _ = stream.write(data).await;\n        let _ = stream.write('\\n'.to_string().as_bytes()).await;\n\n        Ok(())\n    }\n    /// Create a new client from a stream\n    pub fn new(client_id: ClientId, stream: Arc\u003cTcpStream\u003e) -\u003e Self {\n        Client {\n            client_id,\n            _addresses: HashSet::new(),\n            stream,\n        }\n    }\n}\n\npub enum Message {\n    /// A new client just connected to the server\n    NewClient((ClientId, Arc\u003cClient\u003e)),\n    /// Some client just sent a message\n    Message((ClientId, String)),\n    /// A client just disconnected\n    Disconnect(ClientId),\n}\n\npub struct ElectrumServer\u003cBlockchain: BlockchainInterface\u003e {\n    /// The blockchain backend we are using. This will be used to query\n    /// blockchain information and broadcast transactions.\n    pub chain: Arc\u003cBlockchain\u003e,\n    /// The address cache is used to store addresses and transactions, like a\n    /// watch-only wallet, but it is adapted to the electrum protocol.\n    pub address_cache: Arc\u003cRwLock\u003cAddressCache\u003cKvDatabase\u003e\u003e\u003e,\n    /// The TCP listener is used to accept new connections to our server.\n    pub tcp_listener: Arc\u003cTcpListener\u003e,\n    /// The clients are the clients connected to our server, we keep track of them\n    /// using a unique id.\n    pub clients: HashMap\u003cClientId, Arc\u003cClient\u003e\u003e,\n    /// The message_receiver receive messages and handles them.\n    pub message_receiver: Receiver\u003cMessage\u003e,\n    /// The message_transmitter is used to send requests from clients or notifications\n    /// like new or dropped clients\n    pub message_transmitter: Sender\u003cMessage\u003e,\n    /// The client_addresses is used to keep track of the addresses of each client.\n    /// We keep the script_hash and which client has it, so we can notify the\n    /// clients when a new transaction is received.\n    pub client_addresses: HashMap\u003csha256::Hash, Arc\u003cClient\u003e\u003e,\n    /// A Arc-ed copy of the block filters backend that we can use to check if a\n    /// block contains a transaction that we are interested in.\n    pub block_filters: Option\u003cArc\u003cNetworkFilters\u003cKvFilterStore\u003e\u003e\u003e,\n    /// An interface to a running node, used to broadcast transactions and request\n    /// blocks.\n    pub node_interface: Arc\u003cNodeInterface\u003e,\n    /// A list of addresses that we've just learned about and need to rescan for\n    /// transactions.\n    ///\n    /// We accumulate those addresses here and then periodically\n    /// scan, since a wallet will often send multiple addresses, but\n    /// in different requests.\n    pub addresses_to_scan: Vec\u003csha256::Hash\u003e,\n}\n\nimpl\u003cBlockchain: BlockchainInterface\u003e ElectrumServer\u003cBlockchain\u003e {\n    pub async fn new(\n        address: String,\n        address_cache: Arc\u003cRwLock\u003cAddressCache\u003cKvDatabase\u003e\u003e\u003e,\n        chain: Arc\u003cBlockchain\u003e,\n        block_filters: Option\u003cArc\u003cNetworkFilters\u003cKvFilterStore\u003e\u003e\u003e,\n        node_interface: Arc\u003cNodeInterface\u003e,\n    ) -\u003e Result\u003cElectrumServer\u003cBlockchain\u003e, Box\u003cdyn std::error::Error\u003e\u003e {\n        let listener = Arc::new(TcpListener::bind(address).await?);\n        let (tx, rx) = unbounded();\n        let unconfirmed = address_cache.read().await.find_unconfirmed().unwrap();\n        for tx in unconfirmed {\n            chain.broadcast(\u0026tx).expect(\"Invalid chain\");\n        }\n        Ok(ElectrumServer {\n            chain,\n            address_cache,\n            block_filters,\n            node_interface,\n            tcp_listener: listener,\n            clients: HashMap::new(),\n            message_receiver: rx,\n            message_transmitter: tx,\n            client_addresses: HashMap::new(),\n            addresses_to_scan: Vec::new(),\n        })\n    }\n\n    /// Handle a request from a client. All methods are defined in the electrum\n    /// protocol.\n    pub async fn handle_client_request(\n        \u0026mut self,\n        client: Arc\u003cClient\u003e,\n        request: Request,\n    ) -\u003e Result\u003cValue, super::error::Error\u003e {\n        // Methods are in alphabetical order\n        match request.method.as_str() {\n            \"blockchain.block.header\" =\u003e {\n                let height = get_arg!(request, u64, 0);\n                let hash = self\n                    .chain\n                    .get_block_hash(height as u32)\n                    .map_err(|_| super::error::Error::InvalidParams)?;\n                let header = self\n                    .chain\n                    .get_block_header(\u0026hash)\n                    .map_err(|e| super::error::Error::Blockchain(Box::new(e)))?;\n                let header = serialize_hex(\u0026header);\n                json_rpc_res!(request, header)\n            }\n            \"blockchain.block.headers\" =\u003e {\n                let start_height = get_arg!(request, u64, 0);\n                let count = get_arg!(request, u64, 1);\n                let mut headers = String::new();\n                let count = if count \u003c 2016 { count } else { 2016 };\n                for height in start_height..(start_height + count) {\n                    let hash = self\n                        .chain\n                        .get_block_hash(height as u32)\n                        .map_err(|_| super::error::Error::InvalidParams)?;\n\n                    let header = self\n                        .chain\n                        .get_block_header(\u0026hash)\n                        .map_err(|e| super::error::Error::Blockchain(Box::new(e)))?;\n                    let header = serialize_hex(\u0026header);\n                    headers.push_str(\u0026header);\n                }\n                json_rpc_res!(request, {\n                    \"count\": count,\n                    \"hex\": headers,\n                    \"max\": 2016\n                })\n            }\n            \"blockchain.estimatefee\" =\u003e json_rpc_res!(request, 0.0001),\n            \"blockchain.headers.subscribe\" =\u003e {\n                let (height, hash) = self\n                    .chain\n                    .get_best_block()\n                    .map_err(|e| super::error::Error::Blockchain(Box::new(e)))?;\n                let header = self\n                    .chain\n                    .get_block_header(\u0026hash)\n                    .map_err(|e| super::error::Error::Blockchain(Box::new(e)))?;\n                let result = json!({\n                    \"height\": height,\n                    \"hex\": serialize_hex(\u0026header)\n                });\n                json_rpc_res!(request, result)\n            }\n            // TODO: Ask Backend for fees\n            \"blockchain.relayfee\" =\u003e json_rpc_res!(request, 0.00001),\n            \"blockchain.scripthash.get_balance\" =\u003e {\n                let script_hash = get_arg!(request, sha256::Hash, 0);\n                let balance = self\n                    .address_cache\n                    .read()\n                    .await\n                    .get_address_balance(\u0026script_hash);\n                let result = json!({\n                    \"confirmed\": balance,\n                    \"unconfirmed\": 0\n                });\n                json_rpc_res!(request, result)\n            }\n            \"blockchain.scripthash.get_history\" =\u003e {\n                let script_hash = get_arg!(request, sha256::Hash, 0);\n                self.address_cache\n                    .read()\n                    .await\n                    .get_address_history(\u0026script_hash)\n                    .map(|transactions| {\n                        let res = Self::process_history(\u0026transactions);\n                        json_rpc_res!(request, res)\n                    })\n                    .unwrap_or_else(|| {\n                        Ok(json!({\n                            \"jsonrpc\": \"2.0\",\n                            \"result\": null,\n                            \"id\": request.id\n                        }))\n                    })\n            }\n            \"blockchain.scripthash.get_mempool\" =\u003e json_rpc_res!(request, []),\n            \"blockchain.scripthash.listunspent\" =\u003e {\n                let hash = get_arg!(request, sha256::Hash, 0);\n                let utxos = self.address_cache.read().await.get_address_utxos(\u0026hash);\n                if utxos.is_none() {\n                    return json_rpc_res!(request, []);\n                }\n                let mut final_utxos = Vec::new();\n                for (utxo, prevout) in utxos.unwrap().into_iter() {\n                    let height = self\n                        .address_cache\n                        .read()\n                        .await\n                        .get_height(\u0026prevout.txid)\n                        .unwrap();\n\n                    let position = self\n                        .address_cache\n                        .read()\n                        .await\n                        .get_position(\u0026prevout.txid)\n                        .unwrap();\n\n                    final_utxos.push(json!({\n                        \"height\": height,\n                        \"tx_pos\": position,\n                        \"tx_hash\": prevout.txid,\n                        \"value\": utxo.value\n                    }));\n                }\n\n                json_rpc_res!(request, final_utxos)\n            }\n            \"blockchain.scripthash.subscribe\" =\u003e {\n                let hash = get_arg!(request, sha256::Hash, 0);\n                self.client_addresses.insert(hash, client);\n\n                let history = self.address_cache.read().await.get_address_history(\u0026hash);\n                match history {\n                    Some(transactions) if !transactions.is_empty() =\u003e {\n                        let res = get_status(transactions);\n                        json_rpc_res!(request, res)\n                    }\n                    Some(_) =\u003e {\n                        json_rpc_res!(request, null)\n                    }\n                    None =\u003e {\n                        self.addresses_to_scan.push(hash);\n                        json_rpc_res!(request, null)\n                    }\n                }\n            }\n            \"blockchain.scripthash.unsubscribe\" =\u003e {\n                let address = get_arg!(request, sha256::Hash, 0);\n                self.client_addresses.remove(\u0026address);\n                json_rpc_res!(request, true)\n            }\n            \"blockchain.transaction.broadcast\" =\u003e {\n                let tx = get_arg!(request, String, 0);\n                let hex: Vec\u003c_\u003e =\n                    Vec::from_hex(\u0026tx).map_err(|_| super::error::Error::InvalidParams)?;\n                let tx: Transaction =\n                    deserialize(\u0026hex).map_err(|_| super::error::Error::InvalidParams)?;\n                self.chain\n                    .broadcast(\u0026tx)\n                    .map_err(|e| super::error::Error::Blockchain(Box::new(e)))?;\n                let id = tx.txid();\n                let updated = self\n                    .address_cache\n                    .write()\n                    .await\n                    .cache_mempool_transaction(\u0026tx)\n                    .into_iter()\n                    .map(|spend| (tx.clone(), spend))\n                    .collect::\u003cVec\u003c_\u003e\u003e();\n                self.wallet_notify(\u0026updated).await;\n                json_rpc_res!(request, id)\n            }\n            \"blockchain.transaction.get\" =\u003e {\n                let tx_id = get_arg!(request, Txid, 0);\n                let tx = self\n                    .address_cache\n                    .read()\n                    .await\n                    .get_cached_transaction(\u0026tx_id);\n                if let Some(tx) = tx {\n                    return json_rpc_res!(request, tx);\n                }\n\n                Err(super::error::Error::InvalidParams)\n            }\n            \"blockchain.transaction.get_merkle\" =\u003e {\n                let tx_id = get_arg!(request, Txid, 0);\n                let proof = self.address_cache.read().await.get_merkle_proof(\u0026tx_id);\n                let height = self.address_cache.read().await.get_height(\u0026tx_id);\n                if let Some((proof, position)) = proof {\n                    let result = json!({\n                        \"merkle\": proof,\n                        \"block_height\": height.unwrap_or(0),\n                        \"pos\": position\n                    });\n                    return json_rpc_res!(request, result);\n                }\n\n                Err(super::error::Error::InvalidParams)\n            }\n            //blockchain.transaction.id_from_pos\n            // TODO: Create an actual histogram\n            \"mempool.get_fee_histogram\" =\u003e json_rpc_res!(request, []),\n            \"server.add_peer\" =\u003e json_rpc_res!(request, true),\n            \"server.banner\" =\u003e json_rpc_res!(request, \"Welcome to Floresta's Electrum Server.\"),\n            \"server.donation_address\" =\u003e {\n                json_rpc_res!(request, \"\")\n            }\n            \"server.features\" =\u003e {\n                let genesis_hash = self\n                    .chain\n                    .get_block_hash(0)\n                    .expect(\"Genesis block should be present\");\n                let res = json!(\n                    {\n                        \"genesis_hash\": genesis_hash,\n                        \"hosts\": {\"127.0.0.1\": {\"tcp_port\": 50001}},\n                        \"protocol_max\": \"1.4\",\n                        \"protocol_min\": \"1.0\",\n                        \"pruning\": null,\n                        \"server_version\": format!(\"Floresta {}\", env!(\"CARGO_PKG_VERSION\")),\n                        \"hash_function\": \"sha256\"\n                    }\n                );\n                json_rpc_res!(request, res)\n            }\n            \"server.peers.subscribe\" =\u003e json_rpc_res!(request, []),\n            \"server.ping\" =\u003e json_rpc_res!(request, null),\n            \"server.version\" =\u003e json_rpc_res!(\n                request,\n                [format!(\"Floresta {}\", env!(\"CARGO_PKG_VERSION\")), \"1.4\"]\n            ),\n\n            _ =\u003e Err(super::error::Error::InvalidParams),\n        }\n    }\n\n    pub async fn main_loop(mut self) -\u003e Result\u003c(), crate::error::Error\u003e {\n        let blocks = Channel::new();\n        let blocks = Arc::new(blocks);\n\n        self.chain.subscribe(blocks.clone());\n\n        loop {\n            for (block, height) in blocks.recv() {\n                self.handle_block(block, height).await;\n            }\n\n            // handles client requests\n            while let Ok(request) = async_std::future::timeout(\n                std::time::Duration::from_secs(1),\n                self.message_receiver.recv(),\n            )\n            .await\n            {\n                if let Ok(message) = request {\n                    self.handle_message(message).await?;\n                }\n            }\n\n            // rescan for new addresses, if any\n            if !self.addresses_to_scan.is_empty() {\n                info!(\"Catching up with addresses {:?}\", self.addresses_to_scan);\n                let addresses: Vec\u003csha256::Hash\u003e = self.addresses_to_scan.drain(..).collect();\n                for address in addresses.iter().copied() {\n                    self.address_cache.write().await.cache_address_hash(address);\n                }\n                self.rescan_for_addresses(addresses).await?;\n            }\n        }\n    }\n\n    /// If a user adds a new address that we didn't have cached, this method\n    /// will look for historical transactions for it.\n    ///\n    /// Usually, we'll relly on compact block filters to speed things up. If\n    /// we don't have compact block filters, we may rescan using the older,\n    /// more bandwidth-intensive method of actually downloading blocks.\n    async fn rescan_for_addresses(\n        \u0026mut self,\n        addresses: Vec\u003csha256::Hash\u003e,\n    ) -\u003e Result\u003c(), super::error::Error\u003e {\n        // If compact block filters are enabled, use them. Otherwise, fallback\n        // to the \"old-school\" rescaning.\n        match \u0026self.block_filters {\n            Some(cfilters) =\u003e self.rescan_with_block_filters(cfilters, addresses).await,\n            None =\u003e self\n                .chain\n                .rescan(1)\n                .map_err(|e| super::error::Error::Blockchain(Box::new(e))),\n        }\n    }\n\n    /// If we have compact block filters enabled, this method will use them to\n    /// find blocks of interest and download for our wallet to learn about new\n    /// transactions, once a new address is added by subscription.\n    async fn rescan_with_block_filters(\n        \u0026self,\n        cfilters: \u0026Arc\u003cNetworkFilters\u003cKvFilterStore\u003e\u003e,\n        addresses: Vec\u003csha256::Hash\u003e,\n    ) -\u003e Result\u003c(), super::error::Error\u003e {\n        // By default, we look from 1..tip\n        let height = self.chain.get_height().unwrap_or(0) as u64;\n        let mut _addresses = addresses\n            .iter()\n            .map(|hash| hash.borrow())\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        // TODO (Davidson): Let users select what the starting and end height is\n        let blocks: Vec\u003c_\u003e = cfilters\n            .match_any(_addresses, 1, height as u32, self.chain.clone())\n            .into_iter()\n            .flat_map(|hash| self.node_interface.get_block(hash).ok().flatten())\n            .collect();\n\n        // Tells users about the transactions we found\n        for block in blocks {\n            let height = self\n                .chain\n                .get_block_height(\u0026block.block_hash())\n                .ok()\n                .flatten()\n                .unwrap();\n            self.handle_block(block, height).await;\n        }\n\n        Ok(())\n    }\n\n    fn process_history(transactions: \u0026[CachedTransaction]) -\u003e Vec\u003cValue\u003e {\n        let mut res = Vec::new();\n        for transaction in transactions {\n            let entry = if transaction.height == 0 {\n                json!({\n                    \"tx_hash\": transaction.hash,\n                    \"height\": transaction.height,\n                    \"fee\": 2000\n                })\n            } else {\n                json!({\n                    \"tx_hash\": transaction.hash,\n                    \"height\": transaction.height,\n                })\n            };\n\n            res.push(entry);\n        }\n        res\n    }\n\n    async fn handle_block(\u0026self, block: bitcoin::Block, height: u32) {\n        let result = json!({\n            \"jsonrpc\": \"2.0\",\n            \"method\": \"blockchain.headers.subscribe\",\n            \"params\": [{\n                \"height\": height,\n                \"hex\": serialize_hex(\u0026block.header)\n            }]\n        });\n\n        let current_height = self.address_cache.read().await.get_cache_height();\n\n        if (!self.chain.is_in_idb() || height % 1000 == 0) \u0026\u0026 (height \u003e current_height) {\n            let lock = self.address_cache.write().await;\n            lock.bump_height(height);\n        }\n\n        if self.chain.get_height().unwrap() == height {\n            for client in \u0026mut self.clients.values() {\n                let res = client\n                    .write(serde_json::to_string(\u0026result).unwrap().as_bytes())\n                    .await;\n                if res.is_err() {\n                    info!(\"Could not write to client {:?}\", client);\n                }\n            }\n        }\n\n        let transactions = self\n            .address_cache\n            .write()\n            .await\n            .block_process(\u0026block, height);\n\n        self.wallet_notify(\u0026transactions).await;\n    }\n\n    /// Handles each kind of Message\n    async fn handle_message(\u0026mut self, message: Message) -\u003e Result\u003c(), crate::error::Error\u003e {\n        match message {\n            Message::NewClient((id, client)) =\u003e {\n                self.clients.insert(id, client);\n            }\n\n            Message::Message((client, msg)) =\u003e {\n                trace!(\"Message: {msg}\");\n                if let Ok(req) = serde_json::from_str::\u003cRequest\u003e(msg.as_str()) {\n                    let client = self.clients.get(\u0026client);\n                    if client.is_none() {\n                        error!(\"Client sent a message but is not listed as client\");\n                        return Ok(());\n                    }\n                    let client = client.unwrap().to_owned();\n                    let id = req.id.to_owned();\n                    let res = self.handle_client_request(client.clone(), req).await;\n\n                    if let Ok(res) = res {\n                        client\n                            .write(serde_json::to_string(\u0026res).unwrap().as_bytes())\n                            .await?;\n                    } else {\n                        let res = json!({\n                            \"jsonrpc\": \"2.0\",\n                            \"error\": {\n                                \"code\": -32000,\n                                \"message\": \"Internal JSON-RPC error.\",\n                                \"data\": null\n                            },\n                            \"id\": id\n                        });\n                        client\n                            .write(serde_json::to_string(\u0026res).unwrap().as_bytes())\n                            .await?;\n                    }\n                } else if let Ok(requests) = serde_json::from_str::\u003cVec\u003cRequest\u003e\u003e(\u0026msg) {\n                    let mut results = Vec::new();\n                    for req in requests {\n                        let client = self.clients.get(\u0026client);\n                        if client.is_none() {\n                            error!(\"Client sent a message but is not listed as client\");\n                            return Ok(());\n                        }\n                        let client = client.unwrap().to_owned();\n                        let id = req.id.to_owned();\n                        let res = self.handle_client_request(client.clone(), req).await;\n\n                        if let Ok(res) = res {\n                            results.push(res);\n                        } else {\n                            let res = json!({\n                                \"jsonrpc\": \"2.0\",\n                                \"error\": {\n                                    \"code\": -32000,\n                                    \"message\": \"Internal JSON-RPC error.\",\n                                    \"data\": null\n                                },\n                                \"id\": id\n                            });\n                            results.push(res);\n                        }\n                    }\n                    if let Some(client) = self.clients.get(\u0026client) {\n                        client\n                            .write(serde_json::to_string(\u0026results).unwrap().as_bytes())\n                            .await?;\n                    }\n                } else {\n                    let res = json!({\n                        \"jsonrpc\": \"2.0\",\n                        \"error\": {\n                            \"code\": -32700,\n                            \"message\": \"Parse error. Invalid JSON was received by the server.\",\n                            \"data\": null\n                        },\n                        \"id\": null\n                    });\n                    if let Some(client) = self.clients.get(\u0026client) {\n                        client\n                            .write(serde_json::to_string(\u0026res).unwrap().as_bytes())\n                            .await?;\n                    }\n                }\n            }\n\n            Message::Disconnect(id) =\u003e {\n                self.clients.remove(\u0026id);\n            }\n        }\n\n        Ok(())\n    }\n\n    async fn wallet_notify(\u0026self, transactions: \u0026[(Transaction, TxOut)]) {\n        for (_, out) in transactions {\n            let hash = get_spk_hash(\u0026out.script_pubkey);\n            if let Some(client) = self.client_addresses.get(\u0026hash) {\n                let history = self.address_cache.read().await.get_address_history(\u0026hash);\n\n                let status_hash = get_status(history.unwrap());\n                let notify = json!({\n                    \"jsonrpc\": \"2.0\",\n                    \"method\": \"blockchain.scripthash.subscribe\",\n                    \"params\": [hash, status_hash]\n                });\n                if let Err(err) = client\n                    .write(serde_json::to_string(\u0026notify).unwrap().as_bytes())\n                    .await\n                {\n                    error!(\"{err}\");\n                }\n            }\n        }\n    }\n}\n\n/// Each client gets one loop to deal with their requests\nasync fn client_broker_loop(\n    client: Arc\u003cClient\u003e,\n    message_transmitter: Sender\u003cMessage\u003e,\n) -\u003e Result\u003c(), std::io::Error\u003e {\n    let mut _stream = \u0026*client.stream;\n    let mut lines = BufReader::new(_stream).lines();\n\n    while let Some(Ok(line)) = lines.next().await {\n        message_transmitter\n            .send(Message::Message((client.client_id, line)))\n            .await\n            .expect(\"Main loop is broken\");\n    }\n\n    info!(\"Lost client with ID: {}\", client.client_id);\n\n    message_transmitter\n        .send(Message::Disconnect(client.client_id))\n        .await\n        .expect(\"Main loop is broken\");\n\n    Ok(())\n}\n\n/// Listens to new TCP connections in a loop\npub async fn client_accept_loop(listener: Arc\u003cTcpListener\u003e, message_transmitter: Sender\u003cMessage\u003e) {\n    let mut id_count = 0;\n    loop {\n        if let Ok((stream, _addr)) = listener.accept().await {\n            info!(\"New client connection\");\n            let stream = Arc::new(stream);\n            let client = Arc::new(Client::new(id_count, stream));\n            async_std::task::spawn(client_broker_loop(\n                client.clone(),\n                message_transmitter.clone(),\n            ));\n\n            message_transmitter\n                .send(Message::NewClient((client.client_id, client)))\n                .await\n                .expect(\"Main loop is broken\");\n            id_count += 1;\n        }\n    }\n}\n\n/// As per electrum documentation:\n/// ### To calculate the status of a script hash (or address):\n///\n/// 1. order confirmed transactions to the script hash by increasing height (and position in the block if there are more than one in a block)\n///\n/// 2. form a string that is the concatenation of strings \"tx_hash:height:\" for each\n/// transaction in order, where:\n///\n///  tx_hash is the transaction hash in hexadecimal\n///  height is the height of the block it is in.\n///\n/// 3. Next, with mempool transactions in any order, append a similar string for those\n/// transactions, but where height is -1 if the transaction has at least one unconfirmed\n/// input, and 0 if all inputs are confirmed.\n///\n/// 4. The status of the script hash is the sha256() hash of the full string expressed\n/// as a hexadecimal string, or null if the string is empty because there are no\n/// transactions.\nfn get_status(transactions: Vec\u003cCachedTransaction\u003e) -\u003e sha256::Hash {\n    let mut status_preimage = String::new();\n    for transaction in transactions {\n        status_preimage.extend(format!(\"{}:{}:\", transaction.hash, transaction.height).chars());\n    }\n    get_hash_from_u8(status_preimage.as_bytes())\n}\n\n#[macro_export]\n/// Builds the response as defined by jsonrpc v2.0. Request should have type [Request] and the\n/// response is always a [Json]\nmacro_rules! json_rpc_res {\n    ($request: ident, $result: ident) =\u003e (\n        Ok(json!({\n            \"jsonrpc\": \"2.0\",\n            \"result\": $result,\n            \"id\": $request.id\n        }))\n    );\n    ($request: ident, $result: literal) =\u003e (\n        Ok(json!({\n            \"jsonrpc\": \"2.0\",\n            \"result\": $result,\n            \"id\": $request.id\n        }))\n    );\n    ($request: ident, $result: tt) =\u003e {\n        Ok(json!({\n            \"jsonrpc\": \"2.0\",\n            \"result\": $result,\n            \"id\": $request.id\n        }))\n    }\n}\n\n#[macro_export]\n/// Returns and parses a value from the request json or fails with [super::error::Error::InvalidParams].\nmacro_rules! get_arg {\n    ($request:ident, $arg_type:ty, $idx:literal) =\u003e {\n        if let Some(arg) = $request.params.get($idx) {\n            serde_json::from_value::\u003c$arg_type\u003e(arg.clone())?\n        } else {\n            return Err(super::error::Error::InvalidParams);\n        }\n    };\n}\n","traces":[{"line":56,"address":[1450770,1450752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[5998354,5998508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[5998511,5998704,5998284,5998411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[3774271],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[5999231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[1450800,1450928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[1450832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[5989840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[5932880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[5931664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[5987248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":558,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":562,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":598,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":601,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":607,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":613,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":614,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":626,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":631,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":632,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":635,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":636,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":641,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":643,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":645,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":653,"address":[1450960],"length":1,"stats":{"Line":0},"fn_name":"client_broker_loop"},{"line":657,"address":[5901195,5901365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[5901408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":660,"address":[3776946,3776896,3777035,3777060],"length":1,"stats":{"Line":0},"fn_name":null},{"line":661,"address":[5902646,5901716,5902450,5901885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":662,"address":[5902472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":663,"address":[3776724],"length":1,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[5902849,5903009,5902714],"length":1,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[5903494,5903155,5902766,5903615],"length":1,"stats":{"Line":0},"fn_name":null},{"line":670,"address":[5902788,5903118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":671,"address":[3776746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":674,"address":[5903649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":678,"address":[1451021,1451008],"length":1,"stats":{"Line":0},"fn_name":"client_accept_loop"},{"line":679,"address":[5898913],"length":1,"stats":{"Line":0},"fn_name":null},{"line":680,"address":[5898925,5899520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":681,"address":[3776162],"length":1,"stats":{"Line":0},"fn_name":null},{"line":682,"address":[5900015,5900183,5900103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":683,"address":[5900308,5900109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":684,"address":[5900316,5900379],"length":1,"stats":{"Line":0},"fn_name":null},{"line":685,"address":[5900635,5900576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[5900496,5900435],"length":1,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[5900512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":690,"address":[5900657,5900791,5899192,5899335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":691,"address":[5900673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":692,"address":[3776180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":694,"address":[5899423,5899369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":717,"address":[1452023,1451040],"length":1,"stats":{"Line":0},"fn_name":"get_status"},{"line":718,"address":[1451062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":719,"address":[1451136,1451228],"length":1,"stats":{"Line":0},"fn_name":null},{"line":720,"address":[1451734,1451425,1451641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":722,"address":[1451505],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":379},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-electrum","src","error.rs"],"content":"#[cfg(feature = \"cli-blockchain\")]\nuse btcd_rpc::error::UtreexodError;\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum Error {\n    #[error(\"Utreexod error\")]\n    #[cfg(feature = \"cli-blockchain\")]\n    BackendError(#[from] UtreexodError),\n    #[error(\"Invalid params passed in\")]\n    InvalidParams,\n    #[error(\"Invalid json string {0}\")]\n    Parsing(#[from] serde_json::Error),\n    #[error(\"Blockchain error\")]\n    Blockchain(Box\u003cdyn core2::error::Error + Send + 'static\u003e),\n    #[error(\"IO error\")]\n    Io(#[from] std::io::Error),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-electrum","src","lib.rs"],"content":"use serde::Deserialize;\nuse serde::Serialize;\n\npub mod electrum_protocol;\npub mod error;\npub mod request;\n#[derive(Debug, Deserialize, Serialize)]\nstruct TransactionHistoryEntry {\n    height: u32,\n    tx_hash: String,\n}\n#[derive(Debug, Deserialize, Serialize)]\nstruct MempoolTransaction {\n    height: u32,\n    tx_hash: String,\n    fee: u32,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-electrum","src","request.rs"],"content":"use serde::Deserialize;\nuse serde_json::Value;\n\n#[derive(Clone, Debug, Deserialize)]\npub struct Request {\n    pub id: Value,\n    pub method: String,\n    pub jsonrpc: String,\n\n    #[serde(default)]\n    pub params: Vec\u003cValue\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-watch-only","src","kv_database.rs"],"content":"use bitcoin::consensus::deserialize;\nuse bitcoin::consensus::encode::Error;\nuse bitcoin::consensus::serialize;\nuse bitcoin::hashes::Hash;\nuse bitcoin::Txid;\nuse floresta_common::impl_error_from;\nuse floresta_common::prelude::*;\nuse kv::Bucket;\nuse kv::Config;\nuse kv::Store;\n\nuse super::AddressCacheDatabase;\nuse super::Stats;\n\npub struct KvDatabase(Store, Bucket\u003c'static, String, Vec\u003cu8\u003e\u003e);\nimpl KvDatabase {\n    pub fn new(datadir: String) -\u003e Result\u003cKvDatabase\u003e {\n        // Configure the database\n        let cfg = Config::new(datadir);\n\n        // Open the key/value store\n        let store = Store::new(cfg)?;\n        let bucket = store.bucket::\u003cString, Vec\u003cu8\u003e\u003e(Some(\"addresses\"))?;\n        Ok(KvDatabase(store, bucket))\n    }\n}\n#[derive(Debug)]\npub enum KvDatabaseError {\n    KvError(kv::Error),\n    SerdeJsonError(serde_json::Error),\n    WalletNotInitialized,\n    DeserializeError(Error),\n    TransactionNotFound,\n}\nimpl_error_from!(KvDatabaseError, serde_json::Error, SerdeJsonError);\nimpl_error_from!(KvDatabaseError, kv::Error, KvError);\nimpl_error_from!(KvDatabaseError, Error, DeserializeError);\n\nimpl Display for KvDatabaseError {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            KvDatabaseError::KvError(e) =\u003e write!(f, \"KvError: {}\", e),\n            KvDatabaseError::SerdeJsonError(e) =\u003e write!(f, \"SerdeJsonError: {}\", e),\n            KvDatabaseError::WalletNotInitialized =\u003e write!(f, \"WalletNotInitialized\"),\n            KvDatabaseError::DeserializeError(e) =\u003e write!(f, \"DeserializeError: {}\", e),\n            KvDatabaseError::TransactionNotFound =\u003e write!(f, \"TransactionNotFound\"),\n        }\n    }\n}\n\nimpl floresta_common::prelude::Error for KvDatabaseError {}\n\ntype Result\u003cT\u003e = floresta_common::prelude::Result\u003cT, KvDatabaseError\u003e;\n\nimpl AddressCacheDatabase for KvDatabase {\n    type Error = KvDatabaseError;\n    fn load(\u0026self) -\u003e Result\u003cVec\u003csuper::CachedAddress\u003e\u003e {\n        let mut addresses = Vec::new();\n        for item in self.1.iter() {\n            let item = item?;\n            let key = item.key::\u003cString\u003e()?;\n            if *\"height\" == key || *\"desc\" == key {\n                continue;\n            }\n            let value: Vec\u003cu8\u003e = item.value().unwrap();\n            let value = serde_json::from_slice(\u0026value)?;\n            addresses.push(value);\n        }\n        Ok(addresses)\n    }\n    fn save(\u0026self, address: \u0026super::CachedAddress) {\n        let key = address.script_hash.to_string();\n        let value = serde_json::to_vec(\u0026address).expect(\"Invalid object serialization\");\n\n        self.1\n            .set(\u0026key, \u0026value)\n            .expect(\"Fatal: Database isn't working\");\n        self.1.flush().expect(\"Could not write to disk\");\n    }\n    fn update(\u0026self, address: \u0026super::CachedAddress) {\n        self.save(address);\n    }\n    fn get_cache_height(\u0026self) -\u003e Result\u003cu32\u003e {\n        let height = self.1.get(\u0026String::from(\"height\"))?;\n        if let Some(height) = height {\n            return Ok(deserialize(\u0026height)?);\n        }\n        Err(KvDatabaseError::WalletNotInitialized)\n    }\n    fn set_cache_height(\u0026self, height: u32) -\u003e Result\u003c()\u003e {\n        self.1.set(\u0026String::from(\"height\"), \u0026serialize(\u0026height))?;\n        self.1.flush()?;\n        Ok(())\n    }\n\n    fn desc_save(\u0026self, descriptor: \u0026str) -\u003e Result\u003c()\u003e {\n        let mut descs = self.descs_get()?;\n        descs.push(String::from(descriptor));\n        self.1\n            .set(\u0026String::from(\"desc\"), \u0026serde_json::to_vec(\u0026descs).unwrap())?;\n        self.1.flush()?;\n\n        Ok(())\n    }\n\n    fn descs_get(\u0026self) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        let res = self.1.get(\u0026String::from(\"desc\"))?;\n        if let Some(res) = res {\n            return Ok(serde_json::de::from_slice(\u0026res)?);\n        }\n        Ok(Vec::new())\n    }\n\n    fn get_transaction(\u0026self, txid: \u0026bitcoin::Txid) -\u003e Result\u003csuper::CachedTransaction\u003e {\n        let store = self.0.bucket::\u003c\u0026[u8], Vec\u003cu8\u003e\u003e(Some(\"transactions\"))?;\n        let res = store.get(\u0026txid.as_byte_array().to_vec().as_slice())?;\n        if let Some(res) = res {\n            return Ok(serde_json::de::from_slice(\u0026res)?);\n        }\n        Err(KvDatabaseError::TransactionNotFound)\n    }\n\n    fn save_transaction(\u0026self, tx: \u0026super::CachedTransaction) -\u003e Result\u003c()\u003e {\n        let store = self.0.bucket::\u003c\u0026[u8], Vec\u003cu8\u003e\u003e(Some(\"transactions\"))?;\n        let ser_tx = serde_json::to_vec(\u0026tx)?;\n        store.set(\u0026tx.tx.txid().as_byte_array().to_vec().as_slice(), \u0026ser_tx)?;\n        self.1.flush()?;\n\n        Ok(())\n    }\n\n    fn get_stats(\u0026self) -\u003e Result\u003csuper::Stats\u003e {\n        let store = self.0.bucket::\u003c\u0026[u8], Vec\u003cu8\u003e\u003e(Some(\"stats\"))?;\n        let res = store.get(\u0026String::from(\"stats\").as_bytes())?;\n        if let Some(res) = res {\n            return Ok(serde_json::de::from_slice(\u0026res)?);\n        }\n        Err(KvDatabaseError::TransactionNotFound)\n    }\n\n    fn save_stats(\u0026self, stats: \u0026Stats) -\u003e Result\u003c()\u003e {\n        let store = self.0.bucket::\u003c\u0026[u8], Vec\u003cu8\u003e\u003e(Some(\"stats\"))?;\n        let ser_stats = serde_json::to_vec(\u0026stats)?;\n        store.set(\u0026String::from(\"stats\").as_bytes(), \u0026ser_stats)?;\n        self.1.flush()?;\n\n        Ok(())\n    }\n\n    fn list_transactions(\u0026self) -\u003e Result\u003cVec\u003cbitcoin::Txid\u003e\u003e {\n        let mut transactions = Vec::new();\n        let store = self.0.bucket::\u003c\u0026[u8], Vec\u003cu8\u003e\u003e(Some(\"transactions\"))?;\n\n        for item in store.iter() {\n            let item = item?;\n            let key = item.key::\u003c\u0026[u8]\u003e()?;\n            transactions.push(Txid::from_slice(key).unwrap());\n        }\n        Ok(transactions)\n    }\n}\n","traces":[{"line":17,"address":[978352,979181],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[978369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[978791,978379],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[979053,978728,978908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[978961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[979216],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":41,"address":[979248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[979302,979367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[979508,979439],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[979585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[979644,979719],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[979799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[981876,979872,981752],"length":1,"stats":{"Line":0},"fn_name":"load"},{"line":58,"address":[979902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[981852,979925,979994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[980340,980546,980237,981859],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[980842,980531,981842,980707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[981058,980995,980803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[981080],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[981600,981117,981208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[981471],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[980249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[982257,981904],"length":1,"stats":{"Line":0},"fn_name":"save"},{"line":72,"address":[981928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[981961,982009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[982049,982113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[982169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[982288],"length":1,"stats":{"Line":0},"fn_name":"update"},{"line":81,"address":[982302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[982320,983124,983158],"length":1,"stats":{"Line":0},"fn_name":"get_cache_height"},{"line":84,"address":[982345,983189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[982740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[982800,982936,983112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[982833],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[983869,983216],"length":1,"stats":{"Line":0},"fn_name":"set_cache_height"},{"line":91,"address":[983834,983250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[983770,983678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[983765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[984975,983904],"length":1,"stats":{"Line":0},"fn_name":"desc_save"},{"line":97,"address":[984090,983960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[984197,984083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[984630,984430,984209,984366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[984217,984526,984655,984373,984937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[984698,984807,984922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[984786],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[985818,985008,985915],"length":1,"stats":{"Line":0},"fn_name":"descs_get"},{"line":107,"address":[985033,985946],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[985428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[985599,985488,985806],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[985516,985834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[987146,987243,985968],"length":1,"stats":{"Line":0},"fn_name":"get_transaction"},{"line":115,"address":[986006,986145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[986240,986133,987224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[986700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[987124,986964,986769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[986806],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[988484,988497,987264],"length":1,"stats":{"Line":0},"fn_name":"save_transaction"},{"line":124,"address":[987299,987433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[987426,987668,987539,988495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[987753,987639,988453],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[988432,988192,988307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[988280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[988512,989746,989649],"length":1,"stats":{"Line":0},"fn_name":"get_stats"},{"line":133,"address":[988686,988537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[988659,988784,989727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[989208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[989465,989277,989627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[989314],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[989776,990945,990958],"length":1,"stats":{"Line":0},"fn_name":"save_stats"},{"line":142,"address":[989811,989945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[990956,990183,989938,990051],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[990914,990268,990151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[990653,990768,990893],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[990741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[992377,992427,990976],"length":1,"stats":{"Line":0},"fn_name":"list_transactions"},{"line":151,"address":[991006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[991149,991037,992425,991224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[992370,991209,991370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[991928,992388,991616,991722],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[992089,992173,991913],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[992161,992275],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[991628],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":82},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-watch-only","src","lib.rs"],"content":"#![cfg_attr(feature = \"no-std\", no_std)]\nuse core::cmp::Ordering;\nuse core::fmt::Debug;\n\nuse bitcoin::hashes::sha256;\nuse bitcoin::ScriptBuf;\nuse floresta_common::get_spk_hash;\nuse floresta_common::parse_descriptors;\nuse floresta_common::prelude::ToString;\n\npub mod kv_database;\n#[cfg(any(test, feature = \"memory-database\"))]\npub mod memory_database;\npub mod merkle;\n\nuse bitcoin::consensus::deserialize;\nuse bitcoin::consensus::encode::serialize_hex;\nuse bitcoin::hash_types::Txid;\nuse bitcoin::hashes::hex::FromHex;\nuse bitcoin::hashes::sha256::Hash;\nuse bitcoin::hashes::Hash as HashTrait;\nuse bitcoin::Block;\nuse bitcoin::OutPoint;\nuse bitcoin::Transaction;\nuse bitcoin::TxOut;\nuse floresta_common::prelude::*;\nuse merkle::MerkleProof;\nuse serde::Deserialize;\nuse serde::Serialize;\n\n#[derive(Debug)]\npub enum WatchOnlyError\u003cDatabaseError: fmt::Debug\u003e {\n    WalletNotInitialized,\n    TransactionNotFound,\n    DatabaseError(DatabaseError),\n}\nimpl\u003cDatabaseError: fmt::Debug\u003e Display for WatchOnlyError\u003cDatabaseError\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            WatchOnlyError::WalletNotInitialized =\u003e {\n                write!(f, \"Wallet isn't initialized\")\n            }\n            WatchOnlyError::TransactionNotFound =\u003e {\n                write!(f, \"Transaction not found\")\n            }\n            WatchOnlyError::DatabaseError(e) =\u003e {\n                write!(f, \"Database error: {:?}\", e)\n            }\n        }\n    }\n}\nimpl\u003cDatabaseError: fmt::Debug\u003e From\u003cDatabaseError\u003e for WatchOnlyError\u003cDatabaseError\u003e {\n    fn from(e: DatabaseError) -\u003e Self {\n        WatchOnlyError::DatabaseError(e)\n    }\n}\nimpl\u003cT: Debug\u003e floresta_common::prelude::Error for WatchOnlyError\u003cT\u003e {}\n\n/// Every address contains zero or more associated transactions, this struct defines what\n/// data we store for those.\n#[derive(Debug, Clone, Eq, Serialize, Deserialize)]\npub struct CachedTransaction {\n    pub tx: Transaction,\n    pub height: u32,\n    pub merkle_block: Option\u003cMerkleProof\u003e,\n    pub hash: Txid,\n    pub position: u32,\n}\n\nimpl Ord for CachedTransaction {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e Ordering {\n        self.height.cmp(\u0026other.height)\n    }\n}\n\nimpl PartialOrd for CachedTransaction {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n        Some(self.cmp(other))\n    }\n}\n\nimpl PartialEq for CachedTransaction {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.height == other.height\n    }\n}\nimpl Default for CachedTransaction {\n    fn default() -\u003e Self {\n        CachedTransaction {\n            // A placeholder transaction with no input and no outputs, the bare-minimum to be\n            // serializable\n            tx: deserialize(\u0026Vec::from_hex(\"010000000000ffffffff\").unwrap()).unwrap(),\n            height: 0,\n            merkle_block: None,\n            hash: Txid::all_zeros(),\n            position: 0,\n        }\n    }\n}\n\n/// An address inside our cache, contains all information we need to satisfy electrum's requests\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CachedAddress {\n    script_hash: Hash,\n    balance: u64,\n    transactions: Vec\u003cTxid\u003e,\n    utxos: Vec\u003cOutPoint\u003e,\n}\n\n/// Holds some useful data about our wallet, like how many addresses we have, how many\n/// transactions we have, etc.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct Stats {\n    pub address_count: usize,\n    pub transaction_count: usize,\n    pub utxo_count: usize,\n    pub cache_height: u32,\n    pub txo_count: usize,\n    pub balance: u64,\n    pub derivation_index: u32,\n}\n/// Public trait defining a common interface for databases to be used with our cache\npub trait AddressCacheDatabase {\n    type Error: fmt::Debug + Send + Sync + 'static;\n    /// Saves a new address to the database. If the address already exists, `update` should\n    /// be used instead\n    fn save(\u0026self, address: \u0026CachedAddress);\n    /// Loads all addresses we have cached so far\n    fn load(\u0026self) -\u003e Result\u003cVec\u003cCachedAddress\u003e, Self::Error\u003e;\n    /// Loads the data associated with our watch-only wallet.\n    fn get_stats(\u0026self) -\u003e Result\u003cStats, Self::Error\u003e;\n    /// Saves the data associated with our watch-only wallet.\n    fn save_stats(\u0026self, stats: \u0026Stats) -\u003e Result\u003c(), Self::Error\u003e;\n    /// Updates an address, probably because a new transaction arrived\n    fn update(\u0026self, address: \u0026CachedAddress);\n    /// TODO: Maybe turn this into another db\n    /// Returns the height of the last block we filtered\n    fn get_cache_height(\u0026self) -\u003e Result\u003cu32, Self::Error\u003e;\n    /// Saves the height of the last block we filtered\n    fn set_cache_height(\u0026self, height: u32) -\u003e Result\u003c(), Self::Error\u003e;\n    /// Saves the descriptor of associated cache\n    fn desc_save(\u0026self, descriptor: \u0026str) -\u003e Result\u003c(), Self::Error\u003e;\n    /// Get associated descriptors\n    fn descs_get(\u0026self) -\u003e Result\u003cVec\u003cString\u003e, Self::Error\u003e;\n    /// Get a transaction from the database\n    fn get_transaction(\u0026self, txid: \u0026Txid) -\u003e Result\u003cCachedTransaction, Self::Error\u003e;\n    /// Saves a transaction to the database\n    fn save_transaction(\u0026self, tx: \u0026CachedTransaction) -\u003e Result\u003c(), Self::Error\u003e;\n    /// Returns all transaction we have cached so far\n    fn list_transactions(\u0026self) -\u003e Result\u003cVec\u003cTxid\u003e, Self::Error\u003e;\n}\n/// Holds all addresses and associated transactions. We need a database with some basic\n/// methods, to store all data\npub struct AddressCache\u003cD: AddressCacheDatabase\u003e {\n    /// A database that will be used to persist all needed to get our address history\n    database: D,\n    /// Maps a hash to a cached address struct, this is basically an in-memory version\n    /// of our database, used for speeding up processing a block. This hash is the electrum's\n    /// script hash\n    address_map: HashMap\u003cHash, CachedAddress\u003e,\n    /// Holds all scripts we are interested in\n    script_set: HashSet\u003csha256::Hash\u003e,\n    /// Keeps track of all utxos we own, and the script hash they belong to\n    utxo_index: HashMap\u003cOutPoint, Hash\u003e,\n}\n\nimpl\u003cD: AddressCacheDatabase\u003e AddressCache\u003cD\u003e {\n    /// Iterates through a block, finds transactions destined to ourselves.\n    /// Returns all transactions we found.\n    pub fn block_process(\u0026mut self, block: \u0026Block, height: u32) -\u003e Vec\u003c(Transaction, TxOut)\u003e {\n        let mut my_transactions = Vec::new();\n        // Check if this transaction spends from one of our utxos\n        for (position, transaction) in block.txdata.iter().enumerate() {\n            for (vin, txin) in transaction.input.iter().enumerate() {\n                if let Some(script) = self.utxo_index.get(\u0026txin.previous_output) {\n                    let script = self\n                        .address_map\n                        .get(script)\n                        .expect(\"Can't cache a utxo for a address we don't have\")\n                        .to_owned();\n                    let tx = self\n                        .get_transaction(\u0026txin.previous_output.txid)\n                        .expect(\"We cached a utxo for a transaction we don't have\");\n\n                    let utxo = tx\n                        .tx\n                        .output\n                        .get(txin.previous_output.vout as usize)\n                        .expect(\"Did we cache an invalid utxo?\");\n                    let merkle_block = MerkleProof::from_block(block, position as u64);\n\n                    self.cache_transaction(\n                        transaction,\n                        height,\n                        utxo.value.to_sat(),\n                        merkle_block,\n                        position as u32,\n                        vin,\n                        true,\n                        script.script_hash,\n                    )\n                }\n            }\n            // Checks if one of our addresses is the recipient of this transaction\n            for (vout, output) in transaction.output.iter().enumerate() {\n                let hash = get_spk_hash(\u0026output.script_pubkey);\n                if self.script_set.contains(\u0026hash) {\n                    my_transactions.push((transaction.clone(), output.clone()));\n\n                    let merkle_block = MerkleProof::from_block(block, position as u64);\n\n                    self.cache_transaction(\n                        transaction,\n                        height,\n                        output.value.to_sat(),\n                        merkle_block,\n                        position as u32,\n                        vout,\n                        false,\n                        hash,\n                    );\n                }\n            }\n        }\n        my_transactions\n    }\n\n    fn get_stats(\u0026self) -\u003e Stats {\n        self.database\n            .get_stats()\n            .expect(\"Could not get stats from database\")\n    }\n\n    pub fn bump_height(\u0026self, height: u32) {\n        self.database\n            .set_cache_height(height)\n            .expect(\"Database is not working\");\n    }\n\n    pub fn get_cache_height(\u0026self) -\u003e u32 {\n        self.database.get_cache_height().unwrap_or(0)\n    }\n\n    pub fn new(database: D) -\u003e AddressCache\u003cD\u003e {\n        let scripts = database.load().expect(\"Could not load database\");\n        if database.get_stats().is_err() {\n            database\n                .save_stats(\u0026Stats::default())\n                .expect(\"Could not save stats\");\n        }\n        let mut address_map = HashMap::new();\n        let mut script_set = HashSet::new();\n        let mut utxo_index = HashMap::new();\n        for address in scripts {\n            for utxo in address.utxos.iter() {\n                utxo_index.insert(*utxo, address.script_hash);\n            }\n            script_set.insert(address.script_hash);\n            address_map.insert(address.script_hash, address);\n        }\n        AddressCache {\n            database,\n            address_map,\n            script_set,\n            utxo_index,\n        }\n    }\n    pub fn get_address_utxos(\u0026self, script_hash: \u0026Hash) -\u003e Option\u003cVec\u003c(TxOut, OutPoint)\u003e\u003e {\n        let address = self.address_map.get(script_hash)?;\n        let utxos = \u0026address.utxos;\n        let mut address_utxos = Vec::new();\n        for utxo in utxos {\n            let tx = self.get_transaction(\u0026utxo.txid)?;\n            let txout = tx.tx.output.get(utxo.vout as usize)?;\n            address_utxos.push((txout.clone(), *utxo));\n        }\n\n        Some(address_utxos)\n    }\n    pub fn get_transaction(\u0026self, txid: \u0026Txid) -\u003e Option\u003cCachedTransaction\u003e {\n        self.database.get_transaction(txid).ok()\n    }\n    /// Returns all transactions this address has, both input and outputs\n    pub fn get_address_history(\u0026self, script_hash: \u0026Hash) -\u003e Option\u003cVec\u003cCachedTransaction\u003e\u003e {\n        let cached_script = self.address_map.get(script_hash)?;\n        let mut transactions: Vec\u003c_\u003e = cached_script\n            .transactions\n            .iter()\n            .filter_map(|txid| self.get_transaction(txid))\n            .collect();\n        let mut unconfirmed = transactions.clone();\n\n        transactions.retain(|tx| tx.height != 0);\n        transactions.sort();\n        unconfirmed.retain(|tx| tx.height == 0);\n        transactions.extend(unconfirmed);\n        Some(transactions)\n    }\n    /// Returns the balance of this address, debts (spends) are taken in account\n    pub fn get_address_balance(\u0026self, script_hash: \u0026Hash) -\u003e u64 {\n        if let Some(cached_script) = self.address_map.get(script_hash) {\n            return cached_script.balance;\n        }\n\n        0\n    }\n    /// Returns the Merkle Proof for a given address\n    pub fn get_merkle_proof(\u0026self, txid: \u0026Txid) -\u003e Option\u003c(Vec\u003cString\u003e, u32)\u003e {\n        let mut hashes = Vec::new();\n        let tx = self.get_transaction(txid)?;\n        // If a given transaction is cached, but the merkle tree doesn't exist, that means\n        // an unconfirmed transaction.\n        tx.merkle_block.as_ref()?;\n        for hash in tx.merkle_block?.hashes() {\n            hashes.push(hash.to_string());\n        }\n        Some((hashes, tx.position))\n    }\n    pub fn get_position(\u0026self, txid: \u0026Txid) -\u003e Option\u003cu32\u003e {\n        Some(self.get_transaction(txid)?.position)\n    }\n    pub fn get_height(\u0026self, txid: \u0026Txid) -\u003e Option\u003cu32\u003e {\n        Some(self.get_transaction(txid)?.height)\n    }\n    pub fn get_cached_transaction(\u0026self, txid: \u0026Txid) -\u003e Option\u003cString\u003e {\n        let tx = self.get_transaction(txid)?;\n        Some(serialize_hex(\u0026tx.tx))\n    }\n    /// Adds a new address to track, should be called at wallet setup and every once in a while\n    /// to cache new addresses, as we use the first ones. Only requires a script to cache.\n    pub fn cache_address(\u0026mut self, script_pk: ScriptBuf) {\n        let hash = get_spk_hash(\u0026script_pk);\n        if self.address_map.contains_key(\u0026hash) {\n            return;\n        }\n        let new_address = CachedAddress {\n            balance: 0,\n            script_hash: hash,\n            transactions: Vec::new(),\n            utxos: Vec::new(),\n        };\n        self.database.save(\u0026new_address);\n\n        self.address_map.insert(hash, new_address);\n        self.script_set.insert(hash);\n    }\n    pub fn cache_address_hash(\u0026mut self, script_hash: Hash) {\n        if self.address_map.contains_key(\u0026script_hash) {\n            return;\n        }\n        let new_address = CachedAddress {\n            balance: 0,\n            script_hash,\n            transactions: Vec::new(),\n            utxos: Vec::new(),\n        };\n        self.database.save(\u0026new_address);\n\n        self.address_map.insert(script_hash, new_address);\n        self.script_set.insert(script_hash);\n    }\n    /// Setup is the first command that should be executed. In a new cache. It sets our wallet's\n    /// state, like the height we should start scanning and the wallet's descriptor.\n    pub fn setup(\u0026self) -\u003e Result\u003c(), WatchOnlyError\u003cD::Error\u003e\u003e {\n        if self.database.descs_get().is_err() {\n            self.database.set_cache_height(0)?;\n        }\n        Ok(())\n    }\n    /// Tells whether or not a descriptor is already cached\n    pub fn is_cached(\u0026self, desc: \u0026String) -\u003e Result\u003cbool, WatchOnlyError\u003cD::Error\u003e\u003e {\n        let known_descs = self.database.descs_get()?;\n        Ok(known_descs.contains(desc))\n    }\n    pub fn push_descriptor(\u0026self, descriptor: \u0026str) -\u003e Result\u003c(), WatchOnlyError\u003cD::Error\u003e\u003e {\n        Ok(self.database.desc_save(descriptor)?)\n    }\n    fn derive_addresses(\u0026mut self) -\u003e Result\u003c(), WatchOnlyError\u003cD::Error\u003e\u003e {\n        let mut stats = self.get_stats();\n        let descriptors = self.database.descs_get()?;\n        let descriptors = parse_descriptors(\u0026descriptors).expect(\"We validate those descriptors\");\n        for desc in descriptors {\n            let index = stats.derivation_index;\n            for idx in index..(index + 100) {\n                let script = desc\n                    .at_derivation_index(idx)\n                    .expect(\"We validate those descriptors before saving\")\n                    .script_pubkey();\n                self.cache_address(script);\n            }\n        }\n        stats.derivation_index += 100;\n        Ok(self.database.save_stats(\u0026stats)?)\n    }\n    fn maybe_derive_addresses(\u0026mut self) {\n        let stats = self.get_stats();\n        if stats.transaction_count \u003e (stats.derivation_index as usize * 100) {\n            let res = self.derive_addresses();\n            if res.is_err() {\n                log::error!(\"Error deriving addresses: {:?}\", res);\n            }\n        }\n    }\n    pub fn find_unconfirmed(\u0026self) -\u003e Result\u003cVec\u003cTransaction\u003e, WatchOnlyError\u003cD::Error\u003e\u003e {\n        let transactions = self.database.list_transactions()?;\n        let mut unconfirmed = Vec::new();\n\n        for tx in transactions {\n            let tx = self.database.get_transaction(\u0026tx)?;\n            if tx.height == 0 {\n                unconfirmed.push(tx.tx);\n            }\n        }\n        Ok(unconfirmed)\n    }\n    fn find_spend(\u0026self, transaction: \u0026Transaction) -\u003e Vec\u003c(usize, TxOut)\u003e {\n        let mut spends = Vec::new();\n        for (idx, input) in transaction.input.iter().enumerate() {\n            if self.utxo_index.contains_key(\u0026input.previous_output) {\n                let prev_tx = self.get_transaction(\u0026input.previous_output.txid).unwrap();\n                spends.push((\n                    idx,\n                    prev_tx.tx.output[input.previous_output.vout as usize].clone(),\n                ));\n            }\n        }\n        spends\n    }\n    pub fn cache_mempool_transaction(\u0026mut self, transaction: \u0026Transaction) -\u003e Vec\u003cTxOut\u003e {\n        let mut coins = self.find_spend(transaction);\n        for (idx, spend) in coins.iter() {\n            let script = self\n                .address_map\n                .get(\u0026get_spk_hash(\u0026spend.script_pubkey))\n                .unwrap()\n                .to_owned();\n            self.cache_transaction(\n                transaction,\n                0,\n                spend.value.to_sat(),\n                MerkleProof::default(),\n                0,\n                *idx,\n                true,\n                script.script_hash,\n            )\n        }\n        for (idx, out) in transaction.output.iter().enumerate() {\n            let spk_hash = get_spk_hash(\u0026out.script_pubkey);\n            if self.script_set.contains(\u0026spk_hash) {\n                let script = self.address_map.get(\u0026spk_hash).unwrap().to_owned();\n                coins.push((idx, out.clone()));\n                self.cache_transaction(\n                    transaction,\n                    0,\n                    out.value.to_sat(),\n                    MerkleProof::default(),\n                    0,\n                    idx,\n                    true,\n                    script.script_hash,\n                )\n            }\n        }\n        coins\n            .iter()\n            .cloned()\n            .unzip::\u003cusize, TxOut, Vec\u003cusize\u003e, Vec\u003cTxOut\u003e\u003e()\n            .1\n    }\n    fn save_mempool_tx(\u0026mut self, hash: Hash, transaction_to_cache: CachedTransaction) {\n        if let Some(address) = self.address_map.get_mut(\u0026hash) {\n            if !address.transactions.contains(\u0026transaction_to_cache.hash) {\n                address.transactions.push(transaction_to_cache.hash);\n                self.database.update(address);\n            }\n        }\n    }\n    fn save_non_mempool_tx(\n        \u0026mut self,\n        transaction: \u0026Transaction,\n        is_spend: bool,\n        value: u64,\n        index: usize,\n        hash: Hash,\n        transaction_to_cache: CachedTransaction,\n    ) {\n        if let Some(address) = self.address_map.get_mut(\u0026hash) {\n            // This transaction is spending from this address, so we should remove the UTXO\n            if is_spend {\n                assert!(value \u003c= address.balance);\n                address.balance -= value;\n                let input = transaction\n                    .input\n                    .get(index)\n                    .expect(\"Malformed call, index is bigger than the output vector\");\n                let idx = address\n                    .utxos\n                    .iter()\n                    .position(|utxo| *utxo == input.previous_output);\n                if let Some(idx) = idx {\n                    let utxo = address.utxos.remove(idx);\n                    self.utxo_index.remove(\u0026utxo);\n                }\n            } else {\n                // This transaction is creating a new utxo for this address\n                let utxo = OutPoint {\n                    txid: transaction.txid(),\n                    vout: index as u32,\n                };\n                address.utxos.push(utxo);\n                self.utxo_index.insert(utxo, hash);\n                address.balance += value;\n            }\n\n            if !address.transactions.contains(\u0026transaction_to_cache.hash) {\n                address.transactions.push(transaction_to_cache.hash);\n                self.database.update(address);\n            }\n        }\n    }\n    /// Caches a new transaction. This method may be called for addresses we don't follow yet,\n    /// this automatically makes we follow this address.\n    #[allow(clippy::too_many_arguments)]\n    pub fn cache_transaction(\n        \u0026mut self,\n        transaction: \u0026Transaction,\n        height: u32,\n        value: u64,\n        merkle_block: MerkleProof,\n        position: u32,\n        index: usize,\n        is_spend: bool,\n        hash: sha256::Hash,\n    ) {\n        let transaction_to_cache = CachedTransaction {\n            height,\n            merkle_block: Some(merkle_block),\n            tx: transaction.clone(),\n            hash: transaction.txid(),\n            position,\n        };\n        self.database\n            .save_transaction(\u0026transaction_to_cache)\n            .expect(\"Database not working\");\n\n        if let Entry::Vacant(e) = self.address_map.entry(hash) {\n            // This means `cache_transaction` have been called with an address we don't\n            // follow. This may be useful for caching new addresses without re-scanning.\n            // We can track this address from now onwards, but the past history is only\n            // available with full rescan\n            let new_address = CachedAddress {\n                balance: transaction.output[index].value.to_sat(),\n                script_hash: hash,\n                transactions: Vec::from([transaction_to_cache.hash]),\n                utxos: Vec::from([OutPoint {\n                    txid: transaction.txid(),\n                    vout: index as u32,\n                }]),\n            };\n            self.database.save(\u0026new_address);\n\n            e.insert(new_address);\n            self.script_set.insert(hash);\n        }\n        self.maybe_derive_addresses();\n        // Confirmed transaction\n        if height \u003e 0 {\n            return self.save_non_mempool_tx(\n                transaction,\n                is_spend,\n                value,\n                index,\n                hash,\n                transaction_to_cache,\n            );\n        }\n        // Unconfirmed transaction\n        self.save_mempool_tx(hash, transaction_to_cache);\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use bitcoin::address::NetworkUnchecked;\n    use bitcoin::consensus::deserialize;\n    use bitcoin::consensus::Decodable;\n    use bitcoin::hashes::hex::FromHex;\n    use bitcoin::hashes::sha256;\n    use bitcoin::Address;\n    use bitcoin::ScriptBuf;\n    use bitcoin::Txid;\n    use floresta_common::get_spk_hash;\n    use floresta_common::prelude::*;\n\n    const BLOCK_FIRST_UTXO: \u0026str = \"00000020b4f594a390823c53557c5a449fa12413cbbae02be529c11c4eb320ff8e000000dd1211eb35ca09dc0ee519b0f79319fae6ed32c66f8bbf353c38513e2132c435474d81633c4b011e195a220002010000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff0403edce01feffffff028df2052a0100000016001481113cad52683679a83e76f76f84a4cfe36f75010000000000000000776a24aa21a9ed67863b4f356b7b9f3aab7a2037615989ef844a0917fb0a1dcd6c23a383ee346b4c4fecc7daa2490047304402203768ff10a948a2dd1825cc5a3b0d336d819ea68b5711add1390b290bf3b1cba202201d15e73791b2df4c0904fc3f7c7b2f22ab77762958e9bc76c625138ad3a04d290100012000000000000000000000000000000000000000000000000000000000000000000000000002000000000101be07b18750559a418d144f1530be380aa5f28a68a0269d6b2d0e6ff3ff25f3200000000000feffffff0240420f00000000001600142b6a2924aa9b1b115d1ac3098b0ba0e6ed510f2a326f55d94c060000160014c2ed86a626ee74d854a12c9bb6a9b72a80c0ddc50247304402204c47f6783800831bd2c75f44d8430bf4d962175349dc04d690a617de6c1eaed502200ffe70188a6e5ad89871b2acb4d0f732c2256c7ed641d2934c6e84069c792abc012103ba174d9c66078cf813d0ac54f5b19b5fe75104596bdd6c1731d9436ad8776f41ecce0100\";\n    const BLOCK_SPEND: \u0026str = \"000000203ea734fa2c8dee7d3194878c9eaf6e83a629f79b3076ec857793995e01010000eb99c679c0305a1ac0f5eb2a07a9f080616105e605b92b8c06129a2451899225ab5481633c4b011e0b26720102020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff0403efce01feffffff026ef2052a01000000225120a1a1b1376d5165617a50a6d2f59abc984ead8a92df2b25f94b53dbc2151824730000000000000000776a24aa21a9ed1b4c48a7220572ff3ab3d2d1c9231854cb62542fbb1e0a4b21ebbbcde8d652bc4c4fecc7daa2490047304402204b37c41fce11918df010cea4151737868111575df07f7f2945d372e32a6d11dd02201658873a8228d7982df6bdbfff5d0cad1d6f07ee400e2179e8eaad8d115b7ed001000120000000000000000000000000000000000000000000000000000000000000000000000000020000000001017ca523c5e6df0c014e837279ab49be1676a9fe7571c3989aeba1e5d534f4054a0000000000fdffffff01d2410f00000000001600142b6a2924aa9b1b115d1ac3098b0ba0e6ed510f2a02473044022071b8583ba1f10531b68cb5bd269fb0e75714c20c5a8bce49d8a2307d27a082df022069a978dac00dd9d5761aa48c7acc881617fa4d2573476b11685596b17d437595012103b193d06bd0533d053f959b50e3132861527e5a7a49ad59c5e80a265ff6a77605eece0100\";\n    fn deserialize_from_str\u003cT: Decodable\u003e(thing: \u0026str) -\u003e T {\n        let hex = Vec::from_hex(thing).unwrap();\n        deserialize(\u0026hex).unwrap()\n    }\n    use super::memory_database::MemoryDatabase;\n    use super::AddressCache;\n    fn get_test_cache() -\u003e AddressCache\u003cMemoryDatabase\u003e {\n        let database = MemoryDatabase::new();\n        AddressCache::new(database)\n    }\n    fn get_test_address() -\u003e (Address\u003cNetworkUnchecked\u003e, sha256::Hash) {\n        let address = Address::from_str(\"tb1q9d4zjf92nvd3zhg6cvyckzaqumk4zre26x02q9\").unwrap();\n        let script_hash = get_spk_hash(\u0026address.payload().script_pubkey());\n        (address, script_hash)\n    }\n    #[test]\n    fn test_create() {\n        let _ = get_test_cache();\n    }\n    #[test]\n    fn test_cache_address() {\n        let (address, script_hash) = get_test_address();\n        let mut cache = get_test_cache();\n        // Should have no address before caching\n        assert_eq!(cache.address_map.len(), 0);\n\n        cache.cache_address(address.payload().script_pubkey());\n        // Assert we indeed have one cached address\n        assert_eq!(cache.address_map.len(), 1);\n        assert_eq!(cache.get_address_balance(\u0026script_hash), 0);\n        assert_eq!(cache.get_address_history(\u0026script_hash), Some(Vec::new()));\n    }\n    #[test]\n    fn test_cache_transaction() {\n        // Signet transaction with id 6bb0665122c7dcecc6e6c45b6384ee2bdce148aea097896e6f3e9e08070353ea\n        // block hash 0000009298f9e75a91fa763c78b66d1555cb059d9ca9d45601eed2b95166a151.\n        let transaction = \"020000000001017ca523c5e6df0c014e837279ab49be1676a9fe7571c3989aeba1e5d534f4054a0000000000fdffffff01d2410f00000000001600142b6a2924aa9b1b115d1ac3098b0ba0e6ed510f2a02473044022071b8583ba1f10531b68cb5bd269fb0e75714c20c5a8bce49d8a2307d27a082df022069a978dac00dd9d5761aa48c7acc881617fa4d2573476b11685596b17d437595012103b193d06bd0533d053f959b50e3132861527e5a7a49ad59c5e80a265ff6a77605eece0100\";\n        let transaction = Vec::from_hex(transaction).unwrap();\n        let transaction = deserialize(\u0026transaction).unwrap();\n\n        let merkle_block = \"0100000000000000ea530307089e3e6f6e8997a0ae48e1dc2bee84635bc4e6c6ecdcc7225166b06b010000000000000034086ef398efcdec47b37241221c8f4613e02bc31026cc74d07ddb3092e6d6e7\";\n        let merkle_block = Vec::from_hex(merkle_block).unwrap();\n        let merkle_block = deserialize(\u0026merkle_block).unwrap();\n\n        let (address, script_hash) = get_test_address();\n        let mut cache = get_test_cache();\n        cache.cache_address(address.payload().script_pubkey());\n\n        cache.cache_transaction(\n            \u0026transaction,\n            118511,\n            transaction.output[0].value.to_sat(),\n            merkle_block,\n            1,\n            0,\n            false,\n            get_spk_hash(\u0026transaction.output[0].script_pubkey),\n        );\n\n        let balance = cache.get_address_balance(\u0026script_hash);\n        let history = cache.get_address_history(\u0026script_hash).unwrap();\n        let cached_merkle_block = cache.get_merkle_proof(\u0026transaction.txid()).unwrap();\n        assert_eq!(balance, 999890);\n        assert_eq!(\n            Ok(history[0].hash),\n            Txid::from_str(\"6bb0665122c7dcecc6e6c45b6384ee2bdce148aea097896e6f3e9e08070353ea\")\n        );\n        let expected_hashes = Vec::from([String::from(\n            \"e7d6e69230db7dd074cc2610c32be013468f1c224172b347eccdef98f36e0834\",\n        )]);\n        assert_eq!(cached_merkle_block, (expected_hashes, 1));\n    }\n    #[test]\n    fn test_process_block() {\n        let (address, script_hash) = get_test_address();\n        let mut cache = get_test_cache();\n        cache.cache_address(address.payload().script_pubkey());\n\n        let block = \"000000203ea734fa2c8dee7d3194878c9eaf6e83a629f79b3076ec857793995e01010000eb99c679c0305a1ac0f5eb2a07a9f080616105e605b92b8c06129a2451899225ab5481633c4b011e0b26720102020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff0403efce01feffffff026ef2052a01000000225120a1a1b1376d5165617a50a6d2f59abc984ead8a92df2b25f94b53dbc2151824730000000000000000776a24aa21a9ed1b4c48a7220572ff3ab3d2d1c9231854cb62542fbb1e0a4b21ebbbcde8d652bc4c4fecc7daa2490047304402204b37c41fce11918df010cea4151737868111575df07f7f2945d372e32a6d11dd02201658873a8228d7982df6bdbfff5d0cad1d6f07ee400e2179e8eaad8d115b7ed001000120000000000000000000000000000000000000000000000000000000000000000000000000020000000001017ca523c5e6df0c014e837279ab49be1676a9fe7571c3989aeba1e5d534f4054a0000000000fdffffff01d2410f00000000001600142b6a2924aa9b1b115d1ac3098b0ba0e6ed510f2a02473044022071b8583ba1f10531b68cb5bd269fb0e75714c20c5a8bce49d8a2307d27a082df022069a978dac00dd9d5761aa48c7acc881617fa4d2573476b11685596b17d437595012103b193d06bd0533d053f959b50e3132861527e5a7a49ad59c5e80a265ff6a77605eece0100\";\n        let block = deserialize(\u0026Vec::from_hex(block).unwrap()).unwrap();\n        cache.block_process(\u0026block, 118511);\n\n        let balance = cache.get_address_balance(\u0026script_hash);\n        let history = cache.get_address_history(\u0026script_hash).unwrap();\n        let transaction_id =\n            Txid::from_str(\"6bb0665122c7dcecc6e6c45b6384ee2bdce148aea097896e6f3e9e08070353ea\")\n                .unwrap();\n        let cached_merkle_block = cache.get_merkle_proof(\u0026transaction_id).unwrap();\n        assert_eq!(balance, 999890);\n        assert_eq!(\n            history[0].hash,\n            Txid::from_str(\"6bb0665122c7dcecc6e6c45b6384ee2bdce148aea097896e6f3e9e08070353ea\")\n                .unwrap()\n        );\n        let expected_hashes = Vec::from([String::from(\n            \"e7d6e69230db7dd074cc2610c32be013468f1c224172b347eccdef98f36e0834\",\n        )]);\n        assert_eq!(cached_merkle_block, (expected_hashes, 1));\n    }\n    #[test]\n    fn test_multiple_transaction() {\n        let block1 = deserialize_from_str(BLOCK_FIRST_UTXO);\n        let block2 = deserialize_from_str(BLOCK_SPEND);\n\n        let spk = ScriptBuf::from_hex(\"00142b6a2924aa9b1b115d1ac3098b0ba0e6ed510f2a\")\n            .expect(\"Valid address\");\n        let script_hash = get_spk_hash(\u0026spk);\n        let mut cache = get_test_cache();\n\n        cache.cache_address(spk);\n\n        cache.block_process(\u0026block1, 118511);\n        cache.block_process(\u0026block2, 118509);\n\n        let address = cache.address_map.get(\u0026script_hash).unwrap();\n\n        assert_eq!(address.transactions.len(), 2);\n        assert_eq!(address.utxos.len(), 1);\n    }\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[1089552],"length":1,"stats":{"Line":0},"fn_name":"cmp"},{"line":72,"address":[1089566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[1089600],"length":1,"stats":{"Line":0},"fn_name":"partial_cmp"},{"line":78,"address":[1089614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[1089632],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":84,"address":[1089642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[1090091,1090121,1089664],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":92,"address":[1089681,1089825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[1089885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[1406310,1404976],"length":1,"stats":{"Line":3},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":525,"address":[1406384,1408089,1407826],"length":1,"stats":{"Line":1},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":564,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":97,"coverable":255},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-watch-only","src","memory_database.rs"],"content":"//! An in-memory database to store addresses data. Being in-memory means this database is\n//! volatile, and all data is lost after the database is dropped or the process is terminated.\n//! It's not meant to use in production, but for the integrated testing framework\n//!\n//! For actual databases that can be used for production code, see [KvDatabase].\nuse bitcoin::hashes::sha256;\nuse bitcoin::Txid;\nuse floresta_common::prelude::sync::RwLock;\nuse floresta_common::prelude::*;\n\nuse super::AddressCacheDatabase;\nuse super::CachedAddress;\nuse super::CachedTransaction;\nuse super::Stats;\n#[derive(Debug, Default)]\nstruct Inner {\n    addresses: HashMap\u003csha256::Hash, CachedAddress\u003e,\n    transactions: HashMap\u003cTxid, CachedTransaction\u003e,\n    stats: Stats,\n    height: u32,\n    descriptors: Vec\u003cString\u003e,\n}\n\n#[derive(Debug)]\npub enum MemoryDatabaseError {\n    PoisonedLock,\n}\n#[derive(Debug, Default)]\npub struct MemoryDatabase {\n    inner: RwLock\u003cInner\u003e,\n}\n\ntype Result\u003cT\u003e = floresta_common::prelude::Result\u003cT, MemoryDatabaseError\u003e;\n\nimpl MemoryDatabase {\n    fn get_inner(\u0026self) -\u003e Result\u003csync::RwLockReadGuard\u003cInner\u003e\u003e {\n        self.inner\n            .read()\n            .map_err(|_| MemoryDatabaseError::PoisonedLock)\n    }\n    fn get_inner_mut(\u0026self) -\u003e Result\u003csync::RwLockWriteGuard\u003cInner\u003e\u003e {\n        self.inner\n            .write()\n            .map_err(|_| MemoryDatabaseError::PoisonedLock)\n    }\n    pub fn new() -\u003e MemoryDatabase {\n        MemoryDatabase {\n            inner: Default::default(),\n        }\n    }\n}\nimpl AddressCacheDatabase for MemoryDatabase {\n    type Error = MemoryDatabaseError;\n    fn save(\u0026self, address: \u0026CachedAddress) {\n        self.get_inner_mut()\n            .map(|mut inner| {\n                inner\n                    .addresses\n                    .insert(address.script_hash, address.to_owned())\n            })\n            .unwrap();\n    }\n\n    fn load(\u0026self) -\u003e Result\u003cVec\u003cCachedAddress\u003e\u003e {\n        Ok(self.get_inner()?.addresses.values().cloned().collect())\n    }\n\n    fn get_stats(\u0026self) -\u003e Result\u003csuper::Stats\u003e {\n        Ok(self.get_inner()?.stats.to_owned())\n    }\n\n    fn save_stats(\u0026self, stats: \u0026super::Stats) -\u003e Result\u003c()\u003e {\n        self.get_inner_mut().map(|mut inner| {\n            inner.stats.clone_from(stats);\n        })?;\n        Ok(())\n    }\n\n    fn update(\u0026self, address: \u0026super::CachedAddress) {\n        self.get_inner_mut()\n            .map(|mut inner| {\n                inner\n                    .addresses\n                    .entry(address.script_hash)\n                    .and_modify(|addr| addr.clone_from(address));\n            })\n            .unwrap();\n    }\n\n    fn get_cache_height(\u0026self) -\u003e Result\u003cu32\u003e {\n        Ok(self.get_inner()?.height)\n    }\n\n    fn set_cache_height(\u0026self, height: u32) -\u003e Result\u003c()\u003e {\n        self.get_inner_mut()?.height = height;\n        Ok(())\n    }\n\n    fn desc_save(\u0026self, descriptor: \u0026str) -\u003e Result\u003c()\u003e {\n        self.get_inner_mut().map(|mut inner| {\n            inner.descriptors.push(descriptor.into());\n        })\n    }\n\n    fn descs_get(\u0026self) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        Ok(self.get_inner()?.descriptors.to_owned())\n    }\n\n    fn get_transaction(\u0026self, txid: \u0026bitcoin::Txid) -\u003e Result\u003csuper::CachedTransaction\u003e {\n        if let Some(tx) = self.get_inner()?.transactions.get(txid) {\n            return Ok(tx.clone());\n        }\n        Err(MemoryDatabaseError::PoisonedLock)\n    }\n\n    fn save_transaction(\u0026self, tx: \u0026super::CachedTransaction) -\u003e Result\u003c()\u003e {\n        self.get_inner_mut()?\n            .transactions\n            .insert(tx.hash, tx.to_owned());\n        Ok(())\n    }\n\n    fn list_transactions(\u0026self) -\u003e Result\u003cVec\u003cTxid\u003e\u003e {\n        Ok(self.get_inner()?.transactions.keys().copied().collect())\n    }\n}\n","traces":[{"line":36,"address":[1070544],"length":1,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[1070565],"length":1,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[1012032,1012045],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":41,"address":[1070592],"length":1,"stats":{"Line":4},"fn_name":null},{"line":42,"address":[1070613],"length":1,"stats":{"Line":4},"fn_name":null},{"line":44,"address":[1012064,1012081],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":46,"address":[1070640],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[1070657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[1070704],"length":1,"stats":{"Line":4},"fn_name":"save"},{"line":55,"address":[1070731,1070751],"length":1,"stats":{"Line":8},"fn_name":null},{"line":56,"address":[1012270,1012096],"length":1,"stats":{"Line":8},"fn_name":"{closure#0}"},{"line":57,"address":[1012135,1012240],"length":1,"stats":{"Line":8},"fn_name":null},{"line":59,"address":[1012181],"length":1,"stats":{"Line":4},"fn_name":null},{"line":64,"address":[1071151,1070816],"length":1,"stats":{"Line":1},"fn_name":"load"},{"line":65,"address":[1070846,1071053],"length":1,"stats":{"Line":8},"fn_name":null},{"line":68,"address":[1071184,1071460],"length":1,"stats":{"Line":4},"fn_name":"get_stats"},{"line":69,"address":[1071385,1071214],"length":1,"stats":{"Line":8},"fn_name":null},{"line":72,"address":[1071488],"length":1,"stats":{"Line":0},"fn_name":"save_stats"},{"line":73,"address":[1012304,1012407],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":74,"address":[1012331,1012376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[1071570],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[1071616],"length":1,"stats":{"Line":3},"fn_name":"update"},{"line":80,"address":[1071655,1071635],"length":1,"stats":{"Line":6},"fn_name":null},{"line":81,"address":[1012432,1012619],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":82,"address":[1012576,1012556,1012462],"length":1,"stats":{"Line":9},"fn_name":null},{"line":84,"address":[1012514],"length":1,"stats":{"Line":3},"fn_name":null},{"line":85,"address":[1012656,1012681,1012563],"length":1,"stats":{"Line":9},"fn_name":"{closure#0}"},{"line":90,"address":[1071696,1071900],"length":1,"stats":{"Line":0},"fn_name":"get_cache_height"},{"line":91,"address":[1071700,1071859],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[1072136,1071936],"length":1,"stats":{"Line":0},"fn_name":"set_cache_height"},{"line":95,"address":[1071944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[1072117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[1072160],"length":1,"stats":{"Line":0},"fn_name":"desc_save"},{"line":100,"address":[1012704,1012846],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":101,"address":[1012781,1012736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[1072513,1072256],"length":1,"stats":{"Line":0},"fn_name":"descs_get"},{"line":106,"address":[1072443,1072286],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[1072544,1072912],"length":1,"stats":{"Line":2},"fn_name":"get_transaction"},{"line":110,"address":[1072579,1072769],"length":1,"stats":{"Line":6},"fn_name":null},{"line":111,"address":[1072874,1072839],"length":1,"stats":{"Line":6},"fn_name":null},{"line":113,"address":[1072861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[1072944,1073300],"length":1,"stats":{"Line":1},"fn_name":"save_transaction"},{"line":117,"address":[1072956,1073166,1073246],"length":1,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[1073258,1073124,1073175],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[1073278],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[1073667,1073328],"length":1,"stats":{"Line":0},"fn_name":"list_transactions"},{"line":124,"address":[1073358,1073560],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":28,"coverable":47},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-watch-only","src","merkle.rs"],"content":"use bitcoin::consensus::Decodable;\nuse bitcoin::consensus::Encodable;\nuse bitcoin::hashes::sha256d;\nuse bitcoin::hashes::Hash;\nuse bitcoin::hashes::HashEngine;\nuse bitcoin::Block;\nuse bitcoin::Txid;\nuse floresta_common::prelude::*;\nuse serde::Deserialize;\nuse serde::Serialize;\n#[derive(Clone, Debug, Hash, PartialEq, Eq, Serialize, Deserialize)]\npub struct MerkleProof {\n    target: Txid,\n    pos: u64,\n    hashes: Vec\u003csha256d::Hash\u003e,\n}\nimpl Default for MerkleProof {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\nimpl MerkleProof {\n    /// Creates an empty proof\n    fn new() -\u003e Self {\n        MerkleProof {\n            target: Txid::all_zeros(),\n            hashes: Vec::new(),\n            pos: 0,\n        }\n    }\n    /// Returns the hashes for this proof\n    pub fn hashes(\u0026self) -\u003e Vec\u003csha256d::Hash\u003e {\n        self.hashes.clone()\n    }\n    /// Creates a new proof from a list of hashes and a target. Target is a 64 bits\n    /// unsigned integer indicating the index of a transaction we with to prove. Note that\n    /// this only proves one tx at the time.\n    pub fn from_block_hashes(tx_list: Vec\u003csha256d::Hash\u003e, target: u64) -\u003e Self {\n        let target_hash = tx_list[target as usize];\n        let (_, proof) = Self::transverse(tx_list, Vec::new(), target);\n        Self {\n            target: target_hash.into(),\n            pos: target,\n            hashes: proof,\n        }\n    }\n    /// Same as [MerkleProof::from_block_hashes] but you give a block instead of a list of\n    /// hashes.\n    pub fn from_block(block: \u0026Block, target: u64) -\u003e Self {\n        let tx_list: Vec\u003c_\u003e = block\n            .txdata\n            .iter()\n            .map(|tx| tx.txid().to_raw_hash())\n            .collect();\n        Self::from_block_hashes(tx_list, target)\n    }\n    #[allow(unused)]\n    /// Verifies a proof by hashing up all nodes until reach a root, and compare `root` with\n    /// computed root.\n    pub fn verify(\u0026self, root: sha256d::Hash) -\u003e Result\u003cbool, String\u003e {\n        let mut computed = self.target.to_raw_hash();\n        let mut placement = self.pos;\n        for hash in self.hashes.iter() {\n            if placement \u0026 1 == 0 {\n                computed = Self::parent_hash(computed.as_ref(), hash.as_ref());\n            } else {\n                computed = Self::parent_hash(hash.as_ref(), computed.as_ref());\n            }\n\n            placement \u003e\u003e= 1;\n        }\n        Ok(root == computed)\n    }\n    /// Returns the position of a node's parent\n    fn get_parent(pos: u64) -\u003e u64 {\n        (pos ^ 1) / 2\n    }\n    /// Returns a node's sibling. This is useful because we have to copy a node's sibling\n    /// to proof, so we can compute it's parent.\n    fn get_sibling(pos: u64) -\u003e u64 {\n        pos ^ 1\n    }\n    /// Computes the hash of two node's parent, by taking sha256d(left_child | right_child), where |\n    /// means byte-wise concatenation.\n    fn parent_hash(left: \u0026[u8], right: \u0026[u8]) -\u003e sha256d::Hash {\n        let mut engine = sha256d::Hash::engine();\n        engine.input(left);\n        engine.input(right);\n        sha256d::Hash::from_engine(engine)\n    }\n    /// Iterates over the tree, collecting required nodes for proof, internally we compute\n    /// all intermediate nodes, but don't keep them.\n    fn transverse(\n        nodes: Vec\u003csha256d::Hash\u003e,\n        mut proof: Vec\u003csha256d::Hash\u003e,\n        target: u64,\n    ) -\u003e (Vec\u003csha256d::Hash\u003e, Vec\u003csha256d::Hash\u003e) {\n        // We reached a root. This is the recursion base\n        if nodes.len() == 1 {\n            return (nodes, proof);\n        }\n        // Here we store all nodes for the next row\n        let mut new_nodes = Vec::new();\n        // Grab a node's sibling. In a Merkle Tree, our target nodes are given, and its parent\n        // can be computed using available data. We must only provide a node's sibling, so verifier\n        // can get a parent hash.\n        let sibling = Self::get_sibling(target);\n\n        // This if catches an edge case where we try to get a sibling from the last node\n        // in a non-perfect tree. This yields an out-of-bound read from nodes.\n        if sibling != nodes.len() as u64 {\n            proof.push(nodes[sibling as usize]);\n        } else {\n            proof.push(nodes[target as usize]);\n        }\n        // If the row has a odd number of nodes, we must repeat the last node to force it\n        // even.\n        let node_count = nodes.len();\n\n        let pairs = if node_count % 2 == 0 {\n            node_count / 2\n        } else {\n            (node_count + 1) / 2\n        };\n\n        for idx in 0..pairs {\n            if (2 * idx + 1) \u003e= node_count {\n                new_nodes.push(Self::parent_hash(\n                    nodes[2 * idx].as_ref(),\n                    nodes[2 * idx].as_ref(),\n                ));\n            } else {\n                new_nodes.push(Self::parent_hash(\n                    nodes[2 * idx].as_ref(),\n                    nodes[2 * idx + 1].as_ref(),\n                ));\n            }\n        }\n        Self::transverse(new_nodes, proof, Self::get_parent(target))\n    }\n}\n\nimpl Decodable for MerkleProof {\n    fn consensus_decode\u003cR: Read + ?Sized\u003e(\n        reader: \u0026mut R,\n    ) -\u003e Result\u003cSelf, bitcoin::consensus::encode::Error\u003e {\n        let pos = u64::consensus_decode(reader)?;\n        let target = Txid::consensus_decode(reader)?;\n        let len = u64::consensus_decode(reader)?;\n        let mut hashes = Vec::new();\n        for _ in 0..len {\n            let hash = sha256d::Hash::consensus_decode(reader)?;\n            hashes.push(hash);\n        }\n        Ok(Self {\n            hashes,\n            pos,\n            target,\n        })\n    }\n}\n\nimpl Encodable for MerkleProof {\n    fn consensus_encode\u003cW: Write + ?Sized\u003e(\u0026self, writer: \u0026mut W) -\u003e Result\u003cusize, ioError\u003e {\n        let mut len = 0;\n        len += self.pos.consensus_encode(writer)?;\n        len += self.target.consensus_encode(writer)?;\n\n        let hashes_len = self.hashes.len() as u64;\n        len += hashes_len.consensus_encode(writer)?;\n\n        for hash in self.hashes.iter() {\n            len += hash.consensus_encode(writer)?;\n        }\n        Ok(len)\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use bitcoin::consensus::deserialize;\n    use bitcoin::hashes::hex::FromHex;\n    use bitcoin::hashes::sha256d;\n    use floresta_common::prelude::*;\n\n    use super::MerkleProof;\n    #[test]\n    fn test_merkle_root() {\n        let hashes = Vec::from([\n            \"9fe0683d05e5a8ce867712f0f744a1e9893365307d433ab3b8f65dfc59d561de\",\n            \"9e2804f04a9d52ad4b67e10cba631934915a7d6d083126b338dda680522bb602\",\n            \"01ad659d8d3f17e96d54e4240614fad5813a58cc1ac67a336839b0bf6c56f2d3\",\n            \"8627dad7e4df3cc60d1349aac61cae36436423429a12f3df9a1e54a5ca8ee008\",\n            \"5f82784d819f440ee1766d9802d113c54626bd613009cbf699213f49adf2fbbd\",\n        ]);\n        let root = sha256d::Hash::from_str(\n            \"ff8fa20a8da05e334d59d257c8ba6f76b31856fafe92afdb51151daa2fe0a240\",\n        )\n        .unwrap();\n        let hashes: Vec\u003c_\u003e = hashes\n            .iter()\n            .map(|txid| sha256d::Hash::from_str(txid).unwrap())\n            .collect();\n        let proof = MerkleProof::from_block_hashes(hashes, 2);\n        assert_eq!(Ok(true), proof.verify(root));\n    }\n    #[test]\n    fn test_serialization() {\n        use bitcoin::consensus::serialize;\n        let hashes = Vec::from([\n            \"9fe0683d05e5a8ce867712f0f744a1e9893365307d433ab3b8f65dfc59d561de\",\n            \"9e2804f04a9d52ad4b67e10cba631934915a7d6d083126b338dda680522bb602\",\n            \"01ad659d8d3f17e96d54e4240614fad5813a58cc1ac67a336839b0bf6c56f2d3\",\n            \"8627dad7e4df3cc60d1349aac61cae36436423429a12f3df9a1e54a5ca8ee008\",\n            \"5f82784d819f440ee1766d9802d113c54626bd613009cbf699213f49adf2fbbd\",\n        ]);\n        let root = sha256d::Hash::from_str(\n            \"ff8fa20a8da05e334d59d257c8ba6f76b31856fafe92afdb51151daa2fe0a240\",\n        )\n        .unwrap();\n        let hashes: Vec\u003c_\u003e = hashes\n            .iter()\n            .map(|txid| sha256d::Hash::from_str(txid).unwrap())\n            .collect();\n\n        let proof = MerkleProof::from_block_hashes(hashes, 2);\n        let ser_proof = serialize(\u0026proof);\n        let de_proof = deserialize::\u003cMerkleProof\u003e(\u0026ser_proof);\n\n        assert!(de_proof.is_ok());\n\n        let de_proof = de_proof.unwrap();\n        assert_eq!(de_proof, proof);\n        assert!(de_proof.verify(root).unwrap());\n    }\n    #[test]\n    fn test_from_block() {\n        // Example from signet block 114448. This has a edge case of the target transaction\n        // being the last one in a odd number of elements, this caused this code to break in the past\n        // credit to @jaonoctus for finding it.\n        let block_hex = Vec::from_hex(\"000000200e7a1b4acac9d0fede38780af685f4f2468f379441da88d9333190e9fd000000de17ded487dedf4febfc2062696f726daf82c387c40ac6bf3f730cb6b8078ea6c7cb5c631e52011eafd2850109010000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff040310bf01feffffff02cdf7052a0100000016001481113cad52683679a83e76f76f84a4cfe36f75010000000000000000776a24aa21a9ed1a57f94172436261a598a05fd00f5dc6f0af113118b2ad0fd5ab067cdf14d0844c4fecc7daa2490047304402200188f50f763b594ad2515b5fe7a6ccd0651cb21a57f7c9462517809b0a71056a022073de9d51712ed92333fdf103021ab15f9d7ee438a9f40c4d21a2aae25e30a746010001200000000000000000000000000000000000000000000000000000000000000000000000000200000000010600f477f4573600d59279b8590ad2f393e80e35a4747a6bb980ed435cae516a470100000000fdffffffeeed54083b3a3b3d5fbd2b89dbd584cf9473caecff5307ef6a45d4bf895d3c9f0100000000fdffffff71998948a594919d5f458ca629851af2cddc6a707a46953946fa169785809cc50000000000fdffffff95aff1490be1d5cd7c0147cad2f09e85419661322abe55177e6c37cf74a274da0100000000fdffffff3989e6239f74d9f01863b9cdeb139c911f864e56f42d9a423e2fb56b8acff0e40100000000fdffffffa14095a3c7134dcfe63670990f1aae604e9c75c995bbe4e786d5dad9e210bdfa0100000000fdffffff011e21730200000000160014167905ff5769be1088fba282d5f2fe083eafd24f024730440220524dae54f383a34a3605a0fdd403f5e69e991675d4d631925fd38b16f11d965b02207946cd9a39407d722cb3407913dfd13970b347473e87fdf2dfa3d5ea9dc2e14d012102e62ff0a4b5f94bed13bda49c6f28016a4c462246ca234d91010050d67a766d850247304402206e2410b4b76d09b4c67c84f005d84e46e9d444495734dd3037f1cd8ac938de8602206da11b400e7b02a7ee6a51cb7b42b893db214a2ffff2eac75502429f50b03f8301210215a12de3be0588cc75b0f4c313dae06dbd9ecee933532f4d792bc25fa7a866aa024730440220255e7e199d8dfdc3764e7328b96a26d014f337d27f6629022bc4d6499af832020220703ae4dee6b14a568c877e31af8ead209316891a33eee085dc695ae7fc1cfc84012103dceb3c814a400f39c67d4cd71f926bf1e1dc8944445f712a3ea583ea5f4d1e9b0247304402203a5eb82548dd0ff5f443b66e7f26f5c846315cfbfe488854027dc417c27993090220058ce815c913b0a4b24bd8d9db0a350f5c3bb2b4dcdec2a002a24c440b8496e0012102e8f9662c11aec882442f42dad5d7c19373249793a2a6b630c1971c8e2930ad0f0247304402203411bb65d910def1892d83dba89c6ea6664313eda18af70248884efe4ec6c204022029845c30b2904b60ab5fe6e19cf448f970dfe61cf2e4079482c55f1bb8b8cf4a0121030e8756107674bf33e2392d77f20d2890570c605282e665ec56358b72861219da02473044022075517e3dcfde63549abb19db17fe8a88b2cc643c921b295388c79f78936d3d8802202699e190c42a53856e99211f7b2a702fbc29466bfcac5d7a10e57fd77c109b1801210381477a1e64fda3873c3833c7cbe12cf0a8379a10c57e143be887cf5a53fe46bc0ebf0100020000000001011963991b6c03ca15f9ec0e4ad611e474c3277d0c3655bc9d797de1c14ab7aa7c0100000000feffffff0240420f00000000001600142349b57a01d75c7c858ac751f897239a86bbf04bb873285d5106000016001414bf9b0fe92caa0097b63a1ef3ea275d410fd98d02473044022054b442f21f988a0b97e6d7e8b24e23ccfecfaa12c0eb9eb96775a7765af941de022050d04a2db06e86fe9c9f90fee1169648cf9531e4c3697a744296f6b61324f4830121028bf1e30de43373796a0991b98aa5a4195c86495fba684656a26b0096df3110990fbf010002000000000101344f1ef28a664fe17a4aa50b8d3009ef6c6e49b85d66f8f9b3449bb74582ea350000000000feffffff0240420f0000000000160014e44b51eb316763098c5d18de6ca8b2c0a59c0e17bc9ce6df4f0600001600145fd025abef9e808689076765f4f0c56738c59f39024730440220479115072916500cffc1cc52fd889e5bf832a353125a1bdece97f7563feb5e090220504c4c7dd6a1f6cb0c2ba50c44187f46075dd8b20f94ad6c8b6bafc790dbcc31012102f2bdad8ec4652cb21e7605f26bc81ca66c10ff28e0f3d2a0ea19fc8cd52099b10fbf010002000000000101edd9a6cc38a24a387dc9abe7a1701886fcb2320657b144d0d0316e8ca43ae3d70000000000feffffff0240420f000000000022512010e8ae98031a5708b4bf6569c51f2fff6b000d0237d094bba411b684bb91357aafcb93035206000016001460f37086e9aaae4ddbf4b239482368a10d9c41c70247304402201ee3fdce8f0fb88e23ebdb43fab44044d099f85f506a93feb18b3dd2396b10f002206e82dab913ea09a62509b34b9d1799682af3dc2852a7ca3a851f0d377f8f387001210263bb044157db46c69b30e280e1b012aeeef7e4d2e324bb1badf6b271eea081d50fbf010002000000000101716c42179f6c5c18bb8c648fbb5697e4ada7a3661d6dc41988898b4a3366f00b0000000000feffffff028fbb1b0c000000001600145cb211255a52a72c50ff28125e6d19c3783634246a2b010000000000160014b323d1a6d231f481ec9d0edb4b6628ad7c3013ed02473044022013a5cf7f8b40b66b49d1d3b0da3b045c55eb65da1f0ab5b51925ad1ab74676420220670a2cc57fdd95bec289f3659254683401f550ead6c518ea69b2ac5e154a984d012102638e70a1e4a118a68d0a222d6783bb89308e54c403b44347c140c47d9f3f00290fbf0100020000000001018aece6fc6208c756036d569293b3f309fd753b7e72aef0d57d9d937db72721cf0100000000feffffff02590db89c5006000016001456e2f3da4da33aef14ddfcb6b732a81ff7e8675d40420f00000000002251205e15d348f226d1ea063a79e25aace48990dc473f61ae23f517e07f2917ac721c024730440220545d47834d82f7701cf229d5261f7de206f935ba4b0b58bb89d515add9a900d402207fd29ec10e8e2c935aba34c22d9dc8fc37b32cb0ab4ab4bff91fe6c68456b0c1012103ae5be7da80c63939f16a801363033d52c4e551b55eb1329d09ffa244e0d793290fbf010002000000000101911cf9966a3d8cd2bfb90f6f5d099c1e568a55bdcc55c4e6c041fc600614a3520100000000feffffff020dce63d44e0600001600145cee73b449f3da151659deb159148753c283381140420f0000000000225120b3b15df11fed9bca782f500031c94efc4ed8e4b0521c00295784d7dc5ac8684c02473044022046abbd3a4c279ddd535c3695bb89300f46494411f29c617862ccbb38b923ee740220638ad662b069c9977d4ac51065b493545ff3f4a890c05b42717be6d5ab9b3bd201210254f0f69224472b7f6a0849587a171637916a274d7ddef895dba298e6a1d89dbfadbe0100020000000001013d154c4a311dc630d1b3b403a327f03c07348b6c6cf0557500ef518ca412a2990000000000feffffff026d0833374d060000160014359a35960efb7c6ad62119702edf555163c03ab640420f0000000000225120dd0440d706666db07ae597a02d7af497d8fe1fdf059d1ca0b3c13b6d00a7d24f02473044022038535e6b04102ac866e896a33692e4050339de1f078b375c72d14914133cf9c6022034ad2f08092667cf8e5c60973771bef68315a47dff73f8ad4f0ef1d4a7d863110121032a42df4c108ad44282a75746f52161759aff3adc38bde305be7f5ddf172860120ebf0100\").unwrap();\n        let block = deserialize(\u0026block_hex).unwrap();\n        let merkle = MerkleProof::from_block(\u0026block, 8);\n\n        assert!(merkle\n            .verify(*block.header.merkle_root.as_raw_hash())\n            .unwrap());\n    }\n}\n","traces":[{"line":18,"address":[993152],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":19,"address":[993160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[993184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[993197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[993207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[993312],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[993329],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[993344,993964,993931],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[993395,993489],"length":1,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[993506,993942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[993733],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[994000],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[994042],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[1154272,1154307],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":55,"address":[994094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[994144],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[994179],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[994239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[994393,994251,994677],"length":1,"stats":{"Line":5},"fn_name":null},{"line":64,"address":[994414,994545],"length":1,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[994432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[994552],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[994658],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[994350],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[994688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[994696],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[994704],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[994712],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[994720],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[994789],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[994810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[994831],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[994842],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[997205,996313,994912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[994978,995082],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[995116],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[995275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[995306,995386],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[995394],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[995484,995605],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[995522,995446],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[995574,995657],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[995673,995857],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[995722,995683],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[995804,995693],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[995875,996087,995733],"length":1,"stats":{"Line":3},"fn_name":null},{"line":127,"address":[996111,996354],"length":1,"stats":{"Line":3},"fn_name":null},{"line":128,"address":[997106],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[996883,996505],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[996969],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[996831],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[996550,996472],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[996636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[995985,996279,996143,996324],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[1154352,1155555],"length":1,"stats":{"Line":1},"fn_name":"consensus_decode\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":147,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":68,"coverable":75},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","cli_wire","mod.rs"],"content":"use std::{\n    collections::HashMap,\n    io::BufReader,\n    net::TcpStream,\n    sync::{atomic::AtomicBool, Arc},\n    time::Duration,\n};\n\nuse bitcoin::{\n    consensus::{deserialize, deserialize_partial, Encodable},\n    hashes::{\n        hex::{FromHex, ToHex},\n        sha256, Hash,\n    },\n    Block, BlockHash, BlockHeader, OutPoint,\n};\nuse btcd_rpc::{\n    client::{BTCDClient, BtcdRpc},\n    json_types::{blockchain::GetUtreexoProofResult, VerbosityOutput},\n};\nuse log::{error, info};\nuse rustreexo::accumulator::proof::Proof;\nuse serde::Deserialize;\n\nuse super::{\n    chain_state::ChainState, chainstore::KvChainStore, error::BlockchainError, udata::LeafData,\n    BlockchainInterface, Result, UpdatableChainstate,\n};\nuse crate::try_and_log;\n\npub struct UtreexodBackend {\n    pub use_batch_sync: bool,\n    pub batch_sync_hostname: String,\n    pub rpc: Arc\u003cBTCDClient\u003e,\n    pub chainstate: Arc\u003cChainState\u003cKvChainStore\u003e\u003e,\n    pub term: Arc\u003cAtomicBool\u003e,\n}\n\nimpl UtreexodBackend {\n    fn _get_block_hash(\u0026self, height: u32) -\u003e Result\u003cbitcoin::BlockHash\u003e {\n        Ok(BlockHash::from_hex(\n            self.rpc.getblockhash(height as usize)?.as_str(),\n        )?)\n    }\n    fn get_height(\u0026self) -\u003e Result\u003cu32\u003e {\n        let block = self.rpc.getbestblock()?;\n        Ok(block.height as u32)\n    }\n\n    fn broadcast(\u0026self, tx: \u0026bitcoin::Transaction) -\u003e Result\u003c()\u003e {\n        let mut writer = Vec::new();\n        let _ = tx\n            .consensus_encode(\u0026mut writer)\n            .expect(\"Should be a valid transaction\");\n        if self.rpc.sendrawtransaction(writer.to_hex()).is_err() {\n            error!(\"Error while broadcasting tx {}\", tx.txid());\n        }\n        Ok(())\n    }\n\n    fn _estimate_fee(\u0026self, target: usize) -\u003e Result\u003cf64\u003e {\n        let feerate = self.rpc.estimatefee(target as u32)?;\n        Ok(feerate)\n    }\n    pub fn get_block(\u0026self, height: u32) -\u003e Result\u003cBlock\u003e {\n        let hash = self.rpc.getblockhash(height as usize)?;\n        let block = self.rpc.getblock(hash, false)?;\n        if let VerbosityOutput::Simple(hex) = block {\n            let block = Vec::from_hex(hex.as_str())?;\n            let (block, _): (Block, usize) = deserialize_partial(\u0026block).unwrap();\n            let validation = block.header.validate_pow(\u0026block.header.target());\n            assert!(validation.is_ok());\n            return Ok(block);\n        }\n        Err(BlockchainError::BlockNotPresent)\n    }\n    pub fn get_proof\u003cT: BtcdRpc\u003e(\n        rpc: \u0026T,\n        hash: \u0026String,\n    ) -\u003e Result\u003c(Proof, Vec\u003csha256::Hash\u003e, Vec\u003cLeafData\u003e)\u003e {\n        let proof = rpc.getutreexoproof(hash.to_string(), true)?.get_verbose();\n        Self::process_proof(proof)\n    }\n    fn process_proof(\n        proof: GetUtreexoProofResult,\n    ) -\u003e Result\u003c(Proof, Vec\u003csha256::Hash\u003e, Vec\u003cLeafData\u003e)\u003e {\n        let preimages: Vec\u003c_\u003e = proof\n            .target_preimages\n            .iter()\n            .map(|preimage| {\n                deserialize_partial::\u003cLeafData\u003e(\u0026Vec::from_hex(preimage).unwrap())\n                    .unwrap()\n                    .0\n            })\n            .collect();\n\n        let proof_hashes: Vec\u003c_\u003e = proof\n            .proofhashes\n            .iter()\n            .map(|hash| sha256::Hash::from_hex(hash).unwrap())\n            .collect();\n        let targets = proof.prooftargets;\n\n        let targethashes: Vec\u003c_\u003e = proof\n            .targethashes\n            .iter()\n            .map(|hash| sha256::Hash::from_hex(hash).unwrap())\n            .collect();\n        let proof = Proof::new(targets, proof_hashes);\n\n        Ok((proof, targethashes, preimages))\n    }\n\n    pub fn handle_broadcast(\u0026self) -\u003e Result\u003c()\u003e {\n        let tx_list = self.chainstate.get_unbroadcasted();\n        for tx in tx_list {\n            self.broadcast(\u0026tx)?;\n        }\n        Ok(())\n    }\n    pub async fn handle_tip_update(\u0026self) -\u003e Result\u003c()\u003e {\n        let height = self.get_height()?;\n        let local_best = self.chainstate.get_best_block().unwrap().0;\n        if height \u003e local_best {\n            self.get_headers()?;\n            self.download_blocks().await?;\n        }\n        Ok(())\n    }\n    fn process_block(\u0026self, block_height: u32) -\u003e Result\u003c()\u003e {\n        let block = self.get_block(block_height)?;\n        let (proof, del_hashes, leaf_data) =\n            Self::get_proof(\u0026*self.rpc, \u0026block.block_hash().to_string())?;\n        let mut inputs = HashMap::new();\n        for tx in block.txdata.iter() {\n            for (vout, out) in tx.output.iter().enumerate() {\n                inputs.insert(\n                    OutPoint {\n                        txid: tx.txid(),\n                        vout: vout as u32,\n                    },\n                    out.clone(),\n                );\n            }\n        }\n        for leaf in leaf_data {\n            inputs.insert(leaf.prevout, leaf.utxo);\n        }\n        self.chainstate\n            .connect_block(\u0026block, proof, inputs, del_hashes)?;\n        Ok(())\n    }\n    async fn download_blocks(\u0026self) -\u003e Result\u003c()\u003e {\n        let height = self.get_height()?;\n        let current = self.chainstate.get_validation_index()?;\n        // We don't download genesis, because utreexod will error out if we try to fetch\n        // proof for it.\n        let current = if current == 0 { 1 } else { current };\n        if self.chainstate.is_in_idb() {\n            info!(\"Start Initial Block Download at height {current} of {height}\");\n        }\n        for block_height in current..=height {\n            if self.is_shutting_down() {\n                return Ok(());\n            }\n\n            if block_height % 10_000 == 0 {\n                info!(\"Sync at block {block_height}\");\n                if block_height % 100_000 == 0 {\n                    self.chainstate.flush()?;\n                }\n            }\n            self.process_block(block_height)?;\n        }\n        if self.chainstate.is_in_idb() {\n            info!(\"Leaving Initial Block Download at height {height}\");\n        } else {\n            info!(\"New tip: {height}\");\n        }\n        self.chainstate.toggle_ibd(false);\n        self.chainstate.flush()?;\n\n        Ok(())\n    }\n    async fn process_batch_block(\u0026self) -\u003e Result\u003c()\u003e {\n        let socket = TcpStream::connect(self.batch_sync_hostname.to_owned().as_str())?;\n\n        let height = self.get_height()?;\n        let current = self.chainstate.get_validation_index()?;\n        let mut reader = BufReader::new(socket);\n        for _ in (current + 1)..=height {\n            if self.is_shutting_down() {\n                return Ok(());\n            }\n            let block_data = rmp_serde::decode::from_read::\u003c_, BlockData\u003e(\u0026mut reader);\n            if block_data.is_err() {\n                error!(\"{:?}\", block_data);\n                break;\n            }\n            let block_data = block_data.unwrap();\n            let (proof, del_hashes, leaf_data) = Self::process_proof(block_data.proof)?;\n            let mut inputs = HashMap::new();\n            for tx in block_data.block.txdata.iter() {\n                for (vout, out) in tx.output.iter().enumerate() {\n                    inputs.insert(\n                        OutPoint {\n                            txid: tx.txid(),\n                            vout: vout as u32,\n                        },\n                        out.clone(),\n                    );\n                }\n            }\n            if block_data.height % 10_000 == 0 {\n                info!(\"Sync at block {}\", block_data.height);\n                self.chainstate.flush()?;\n            }\n            for leaf in leaf_data {\n                inputs.insert(leaf.prevout, leaf.utxo);\n            }\n            self.chainstate\n                .connect_block(\u0026block_data.block, proof, inputs, del_hashes)?;\n        }\n        info!(\"Leaving ibd\");\n        self.chainstate.toggle_ibd(false);\n        self.chainstate.flush()?;\n\n        Ok(())\n    }\n    fn get_headers(\u0026self) -\u003e Result\u003c()\u003e {\n        let tip = self.get_height()?;\n        let current = self.chainstate.get_best_block()?.0;\n        info!(\"Downloading headers\");\n        for i in (current / 2_000)..((tip / 2_000) + 1) {\n            if self.is_shutting_down() {\n                return Ok(());\n            }\n            let locator = self.chainstate.get_block_locator()?;\n            let locator = locator\n                .iter()\n                .map(|hash| hash.to_string())\n                .collect::\u003cVec\u003c_\u003e\u003e();\n\n            let headers = self\n                .rpc\n                .getheaders(locator, BlockHash::all_zeros().to_string())?;\n\n            let headers = headers\n                .iter()\n                .map(|header| {\n                    let header = Vec::from_hex(header).unwrap();\n                    deserialize::\u003cBlockHeader\u003e(\u0026header).unwrap()\n                })\n                .collect::\u003cVec\u003c_\u003e\u003e();\n\n            for header in headers {\n                self.chainstate.accept_header(header)?;\n            }\n            self.chainstate.flush()?;\n            info!(\n                \"Downloading headers...{:02.0}%\",\n                ((i * 2_000) as f64) / (tip as f64) * 100.00\n            );\n        }\n        Ok(())\n    }\n\n    pub async fn run(self) {\n        try_and_log!(self.get_headers());\n        if self.is_shutting_down() {\n            info!(\"Shuting blockchain down\");\n            try_and_log!(self.chainstate.flush());\n            return;\n        }\n        if self.use_batch_sync {\n            try_and_log!(self.process_batch_block().await);\n        } else {\n            try_and_log!(self.download_blocks().await);\n        }\n        self.chainstate.toggle_ibd(false);\n        loop {\n            async_std::task::sleep(Duration::from_secs(1)).await;\n            if self.is_shutting_down() {\n                info!(\"Shuting blockchain down\");\n                try_and_log!(self.chainstate.flush());\n                return;\n            }\n            try_and_log!(self.handle_broadcast());\n            try_and_log!(self.handle_tip_update().await);\n            try_and_log!(self.chainstate.flush());\n        }\n    }\n    fn is_shutting_down(\u0026self) -\u003e bool {\n        self.term\n            .fetch_and(true, std::sync::atomic::Ordering::AcqRel)\n    }\n}\n#[macro_export]\n/// Attempt to execute a function, and logs the error, if any.\nmacro_rules! try_and_log {\n    ($what: expr) =\u003e {\n        let result = $what;\n        if let Err(error) = result {\n            log::error!(\"{:?}\", error);\n        }\n    };\n}\n#[allow(unused)]\n#[derive(Debug, Deserialize)]\nstruct BlockData {\n    height: u32,\n    block: Block,\n    proof: GetUtreexoProofResult,\n}\n","traces":[{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","lib.rs"],"content":"// SPDX-License-Identifier: MIT\n//! # Floresta Wire\n//! This crate provides the core networking logic for a full node using libfloresta,\n//! including the P2P network and the mempool. You can easily integrate it with any\n//! other crate that provides a `BlockchainInterface` and `UpdatableChainstate`\n//! implementation.\n//!\n//! A node also gives you a `handle` that you can use to send messages to the node,\n//! like requesting blocks, mempool transactions or asking to connect with a given\n//! peer.\n\n#[cfg(not(target_arch = \"wasm32\"))]\nmod p2p_wire;\nuse bitcoin::block::Header as BlockHeader;\nuse bitcoin::Block;\nuse bitcoin::Transaction;\n#[cfg(not(target_arch = \"wasm32\"))]\npub use p2p_wire::address_man;\n#[cfg(not(target_arch = \"wasm32\"))]\npub use p2p_wire::mempool;\n#[cfg(not(target_arch = \"wasm32\"))]\npub use p2p_wire::node;\n#[cfg(not(target_arch = \"wasm32\"))]\npub use p2p_wire::node_context;\n#[cfg(not(target_arch = \"wasm32\"))]\npub use p2p_wire::node_interface;\n#[cfg(not(target_arch = \"wasm32\"))]\npub use p2p_wire::running_node;\npub use p2p_wire::UtreexoNodeConfig;\n/// NodeHooks is a trait that defines the hooks that a node can use to interact with the network\n/// and the blockchain. Every time an event happens, the node will call the corresponding hook.\npub trait NodeHooks {\n    /// We've received a new block\n    fn on_block_received(\u0026mut self, block: \u0026Block);\n    /// We've received a new transaction\n    fn on_transaction_received(\u0026mut self, transaction: \u0026Transaction);\n    /// We've received a new peer\n    fn on_peer_connected(\u0026mut self, peer: \u0026u32);\n    /// We've lost a peer\n    fn on_peer_disconnected(\u0026mut self, peer: \u0026u32);\n    /// We've received a new header\n    fn on_header_received(\u0026mut self, header: \u0026BlockHeader);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","address_man.rs"],"content":"//! Address manager is a module that keeps track of known peer addresses and associated\n//! metadata. This module is very important in keeping our node protected against targeted\n//! attacks, like eclipse attacks.\n\nuse std::collections::HashMap;\nuse std::fs::File;\nuse std::io;\nuse std::io::Read;\nuse std::net::IpAddr;\nuse std::net::Ipv4Addr;\nuse std::net::Ipv6Addr;\nuse std::str::FromStr;\nuse std::time::SystemTime;\nuse std::time::UNIX_EPOCH;\n\nuse async_std::fs::DirBuilder;\nuse bitcoin::p2p::address::AddrV2;\nuse bitcoin::p2p::address::AddrV2Message;\nuse bitcoin::p2p::ServiceFlags;\nuse floresta_chain::get_chain_dns_seeds;\nuse floresta_chain::Network;\nuse log::info;\nuse rand::Rng;\nuse serde::Deserialize;\nuse serde::Serialize;\nuse thiserror::Error;\n\nconst RETRY_TIME: u64 = 60 * 60; // 1 hour\ntype AddressToSend = Vec\u003c(AddrV2, u64, ServiceFlags, u16)\u003e;\n\n#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]\npub enum AddressState {\n    /// We never tried this peer before, so we don't know what to expect. This variant\n    /// also applies to peers that we tried to connect, but failed or we didn't connect\n    /// to for a long time.\n    NeverTried,\n    /// We tried this peer before, and had success at least once, so we know what to expect\n    Tried(u64),\n    /// This peer misbehaved and we banned them\n    Banned(u64),\n    /// We are connected to this peer right now\n    Connected,\n    /// We tried connecting, but failed\n    Failed(u64),\n}\n/// How do we store peers locally\n#[derive(Debug, Clone, PartialEq)]\npub struct LocalAddress {\n    /// An actual address\n    address: AddrV2,\n    /// Last time we successfully connected to this peer, only relevant is state == State::Tried\n    last_connected: u64,\n    /// Our local state for this peer, as defined in AddressState\n    state: AddressState,\n    /// Network services announced by this peer\n    services: ServiceFlags,\n    /// Network port this peers listens to\n    port: u16,\n    /// Random id for this peer\n    pub id: usize,\n}\n/// Seed Data for paesing in tests.\n#[derive(Debug, Clone, PartialEq, Deserialize)]\npub struct SeedData {\n    /// An actual address\n    address: SeedAddress,\n    /// Last time we successfully connected to this peer, only relevant is state == State::Tried\n    last_connected: u64,\n    /// Our local state for this peer, as defined in AddressState\n    state: AddressState,\n    /// Network services announced by this peer\n    pub services: u64,\n    /// Network port this peers listens to\n    port: u16,\n}\n#[derive(Debug, Deserialize, Serialize, Clone, PartialEq)]\nstruct SeedAddress {\n    V4: Ipv4Addr,\n}\n#[derive(Debug, Error)]\npub enum AddrManError {}\nimpl From\u003cAddrV2\u003e for LocalAddress {\n    fn from(value: AddrV2) -\u003e Self {\n        LocalAddress {\n            address: value,\n            last_connected: SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            state: AddressState::NeverTried,\n            services: ServiceFlags::NONE,\n            port: 8333,\n            id: rand::random::\u003cusize\u003e(),\n        }\n    }\n}\nimpl From\u003cAddrV2Message\u003e for LocalAddress {\n    fn from(value: AddrV2Message) -\u003e Self {\n        LocalAddress {\n            address: value.addr,\n            last_connected: value.time.into(),\n            state: AddressState::NeverTried,\n            services: value.services,\n            port: value.port,\n            id: rand::random::\u003cusize\u003e(),\n        }\n    }\n}\nimpl FromStr for LocalAddress {\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        LocalAddress::try_from(s)\n    }\n    type Err = std::net::AddrParseError;\n}\nimpl TryFrom\u003c\u0026str\u003e for LocalAddress {\n    fn try_from(value: \u0026str) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let split = value.split(':').collect::\u003cVec\u003c_\u003e\u003e();\n        let address = split[0].parse::\u003cIpv4Addr\u003e()?;\n        let port = if let Some(port) = split.get(1) {\n            port.parse().unwrap_or(8333)\n        } else {\n            8333\n        };\n        Ok(LocalAddress::new(\n            AddrV2::Ipv4(address),\n            SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            super::address_man::AddressState::NeverTried,\n            ServiceFlags::NONE,\n            port,\n            rand::random::\u003cusize\u003e(),\n        ))\n    }\n\n    type Error = std::net::AddrParseError;\n}\n\nimpl LocalAddress {\n    pub fn new(\n        address: AddrV2,\n        last_connected: u64,\n        state: AddressState,\n        services: ServiceFlags,\n        port: u16,\n        id: usize,\n    ) -\u003e LocalAddress {\n        LocalAddress {\n            address,\n            last_connected,\n            state,\n            services,\n            port,\n            id,\n        }\n    }\n    /// Returns this address's port\n    pub fn get_port(\u0026self) -\u003e u16 {\n        self.port\n    }\n    /// Return an IP address associated with this peer address\n    pub fn get_net_address(\u0026self) -\u003e IpAddr {\n        match self.address {\n            // IPV4\n            AddrV2::Ipv4(ipv4) =\u003e IpAddr::V4(ipv4),\n            // IPV6\n            AddrV2::Ipv6(ipv6) =\u003e IpAddr::V6(ipv6),\n            _ =\u003e IpAddr::V4(Ipv4Addr::LOCALHOST),\n        }\n    }\n    /// Returns the actual address, as defined in AddrV2. This is useful\n    /// if we are trying a peer that needs a proxy like Tor.\n    pub fn get_address(\u0026self) -\u003e AddrV2 {\n        self.address.clone()\n    }\n}\n/// A module that keeps track of know addresses and serve them to our node to connect\n#[derive(Default)]\npub struct AddressMan {\n    addresses: HashMap\u003cusize, LocalAddress\u003e,\n    good_addresses: Vec\u003cusize\u003e,\n    utreexo_addresses: Vec\u003cusize\u003e,\n}\nimpl AddressMan {\n    /// Add a new address to our list of known address\n    pub fn push_addresses(\u0026mut self, addresses: \u0026[LocalAddress]) {\n        for address in addresses {\n            let id = address.id;\n            if let std::collections::hash_map::Entry::Vacant(e) = self.addresses.entry(id) {\n                // For now we assume that all addresses are valid, until proven otherwise.\n                self.good_addresses.push(id);\n                if address.services.has(ServiceFlags::from(1 \u003c\u003c 24)) {\n                    self.utreexo_addresses.push(id);\n                }\n                e.insert(address.to_owned());\n            }\n        }\n    }\n    pub fn get_addresses_to_send(\u0026self) -\u003e AddressToSend {\n        let addresses = self\n            .addresses\n            .iter()\n            .flat_map(|(time, v)| match v.state {\n                AddressState::Tried(time) =\u003e {\n                    let timeout = time + RETRY_TIME;\n                    let now_as_sec = SystemTime::now()\n                        .duration_since(UNIX_EPOCH)\n                        .unwrap()\n                        .as_secs();\n                    if timeout \u003c now_as_sec {\n                        return Some((v.address.clone(), time, v.services, v.port));\n                    }\n                    None\n                }\n                AddressState::Connected =\u003e {\n                    Some((v.address.clone(), *time as u64, v.services, v.port))\n                }\n                _ =\u003e None,\n            })\n            .collect();\n        addresses\n    }\n    pub fn get_seeds_from_dns(\n        \u0026mut self,\n        seed: \u0026str,\n        default_port: u16,\n    ) -\u003e Result\u003cusize, std::io::Error\u003e {\n        let mut addresses = Vec::new();\n        let utreexo_seed = seed.contains(\"x1000000.\");\n        for ip in dns_lookup::lookup_host(seed)? {\n            if let Ok(mut ip) = LocalAddress::try_from(format!(\"{}:{}\", ip, default_port).as_str())\n            {\n                // This seed returns utreexo nodes\n                if utreexo_seed {\n                    ip.services |= ServiceFlags::from(1 \u003c\u003c 24);\n                }\n                addresses.push(ip);\n            }\n        }\n        self.push_addresses(\u0026addresses);\n        Ok(addresses.len())\n    }\n    /// Returns a new random address to open a new connection, we try to get addresses with\n    /// a set of features supported for our peers\n    pub fn get_address_to_connect(\n        \u0026mut self,\n        flags: ServiceFlags,\n        feeler: bool,\n    ) -\u003e Option\u003c(usize, LocalAddress)\u003e {\n        if self.addresses.is_empty() {\n            return None;\n        }\n        // Feeler connection are used to test if a peer is still alive, we don't care about\n        // the features it supports or even if it's a valid peer. The only thing we care about\n        // is that we haven't banned it.\n        let (id, peer) = if feeler {\n            let idx = rand::random::\u003cusize\u003e() % self.addresses.len();\n            let peer = self.addresses.keys().nth(idx)?;\n            let address = self.addresses.get(peer)?.to_owned();\n            if let AddressState::Banned(_) = address.state {\n                return None;\n            }\n            (*peer, address)\n        } else if flags.has(ServiceFlags::from(1 \u003c\u003c 24)) {\n            // if we don't have an utreexo address, we fallback to a normal good address\n            self.get_random_utreexo_address()\n                .or_else(|| self.get_random_good_address())?\n        } else {\n            self.get_random_good_address()?\n        };\n        let now = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .unwrap()\n            .as_secs();\n        match peer.state {\n            AddressState::Banned(_) =\u003e None,\n            AddressState::Connected =\u003e self.get_random_good_address(),\n            AddressState::NeverTried | AddressState::Tried(_) =\u003e Some((id, peer)),\n            AddressState::Failed(time) =\u003e {\n                if now - time \u003e RETRY_TIME {\n                    Some((id, peer))\n                } else {\n                    None\n                }\n            }\n        }\n    }\n    pub fn dump_peers(\u0026self, datadir: \u0026str) -\u003e std::io::Result\u003c()\u003e {\n        let peers: Vec\u003c_\u003e = self\n            .addresses\n            .values()\n            .cloned()\n            .map(Into::\u003cDiskLocalAddress\u003e::into)\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        let peers = serde_json::to_string(\u0026peers);\n        if let Ok(peers) = peers {\n            std::fs::write(datadir.to_owned() + \"/peers.json\", peers)?;\n        }\n        Ok(())\n    }\n    fn get_random_good_address(\u0026self) -\u003e Option\u003c(usize, LocalAddress)\u003e {\n        if self.good_addresses.is_empty() {\n            return None;\n        }\n        let idx = rand::random::\u003cusize\u003e() % self.good_addresses.len();\n        let good_peer = self.good_addresses.get(idx)?;\n        Some((*good_peer, self.addresses.get(good_peer)?.to_owned()))\n    }\n    fn get_random_utreexo_address(\u0026self) -\u003e Option\u003c(usize, LocalAddress)\u003e {\n        if self.utreexo_addresses.is_empty() {\n            return None;\n        }\n        let idx = rand::random::\u003cusize\u003e() % self.utreexo_addresses.len();\n        let utreexo_peer = self.utreexo_addresses.get(idx)?;\n        Some((*utreexo_peer, self.addresses.get(utreexo_peer)?.to_owned()))\n    }\n    fn get_net_seeds(network: Network) -\u003e \u0026'static str {\n        match network {\n            Network::Bitcoin =\u003e include_str!(\"seeds/mainnet_seeds.json\"),\n            Network::Testnet =\u003e include_str!(\"seeds/testnet_seeds.json\"),\n            Network::Signet =\u003e include_str!(\"seeds/signet_seeds.json\"),\n            Network::Regtest =\u003e include_str!(\"seeds/regtest_seeds.json\"),\n        }\n    }\n    pub fn start_addr_man(\n        \u0026mut self,\n        datadir: String,\n        default_port: u16,\n        network: Network,\n        dns_seeds: \u0026[\u0026'static str],\n    ) -\u003e Result\u003cVec\u003cLocalAddress\u003e, std::io::Error\u003e {\n        let local_db = std::fs::read_to_string(format!(\"{datadir}/peers.json\"));\n        let peers = if let Ok(peers) = local_db {\n            info!(\"Peers database found, using it\");\n\n            serde_json::from_str::\u003cVec\u003cDiskLocalAddress\u003e\u003e(\u0026peers)\n        } else {\n            info!(\"No peers available, using fixed peers\");\n            let mut peers_from_dns = 0;\n            for seed in dns_seeds {\n                peers_from_dns += self.get_seeds_from_dns(seed, default_port)?;\n            }\n            info!(\"Got {peers_from_dns} peers from DNS Seeds\",);\n            let addresses = Self::get_net_seeds(network);\n            serde_json::from_str(addresses)\n        };\n        if let Ok(peers) = peers {\n            let peers = peers\n                .iter()\n                .cloned()\n                .map(Into::\u003cLocalAddress\u003e::into)\n                .collect::\u003cVec\u003c_\u003e\u003e();\n            self.push_addresses(\u0026peers);\n        }\n        let anchors = std::fs::read_to_string(format!(\"{datadir}/anchors.json\"));\n        if anchors.is_err() {\n            return Ok(Vec::new());\n        }\n        if let Ok(anchors) = serde_json::from_str::\u003cVec\u003cDiskLocalAddress\u003e\u003e(\u0026anchors.unwrap()) {\n            let anchors = anchors\n                .iter()\n                .cloned()\n                .map(Into::\u003cLocalAddress\u003e::into)\n                .collect::\u003cVec\u003c_\u003e\u003e();\n            return Ok(anchors);\n        }\n        Ok(Vec::new())\n    }\n    /// This function moves addresses between buckets, like if the ban time of a peer expired,\n    /// or if we tried to connect to a peer and it failed in the past, but now it might be online\n    /// again.\n    pub fn rearrange_buckets(\u0026mut self) {\n        let now = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .unwrap()\n            .as_secs();\n        for (_, address) in self.addresses.iter_mut() {\n            match address.state {\n                AddressState::Banned(ban_time) =\u003e {\n                    if ban_time \u003c now {\n                        address.state = AddressState::NeverTried;\n                    }\n                }\n                AddressState::Tried(tried_time) =\u003e {\n                    if tried_time + RETRY_TIME \u003c now {\n                        address.state = AddressState::NeverTried;\n                    }\n                }\n                AddressState::Failed(failed_time) =\u003e {\n                    if failed_time + RETRY_TIME \u003c now {\n                        address.state = AddressState::NeverTried;\n                    }\n                }\n                AddressState::Connected | AddressState::NeverTried =\u003e {}\n            }\n        }\n    }\n    /// Updates the state of an address\n    pub fn update_set_state(\u0026mut self, idx: usize, state: AddressState) -\u003e \u0026mut Self {\n        if matches!(state, AddressState::Banned(_)) {\n            return self;\n        }\n\n        match state {\n            AddressState::Banned(_) =\u003e {\n                self.good_addresses.retain(|\u0026x| x != idx);\n            }\n            AddressState::Tried(_) =\u003e {\n                if !self.good_addresses.contains(\u0026idx) {\n                    self.good_addresses.push(idx);\n                }\n            }\n            AddressState::NeverTried =\u003e {\n                self.good_addresses.retain(|\u0026x| x != idx);\n            }\n            AddressState::Connected =\u003e {\n                if !self.good_addresses.contains(\u0026idx) {\n                    self.good_addresses.push(idx);\n                }\n            }\n            AddressState::Failed(_) =\u003e {\n                self.good_addresses.retain(|\u0026x| x != idx);\n            }\n        }\n        if let Some(address) = self.addresses.get_mut(\u0026idx) {\n            address.state = state;\n        };\n        self\n    }\n    /// Updates the service flags after we receive a version message\n    pub fn update_set_service_flag(\u0026mut self, idx: usize, flags: ServiceFlags) -\u003e \u0026mut Self {\n        if let Some(address) = self.addresses.get_mut(\u0026idx) {\n            address.services = flags;\n        }\n        self\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DiskLocalAddress {\n    /// An actual address\n    address: Address,\n    /// Last time we successfully connected to this peer, only relevant is state == State::Tried\n    last_connected: u64,\n    /// Our local state for this peer, as defined in AddressState\n    state: AddressState,\n    /// Network services announced by this peer\n    services: u64,\n    /// Network port this peers listens to\n    port: u16,\n    /// An id to identify this address\n    id: Option\u003cusize\u003e,\n}\nimpl From\u003cLocalAddress\u003e for DiskLocalAddress {\n    fn from(value: LocalAddress) -\u003e Self {\n        let address = match value.address {\n            AddrV2::Ipv4(ip) =\u003e Address::V4(ip),\n            AddrV2::Ipv6(ip) =\u003e Address::V6(ip),\n            AddrV2::Cjdns(ip) =\u003e Address::Cjdns(ip),\n            AddrV2::I2p(ip) =\u003e Address::I2p(ip),\n            AddrV2::TorV2(ip) =\u003e Address::OnionV2(ip),\n            AddrV2::TorV3(ip) =\u003e Address::OnionV3(ip),\n            AddrV2::Unknown(_, _) =\u003e Address::V4(Ipv4Addr::LOCALHOST),\n        };\n\n        DiskLocalAddress {\n            address,\n            last_connected: value.last_connected,\n            state: if value.state == AddressState::Connected {\n                AddressState::Tried(\n                    SystemTime::now()\n                        .duration_since(UNIX_EPOCH)\n                        .unwrap()\n                        .as_secs(),\n                )\n            } else {\n                value.state\n            },\n            services: value.services.to_u64(),\n            port: value.port,\n            id: Some(value.id),\n        }\n    }\n}\nimpl From\u003cDiskLocalAddress\u003e for LocalAddress {\n    fn from(value: DiskLocalAddress) -\u003e Self {\n        let address = match value.address {\n            Address::V4(ip) =\u003e AddrV2::Ipv4(ip),\n            Address::V6(ip) =\u003e AddrV2::Ipv6(ip),\n            Address::Cjdns(ip) =\u003e AddrV2::Cjdns(ip),\n            Address::I2p(ip) =\u003e AddrV2::I2p(ip),\n            Address::OnionV2(ip) =\u003e AddrV2::TorV2(ip),\n            Address::OnionV3(ip) =\u003e AddrV2::TorV3(ip),\n        };\n        let services = ServiceFlags::from(value.services);\n        LocalAddress {\n            address,\n            last_connected: value.last_connected,\n            state: value.state,\n            services,\n            port: value.port,\n            id: value.id.unwrap_or_else(rand::random::\u003cusize\u003e),\n        }\n    }\n}\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum Address {\n    /// Regular ipv4 address\n    V4(Ipv4Addr),\n    /// Regular ipv6 address\n    V6(Ipv6Addr),\n    /// Tor v2 address, this may never be used, as OnionV2 is deprecated\n    /// but we'll keep it here for completeness sake\n    OnionV2([u8; 10]),\n    /// Tor v3 address. This is the preferred way to connect to a tor node\n    OnionV3([u8; 32]),\n    /// Cjdns ipv6 address\n    Cjdns(Ipv6Addr),\n    /// I2p address, a 32 byte node key\n    I2p([u8; 32]),\n}\n\n#[cfg(test)]\n\nfn load_addresses_from_json(file_path: \u0026str) -\u003e io::Result\u003cVec\u003cLocalAddress\u003e\u003e {\n    use rand::Rng;\n\n    let mut contents = String::new();\n    File::open(file_path)?.read_to_string(\u0026mut contents)?;\n\n    let seeds: Vec\u003cSeedData\u003e = serde_json::from_str(\u0026contents).expect(\"JSON not well-formatted\");\n    let mut addresses = Vec::new();\n    let mut rng = rand::thread_rng();\n\n    for seed in seeds {\n        let state = match seed.state {\n            AddressState::Tried(time) =\u003e AddressState::Tried(time),\n            _ =\u003e continue,\n        };\n\n        let _address = AddrV2::Ipv4(seed.address.V4);\n\n        let local_address = LocalAddress {\n            address: _address,\n            last_connected: seed.last_connected,\n            state: state,\n            services: ServiceFlags::from(seed.services),\n            port: seed.port,\n            id: rng.gen(),\n        };\n        addresses.push(local_address);\n    }\n\n    Ok(addresses)\n}\n#[test]\nfn test_parse() {\n    let signet_address =\n        load_addresses_from_json(\"./src/p2p_wire/seeds/signet_seeds.json\").unwrap();\n\n    assert!(!signet_address.is_empty());\n    let random = rand::thread_rng().gen_range(1..=14);\n    let loc_adr_1 = LocalAddress::from(signet_address[random].address.clone());\n    assert_eq!(loc_adr_1.address, signet_address[random].address);\n}\n#[test]\nfn test_address_man() {\n    let mut address_man = AddressMan {\n        addresses: HashMap::new(),\n        good_addresses: Vec::new(),\n        utreexo_addresses: Vec::new(),\n    };\n\n    let signet_address =\n        load_addresses_from_json(\"./src/p2p_wire/seeds/signet_seeds.json\").unwrap();\n\n    address_man.push_addresses(\u0026signet_address);\n\n    assert!(!address_man.good_addresses.is_empty());\n\n    assert!(!address_man.utreexo_addresses.is_empty());\n\n    assert!(!address_man.get_addresses_to_send().is_empty());\n\n    assert!(address_man\n        .get_address_to_connect(ServiceFlags::default(), true)\n        .is_some());\n\n    assert!(address_man\n        .get_address_to_connect(ServiceFlags::default(), false)\n        .is_some());\n\n    assert!(address_man.dump_peers(\"./data\").is_ok());\n\n    assert!(address_man.get_random_good_address().is_some());\n\n    assert!(address_man.get_random_utreexo_address().is_some());\n\n    assert!(!AddressMan::get_net_seeds(Network::Signet).is_empty());\n    assert!(!AddressMan::get_net_seeds(Network::Bitcoin).is_empty());\n    assert!(!AddressMan::get_net_seeds(Network::Regtest).is_empty());\n    assert!(!AddressMan::get_net_seeds(Network::Testnet).is_empty());\n\n    assert!(address_man\n        .get_seeds_from_dns(\u0026get_chain_dns_seeds(Network::Signet)[0], 8333)\n        .is_ok());\n\n    assert!(address_man\n        .start_addr_man(\n            \"./data\".to_string(),\n            8333,\n            Network::Signet,\n            \u0026get_chain_dns_seeds(Network::Signet)\n        )\n        .is_ok());\n\n    address_man.rearrange_buckets();\n}\n","traces":[{"line":83,"address":[1591260,1590912],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":86,"address":[1591025,1590955],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[1591153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[1591536,1591296],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":100,"address":[1591318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[1591344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[1591411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[1591420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[1591429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[1591568],"length":1,"stats":{"Line":0},"fn_name":"from_str"},{"line":111,"address":[1591589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[1591616,1592672,1592699],"length":1,"stats":{"Line":1},"fn_name":"try_from"},{"line":117,"address":[1591652],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[1591805,1591727,1592032],"length":1,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[1592082,1592184,1592010],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[1592152,1592190],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[1592174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[1592525,1592602],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[1592248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[1592278,1592348],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[1592473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[1592485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[1592498],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[1592720],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[1592880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[1592885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[1592896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[1592916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[1592974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[1593003],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[1592950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[1593056],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[1593073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[1593104],"length":1,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[1593166,1593235],"length":1,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[1593253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[1593270],"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[1593346],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[1593361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[1593450],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[1593404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[1593472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[1593497],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[1637587,1637536],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":205,"address":[1637650],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[1637979,1637667,1637850],"length":1,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[1637858],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[1637972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[1638027],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[1638014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[1637699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[1637637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[1593553],"length":1,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[1595093,1595179,1593600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[1593674],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[1593719,1593812],"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[1593821,1595156],"length":1,"stats":{"Line":2},"fn_name":null},{"line":232,"address":[1594488,1594701,1595070],"length":1,"stats":{"Line":3},"fn_name":null},{"line":235,"address":[1594791],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[1595046,1594963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[1594836],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[1594269],"length":1,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[1594316],"length":1,"stats":{"Line":1},"fn_name":null},{"line":246,"address":[1595200,1596946],"length":1,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[1595275,1596535],"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[1595313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[1595299,1596309,1595660],"length":1,"stats":{"Line":3},"fn_name":null},{"line":258,"address":[1595357,1595911,1596007],"length":1,"stats":{"Line":2},"fn_name":null},{"line":259,"address":[1596042,1595929,1596123],"length":1,"stats":{"Line":2},"fn_name":null},{"line":260,"address":[1596183,1596133,1596063],"length":1,"stats":{"Line":2},"fn_name":null},{"line":261,"address":[1596162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[1596201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[1596232],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[1595876,1595640,1596209,1595326],"length":1,"stats":{"Line":2},"fn_name":null},{"line":267,"address":[1595503,1595477,1595824,1595889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[1595495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[1595250,1595588,1595407,1595650],"length":1,"stats":{"Line":3},"fn_name":null},{"line":272,"address":[1595785,1596363],"length":1,"stats":{"Line":2},"fn_name":null},{"line":276,"address":[1596501],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[1596650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[1596743,1596673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[1596537],"length":1,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[1596685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[1596750,1596808,1596913,1596701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[1596810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[1596800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[1597740,1597838,1596976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[1597023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[1597133,1597177],"length":1,"stats":{"Line":2},"fn_name":null},{"line":297,"address":[1597185,1597549],"length":1,"stats":{"Line":2},"fn_name":null},{"line":298,"address":[1597375,1597280,1597554,1596999],"length":1,"stats":{"Line":3},"fn_name":null},{"line":300,"address":[1597287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":302,"address":[1597856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[1597894],"length":1,"stats":{"Line":1},"fn_name":null},{"line":304,"address":[1597956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[1598069,1597984,1597908],"length":1,"stats":{"Line":2},"fn_name":null},{"line":307,"address":[1598181,1598104,1598002],"length":1,"stats":{"Line":2},"fn_name":null},{"line":308,"address":[1598117,1597886,1598280,1598188],"length":1,"stats":{"Line":3},"fn_name":null},{"line":310,"address":[1598304],"length":1,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[1598342],"length":1,"stats":{"Line":1},"fn_name":null},{"line":312,"address":[1598404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[1598432,1598356,1598517],"length":1,"stats":{"Line":2},"fn_name":null},{"line":315,"address":[1598450,1598552,1598629],"length":1,"stats":{"Line":2},"fn_name":null},{"line":316,"address":[1598565,1598636,1598334,1598728],"length":1,"stats":{"Line":3},"fn_name":null},{"line":318,"address":[1598752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":319,"address":[1598759],"length":1,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[1598792],"length":1,"stats":{"Line":1},"fn_name":null},{"line":321,"address":[1598815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":322,"address":[1598861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":323,"address":[1598838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":326,"address":[1598896,1603075,1599930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":333,"address":[1599044,1599201],"length":1,"stats":{"Line":2},"fn_name":null},{"line":334,"address":[1599344,1600805],"length":1,"stats":{"Line":1},"fn_name":null},{"line":335,"address":[1599413,1599557,1599645],"length":1,"stats":{"Line":3},"fn_name":null},{"line":337,"address":[1599798,1599571],"length":1,"stats":{"Line":2},"fn_name":null},{"line":339,"address":[1599458,1600060,1599948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[1599970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[1599982,1600354,1602897,1600205],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[1602772,1600370,1602902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[1600406,1600293,1600649,1600496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[1600766,1600419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[1600790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[1600810,1599892],"length":1,"stats":{"Line":2},"fn_name":null},{"line":349,"address":[1600858,1601021],"length":1,"stats":{"Line":2},"fn_name":null},{"line":354,"address":[1601224,1601149],"length":1,"stats":{"Line":2},"fn_name":null},{"line":356,"address":[1601340],"length":1,"stats":{"Line":1},"fn_name":null},{"line":357,"address":[1601547,1601491],"length":1,"stats":{"Line":2},"fn_name":null},{"line":358,"address":[1602513,1601631],"length":1,"stats":{"Line":2},"fn_name":null},{"line":360,"address":[1601553,1601649,1601728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[1601804,1601889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[1601993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[1602247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[1603104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[1603124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[1603348,1603228,1603398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[1603369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[1603447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[1603459,1603651],"length":1,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[1603616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[1603405],"length":1,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[1603526,1603606,1603417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[1603571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[1603478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[1603745,1603665,1603490],"length":1,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[1603710],"length":1,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[1603760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[1603850,1603789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[1603802],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[1603809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[1603931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[1603891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[1604076],"length":1,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[1603857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[1603962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[1604098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[1603999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[1604115,1604028],"length":1,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[1604125],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[1604147],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[1604160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[1604188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[1604244],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[1605246,1604272],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":457,"address":[1604294],"length":1,"stats":{"Line":1},"fn_name":null},{"line":458,"address":[1604331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":459,"address":[1604367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[1604630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[1604565],"length":1,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[1604432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[1604497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[1604687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[1604750],"length":1,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[1604759,1605069,1604826,1604860],"length":1,"stats":{"Line":3},"fn_name":null},{"line":480,"address":[1604887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":481,"address":[1605084],"length":1,"stats":{"Line":1},"fn_name":null},{"line":482,"address":[1605093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":487,"address":[1605280,1606079],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":488,"address":[1605302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":489,"address":[1605347],"length":1,"stats":{"Line":1},"fn_name":null},{"line":490,"address":[1605391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[1605610],"length":1,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[1605680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[1605464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[1605537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[1605748,1605819],"length":1,"stats":{"Line":2},"fn_name":null},{"line":499,"address":[1605874],"length":1,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[1605883],"length":1,"stats":{"Line":1},"fn_name":null},{"line":502,"address":[1605901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":503,"address":[1605910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":526,"address":[1606128,1607701,1607617],"length":1,"stats":{"Line":2},"fn_name":"load_addresses_from_json"},{"line":529,"address":[1606171],"length":1,"stats":{"Line":2},"fn_name":null},{"line":530,"address":[1606267,1606207,1607699,1607664],"length":1,"stats":{"Line":4},"fn_name":null},{"line":532,"address":[1606552],"length":1,"stats":{"Line":2},"fn_name":null},{"line":533,"address":[1606652],"length":1,"stats":{"Line":2},"fn_name":null},{"line":534,"address":[1606700,1606767],"length":1,"stats":{"Line":4},"fn_name":null},{"line":536,"address":[1606882,1606775],"length":1,"stats":{"Line":4},"fn_name":null},{"line":537,"address":[1607076],"length":1,"stats":{"Line":2},"fn_name":null},{"line":538,"address":[1607223],"length":1,"stats":{"Line":2},"fn_name":null},{"line":542,"address":[1607259],"length":1,"stats":{"Line":2},"fn_name":null},{"line":546,"address":[1607343],"length":1,"stats":{"Line":2},"fn_name":null},{"line":548,"address":[1607356],"length":1,"stats":{"Line":2},"fn_name":null},{"line":549,"address":[1607424],"length":1,"stats":{"Line":2},"fn_name":null},{"line":550,"address":[1607445],"length":1,"stats":{"Line":2},"fn_name":null},{"line":552,"address":[1607605],"length":1,"stats":{"Line":2},"fn_name":null},{"line":555,"address":[1607101],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":119,"coverable":205},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","chain_selector.rs"],"content":"// SPDX-License-Identifier: MIT\n\n//! A module that connects with multiple peers and finds the best chain.\n//!\n//! # The theory\n//!\n//! In Bitcoin, the history of transactions processed by the network is defined by a sequence of\n//! blocks, chainned by their cryptographic hash. A block commits the hash for the block right\n//! before it. Therefore, if we pick any given block, there's exactly one history leading to the\n//! very first block, that commits to no one. However, if you go in the other way, starting at the\n//! first block and going up, there may not be only one history. Multiple blocks may commit to the\n//! same parent. We need a way to pick just one such chain, among all others.\n//!\n//! To do that, we use the most work rule, sometimes called \"Nakamoto Consensus\" after Bitcoin's\n//! creator, Satoshi Nakamoto. Every block has to solve a probabilistic challenge of finding a\n//! combination of data that hashes to a value smaller than a network-agreed value. Because hash\n//! functions are pseudorandom, one must make certain amount of hashes (on average) before finding a\n//! valid one. If we define the amount of hashes needed to find a block as this block's \"work\",\n//! by adding-up the work in each of a chain's blocks, we arrive with the `chainwork`. The Nakamoto\n//! consensus consists in taking the chain with most work as the best one.\n//!\n//! This works because anyone in the network will compute the same amount of work and pick the same\n//! one, regardless of where and when. Because work is a intrinsic and deterministic property of a\n//! block, everyone comparing the same chain, be on earth, on mars; in 2020 or 2100, they will\n//! choose the exact same chain, always.\n//!\n//! The most critial part of syncing-up a Bitcoin node is making sure you know about the most-work\n//! chain. If someone can eclypse you, they can make you start following a chain that only you and\n//! the attacker care about. If you get paid in this chain, you can't pay someone else outside this\n//! chain, because they will be following other chains. Luckly, we only need one honest peer, to\n//! find the best-work chain and avoid any attacker to fools us into accepting payments in a \"fake\n//! Bitcoin\"\n//!\n//! # Implementation\n//!\n//! In Floresta, we try to pick a good balance between data downloaded and security. We could\n//! simply download all chains from all peers and pick the most work one. But each header is\n//! 80 bytes-long, with ~800k blocks, that's arround 60 MBs. If we have 10 peers, that's 600MBs\n//! (excluding overhead by the p2p messages). Moreover, it's very uncommon to actually have peers\n//! in different chains. So we can optmistically download all headers from one random peer, and\n//! then check with the others if they aggree. If they have another chain for us, we download that\n//! chain, and pick whichever has more work.\n//!\n//! Most likely we'll only download one chain and all peers will agree with it. Then we can start\n//! downloading the actual blocks and validating them.\nuse std::collections::HashSet;\nuse std::sync::Arc;\nuse std::time::Duration;\nuse std::time::Instant;\n\nuse async_std::future::timeout;\nuse async_std::sync::RwLock;\nuse bitcoin::block::Header;\nuse bitcoin::consensus::deserialize;\nuse bitcoin::p2p::utreexo::UtreexoBlock;\nuse bitcoin::p2p::ServiceFlags;\nuse bitcoin::BlockHash;\nuse floresta_chain::pruned_utreexo::BlockchainInterface;\nuse floresta_chain::pruned_utreexo::UpdatableChainstate;\nuse log::info;\nuse log::warn;\nuse rustreexo::accumulator::node_hash::NodeHash;\nuse rustreexo::accumulator::stump::Stump;\n\nuse super::error::WireError;\nuse super::peer::PeerMessages;\nuse crate::address_man::AddressState;\nuse crate::node::periodic_job;\nuse crate::node::try_and_log;\nuse crate::node::InflightRequests;\nuse crate::node::NodeNotification;\nuse crate::node::NodeRequest;\nuse crate::node::UtreexoNode;\nuse crate::node_context::NodeContext;\nuse crate::node_context::PeerId;\n\n#[derive(Debug, Default, Clone)]\n/// A p2p driver that attemps to connect with multiple peers, ask which chain are them following\n/// and download and verify the headers, **not** the actual blocks. This is the first part of a\n/// loger IBD pipeline.\n/// The actual blocks should be downloaded by a SyncPeer.\npub struct ChainSelector {\n    /// The state we are in\n    state: ChainSelectorState,\n    /// To save in bandwi****, we download headers from only one peer, and then look for forks\n    /// afterwards. This is the peer we are using during this phase\n    sync_peer: PeerId,\n    /// Peers that already sent us a message we are waiting for\n    done_peers: HashSet\u003cPeerId\u003e,\n}\n\n#[derive(Debug, Default, Clone, PartialEq, Eq)]\npub enum ChainSelectorState {\n    #[default]\n    /// We are opening connection with some peers\n    CreatingConnections,\n    /// We are downloading headers from only one peer, assuming this peer is honest\n    DownloadingHeaders,\n    /// We've downloaded all headers, and now we are checking with our peers if they\n    /// have an alternative tip with more PoW. Very unlikely, but we shouldn't trust\n    /// only one peer...\n    LookingForForks,\n    /// We've downloaded all headers\n    Done,\n}\n\npub enum FindAccResult {\n    Found(Vec\u003cu8\u003e),\n    KeepLooking(Vec\u003c(PeerId, Vec\u003cu8\u003e)\u003e),\n}\n\nimpl NodeContext for ChainSelector {\n    const REQUEST_TIMEOUT: u64 = 10; // Ban peers stalling our IBD\n    const TRY_NEW_CONNECTION: u64 = 10; // Try creating connections more aggressively\n\n    fn get_required_services(\u0026self) -\u003e ServiceFlags {\n        ServiceFlags::NETWORK | ServiceFlags::UTREEXO\n    }\n}\n\nimpl\u003cChain\u003e UtreexoNode\u003cChainSelector, Chain\u003e\nwhere\n    WireError: From\u003c\u003cChain as BlockchainInterface\u003e::Error\u003e,\n    Chain: BlockchainInterface + UpdatableChainstate + 'static,\n{\n    /// This function is called every time we get a `Headers` message from a peer.\n    /// It will validate the headers and add them to our chain, if they are valid.\n    /// If we get an empty headers message, we'll check what to do next, depending on\n    /// our current state. We may poke our peers to see if they have an alternative tip,\n    /// or we may just finish the IBD, if no one have an alternative tip.\n    async fn handle_headers(\n        \u0026mut self,\n        peer: PeerId,\n        headers: Vec\u003cHeader\u003e,\n    ) -\u003e Result\u003c(), WireError\u003e {\n        if headers.is_empty() {\n            self.empty_headers_message(peer).await?;\n            return Ok(());\n        }\n\n        info!(\n            \"Downloading headers from peer={peer} at height={} hash={}\",\n            self.chain.get_best_block()?.0 + 1,\n            headers[0].block_hash()\n        );\n\n        for header in headers.iter() {\n            if let Err(e) = self.chain.accept_header(*header) {\n                log::error!(\"Error while downloading headers from peer={peer} err={e}\");\n\n                self.send_to_peer(peer, NodeRequest::Shutdown).await?;\n\n                let peer = self.peers.get(\u0026peer).unwrap();\n                self.0.address_man.update_set_state(\n                    peer.address_id as usize,\n                    AddressState::Banned(ChainSelector::BAN_TIME),\n                );\n            }\n        }\n\n        self.request_headers(headers.last().unwrap().block_hash())\n            .await\n    }\n\n    /// Takes a serialized accumulator and parses it into a Stump\n    fn parse_acc(mut acc: Vec\u003cu8\u003e) -\u003e Result\u003cStump, WireError\u003e {\n        if acc.is_empty() {\n            return Ok(Stump::default());\n        }\n        let leaves = deserialize(acc.drain(0..8).as_slice()).unwrap_or(0);\n        let mut roots = Vec::new();\n        while !acc.is_empty() {\n            let slice = acc.drain(0..32);\n            let mut root = [0u8; 32];\n            root.copy_from_slice(\u0026slice.collect::\u003cVec\u003cu8\u003e\u003e());\n            roots.push(NodeHash::from(root));\n        }\n        Ok(Stump { leaves, roots })\n    }\n\n    /// Sends a request to two peers and wait for their response\n    ///\n    /// This function will send a `GetUtreexoState` request to two peers and wait for their\n    /// response. If both peers respond, it will return the accumulator from both peers.\n    /// If only one peer responds, it will return the accumulator from that peer and `None`\n    /// for the other. If no peer responds, it will return `None` for both.\n    /// We use this during the cut-and-choose protocol, to find where they disagree.\n    async fn grab_both_peers_version(\n        \u0026mut self,\n        peer1: PeerId,\n        peer2: PeerId,\n        block_hash: BlockHash,\n        block_height: u32,\n    ) -\u003e Result\u003c(Option\u003cVec\u003cu8\u003e\u003e, Option\u003cVec\u003cu8\u003e\u003e), WireError\u003e {\n        self.send_to_peer(\n            peer1,\n            NodeRequest::GetUtreexoState((block_hash, block_height)),\n        )\n        .await?;\n\n        self.send_to_peer(\n            peer2,\n            NodeRequest::GetUtreexoState((block_hash, block_height)),\n        )\n        .await?;\n\n        let mut peer1_version = None;\n        let mut peer2_version = None;\n        for _ in 0..2 {\n            if let Ok(Ok(NodeNotification::FromPeer(peer, PeerMessages::UtreexoState(state)))) =\n                timeout(Duration::from_secs(60), self.node_rx.recv()).await\n            {\n                if peer == peer1 {\n                    peer1_version = Some(state);\n                } else if peer == peer2 {\n                    peer2_version = Some(state);\n                }\n            }\n        }\n\n        Ok((peer1_version, peer2_version))\n    }\n\n    /// Find which peer is lying about what the accumulator state is at given\n    ///\n    /// This function will ask peers their accumulator for a given block, and check whether\n    /// they agree or not. If they don't, we cut the search in half and keep looking for the\n    /// fork point. Once we find the fork point, we ask for the block that comes after the fork\n    /// download the block and proof, update the acc they agreed on, update the stump and see\n    /// who is lying.\n    async fn find_who_is_lying(\n        \u0026mut self,\n        peer1: PeerId,\n        peer2: PeerId,\n    ) -\u003e Result\u003cOption\u003cPeerId\u003e, WireError\u003e {\n        let (mut height, mut hash) = self.chain.get_best_block()?;\n        let mut prev_height = 0;\n        let agree = false;\n        // we first norrow down the possible fork point to a couple of blocks, looking\n        // for all blocks in a linear search would be too slow\n        loop {\n            // ask both peers for the utreexo state\n            self.send_to_peer(peer1, NodeRequest::GetUtreexoState((hash, height)))\n                .await?;\n            self.send_to_peer(peer2, NodeRequest::GetUtreexoState((hash, height)))\n                .await?;\n\n            let (peer1_acc, peer2_acc) = self\n                .grab_both_peers_version(peer1, peer2, hash, height)\n                .await?;\n\n            let (peer1_acc, peer2_acc) = match (peer1_acc, peer2_acc) {\n                (Some(acc1), Some(acc2)) =\u003e (acc1, acc2),\n                (None, Some(_)) =\u003e return Ok(Some(peer2)),\n                (Some(_), None) =\u003e return Ok(Some(peer1)),\n                (None, None) =\u003e return Ok(None),\n            };\n\n            // if we have different states, we need to keep looking until we find the\n            // fork point\n            let interval = height.abs_diff(prev_height);\n            prev_height = height;\n\n            if interval \u003c 5 {\n                break;\n            }\n\n            if peer1_acc == peer2_acc {\n                // if they're equal, then the disagreement is in a newer block\n                height += interval / 2;\n            } else {\n                // if they're different, then the disagreement is in an older block\n                height -= interval / 2;\n            }\n\n            hash = self.chain.get_block_hash(height).unwrap();\n        }\n        info!(\"Fork point is arround height={height} hash={hash}\");\n        // at the end, this variable should hold the last block where they agreed\n        let mut fork = 0;\n        loop {\n            // keep asking blocks until we find the fork point\n            let (peer1_acc, peer2_acc) = self\n                .grab_both_peers_version(peer1, peer2, hash, height)\n                .await?;\n\n            // as we go, we'll approach the fork from two possible sides: we came from the side\n            // they disagree, and therefore the point of inflection is the first block they agree.\n            // on the other hand, if are agreeing, and we find they disagreeing, the last block\n            // they've agreed on is the previous one (not the current one)\n            match agree {\n                true =\u003e {\n                    // they agreed in the last block, so the fork is in the next one\n                    if peer1_acc != peer2_acc {\n                        fork = height - 1;\n                    }\n                }\n\n                false =\u003e {\n                    // they disagreed in the last block and now agree, the last block is the fork\n                    if peer1_acc == peer2_acc {\n                        fork = height;\n                    }\n                }\n            }\n\n            if fork != 0 {\n                break;\n            }\n\n            // if we still don't know where the fork is, we need to keep looking\n            if agree {\n                // if they agree on this current block, we need to look in the next one\n                height += 1;\n            } else {\n                // if they disagree on this current block, we need to look in the previous one\n                height -= 1;\n            }\n        }\n\n        // now we know where the fork is, we need to check who is lying\n        let (Some(peer1_acc), Some(peer2_acc)) = self\n            .grab_both_peers_version(peer1, peer2, hash, fork + 1)\n            .await?\n        else {\n            return Ok(None);\n        };\n\n        let (aggreed, _) = self\n            .grab_both_peers_version(peer1, peer2, hash, fork)\n            .await?;\n\n        let agreed = match aggreed {\n            Some(acc) =\u003e Self::parse_acc(acc)?,\n            None =\u003e return Ok(None),\n        };\n\n        let block = self.chain.get_block_hash(fork + 1).unwrap();\n        self.send_to_peer(peer1, NodeRequest::GetBlock((vec![block], true)))\n            .await?;\n\n        let NodeNotification::FromPeer(_, PeerMessages::Block(block)) =\n            self.node_rx.recv().await.unwrap()\n        else {\n            return Ok(None);\n        };\n\n        let acc1 = self.update_acc(agreed, block, fork + 1)?;\n        let peer1_acc = Self::parse_acc(peer1_acc)?;\n        let peer2_acc = Self::parse_acc(peer2_acc)?;\n\n        if peer1_acc != acc1 \u0026\u0026 peer2_acc != acc1 {\n            return Ok(None);\n        }\n\n        if peer1_acc != acc1 {\n            return Ok(Some(peer1));\n        }\n\n        Ok(Some(peer2))\n    }\n\n    /// Updates a Stump, with the data from a Utreexo block\n    fn update_acc(\u0026self, acc: Stump, block: UtreexoBlock, height: u32) -\u003e Result\u003cStump, WireError\u003e {\n        let (proof, del_hashes, _) = floresta_chain::proof_util::process_proof(\n            block.udata.as_ref().unwrap(),\n            \u0026block.block.txdata,\n            \u0026self.chain,\n        )?;\n\n        Ok(self\n            .chain\n            .update_acc(acc, block, height, proof, del_hashes)?)\n    }\n\n    /// Finds the accumulator for one block\n    ///\n    /// This method will find what the accumulator looks like for a block with (height, hash).\n    /// Check-out [this](https://blog.dlsouza.lol/2023/09/28/pow-fraud-proof.html) post\n    /// to learn how the cut-and-choose protocol works\n    async fn find_accumulator_for_block(\n        \u0026mut self,\n        height: u32,\n        hash: BlockHash,\n    ) -\u003e Result\u003cStump, WireError\u003e {\n        let mut candidate_accs = Vec::new();\n\n        match self.find_accumulator_for_block_step(hash, height).await {\n            Ok(FindAccResult::Found(acc)) =\u003e {\n                // everyone agrees. Just parse the accumulator and finish-up\n                let acc = Self::parse_acc(acc)?;\n                return Ok(acc);\n            }\n            Ok(FindAccResult::KeepLooking(mut accs)) =\u003e {\n                accs.sort();\n                accs.dedup();\n                candidate_accs = accs;\n            }\n            _ =\u003e {}\n        }\n\n        let mut invalid_accs = HashSet::new();\n        for peer in candidate_accs.windows(2) {\n            if invalid_accs.contains(\u0026peer[0].1) || invalid_accs.contains(\u0026peer[1].1) {\n                continue;\n            }\n            let (peer1, peer2) = (peer[0].0, peer[1].0);\n\n            if let Some(liar) = self.find_who_is_lying(peer1, peer2).await? {\n                // if we found a liar, we need to ban them\n                self.send_to_peer(liar, NodeRequest::Shutdown).await?;\n                if liar == peer1 {\n                    invalid_accs.insert(peer[0].1.clone());\n                } else {\n                    invalid_accs.insert(peer[1].1.clone());\n                }\n            }\n        }\n        //filter out the invalid accs\n        candidate_accs.retain(|acc| !invalid_accs.contains(\u0026acc.1));\n        //we should have only one candidate left\n        assert_eq!(candidate_accs.len(), 1);\n\n        Self::parse_acc(candidate_accs.pop().unwrap().1)\n    }\n\n    /// If we get an empty `haders` message, our next action depends on which state are\n    /// we in:\n    ///   - If we are downloading headers for the first time, this means we've just\n    ///     finished and should go to the next phase\n    ///   - If we are checking with our peer if they have an alternative tip, this peer\n    ///     has send all blocks they have. Once all peers have finished, we just pick the\n    ///     most PoW chain among all chains that we got\n    async fn empty_headers_message(\u0026mut self, peer: PeerId) -\u003e Result\u003c(), WireError\u003e {\n        match self.1.state {\n            ChainSelectorState::DownloadingHeaders =\u003e {\n                self.poke_peers().await?;\n                self.1.state = ChainSelectorState::LookingForForks;\n            }\n            ChainSelectorState::LookingForForks =\u003e {\n                self.1.done_peers.insert(peer);\n                for peer in self.0.peer_ids.iter() {\n                    // at least one peer haven't finished\n                    if !self.1.done_peers.contains(peer) {\n                        return Ok(());\n                    }\n                }\n\n                if let Some(assume_utreexo) = self.config.assume_utreexo.as_ref() {\n                    let acc = Stump {\n                        leaves: assume_utreexo.leaves,\n                        roots: assume_utreexo.roots.clone(),\n                    };\n                    self.chain.mark_chain_as_assumed(acc)?;\n                }\n\n                let has_peers = self\n                    .peer_by_service\n                    .contains_key(\u0026ServiceFlags::from(1 \u003c\u003c 25));\n\n                if self.config.pow_fraud_proofs \u0026\u0026 has_peers {\n                    self.check_tips().await?;\n                }\n\n                self.1.state = ChainSelectorState::Done;\n            }\n            _ =\u003e {}\n        }\n\n        Ok(())\n    }\n\n    async fn is_our_chain_invalid(\u0026mut self, other_tip: BlockHash) -\u003e Result\u003c(), WireError\u003e {\n        let fork = self.chain.get_fork_point(other_tip)?;\n        self.send_to_random_peer(\n            NodeRequest::GetBlock((vec![fork], true)),\n            ServiceFlags::UTREEXO,\n        )\n        .await?;\n\n        let block = loop {\n            let Ok(NodeNotification::FromPeer(_, PeerMessages::Block(block))) =\n                self.node_rx.recv().await\n            else {\n                continue;\n            };\n            break block;\n        };\n\n        let (proof, del_hashes, inputs) = floresta_chain::proof_util::process_proof(\n            block.udata.as_ref().unwrap(),\n            \u0026block.block.txdata,\n            \u0026self.chain,\n        )?;\n\n        let fork_height = self.chain.get_block_height(\u0026fork)?.unwrap_or(0);\n        let acc = self.find_accumulator_for_block(fork_height, fork).await?;\n        let is_valid = self\n            .chain\n            .validate_block(\u0026block.block, proof, inputs, del_hashes, acc);\n\n        if is_valid.is_err() {\n            self.chain.switch_chain(other_tip)?;\n            self.chain.invalidate_block(fork)?;\n        }\n\n        Ok(())\n    }\n\n    async fn check_tips(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        let (height, _) = self.chain.get_best_block()?;\n        let validation_index = self.chain.get_validation_index()?;\n        if (validation_index + 100) \u003c height {\n            let mut tips = self.chain.get_chain_tips()?;\n            let (height, hash) = self.chain.get_best_block()?;\n            let acc = self.find_accumulator_for_block(height, hash).await?;\n\n            // only one tip, our peers are following the same chain\n            if tips.len() == 1 {\n                info!(\n                    \"Assuming chain with {} blocks\",\n                    self.chain.get_best_block()?.0\n                );\n\n                self.1.state = ChainSelectorState::Done;\n                self.chain.mark_chain_as_assumed(acc).unwrap();\n                self.chain.toggle_ibd(false);\n            }\n            // if we have more than one tip, we need to check if our best chain has an invalid block\n            tips.remove(0); // no need to check our best one\n            for tip in tips {\n                self.is_our_chain_invalid(tip).await?;\n            }\n\n            return Ok(());\n        }\n\n        info!(\"chain close enough to tip, not asking for utreexo state\");\n        self.1.state = ChainSelectorState::Done;\n        Ok(())\n    }\n\n    /// Ask for headers, given a tip\n    ///\n    /// This function will send a `getheaders` request to our peers, assuming this\n    /// peer is following a chain with `tip` inside it. We use this in case some of\n    /// our peer is in a fork, so we can learn about all blocks in that fork and\n    /// compare the candidate chains to pick the best one.\n    async fn request_headers(\u0026mut self, tip: BlockHash) -\u003e Result\u003c(), WireError\u003e {\n        let locator = self\n            .chain\n            .get_block_locator_for_tip(tip)\n            .unwrap_or_default();\n        self.send_to_peer(self.1.sync_peer, NodeRequest::GetHeaders(locator))\n            .await?;\n\n        let peer = self.1.sync_peer;\n        self.inflight\n            .insert(InflightRequests::Headers, (peer, Instant::now()));\n\n        Ok(())\n    }\n\n    /// Checks if some request has timed-out.\n    ///\n    /// If it does, we disconnect and ban this peer\n    async fn check_for_timeout(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        let mut failed = vec![];\n\n        for (request, (peer, instant)) in self.inflight.clone() {\n            if instant.elapsed().as_secs() \u003e ChainSelector::REQUEST_TIMEOUT {\n                self.increase_banscore(peer, 2).await?;\n                failed.push(request)\n            }\n        }\n\n        for request in failed {\n            self.inflight.remove(\u0026request);\n        }\n\n        Ok(())\n    }\n\n    /// Sends a `getheaders` to all our peers\n    ///\n    /// After we download all blocks from one peer, we ask our peers if they\n    /// agree with our sync peer on what is the best chain. If they are in a fork,\n    /// we'll download that fork and compare with our own chain. We should always pick\n    /// the most PoW one.\n    async fn poke_peers(\u0026self) -\u003e Result\u003c(), WireError\u003e {\n        let locator = self.chain.get_block_locator().unwrap();\n        for peer in self.0.peer_ids.iter() {\n            let get_headers = NodeRequest::GetHeaders(locator.clone());\n            self.send_to_peer(*peer, get_headers).await?;\n        }\n\n        Ok(())\n    }\n\n    pub async fn run(\u0026mut self, stop_signal: Arc\u003cRwLock\u003cbool\u003e\u003e) -\u003e Result\u003c(), WireError\u003e {\n        self.create_connection(false).await;\n\n        info!(\"Starting ibd, selecting the best chain\");\n\n        loop {\n            while let Ok(notification) =\n                timeout(Duration::from_millis(10), self.node_rx.recv()).await\n            {\n                try_and_log!(self.handle_notification(notification).await);\n            }\n\n            periodic_job!(\n                self.maybe_open_connection().await,\n                self.last_connection,\n                TRY_NEW_CONNECTION,\n                ChainSelector\n            );\n\n            if self.1.state == ChainSelectorState::CreatingConnections {\n                // If we have enough peers, try to download headers\n                if !self.peer_ids.is_empty() {\n                    let new_sync_peer = rand::random::\u003cusize\u003e() % self.peer_ids.len();\n                    self.1.sync_peer = *self.peer_ids.get(new_sync_peer).unwrap();\n\n                    try_and_log!(self.request_headers(self.chain.get_best_block()?.1).await);\n\n                    self.1.state = ChainSelectorState::DownloadingHeaders;\n                }\n            }\n\n            // We downloaded all headers in the most-pow chain, and all our peers agree\n            // this is the most-pow chain, we're done!\n            if self.1.state == ChainSelectorState::Done {\n                break;\n            }\n\n            try_and_log!(self.check_for_timeout().await);\n\n            if *stop_signal.read().await {\n                break;\n            }\n        }\n\n        Ok(())\n    }\n\n    async fn find_accumulator_for_block_step(\n        \u0026mut self,\n        block: BlockHash,\n        height: u32,\n    ) -\u003e Result\u003cFindAccResult, WireError\u003e {\n        for peer_id in self.0.peer_ids.iter() {\n            let peer = self.peers.get(peer_id).unwrap();\n            if peer.services.has(ServiceFlags::from(1 \u003c\u003c 25)) {\n                self.send_to_peer(*peer_id, NodeRequest::GetUtreexoState((block, height)))\n                    .await?;\n                self.0.inflight.insert(\n                    InflightRequests::UtreexoState(*peer_id),\n                    (*peer_id, Instant::now()),\n                );\n            }\n        }\n\n        if self.inflight.is_empty() {\n            return Err(WireError::NoPeersAvailable);\n        }\n\n        let mut peer_accs = Vec::new();\n        loop {\n            // wait for all peers to respond or timeout after 1 minute\n            if self.inflight.is_empty() {\n                break;\n            }\n\n            if let Ok(Ok(message)) = timeout(Duration::from_secs(60), self.node_rx.recv()).await {\n                match message {\n                    NodeNotification::FromPeer(peer, message) =\u003e {\n                        if let PeerMessages::UtreexoState(state) = message {\n                            self.inflight.remove(\u0026InflightRequests::UtreexoState(peer));\n                            info!(\"got state {state:?}\");\n                            peer_accs.push((peer, state));\n                        }\n                    }\n                }\n            }\n\n            for inflight in self.inflight.clone().iter() {\n                if inflight.1 .1.elapsed().as_secs() \u003e 60 {\n                    self.inflight.remove(inflight.0);\n                }\n            }\n        }\n\n        if peer_accs.len() == 1 {\n            warn!(\"Only one peers with the UTREEXO_FILTER service flag\");\n            return Ok(FindAccResult::Found(peer_accs.pop().unwrap().1));\n        }\n\n        let mut accs = HashSet::new();\n        for (_, acc) in peer_accs.iter() {\n            accs.insert(acc);\n        }\n\n        // if all peers have the same state, we can assume it's the correct one\n        if accs.len() == 1 {\n            return Ok(FindAccResult::Found(peer_accs.pop().unwrap().1));\n        }\n\n        // if we have different states, we need to keep looking until we find the\n        // fork point\n        Ok(FindAccResult::KeepLooking(peer_accs))\n    }\n\n    async fn handle_notification(\n        \u0026mut self,\n        notification: Result\u003cNodeNotification, async_std::channel::RecvError\u003e,\n    ) -\u003e Result\u003c(), WireError\u003e {\n        match notification? {\n            NodeNotification::FromPeer(peer, message) =\u003e match message {\n                PeerMessages::Headers(headers) =\u003e {\n                    self.inflight.remove(\u0026InflightRequests::Headers);\n                    return self.handle_headers(peer, headers).await;\n                }\n\n                PeerMessages::Ready(version) =\u003e {\n                    self.handle_peer_ready(peer, \u0026version).await?;\n                }\n\n                PeerMessages::Disconnected(idx) =\u003e {\n                    if peer == self.1.sync_peer {\n                        self.1.state = ChainSelectorState::CreatingConnections;\n                    }\n                    self.handle_disconnection(peer, idx)?;\n                }\n\n                PeerMessages::Addr(addresses) =\u003e {\n                    let addresses: Vec\u003c_\u003e =\n                        addresses.iter().cloned().map(|addr| addr.into()).collect();\n                    self.address_man.push_addresses(\u0026addresses);\n                }\n\n                _ =\u003e {}\n            },\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":116,"address":[1616928],"length":1,"stats":{"Line":0},"fn_name":"get_required_services"},{"line":117,"address":[1616933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[6338480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[6338848],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[6338624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[6338928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[3543598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":558,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":592,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":601,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":607,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":612,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":613,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":614,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":619,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":623,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":627,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":647,"address":[6338992],"length":1,"stats":{"Line":0},"fn_name":null},{"line":652,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":653,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":655,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":656,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":657,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":659,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":665,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":671,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":672,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":675,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":676,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":677,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":678,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":679,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":680,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":681,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":689,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":695,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":700,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":705,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":706,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":711,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":714,"address":[6338672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":718,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":719,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":722,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":726,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":729,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":730,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":731,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":736,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":737,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":738,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":739,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":742,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":745,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":316},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","error.rs"],"content":"use floresta_chain::BlockchainError;\nuse floresta_common::impl_error_from;\nuse thiserror::Error;\n\nuse super::peer::PeerError;\nuse crate::node::NodeRequest;\n\n#[derive(Error, Debug)]\npub enum WireError {\n    #[error(\"Blockchain error\")]\n    Blockchain(BlockchainError),\n    #[error(\"Error while writing into a channel\")]\n    ChannelSend(async_std::channel::SendError\u003cNodeRequest\u003e),\n    #[error(\"Peer error\")]\n    PeerError(PeerError),\n    #[error(\"Coinbase didn't mature\")]\n    CoinbaseNotMatured,\n    #[error(\"Peer not found in our current connections\")]\n    PeerNotFound,\n    #[error(\"We don't have any peers\")]\n    NoPeersAvailable,\n    #[error(\"Our peer is misbehaving\")]\n    PeerMisbehaving,\n    #[error(\"Error while reading from a channel\")]\n    ChannelRecv(#[from] async_std::channel::RecvError),\n    #[error(\"Generic io error\")]\n    Io(std::io::Error),\n    #[error(\"We don't have any utreexo peers\")]\n    NoUtreexoPeersAvailable,\n    #[error(\"We couldn't find a peer to send the request\")]\n    NoPeerToSendRequest,\n    #[error(\"Peer timed out\")]\n    PeerTimeout,\n}\nimpl_error_from!(WireError, PeerError, PeerError);\nimpl_error_from!(WireError, BlockchainError, Blockchain);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","mempool.rs"],"content":"// SPDX-License-Identifier: MIT\n//! A simple mempool that keeps our transactions in memory. It try to rebroadcast\n//! our transactions every 1 hour.\n//! Once our transaction is included in a block, we remove it from the mempool.\nuse std::collections::HashMap;\nuse std::time::Duration;\nuse std::time::Instant;\n\nuse bitcoin::Block;\nuse bitcoin::Transaction;\nuse bitcoin::Txid;\n/// Holds the transactions that we broadcasted and are still in the mempool.\n#[derive(Debug, Default)]\npub struct Mempool(HashMap\u003cTxid, (Transaction, Instant)\u003e);\n\nimpl Mempool {\n    pub fn new() -\u003e Mempool {\n        Mempool(HashMap::new())\n    }\n    /// Find all transactions that are in the mempool and were included in the given block.\n    /// Remove them from the mempool and return them.\n    pub fn consume_block(\u0026mut self, block: \u0026Block) -\u003e Vec\u003cTransaction\u003e {\n        if self.0.is_empty() {\n            return Vec::new();\n        }\n        let mut delta = Vec::new();\n        for tx in block.txdata.iter() {\n            if self.0.contains_key(\u0026tx.txid()) {\n                delta.push(self.0.remove(\u0026tx.txid()));\n            }\n        }\n        delta.into_iter().flat_map(|tx| Some(tx?.0)).collect()\n    }\n    /// Add a transaction to the mempool.\n    pub fn accept_to_mempool(\u0026mut self, transaction: Transaction) {\n        self.0\n            .insert(transaction.txid(), (transaction, Instant::now()));\n    }\n    /// Get a transaction from the mempool.\n    pub fn get_from_mempool(\u0026self, id: \u0026Txid) -\u003e Option\u003c\u0026Transaction\u003e {\n        if let Some(tx) = self.0.get(id) {\n            return Some(\u0026tx.0);\n        }\n        None\n    }\n    /// Get all transactions that were in the mempool for more than 1 hour.\n    pub fn get_stale(\u0026mut self) -\u003e Vec\u003cTxid\u003e {\n        let mut stale = Vec::new();\n        for (txid, transaction) in self.0.iter_mut() {\n            if transaction.1.elapsed() \u003e Duration::from_secs(60 * 60) {\n                transaction.1 = Instant::now();\n                stale.push(*txid);\n            }\n        }\n        stale\n    }\n}\n","traces":[{"line":17,"address":[1547568],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[16496894],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[16497605,16497574,16496944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[16496995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[1547749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[16497013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[1548014,1547810,1547723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[16497357,16497453],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[1548160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[16497272,16497376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[1548632,1548272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[1548297,1548605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[1548375,1548313,1548617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[16498032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[16498046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[16498093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[1548754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[16498753,16498128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[1548819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[1548897,1548837,1549057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[1549099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[1549291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[1549337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[1549020],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":24},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","mod.rs"],"content":"//! Main module for the p2p chain. This is a blockchain provider, just like cli-chain, but it's\n//! backed by p2p Bitcoin's p2p network.\n\nuse std::net::SocketAddr;\n\nuse bitcoin::BlockHash;\nuse bitcoin::Network;\nuse rustreexo::accumulator::node_hash::NodeHash;\n\nuse self::address_man::LocalAddress;\n\n#[derive(Debug, Clone)]\n/// Configuration for the Utreexo node.\npub struct UtreexoNodeConfig {\n    /// The blockchain we are in, defaults to Bitcoin. Possible values are Bitcoin,\n    /// Testnet, Regtest and Signet.\n    pub network: Network,\n    /// Whether to use PoW fraud proofs. Defaults to false.\n    ///\n    /// PoW fraud proof is a mechanism to skip the verification of the whole blockchain,\n    /// but while also giving a better security than simple SPV. Check out the documentation\n    /// in `pow_fraud_proofs.md` under the `docs` folder.\n    pub pow_fraud_proofs: bool,\n    /// Whether to use compact filters. Defaults to false.\n    ///\n    /// Compact filters are useful to rescan the blockchain for a specific address, without\n    /// needing to download the whole chain. It will download ~1GB of filters, and then\n    /// download the blocks that match the filters.\n    pub compact_filters: bool,\n    /// Fixed peers to connect to. Defaults to None.\n    ///\n    /// If you want to connect to a specific peer, you can set this to a string with the\n    /// format `ip:port`. For example, `localhost:8333`.\n    pub fixed_peer: Option\u003cLocalAddress\u003e,\n    /// Maximum ban score. Defaults to 100.\n    ///\n    /// If a peer misbehaves, we increase its ban score. If the ban score reaches this value,\n    /// we disconnect from the peer.\n    pub max_banscore: u32,\n    /// Maximum number of outbound connections. Defaults to 8.\n    pub max_outbound: u32,\n    /// Maximum number of inflight requests. Defaults to 10.\n    ///\n    /// More inflight requests means more memory usage, but also more parallelism.\n    pub max_inflight: u32,\n    /// Data directory for the node. Defaults to `.floresta-node`.\n    pub datadir: String,\n    /// A SOCKS5 proxy to use. Defaults to None.\n    pub proxy: Option\u003cSocketAddr\u003e,\n    /// If enabled, the node will assume that the provided Utreexo state is valid, and will\n    /// start running from there\n    pub assume_utreexo: Option\u003cAssumeUtreexoValue\u003e,\n    /// If we assumeutreexo or pow_fraud_proof, we can skip the IBD and make our node usable\n    /// faster, with the tradeoff of security. If this is enabled, we will still download the\n    /// blocks in the background, and verify the final Utreexo state. So, the worse case scenario\n    /// is that we are vulnerable to a fraud proof attack for a few hours, but we can spot it\n    /// and react in a couple of hours at most, so the attack window is very small.\n    pub backfill: bool,\n}\n\n/// If enabled, the node will assume that the provided Utreexo state is valid, and will\n/// start running from there. You may use this to make your node start faster, but you\n/// should be sure that the provided state is valid. You may or not verify the state,\n/// by downloading all blocks on background, and then verifying the final Utreexo state.\n#[derive(Debug, Clone)]\npub struct AssumeUtreexoValue {\n    /// The latest block assumed to be valid. This acc is the roots at this block\n    pub block_hash: BlockHash,\n    /// Same as block_hash, but in height\n    pub height: u32,\n    /// The roots of the Utreexo accumulator at this block\n    pub roots: Vec\u003cNodeHash\u003e,\n    /// The number of leaves in the Utreexo accumulator at this block\n    pub leaves: u64,\n}\n\nimpl Default for UtreexoNodeConfig {\n    fn default() -\u003e Self {\n        UtreexoNodeConfig {\n            network: Network::Bitcoin,\n            pow_fraud_proofs: false,\n            compact_filters: false,\n            fixed_peer: None,\n            max_banscore: 100,\n            max_outbound: 8,\n            max_inflight: 10,\n            datadir: \".floresta-node\".to_string(),\n            proxy: None,\n            backfill: false,\n            assume_utreexo: None,\n        }\n    }\n}\n\npub mod address_man;\npub mod chain_selector;\npub mod error;\npub mod mempool;\npub mod node;\npub mod node_context;\npub mod node_interface;\npub mod peer;\npub mod running_node;\npub mod socks;\npub mod stream_reader;\npub mod sync_node;\n","traces":[{"line":78,"address":[1559898,1559568],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":87,"address":[1559599],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","node.rs"],"content":"//! Main file for this blockchain. A node is the central task that runs and handles important\n//! events, such as new blocks, peer connection/disconnection, new addresses, etc.\n//! A node should not care about peer-specific messages, peers'll handle things like pings.\nuse std::collections::HashMap;\nuse std::fmt::Debug;\nuse std::net::IpAddr;\nuse std::net::SocketAddr;\nuse std::ops::Deref;\nuse std::ops::DerefMut;\nuse std::sync::Arc;\nuse std::sync::Mutex;\nuse std::time::Duration;\nuse std::time::Instant;\nuse std::time::SystemTime;\nuse std::time::UNIX_EPOCH;\n\nuse async_std::channel::bounded;\nuse async_std::channel::Receiver;\nuse async_std::channel::Sender;\nuse async_std::channel::{self};\nuse async_std::future::timeout;\nuse async_std::net::TcpStream;\nuse async_std::sync::RwLock;\nuse async_std::task::spawn;\nuse bitcoin::p2p::address::AddrV2;\nuse bitcoin::p2p::address::AddrV2Message;\nuse bitcoin::p2p::utreexo::UtreexoBlock;\nuse bitcoin::p2p::ServiceFlags;\nuse bitcoin::BlockHash;\nuse bitcoin::Txid;\nuse floresta_chain::pruned_utreexo::chainparams::get_chain_dns_seeds;\nuse floresta_chain::pruned_utreexo::BlockchainInterface;\nuse floresta_chain::pruned_utreexo::UpdatableChainstate;\nuse floresta_chain::Network;\nuse floresta_compact_filters::kv_filter_database::KvFilterStore;\nuse floresta_compact_filters::network_filters::NetworkFilters;\nuse futures::Future;\nuse log::debug;\nuse log::info;\nuse log::warn;\n\nuse super::address_man::AddressMan;\nuse super::address_man::AddressState;\nuse super::address_man::LocalAddress;\nuse super::error::WireError;\nuse super::mempool::Mempool;\nuse super::node_context::NodeContext;\nuse super::node_interface::NodeInterface;\nuse super::node_interface::PeerInfo;\nuse super::node_interface::UserRequest;\nuse super::peer::Peer;\nuse super::peer::PeerMessages;\nuse super::peer::Version;\nuse super::running_node::RunningNode;\nuse super::socks::Socks5Addr;\nuse super::socks::Socks5Error;\nuse super::socks::Socks5StreamBuilder;\nuse super::UtreexoNodeConfig;\nuse crate::node_context::PeerId;\n\n#[derive(Debug)]\npub enum NodeNotification {\n    FromPeer(u32, PeerMessages),\n}\n\n#[derive(Debug, Clone, PartialEq, Hash)]\n/// Sent from node to peers, usually to request something\npub enum NodeRequest {\n    /// Get this block's data\n    GetBlock((Vec\u003cBlockHash\u003e, bool)),\n    /// Asks peer for headers\n    GetHeaders(Vec\u003cBlockHash\u003e),\n    /// Ask for other peers addresses\n    GetAddresses,\n    /// Asks this peer to shutdown\n    Shutdown,\n    /// Sends a transaction to peers\n    BroadcastTransaction(Txid),\n    /// Ask for an unconfirmed transaction\n    MempoolTransaction(Txid),\n    /// Sends know addresses to our peers\n    SendAddresses(Vec\u003cAddrV2Message\u003e),\n    GetUtreexoState((BlockHash, u32)),\n    GetFilter((BlockHash, u32)),\n}\n\n#[derive(Debug, Hash, PartialEq, Eq, Clone)]\npub(crate) enum InflightRequests {\n    Headers,\n    UtreexoState(PeerId),\n    Blocks(BlockHash),\n    RescanBlock(BlockHash),\n    UserRequest(UserRequest),\n    Connect(u32),\n    GetFilters,\n}\n\n#[derive(Debug, Clone)]\npub struct LocalPeerView {\n    pub(crate) state: PeerStatus,\n    pub(crate) address_id: u32,\n    pub(crate) channel: Sender\u003cNodeRequest\u003e,\n    pub(crate) services: ServiceFlags,\n    pub(crate) user_agent: String,\n    pub(crate) address: IpAddr,\n    pub(crate) port: u16,\n    pub(crate) _last_message: Instant,\n    pub(crate) feeler: bool,\n    pub(crate) height: u32,\n    pub(crate) banscore: u32,\n}\n\n#[derive(Debug, PartialEq, Clone, Copy)]\npub enum RescanStatus {\n    InProgress(u32),\n    Completed(Instant),\n    None,\n}\n\nimpl Default for RunningNode {\n    fn default() -\u003e Self {\n        RunningNode {\n            last_rescan_request: RescanStatus::None,\n            last_feeler: Instant::now(),\n            last_address_rearrange: Instant::now(),\n            user_requests: Arc::new(NodeInterface {\n                requests: Mutex::new(Vec::new()),\n            }),\n        }\n    }\n}\n\npub struct NodeCommon\u003cChain: BlockchainInterface + UpdatableChainstate\u003e {\n    pub(crate) peer_id_count: u32,\n    pub(crate) last_headers_request: Instant,\n    pub(crate) last_tip_update: Instant,\n    pub(crate) last_connection: Instant,\n    pub(crate) last_peer_db_dump: Instant,\n    pub(crate) last_broadcast: Instant,\n    pub(crate) last_send_addresses: Instant,\n    pub(crate) last_block_request: u32,\n    pub(crate) network: Network,\n    pub(crate) last_get_address_request: Instant,\n    pub(crate) peer_by_service: HashMap\u003cServiceFlags, Vec\u003cu32\u003e\u003e,\n    pub(crate) peer_ids: Vec\u003cu32\u003e,\n    pub(crate) peers: HashMap\u003cu32, LocalPeerView\u003e,\n    pub(crate) chain: Chain,\n    pub(crate) blocks: HashMap\u003cBlockHash, (PeerId, UtreexoBlock)\u003e,\n    pub(crate) inflight: HashMap\u003cInflightRequests, (u32, Instant)\u003e,\n    pub(crate) node_rx: Receiver\u003cNodeNotification\u003e,\n    pub(crate) node_tx: Sender\u003cNodeNotification\u003e,\n    pub(crate) mempool: Arc\u003cRwLock\u003cMempool\u003e\u003e,\n    pub(crate) datadir: String,\n    pub(crate) address_man: AddressMan,\n    pub(crate) max_banscore: u32,\n    pub(crate) socks5: Option\u003cSocks5StreamBuilder\u003e,\n    pub(crate) fixed_peer: Option\u003cLocalAddress\u003e,\n    pub(crate) config: UtreexoNodeConfig,\n    pub(crate) block_filters: Option\u003cArc\u003cNetworkFilters\u003cKvFilterStore\u003e\u003e\u003e,\n    pub(crate) last_filter: BlockHash,\n}\n\npub struct UtreexoNode\u003cContext, Chain: BlockchainInterface + UpdatableChainstate\u003e(\n    pub(crate) NodeCommon\u003cChain\u003e,\n    pub(crate) Context,\n);\n\nimpl\u003cChain: BlockchainInterface + UpdatableChainstate, T\u003e Deref for UtreexoNode\u003cT, Chain\u003e {\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n    type Target = NodeCommon\u003cChain\u003e;\n}\n\nimpl\u003cT, Chain: BlockchainInterface + UpdatableChainstate\u003e DerefMut for UtreexoNode\u003cT, Chain\u003e {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.0\n    }\n}\n\n#[derive(Debug, PartialEq, Clone, Copy)]\npub(crate) enum PeerStatus {\n    Awaiting,\n    Ready,\n}\n\nimpl\u003cT, Chain\u003e UtreexoNode\u003cT, Chain\u003e\nwhere\n    T: 'static + Default + NodeContext,\n    WireError: From\u003c\u003cChain as BlockchainInterface\u003e::Error\u003e,\n    Chain: BlockchainInterface + UpdatableChainstate + 'static,\n{\n    pub fn new(\n        config: UtreexoNodeConfig,\n        chain: Chain,\n        mempool: Arc\u003cRwLock\u003cMempool\u003e\u003e,\n        block_filters: Option\u003cArc\u003cNetworkFilters\u003cKvFilterStore\u003e\u003e\u003e,\n    ) -\u003e Self {\n        let (node_tx, node_rx) = channel::unbounded();\n        let socks5 = config.proxy.map(Socks5StreamBuilder::new);\n        UtreexoNode(\n            NodeCommon {\n                last_filter: chain.get_block_hash(0).unwrap(),\n                block_filters,\n                inflight: HashMap::new(),\n                peer_id_count: 0,\n                peers: HashMap::new(),\n                last_block_request: chain.get_validation_index().expect(\"Invalid chain\"),\n                chain,\n                peer_ids: Vec::new(),\n                peer_by_service: HashMap::new(),\n                mempool,\n                network: config.network.into(),\n                node_rx,\n                node_tx,\n                address_man: AddressMan::default(),\n                last_headers_request: Instant::now(),\n                last_tip_update: Instant::now(),\n                last_connection: Instant::now(),\n                last_peer_db_dump: Instant::now(),\n                last_broadcast: Instant::now(),\n                blocks: HashMap::new(),\n                last_get_address_request: Instant::now(),\n                last_send_addresses: Instant::now(),\n                datadir: config.datadir.clone(),\n                socks5,\n                max_banscore: config.max_banscore,\n                fixed_peer: config.fixed_peer.clone(),\n                config,\n            },\n            T::default(),\n        )\n    }\n\n    pub(crate) fn get_peer_info(\u0026self, peer: \u0026u32) -\u003e Option\u003cPeerInfo\u003e {\n        let peer = self.peers.get(peer)?;\n        Some(PeerInfo {\n            address: format!(\"{}:{}\", peer.address, peer.port),\n            services: peer.services.to_string(),\n            user_agent: peer.user_agent.clone(),\n            initial_height: peer.height,\n        })\n    }\n    pub(crate) fn handle_disconnection(\u0026mut self, peer: u32, idx: usize) -\u003e Result\u003c(), WireError\u003e {\n        if let Some(p) = self.peers.remove(\u0026peer) {\n            p.channel.close();\n            if !p.feeler \u0026\u0026 p.state == PeerStatus::Ready {\n                info!(\"Peer disconnected: {}\", peer);\n            }\n        }\n\n        self.peer_ids.retain(|\u0026id| id != peer);\n        for (_, v) in self.peer_by_service.iter_mut() {\n            v.retain(|\u0026id| id != peer);\n        }\n\n        self.address_man.update_set_state(\n            idx,\n            AddressState::Tried(\n                SystemTime::now()\n                    .duration_since(UNIX_EPOCH)\n                    .unwrap()\n                    .as_secs(),\n            ),\n        );\n        Ok(())\n    }\n    pub(crate) async fn handle_peer_ready(\n        \u0026mut self,\n        peer: u32,\n        version: \u0026Version,\n    ) -\u003e Result\u003c(), WireError\u003e {\n        if version.feeler {\n            self.send_to_peer(peer, NodeRequest::Shutdown).await?;\n            self.address_man.update_set_state(\n                version.address_id,\n                AddressState::Tried(\n                    SystemTime::now()\n                        .duration_since(UNIX_EPOCH)\n                        .unwrap()\n                        .as_secs(),\n                ),\n            );\n            self.address_man\n                .update_set_service_flag(version.address_id, version.services);\n            return Ok(());\n        }\n        info!(\n            \"New peer id={} version={} blocks={} services={}\",\n            version.id, version.user_agent, version.blocks, version.services\n        );\n        self.inflight.remove(\u0026InflightRequests::Connect(peer));\n\n        if let Some(peer_data) = self.0.peers.get_mut(\u0026peer) {\n            // This peer doesn't have basic services, so we disconnect it\n            if !version\n                .services\n                .has(ServiceFlags::NETWORK | ServiceFlags::WITNESS)\n            {\n                self.send_to_peer(peer, NodeRequest::Shutdown).await?;\n                self.peers.remove(\u0026peer);\n                return Ok(());\n            }\n            peer_data.state = PeerStatus::Ready;\n            peer_data.services = version.services;\n            peer_data.user_agent.clone_from(\u0026version.user_agent);\n            peer_data.height = version.blocks;\n\n            if peer_data.services.has(ServiceFlags::UTREEXO) {\n                self.0\n                    .peer_by_service\n                    .entry(ServiceFlags::UTREEXO)\n                    .or_default()\n                    .push(peer);\n            }\n\n            if peer_data.services.has(ServiceFlags::COMPACT_FILTERS) {\n                self.0\n                    .peer_by_service\n                    .entry(ServiceFlags::COMPACT_FILTERS)\n                    .or_default()\n                    .push(peer);\n            }\n\n            if peer_data.services.has(ServiceFlags::from(1 \u003c\u003c 25)) {\n                self.0\n                    .peer_by_service\n                    .entry(ServiceFlags::from(1 \u003c\u003c 25))\n                    .or_default()\n                    .push(peer);\n            }\n\n            self.address_man\n                .update_set_state(version.address_id, AddressState::Connected)\n                .update_set_service_flag(version.address_id, version.services);\n\n            self.peer_ids.push(peer);\n        }\n        Ok(())\n    }\n\n    pub(crate) fn get_default_port(\u0026self) -\u003e u16 {\n        match self.network {\n            Network::Bitcoin =\u003e 8333,\n            Network::Testnet =\u003e 18333,\n            Network::Signet =\u003e 38333,\n            Network::Regtest =\u003e 18444,\n        }\n    }\n\n    pub(crate) async fn send_to_peer(\n        \u0026self,\n        peer_id: u32,\n        req: NodeRequest,\n    ) -\u003e Result\u003c(), WireError\u003e {\n        if let Some(peer) = \u0026self.peers.get(\u0026peer_id) {\n            if peer.state == PeerStatus::Ready {\n                peer.channel\n                    .send(req)\n                    .await\n                    .map_err(WireError::ChannelSend)?;\n            }\n        }\n        Ok(())\n    }\n\n    /// Increses the \"banscore\" of a peer.\n    ///\n    /// This is a always increasing number that, if reaches our `max_banscore` setting,\n    /// will cause our peer to be banned for one BANTIME.\n    /// The amount of each increment is given by factor, and it's callibrated for each misbehaving\n    /// action that a peer may incur in.\n    pub(crate) async fn increase_banscore(\n        \u0026mut self,\n        peer_id: u32,\n        factor: u32,\n    ) -\u003e Result\u003c(), WireError\u003e {\n        let Some(peer) = self.0.peers.get_mut(\u0026peer_id) else {\n            return Ok(());\n        };\n        peer.banscore += factor;\n        // This peer is misbehaving too often, ban it\n        if peer.banscore \u003e= self.0.max_banscore {\n            warn!(\"banning peer {} for misbehaving\", peer_id);\n            let _ = peer.channel.send(NodeRequest::Shutdown).await;\n            self.0.address_man.update_set_state(\n                peer.address_id as usize,\n                AddressState::Banned(RunningNode::BAN_TIME),\n            );\n\n            // remove all inflight requests for that peer\n            let peer_req = self\n                .inflight\n                .keys()\n                .filter(|k| self.inflight.get(k).unwrap().0 == peer_id)\n                .cloned()\n                .collect::\u003cVec\u003c_\u003e\u003e();\n            for peer in peer_req {\n                self.inflight.remove_entry(\u0026peer);\n            }\n        }\n\n        Ok(())\n    }\n\n    pub(crate) fn has_utreexo_peers(\u0026self) -\u003e bool {\n        self.peer_by_service\n            .get(\u0026ServiceFlags::UTREEXO)\n            .unwrap_or(\u0026Vec::new())\n            .is_empty()\n    }\n\n    pub(crate) fn has_compact_filters_peer(\u0026self) -\u003e bool {\n        self.peer_by_service\n            .get(\u0026ServiceFlags::COMPACT_FILTERS)\n            .map(|peers| peers.is_empty())\n            .unwrap_or(false)\n    }\n\n    #[inline]\n    pub(crate) async fn send_to_random_peer(\n        \u0026mut self,\n        req: NodeRequest,\n        required_service: ServiceFlags,\n    ) -\u003e Result\u003cu32, WireError\u003e {\n        if self.peers.is_empty() {\n            return Err(WireError::NoPeersAvailable);\n        }\n\n        let Some(peers) = self.peer_by_service.get(\u0026required_service) else {\n            return Err(WireError::NoPeersAvailable);\n        };\n\n        if peers.is_empty() {\n            return Err(WireError::NoPeersAvailable);\n        }\n\n        let rand = rand::random::\u003cusize\u003e() % peers.len();\n        let peer = peers[rand];\n        self.peers\n            .get(\u0026peer)\n            .unwrap()\n            .channel\n            .send(req)\n            .await\n            .map_err(WireError::ChannelSend)?;\n\n        Ok(peer)\n    }\n\n    pub(crate) async fn init_peers(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        let anchors = self\n            .0\n            .address_man\n            .start_addr_man(\n                self.datadir.clone(),\n                self.get_default_port(),\n                self.network,\n                \u0026get_chain_dns_seeds(self.network),\n            )\n            .map_err(WireError::Io)?;\n        for address in anchors {\n            self.open_connection(false, address.id, address).await;\n        }\n        Ok(())\n    }\n\n    pub(crate) async fn shutdown(\u0026mut self) {\n        info!(\"Shutting down node\");\n        for peer in self.peer_ids.iter() {\n            try_and_log!(self.send_to_peer(*peer, NodeRequest::Shutdown).await);\n        }\n        try_and_log!(self.save_peers());\n        try_and_log!(self.chain.flush());\n    }\n\n    pub(crate) async fn handle_broadcast(\u0026self) -\u003e Result\u003c(), WireError\u003e {\n        for (_, peer) in self.peers.iter() {\n            if peer.services.has(ServiceFlags::from(1 \u003c\u003c 24)) {\n                continue;\n            }\n\n            let transactions = self.chain.get_unbroadcasted();\n\n            for transaction in transactions {\n                let txid = transaction.txid();\n                self.mempool.write().await.accept_to_mempool(transaction);\n                peer.channel\n                    .send(NodeRequest::BroadcastTransaction(txid))\n                    .await\n                    .map_err(WireError::ChannelSend)?;\n            }\n            let stale = self.mempool.write().await.get_stale();\n            for tx in stale {\n                peer.channel\n                    .send(NodeRequest::BroadcastTransaction(tx))\n                    .await\n                    .map_err(WireError::ChannelSend)?;\n            }\n        }\n        Ok(())\n    }\n\n    pub(crate) async fn ask_for_addresses(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        let _ = self\n            .send_to_random_peer(NodeRequest::GetAddresses, ServiceFlags::NONE)\n            .await?;\n        Ok(())\n    }\n\n    pub(crate) fn save_peers(\u0026self) -\u003e Result\u003c(), WireError\u003e {\n        self.address_man\n            .dump_peers(\u0026self.datadir)\n            .map_err(WireError::Io)\n    }\n\n    pub(crate) async fn maybe_open_connection(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        // If the user passes in a `--connect` cli argument, we only connect with\n        // that particular peer.\n        if self.fixed_peer.is_some() \u0026\u0026 !self.peers.is_empty() {\n            return Ok(());\n        }\n        if self.peers.len() \u003c T::MAX_OUTGOING_PEERS {\n            self.create_connection(false).await;\n        }\n        Ok(())\n    }\n\n    pub(crate) async fn open_feeler_connection(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        // No feeler if `-connect` is set\n        if self.fixed_peer.is_some() {\n            return Ok(());\n        }\n        self.create_connection(true).await;\n        Ok(())\n    }\n\n    pub(crate) async fn request_blocks(\u0026mut self, blocks: Vec\u003cBlockHash\u003e) -\u003e Result\u003c(), WireError\u003e {\n        let blocks: Vec\u003c_\u003e = blocks\n            .into_iter()\n            .filter(|block| {\n                !self\n                    .inflight\n                    .contains_key(\u0026InflightRequests::Blocks(*block))\n            })\n            .collect();\n\n        let peer = self\n            .send_to_random_peer(\n                NodeRequest::GetBlock((blocks.clone(), true)),\n                ServiceFlags::UTREEXO,\n            )\n            .await?;\n\n        for block in blocks.iter() {\n            self.inflight\n                .insert(InflightRequests::Blocks(*block), (peer, Instant::now()));\n        }\n\n        Ok(())\n    }\n\n    pub(crate) async fn create_connection(\u0026mut self, feeler: bool) -\u003e Option\u003c()\u003e {\n        // We should try to keep at least two utreexo connections\n        let required_services = self.1.get_required_services();\n\n        let (peer_id, address) = match \u0026self.fixed_peer {\n            Some(address) =\u003e (0, address.clone()),\n            None =\u003e self\n                .address_man\n                .get_address_to_connect(required_services, feeler)?,\n        };\n\n        self.address_man\n            .update_set_state(peer_id, AddressState::Connected);\n        debug!(\"attempting connection with: {}\", address.get_net_address());\n        // Don't connect to the same peer twice\n        if self\n            .0\n            .peers\n            .iter()\n            .any(|peers| peers.1.address == address.get_net_address())\n        {\n            return None;\n        }\n\n        self.open_connection(feeler, peer_id, address).await;\n        Some(())\n    }\n\n    /// Opens a new connection that doesn't require a proxy.\n    #[allow(clippy::too_many_arguments)]\n    pub(crate) fn open_non_proxy_connection(\n        feeler: bool,\n        peer_id: usize,\n        address: LocalAddress,\n        requests_rx: Receiver\u003cNodeRequest\u003e,\n        peer_id_count: u32,\n        mempool: Arc\u003cRwLock\u003cMempool\u003e\u003e,\n        network: bitcoin::Network,\n        node_tx: Sender\u003cNodeNotification\u003e,\n    ) -\u003e impl Future\u003cOutput = ()\u003e + Send + 'static {\n        Peer::\u003cTcpStream\u003e::create_outbound_connection(\n            peer_id_count,\n            (address.get_net_address(), address.get_port()),\n            mempool,\n            network,\n            node_tx,\n            requests_rx,\n            peer_id,\n            feeler,\n        )\n    }\n    /// Opens a connection through a socks5 interface\n    #[allow(clippy::too_many_arguments)]\n    pub(crate) async fn open_proxy_connection(\n        proxy: SocketAddr,\n        feeler: bool,\n        mempool: Arc\u003cRwLock\u003cMempool\u003e\u003e,\n        network: bitcoin::Network,\n        node_tx: Sender\u003cNodeNotification\u003e,\n        peer_id: usize,\n        address: LocalAddress,\n        requests_rx: Receiver\u003cNodeRequest\u003e,\n        peer_id_count: u32,\n    ) -\u003e Result\u003c(), Socks5Error\u003e {\n        let addr = match address.get_address() {\n            AddrV2::Cjdns(addr) =\u003e Socks5Addr::Ipv6(addr),\n            AddrV2::I2p(addr) =\u003e Socks5Addr::Domain(addr.into()),\n            AddrV2::Ipv4(addr) =\u003e Socks5Addr::Ipv4(addr),\n            AddrV2::Ipv6(addr) =\u003e Socks5Addr::Ipv6(addr),\n            AddrV2::TorV2(addr) =\u003e Socks5Addr::Domain(addr.into()),\n            AddrV2::TorV3(addr) =\u003e Socks5Addr::Domain(addr.into()),\n            AddrV2::Unknown(_, _) =\u003e {\n                return Err(Socks5Error::InvalidAddress);\n            }\n        };\n\n        let proxy = TcpStream::connect(proxy).await?;\n        let stream = Socks5StreamBuilder::connect(proxy, addr, address.get_port()).await?;\n        Peer::create_peer_from_transport(\n            stream,\n            peer_id_count,\n            mempool,\n            network,\n            node_tx,\n            requests_rx,\n            peer_id,\n            feeler,\n        );\n        Ok(())\n    }\n\n    /// Creates a new outgoing connection with `address`. Connection may or may not be feeler,\n    /// a special connection type that is used to learn about good peers, but are not kept afer\n    /// handshake.\n    pub(crate) async fn open_connection(\n        \u0026mut self,\n        feeler: bool,\n        peer_id: usize,\n        address: LocalAddress,\n    ) {\n        let (requests_tx, requests_rx) = bounded(1024);\n        if let Some(ref proxy) = self.socks5 {\n            spawn(timeout(\n                Duration::from_secs(10),\n                Self::open_proxy_connection(\n                    proxy.address,\n                    feeler,\n                    self.mempool.clone(),\n                    self.network.into(),\n                    self.node_tx.clone(),\n                    peer_id,\n                    address.clone(),\n                    requests_rx,\n                    self.peer_id_count,\n                ),\n            ));\n        } else {\n            spawn(Self::open_non_proxy_connection(\n                feeler,\n                peer_id,\n                address.clone(),\n                requests_rx,\n                self.peer_id_count,\n                self.mempool.clone(),\n                self.network.into(),\n                self.node_tx.clone(),\n            ));\n        }\n\n        let peer_count: u32 = self.peer_id_count;\n\n        self.inflight.insert(\n            InflightRequests::Connect(peer_count),\n            (peer_count, Instant::now()),\n        );\n\n        self.peers.insert(\n            peer_count,\n            LocalPeerView {\n                address: address.get_net_address(),\n                port: address.get_port(),\n                user_agent: \"\".to_string(),\n                state: PeerStatus::Awaiting,\n                channel: requests_tx,\n                services: ServiceFlags::NONE,\n                _last_message: Instant::now(),\n                feeler,\n                address_id: peer_id as u32,\n                height: 0,\n                banscore: 0,\n            },\n        );\n\n        self.peer_id_count += 1;\n    }\n}\n\n/// Run a task and log any errors that might occur.\nmacro_rules! try_and_log {\n    ($what:expr) =\u003e {\n        let result = $what;\n\n        if let Err(error) = result {\n            log::error!(\"{}:{} - {:?}\", line!(), file!(), error);\n        }\n    };\n}\nmacro_rules! periodic_job {\n    ($what:expr, $timer:expr, $interval:ident, $context:ty) =\u003e {\n        if $timer.elapsed() \u003e Duration::from_secs(\u003c$context\u003e::$interval) {\n            try_and_log!($what);\n            $timer = Instant::now();\n        }\n    };\n    ($what:expr, $timer:expr, $interval:ident, $context:ty, $no_log:literal) =\u003e {\n        if $timer.elapsed() \u003e Duration::from_secs(\u003c$context\u003e::$interval) {\n            $what;\n            $timer = Instant::now();\n        }\n    };\n}\npub(crate) use periodic_job;\npub(crate) use try_and_log;\n","traces":[{"line":121,"address":[1526096],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":124,"address":[1526121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[1526135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[1526181],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[6444125,6444301,6441456,6444336,6447198,6447018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[6381968,6382000,6382064,6382032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[6342368,6342528,6342448,6342288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[6397904,6397968,6397936,6398000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[6405936,6406128,6405840,6406032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":582,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[6440400,6440319,6440913,6439857,6440847,6440385,6440928,6441441,6439344,6441375,6439872,6439791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":607,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[6421456,6421696,6421936,6422176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":627,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":628,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":631,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":632,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":635,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":643,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":645,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":647,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":651,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":657,"address":[6353632,6353824,6353728,6353920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":665,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":670,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":671,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":672,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":673,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":674,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":675,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":676,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":680,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":681,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":682,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":683,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":684,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":685,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":695,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":700,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":705,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":706,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":707,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":709,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":710,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":711,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":712,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":716,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":326},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","node_context.rs"],"content":"//! During the lifetime of a Bitcoin client, we have a couple of phases that are slightly different\n//! from each other, having to implement their own state-machines and logic for handing requests.\n//! While we could simply put everything in one struct and have a single `impl` block, that would\n//! create a massive amount of if's in the code, taking different paths depending on which state\n//! are we in. For that reason, we define the basics of a node, like code shared by all the\n//! states into one base struct called `UtreexoNode`, we then further refine this struct using\n//! fine-tunned `Contexts`, that should implement [NodeContext] and are passed-in as a generic\n//! parameter by the caller.\n//!\n//! The three flavors of node are:\n//!  - ChainSelector: This finds the best PoW chain, by downloding multiple candidates and taking\n//!                   the one with more PoW. It should do it's job quickly, as it blocks our main\n//!                   client and can't proceed without this information.\n//!  - SyncNode: Used to download and verify all blocks in a chain. This is computationally\n//!              expensive and may take a while to run. After this ends it's job, it gives us 100%\n//!              centanty that this chain is valid.\n//!  - Running Node: This is the one that users interacts with, and should be the one running most\n//!                  of the time. This node is started right after `ChainSelector` returns, and\n//!                  will handle new blocks (even if `SyncNode` haven't returned) and handle\n//!                  requests by users.\n\nuse bitcoin::p2p::ServiceFlags;\n\n/// This trait mainly defines a bunch of constants that we need for the node, but we may tweak\n/// those values for each one. It's also an organized way of defining those constants anyway.\npub trait NodeContext {\n    const REQUEST_TIMEOUT: u64;\n    /// Max number of simultaneous connections we initiates we are willing to hold\n    const MAX_OUTGOING_PEERS: usize = 10;\n    /// We ask for peers every ASK_FOR_PEERS_INTERVAL seconds\n    const ASK_FOR_PEERS_INTERVAL: u64 = 60 * 60; // One hour\n    /// Save our database of peers every PEER_DB_DUMP_INTERVAL seconds\n    const PEER_DB_DUMP_INTERVAL: u64 = 60 * 5; // 5 minutes\n    /// Attempt to open a new connection (if needed) every TRY_NEW_CONNECTION seconds\n    const TRY_NEW_CONNECTION: u64 = 10; // 10 seconds\n    /// If ASSUME_STALE seconds passed since our last tip update, treat it as stale\n    const ASSUME_STALE: u64 = 15 * 60; // 15 minutes\n    /// While on IBD, if we've been without blocks for this long, ask for headers again\n    const IBD_REQUEST_BLOCKS_AGAIN: u64 = 30; // 30 seconds\n    /// How often we broadcast transactions\n    const BROADCAST_DELAY: u64 = 30; // 30 seconds\n    /// Max number of simultaneous inflight requests we allow\n    const MAX_INFLIGHT_REQUESTS: usize = 1_000;\n    /// Interval at which we open new feeler connections\n    const FEELER_INTERVAL: u64 = 60 * 5; // 5 minutes\n    /// Interval at which we rearrange our addresses\n    const ADDRESS_REARRANGE_INTERVAL: u64 = 60 * 60; // 1 hour\n    /// How long we ban a peer for\n    const BAN_TIME: u64 = 60 * 60 * 24;\n    /// How often we check if we haven't missed a block\n    const BLOCK_CHECK_INTERVAL: u64 = 60 * 5; // 5 minutes\n    /// How often we send our addresses to our peers\n    const SEND_ADDRESSES_INTERVAL: u64 = 60 * 60; // 1 hour\n    fn get_required_services(\u0026self) -\u003e ServiceFlags {\n        ServiceFlags::NETWORK\n    }\n}\n\npub(crate) type PeerId = u32;\n","traces":[{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","node_interface.rs"],"content":"use std::net::IpAddr;\nuse std::sync::Mutex;\nuse std::time::Instant;\n\nuse bitcoin::p2p::utreexo::UtreexoBlock;\nuse bitcoin::Block;\nuse bitcoin::BlockHash;\nuse bitcoin::Transaction;\nuse bitcoin::Txid;\nuse serde::Deserialize;\nuse serde::Serialize;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum UserRequest {\n    Block(BlockHash),\n    UtreexoBlock(BlockHash),\n    MempoolTransaction(Txid),\n    GetPeerInfo,\n    Connect((IpAddr, u16)),\n}\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PeerInfo {\n    pub address: String,\n    pub services: String,\n    pub user_agent: String,\n    pub initial_height: u32,\n}\n\n#[derive(Debug, Clone)]\npub enum NodeResponse {\n    Block(Block),\n    UtreexoBlock(UtreexoBlock),\n    MempoolTransaction(Transaction),\n    GetPeerInfo(Vec\u003cPeerInfo\u003e),\n    Connect(bool),\n}\n\npub trait NodeMethods {\n    fn get_block(\u0026self, block: BlockHash) -\u003e Result\u003cOption\u003cBlock\u003e, oneshot::RecvError\u003e;\n    fn get_utreexo_block(\n        \u0026self,\n        block: BlockHash,\n    ) -\u003e Result\u003cOption\u003cUtreexoBlock\u003e, oneshot::RecvError\u003e;\n    fn get_mempool_transaction(\n        \u0026self,\n        txid: Txid,\n    ) -\u003e Result\u003cOption\u003cTransaction\u003e, oneshot::RecvError\u003e;\n    fn get_peer_info(\u0026self) -\u003e Result\u003cVec\u003cPeerInfo\u003e, oneshot::RecvError\u003e;\n    fn connect(\u0026self, addr: IpAddr, port: u16) -\u003e Result\u003cbool, oneshot::RecvError\u003e;\n}\n#[derive(Debug)]\npub struct NodeInterface {\n    pub(super) requests: Mutex\u003cVec\u003cRequestData\u003e\u003e,\n}\n#[derive(Debug)]\npub struct RequestData {\n    pub time: Instant,\n    pub resolve: oneshot::Sender\u003cOption\u003cNodeResponse\u003e\u003e,\n    pub req: UserRequest,\n}\nimpl NodeInterface {\n    pub fn send_answer(\u0026self, request: UserRequest, answer: Option\u003cNodeResponse\u003e) {\n        let mut requests = self.requests.lock().unwrap();\n        let req = requests.iter().position(|x| x.req == request);\n        if let Some(req) = req {\n            let req = requests.remove(req);\n            req.resolve.send(answer).unwrap();\n        }\n    }\n}\nimpl NodeMethods for NodeInterface {\n    fn connect(\u0026self, addr: IpAddr, port: u16) -\u003e Result\u003cbool, oneshot::RecvError\u003e {\n        let (tx, rx) = oneshot::channel();\n        self.requests.lock().unwrap().push(RequestData {\n            time: Instant::now(),\n            resolve: tx,\n            req: UserRequest::Connect((addr, port)),\n        });\n        let connected = rx.recv()?;\n        Ok(match connected {\n            Some(NodeResponse::Connect(connected)) =\u003e connected,\n            _ =\u003e unreachable!(),\n        })\n    }\n    fn get_block(\u0026self, block: BlockHash) -\u003e Result\u003cOption\u003cBlock\u003e, oneshot::RecvError\u003e {\n        let (tx, rx) = oneshot::channel();\n        self.requests.lock().unwrap().push(RequestData {\n            time: Instant::now(),\n            resolve: tx,\n            req: UserRequest::Block(block),\n        });\n        let blk = rx.recv()?;\n        Ok(match blk {\n            Some(NodeResponse::Block(blk)) =\u003e Some(blk),\n            None =\u003e None,\n            _ =\u003e unreachable!(),\n        })\n    }\n\n    fn get_utreexo_block(\n        \u0026self,\n        block: BlockHash,\n    ) -\u003e Result\u003cOption\u003cUtreexoBlock\u003e, oneshot::RecvError\u003e {\n        let (tx, rx) = oneshot::channel();\n        self.requests.lock().unwrap().push(RequestData {\n            time: Instant::now(),\n            resolve: tx,\n            req: UserRequest::UtreexoBlock(block),\n        });\n        let blk = rx.recv()?;\n        Ok(match blk {\n            Some(NodeResponse::UtreexoBlock(blk)) =\u003e Some(blk),\n            None =\u003e None,\n            _ =\u003e unreachable!(),\n        })\n    }\n\n    fn get_mempool_transaction(\n        \u0026self,\n        txid: Txid,\n    ) -\u003e Result\u003cOption\u003cTransaction\u003e, oneshot::RecvError\u003e {\n        let (tx, rx) = oneshot::channel();\n        self.requests.lock().unwrap().push(RequestData {\n            time: Instant::now(),\n            resolve: tx,\n            req: UserRequest::MempoolTransaction(txid),\n        });\n        let tx = rx.recv()?;\n        Ok(match tx {\n            Some(NodeResponse::MempoolTransaction(tx)) =\u003e Some(tx),\n            None =\u003e None,\n            _ =\u003e unreachable!(),\n        })\n    }\n\n    fn get_peer_info(\u0026self) -\u003e Result\u003cVec\u003cPeerInfo\u003e, oneshot::RecvError\u003e {\n        let (tx, rx) = oneshot::channel();\n        self.requests.lock().unwrap().push(RequestData {\n            time: Instant::now(),\n            resolve: tx,\n            req: UserRequest::GetPeerInfo,\n        });\n        let peer_info = rx.recv()?;\n        Ok(match peer_info {\n            Some(NodeResponse::GetPeerInfo(peer_info)) =\u003e peer_info,\n            None =\u003e Vec::new(),\n            _ =\u003e unreachable!(),\n        })\n    }\n}\n","traces":[{"line":62,"address":[1532352,1532946],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[1532455,1532383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[1532518,1532575],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[1532717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[1532757,1532797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[1532824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[1533844,1532992,1533783],"length":1,"stats":{"Line":0},"fn_name":"connect"},{"line":73,"address":[1533033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[1533362,1533090,1533138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[1533235],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[1533279],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[1533292],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[1533798,1533460,1533017,1533615],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[1533588,1533636,1533694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[1533680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[1533650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[1534863,1534802,1533872],"length":1,"stats":{"Line":0},"fn_name":"get_block"},{"line":86,"address":[1533907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[1534020,1533972,1534200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[1534117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[1534156],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[1534169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[1533899,1534466,1534298],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[1534434,1534497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[1534579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[1534483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[1534637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[1535826,1535887,1534896],"length":1,"stats":{"Line":0},"fn_name":"get_utreexo_block"},{"line":104,"address":[1534931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[1534996,1535044,1535224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[1535141],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[1535180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[1535193],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[1535322,1534923,1535490],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[1535521,1535458],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[1535603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[1535507],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[1535661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[1536894,1535920,1536833],"length":1,"stats":{"Line":0},"fn_name":"get_mempool_transaction"},{"line":122,"address":[1535955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[1536248,1536020,1536068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[1536165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[1536204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[1536217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[1536514,1535947,1536346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[1536544,1536482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[1536610],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[1536531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[1536668],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[1538010,1538082,1536928],"length":1,"stats":{"Line":0},"fn_name":"get_peer_info"},{"line":137,"address":[1536958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[1537231,1537079,1537031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[1537176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[1537210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[1537223],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[1537329,1537505,1536950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[1537537,1537623,1537473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[1537692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[1537616,1537530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[1537801],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":60},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","peer.rs"],"content":"use std::fmt::Debug;\nuse std::sync::Arc;\nuse std::time::Duration;\nuse std::time::Instant;\n\nuse async_std::channel::unbounded;\nuse async_std::channel::Receiver;\nuse async_std::channel::Sender;\nuse async_std::io::BufReader;\nuse async_std::net::TcpStream;\nuse async_std::net::ToSocketAddrs;\nuse async_std::sync::RwLock;\nuse async_std::task::spawn;\nuse bitcoin::bip158;\nuse bitcoin::block::Header as BlockHeader;\nuse bitcoin::consensus::serialize;\nuse bitcoin::hashes::Hash;\nuse bitcoin::p2p::address::AddrV2Message;\nuse bitcoin::p2p::message::NetworkMessage;\nuse bitcoin::p2p::message::RawNetworkMessage;\nuse bitcoin::p2p::message_blockdata::Inventory;\nuse bitcoin::p2p::message_network::VersionMessage;\nuse bitcoin::p2p::utreexo::UtreexoBlock;\nuse bitcoin::p2p::ServiceFlags;\nuse bitcoin::BlockHash;\nuse bitcoin::Network;\nuse bitcoin::Transaction;\nuse futures::AsyncRead;\nuse futures::AsyncWrite;\nuse futures::AsyncWriteExt;\nuse futures::FutureExt;\nuse log::error;\nuse log::warn;\nuse thiserror::Error;\n\nuse self::peer_utils::make_pong;\nuse super::mempool::Mempool;\nuse super::node::NodeNotification;\nuse super::node::NodeRequest;\nuse super::stream_reader::StreamReader;\n\n/// If we send a ping, and our peer takes more than PING_TIMEOUT to\n/// reply, disconnect.\nconst PING_TIMEOUT: u64 = 30;\n/// If the last message we've got was more than XX, send out a ping\nconst SEND_PING_TIMEOUT: u64 = 60;\n\n#[derive(Debug, PartialEq)]\nenum State {\n    None,\n    SentVersion(Instant),\n    SentVerack,\n    Connected,\n}\n/// A trait defining how the transport we use should behave. Transport is anything\n/// that allows to read/write from/into. Like a TcpStream or a Socks5 proxy\npub trait Transport:\n    AsyncRead + AsyncWrite + Unpin + Clone + Sync + Send + AsyncWriteExt + 'static\n{\n    /// Asks the stream to shutdown, the final part of the disconnection process\n    fn shutdown(\u0026mut self) -\u003e Result\u003c()\u003e;\n}\n\nimpl Transport for TcpStream {\n    fn shutdown(\u0026mut self) -\u003e Result\u003c()\u003e {\n        Ok(TcpStream::shutdown(self, std::net::Shutdown::Both)?)\n    }\n}\n\npub struct Peer\u003cT: Transport\u003e {\n    stream: T,\n    mempool: Arc\u003cRwLock\u003cMempool\u003e\u003e,\n    network: Network,\n    blocks_only: bool,\n    services: ServiceFlags,\n    user_agent: String,\n    messages: u64,\n    start_time: Instant,\n    last_message: Instant,\n    current_best_block: i32,\n    last_ping: Option\u003cInstant\u003e,\n    id: u32,\n    node_tx: Sender\u003cNodeNotification\u003e,\n    state: State,\n    send_headers: bool,\n    node_requests: Receiver\u003cNodeRequest\u003e,\n    address_id: usize,\n    feeler: bool,\n    wants_addrv2: bool,\n    shutdown: bool,\n}\n#[derive(Debug, Error)]\npub enum PeerError {\n    #[error(\"Error while sending to peer\")]\n    Send,\n    #[error(\"Error while reading from peer\")]\n    Read(#[from] std::io::Error),\n    #[error(\"Error while parsing message\")]\n    Parse(#[from] bitcoin::consensus::encode::Error),\n    #[error(\"Peer sent us a message that we aren't expecting\")]\n    UnexpectedMessage,\n    #[error(\"Peer sent us a message that is too big\")]\n    MessageTooBig,\n    #[error(\"Peer sent us a message with the wrong magic bits\")]\n    MagicBitsMismatch,\n    #[error(\"Peer sent us too many message in a short period of time\")]\n    TooManyMessages,\n    #[error(\"Peer timed a ping out\")]\n    Timeout,\n}\nimpl Debug for Peer\u003cTcpStream\u003e {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.id)?;\n        write!(f, \"{:?}\", self.stream.peer_addr())?;\n        Ok(())\n    }\n}\n\ntype Result\u003cT\u003e = std::result::Result\u003cT, PeerError\u003e;\n\nimpl\u003cT: Transport\u003e Peer\u003cT\u003e {\n    pub async fn read_loop(mut self) -\u003e Result\u003c()\u003e {\n        let err = self.peer_loop_inner().await;\n\n        if let Err(err) = err {\n            warn!(\"Peer {} connection loop closed: {err:?}\", self.id);\n        }\n\n        self.send_to_node(PeerMessages::Disconnected(self.address_id))\n            .await;\n        Ok(())\n    }\n    async fn peer_loop_inner(\u0026mut self) -\u003e Result\u003c()\u003e {\n        // send a version\n        let version = peer_utils::build_version_message();\n        self.write(version).await?;\n        self.state = State::SentVersion(Instant::now());\n        let read_stream = BufReader::new(self.stream.clone());\n        let (tx, rx) = unbounded();\n        let magic = self.network.magic();\n        let stream: StreamReader\u003c_, RawNetworkMessage\u003e = StreamReader::new(read_stream, magic, tx);\n        spawn(stream.read_loop());\n        loop {\n            futures::select! {\n                request = self.node_requests.recv().fuse() =\u003e {\n                    if let Ok(request) = request {\n                        self.handle_node_request(request).await?;\n                    }\n                }\n                peer_request = async_std::future::timeout(Duration::from_secs(10), rx.recv()).fuse() =\u003e {\n                    if let Ok(Ok(peer_request)) = peer_request {\n                        self.handle_peer_message(peer_request?).await?;\n                    }\n                }\n            };\n            if self.shutdown {\n                return Ok(());\n            }\n            // If we send a ping and our peer doesn't respond in time, disconnect\n            if let Some(when) = self.last_ping {\n                if when.elapsed().as_secs() \u003e PING_TIMEOUT {\n                    return Err(PeerError::Timeout);\n                }\n            }\n\n            // Send a ping to check if this peer is still good\n            let last_message = self.last_message.elapsed().as_secs();\n            if last_message \u003e SEND_PING_TIMEOUT {\n                let nonce = rand::random();\n                self.last_ping = Some(Instant::now());\n                self.write(NetworkMessage::Ping(nonce)).await?;\n            }\n\n            // divide the number of messages by the number of seconds we've been connected,\n            // if it's more than 100 msg/sec, this peer is sending us too many messages, and we should\n            // disconnect.\n            let msg_sec = self\n                .messages\n                .checked_div(Instant::now().duration_since(self.start_time).as_secs())\n                .unwrap_or(0);\n\n            if msg_sec \u003e 10 {\n                error!(\n                    \"Peer {} is sending us too many messages, disconnecting\",\n                    self.id\n                );\n                return Err(PeerError::TooManyMessages);\n            }\n\n            if let State::SentVersion(when) = self.state {\n                if Instant::now().duration_since(when) \u003e Duration::from_secs(10) {\n                    return Err(PeerError::UnexpectedMessage);\n                }\n            }\n        }\n    }\n    pub async fn handle_node_request(\u0026mut self, request: NodeRequest) -\u003e Result\u003c()\u003e {\n        match request {\n            NodeRequest::GetBlock((block_hashes, proof)) =\u003e {\n                let inv = if proof {\n                    block_hashes\n                        .iter()\n                        .map(|block| Inventory::UtreexoWitnessBlock(*block))\n                        .collect()\n                } else {\n                    block_hashes\n                        .iter()\n                        .map(|block| Inventory::Block(*block))\n                        .collect()\n                };\n\n                let _ = self.write(NetworkMessage::GetData(inv)).await;\n            }\n            NodeRequest::GetUtreexoState((block_hash, height)) =\u003e {\n                let get_filter = bitcoin::p2p::message_filter::GetCFilters {\n                    filter_type: 1,\n                    start_height: height,\n                    stop_hash: block_hash,\n                };\n\n                let _ = self.write(NetworkMessage::GetCFilters(get_filter)).await;\n            }\n            NodeRequest::GetHeaders(locator) =\u003e {\n                let _ = self\n                    .write(NetworkMessage::GetHeaders(\n                        bitcoin::p2p::message_blockdata::GetHeadersMessage {\n                            version: 0,\n                            locator_hashes: locator,\n                            stop_hash: BlockHash::all_zeros(),\n                        },\n                    ))\n                    .await;\n            }\n            NodeRequest::Shutdown =\u003e {\n                self.shutdown = true;\n                let _ = self.stream.shutdown();\n            }\n            NodeRequest::GetAddresses =\u003e {\n                self.write(NetworkMessage::GetAddr).await?;\n            }\n            NodeRequest::BroadcastTransaction(tx) =\u003e {\n                self.write(NetworkMessage::Inv(vec![Inventory::Transaction(tx)]))\n                    .await?;\n            }\n            NodeRequest::MempoolTransaction(txid) =\u003e {\n                self.write(NetworkMessage::GetData(vec![Inventory::Transaction(txid)]))\n                    .await?;\n            }\n            NodeRequest::SendAddresses(addresses) =\u003e {\n                self.write(NetworkMessage::AddrV2(addresses)).await?;\n            }\n            NodeRequest::GetFilter((stop_hash, start_height)) =\u003e {\n                let get_filter = bitcoin::p2p::message_filter::GetCFilters {\n                    filter_type: 0,\n                    start_height,\n                    stop_hash,\n                };\n\n                self.write(NetworkMessage::GetCFilters(get_filter)).await?;\n            }\n        }\n        Ok(())\n    }\n    pub async fn handle_peer_message(\u0026mut self, message: RawNetworkMessage) -\u003e Result\u003c()\u003e {\n        self.last_message = Instant::now();\n\n        match self.state {\n            State::Connected =\u003e match message.payload().to_owned() {\n                NetworkMessage::Inv(inv) =\u003e {\n                    for inv_entry in inv {\n                        match inv_entry {\n                            Inventory::Error =\u003e {}\n                            Inventory::Transaction(_) =\u003e {}\n                            Inventory::Block(block_hash)\n                            | Inventory::WitnessBlock(block_hash)\n                            | Inventory::CompactBlock(block_hash) =\u003e {\n                                self.send_to_node(PeerMessages::NewBlock(block_hash)).await;\n                            }\n                            _ =\u003e {}\n                        }\n                    }\n                }\n                NetworkMessage::GetHeaders(_) =\u003e {\n                    self.write(NetworkMessage::Headers(Vec::new())).await?;\n                }\n                NetworkMessage::Block(block) =\u003e {\n                    self.send_to_node(PeerMessages::Block(block)).await;\n                }\n                NetworkMessage::Headers(headers) =\u003e {\n                    self.send_to_node(PeerMessages::Headers(headers)).await;\n                }\n                NetworkMessage::SendHeaders =\u003e {\n                    self.send_headers = true;\n                    self.write(NetworkMessage::SendHeaders).await?;\n                }\n                NetworkMessage::Ping(nonce) =\u003e {\n                    self.handle_ping(nonce).await?;\n                }\n                NetworkMessage::FeeFilter(_) =\u003e {\n                    self.write(NetworkMessage::FeeFilter(1000)).await?;\n                }\n                NetworkMessage::AddrV2(addresses) =\u003e {\n                    self.send_to_node(PeerMessages::Addr(addresses)).await;\n                }\n                NetworkMessage::GetBlocks(_) =\u003e {\n                    self.write(NetworkMessage::Inv(Vec::new())).await?;\n                }\n                NetworkMessage::GetAddr =\u003e {\n                    self.write(NetworkMessage::AddrV2(Vec::new())).await?;\n                }\n                NetworkMessage::GetData(inv) =\u003e {\n                    for inv_el in inv {\n                        self.handle_get_data(inv_el).await?;\n                    }\n                }\n                NetworkMessage::Tx(tx) =\u003e {\n                    self.send_to_node(PeerMessages::Transaction(tx)).await;\n                }\n                NetworkMessage::NotFound(inv) =\u003e {\n                    for inv_el in inv {\n                        self.send_to_node(PeerMessages::NotFound(inv_el)).await;\n                    }\n                }\n                NetworkMessage::SendAddrV2 =\u003e {\n                    self.wants_addrv2 = true;\n                    self.write(NetworkMessage::SendAddrV2).await?;\n                }\n                NetworkMessage::Pong(_) =\u003e {\n                    self.last_ping = None;\n                }\n                NetworkMessage::Unknown { command, payload } =\u003e {\n                    warn!(\"Unknown message: {} {:?}\", command, payload);\n                }\n                NetworkMessage::CFilter(filter_msg) =\u003e match filter_msg.filter_type {\n                    0 =\u003e {\n                        let filter = bip158::BlockFilter::new(\u0026filter_msg.filter);\n\n                        // FIXME\n                        let filter = unsafe {\n                            std::mem::transmute::\u003c\n                                bitcoin::bip158::BlockFilter,\n                                floresta_compact_filters::BlockFilter,\n                            \u003e(filter)\n                        };\n                        self.send_to_node(PeerMessages::BlockFilter((\n                            filter_msg.block_hash,\n                            filter,\n                        )))\n                        .await;\n                    }\n                    1 =\u003e {\n                        self.send_to_node(PeerMessages::UtreexoState(filter_msg.filter))\n                            .await;\n                    }\n                    _ =\u003e {}\n                },\n                // Explicitly ignore these messages, if something changes in the future\n                // this would cause a compile error.\n                NetworkMessage::Verack\n                | NetworkMessage::Version(_)\n                | NetworkMessage::WtxidRelay\n                | NetworkMessage::Reject(_)\n                | NetworkMessage::Alert(_)\n                | NetworkMessage::BlockTxn(_)\n                | NetworkMessage::CFCheckpt(_)\n                | NetworkMessage::CFHeaders(_)\n                | NetworkMessage::CmpctBlock(_)\n                | NetworkMessage::FilterAdd(_)\n                | NetworkMessage::FilterClear\n                | NetworkMessage::FilterLoad(_)\n                | NetworkMessage::GetBlockTxn(_)\n                | NetworkMessage::GetCFCheckpt(_)\n                | NetworkMessage::GetCFHeaders(_)\n                | NetworkMessage::Addr(_)\n                | NetworkMessage::GetCFilters(_)\n                | NetworkMessage::MemPool\n                | NetworkMessage::MerkleBlock(_)\n                | NetworkMessage::SendCmpct(_) =\u003e {}\n            },\n            State::None | State::SentVersion(_) =\u003e match message.payload().to_owned() {\n                bitcoin::p2p::message::NetworkMessage::Version(version) =\u003e {\n                    self.handle_version(version).await?;\n                    self.send_to_node(PeerMessages::Ready(Version {\n                        user_agent: self.user_agent.clone(),\n                        protocol_version: 0,\n                        id: self.id,\n                        blocks: self.current_best_block.unsigned_abs(),\n                        address_id: self.address_id,\n                        services: self.services,\n                        feeler: self.feeler,\n                    }))\n                    .await;\n                }\n                _ =\u003e {\n                    warn!(\n                        \"unexpected message: {:?} from peer {}\",\n                        message.payload(),\n                        self.id\n                    );\n                    return Err(PeerError::UnexpectedMessage);\n                }\n            },\n            State::SentVerack =\u003e match message.payload() {\n                bitcoin::p2p::message::NetworkMessage::Verack =\u003e {\n                    self.state = State::Connected;\n                }\n                bitcoin::p2p::message::NetworkMessage::SendAddrV2 =\u003e {\n                    self.wants_addrv2 = true;\n                }\n                bitcoin::p2p::message::NetworkMessage::SendHeaders =\u003e {\n                    self.send_headers = true;\n                }\n                bitcoin::p2p::message::NetworkMessage::WtxidRelay =\u003e {}\n                _ =\u003e {\n                    warn!(\n                        \"unexpected message: {:?} from peer {}\",\n                        message.payload(),\n                        self.id\n                    );\n                    return Err(PeerError::UnexpectedMessage);\n                }\n            },\n        }\n        Ok(())\n    }\n}\nimpl\u003cT: Transport\u003e Peer\u003cT\u003e {\n    pub async fn write(\u0026mut self, msg: NetworkMessage) -\u003e Result\u003c()\u003e {\n        let data = \u0026mut RawNetworkMessage::new(self.network.magic(), msg);\n        let data = serialize(\u0026data);\n        self.stream.write_all(data.as_slice()).await?;\n        Ok(())\n    }\n    pub async fn handle_get_data(\u0026mut self, inv: Inventory) -\u003e Result\u003c()\u003e {\n        match inv {\n            Inventory::WitnessTransaction(txid) =\u003e {\n                let tx = self.mempool.read().await.get_from_mempool(\u0026txid).cloned();\n                if let Some(tx) = tx {\n                    self.write(NetworkMessage::Tx(tx)).await?;\n                }\n            }\n            Inventory::Transaction(txid) =\u003e {\n                let tx = self.mempool.read().await.get_from_mempool(\u0026txid).cloned();\n                if let Some(tx) = tx {\n                    self.write(NetworkMessage::Tx(tx)).await?;\n                }\n            }\n            _ =\u003e {}\n        }\n        Ok(())\n    }\n    #[allow(clippy::too_many_arguments)]\n    pub fn create_peer_from_transport(\n        stream: T,\n        id: u32,\n        mempool: Arc\u003cRwLock\u003cMempool\u003e\u003e,\n        network: Network,\n        node_tx: Sender\u003cNodeNotification\u003e,\n        node_requests: Receiver\u003cNodeRequest\u003e,\n        address_id: usize,\n        feeler: bool,\n    ) {\n        let peer = Peer {\n            address_id,\n            blocks_only: false,\n            current_best_block: -1,\n            id,\n            mempool,\n            last_ping: None,\n            last_message: Instant::now(),\n            network,\n            node_tx,\n            services: ServiceFlags::NONE,\n            stream,\n            messages: 0,\n            start_time: Instant::now(),\n            user_agent: \"\".into(),\n            state: State::None,\n            send_headers: false,\n            node_requests,\n            feeler,\n            wants_addrv2: false,\n            shutdown: false,\n        };\n        spawn(peer.read_loop());\n    }\n\n    #[allow(clippy::too_many_arguments)]\n    pub async fn create_outbound_connection\u003cA: ToSocketAddrs + Debug\u003e(\n        id: u32,\n        address: A,\n        mempool: Arc\u003cRwLock\u003cMempool\u003e\u003e,\n        network: Network,\n        node_tx: Sender\u003cNodeNotification\u003e,\n        node_requests: Receiver\u003cNodeRequest\u003e,\n        address_id: usize,\n        feeler: bool,\n    ) {\n        let stream =\n            async_std::future::timeout(Duration::from_secs(10), TcpStream::connect(address)).await;\n        let Ok(Ok(stream)) = stream else {\n            let _ = node_tx\n                .send(NodeNotification::FromPeer(\n                    id,\n                    PeerMessages::Disconnected(id as usize),\n                ))\n                .await;\n            return;\n        };\n        let peer = Peer {\n            address_id,\n            blocks_only: false,\n            current_best_block: -1,\n            id,\n            mempool,\n            last_ping: None,\n            last_message: Instant::now(),\n            network,\n            node_tx,\n            services: ServiceFlags::NONE,\n            stream,\n            messages: 0,\n            start_time: Instant::now(),\n            user_agent: \"\".into(),\n            state: State::None,\n            send_headers: false,\n            node_requests,\n            feeler,\n            wants_addrv2: false,\n            shutdown: false,\n        };\n        spawn(peer.read_loop());\n    }\n    async fn handle_ping(\u0026mut self, nonce: u64) -\u003e Result\u003c()\u003e {\n        let pong = make_pong(nonce);\n        self.write(pong).await\n    }\n    async fn handle_version(\u0026mut self, version: VersionMessage) -\u003e Result\u003c()\u003e {\n        self.user_agent = version.user_agent;\n        self.blocks_only = !version.relay;\n        self.current_best_block = version.start_height;\n        self.services = version.services;\n        if version.version \u003e= 70016 {\n            self.write(NetworkMessage::SendAddrV2).await?;\n        }\n        self.state = State::SentVerack;\n        let verack = NetworkMessage::Verack;\n        self.state = State::SentVerack;\n        self.write(verack).await\n    }\n    async fn send_to_node(\u0026self, message: PeerMessages) {\n        let message = NodeNotification::FromPeer(self.id, message);\n        let _ = self.node_tx.send(message).await;\n    }\n}\npub(super) mod peer_utils {\n    use std::net::IpAddr;\n    use std::net::Ipv4Addr;\n    use std::net::SocketAddr;\n    use std::time::SystemTime;\n    use std::time::UNIX_EPOCH;\n\n    use bitcoin::p2p::address;\n    use bitcoin::p2p::message::NetworkMessage;\n    use bitcoin::p2p::message::{self};\n    use bitcoin::p2p::message_network;\n    use floresta_common::constants::FLORESTA_VERSION;\n    use floresta_common::constants::RUSTREEXO_VERSION;\n    use floresta_common::constants::RUST_BITCOIN_VERSION;\n\n    /// Protocol version we speak\n    pub const PROTOCOL_VERSION: u32 = 70016;\n\n    pub(super) fn make_pong(nonce: u64) -\u003e NetworkMessage {\n        NetworkMessage::Pong(nonce)\n    }\n\n    pub(crate) fn build_version_message() -\u003e message::NetworkMessage {\n        use bitcoin::p2p::ServiceFlags;\n\n        // Building version message, see https://en.bitcoin.it/wiki/Protocol_documentation#version\n        let my_address = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 38332);\n\n        // \"bitfield of features to be enabled for this connection\"\n        let services = ServiceFlags::NETWORK | ServiceFlags::from(1 \u003c\u003c 24) | ServiceFlags::WITNESS;\n\n        // \"standard UNIX timestamp in seconds\"\n        let timestamp = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .expect(\"Time error\")\n            .as_secs();\n\n        // \"The network address of the node receiving this message\"\n        let addr_recv = address::Address::new(\u0026my_address, ServiceFlags::NONE);\n\n        // \"The network address of the node emitting this message\"\n        let addr_from = address::Address::new(\u0026my_address, ServiceFlags::NONE);\n\n        // \"Node random nonce, randomly generated every time a version packet is sent. This nonce is used to detect connections to self.\"\n        let nonce: u64 = 1;\n\n        // \"User Agent (0x00 if string is 0 bytes long)\"\n        let user_agent = format!(\n            \"/rust-bitcoin:{}/rustreexo:{}/Floresta:{}/\",\n            RUST_BITCOIN_VERSION, RUSTREEXO_VERSION, FLORESTA_VERSION\n        );\n\n        // \"The last block received by the emitting node\"\n        let start_height: i32 = 0;\n\n        // Construct the message\n        message::NetworkMessage::Version(message_network::VersionMessage {\n            services,\n            timestamp: timestamp as i64,\n            receiver: addr_recv,\n            sender: addr_from,\n            nonce,\n            user_agent,\n            start_height,\n            relay: false,\n            version: PROTOCOL_VERSION,\n        })\n    }\n}\n#[derive(Debug)]\npub struct Version {\n    pub user_agent: String,\n    pub protocol_version: u32,\n    pub blocks: u32,\n    pub id: u32,\n    pub address_id: usize,\n    pub services: ServiceFlags,\n    pub feeler: bool,\n}\n/// Messages passed from different modules to the main node to process. They should minimal\n/// and only if it requires global states, everything else should be handled by the module\n/// itself.\n#[derive(Debug)]\npub enum PeerMessages {\n    /// A new block just arrived, we should ask for it and update our chain\n    NewBlock(BlockHash),\n    /// We got a full block from our peer, presumptively we asked for it\n    Block(UtreexoBlock),\n    /// A response to a `getheaders` request\n    Headers(Vec\u003cBlockHeader\u003e),\n    /// We got some p2p addresses, add this to our local database\n    Addr(Vec\u003cAddrV2Message\u003e),\n    /// Peer notify its readiness\n    Ready(Version),\n    /// Remote peer disconnected\n    Disconnected(usize),\n    /// Remote peer doesn't known the data we asked for\n    NotFound(Inventory),\n    /// Remote peer sent us a transaction\n    Transaction(Transaction),\n    UtreexoState(Vec\u003cu8\u003e),\n    BlockFilter((BlockHash, floresta_compact_filters::BlockFilter)),\n}\n","traces":[{"line":65,"address":[1583712],"length":1,"stats":{"Line":0},"fn_name":"shutdown"},{"line":66,"address":[1583815,1583739],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[1705376,1705964],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":113,"address":[1705409,1705667,1705471],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[1705943,1705569,1705900,1705699,1705393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[1705893],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[5235776,5236712,5236635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[5232176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[1581568],"length":1,"stats":{"Line":0},"fn_name":"make_pong"},{"line":575,"address":[1581576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[1581584],"length":1,"stats":{"Line":0},"fn_name":"build_version_message"},{"line":582,"address":[1581634],"length":1,"stats":{"Line":0},"fn_name":null},{"line":585,"address":[1581712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[1581777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":594,"address":[1581929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[1581974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[1581601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":603,"address":[1582141],"length":1,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[1581610],"length":1,"stats":{"Line":0},"fn_name":null},{"line":612,"address":[1582440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":615,"address":[1582312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[1582376],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":265},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","running_node.rs"],"content":"/// After a node catches-up with the network, we can start listening for new blocks, handing any\n/// request our user might make and keep our peers alive. This mode requires way less bandwidth and\n/// CPU to run, being bound by the number of blocks found in a given period.\nuse std::net::IpAddr;\nuse std::sync::Arc;\nuse std::time::Duration;\nuse std::time::Instant;\n\nuse async_std::channel::SendError;\nuse async_std::future::timeout;\nuse async_std::sync::RwLock;\nuse bitcoin::p2p::address::AddrV2;\nuse bitcoin::p2p::address::AddrV2Message;\nuse bitcoin::p2p::message_blockdata::Inventory;\nuse bitcoin::p2p::utreexo::UtreexoBlock;\nuse bitcoin::p2p::ServiceFlags;\nuse floresta_chain::pruned_utreexo::partial_chain::PartialChainState;\nuse floresta_chain::pruned_utreexo::BlockchainInterface;\nuse floresta_chain::pruned_utreexo::UpdatableChainstate;\nuse floresta_chain::BlockValidationErrors;\nuse floresta_chain::BlockchainError;\nuse log::debug;\nuse log::error;\nuse log::info;\nuse log::warn;\nuse rustreexo::accumulator::stump::Stump;\n\nuse super::error::WireError;\nuse super::peer::PeerMessages;\nuse crate::address_man::AddressState;\nuse crate::address_man::LocalAddress;\nuse crate::node::periodic_job;\nuse crate::node::try_and_log;\nuse crate::node::InflightRequests;\nuse crate::node::NodeNotification;\nuse crate::node::NodeRequest;\nuse crate::node::RescanStatus;\nuse crate::node::UtreexoNode;\nuse crate::node_context::NodeContext;\nuse crate::node_interface::NodeInterface;\nuse crate::node_interface::NodeResponse;\nuse crate::node_interface::UserRequest;\nuse crate::p2p_wire::chain_selector::ChainSelector;\nuse crate::p2p_wire::sync_node::SyncNode;\n\n#[derive(Debug, Clone)]\npub struct RunningNode {\n    pub(crate) last_rescan_request: RescanStatus,\n    pub(crate) last_feeler: Instant,\n    pub(crate) last_address_rearrange: Instant,\n    pub(crate) user_requests: Arc\u003cNodeInterface\u003e,\n}\n\nimpl NodeContext for RunningNode {\n    const REQUEST_TIMEOUT: u64 = 30;\n    fn get_required_services(\u0026self) -\u003e ServiceFlags {\n        ServiceFlags::UTREEXO\n            | ServiceFlags::NETWORK\n            | ServiceFlags::WITNESS\n            | ServiceFlags::COMPACT_FILTERS\n    }\n}\n\nimpl\u003cChain\u003e UtreexoNode\u003cRunningNode, Chain\u003e\nwhere\n    WireError: From\u003c\u003cChain as BlockchainInterface\u003e::Error\u003e,\n    Chain: BlockchainInterface + UpdatableChainstate + 'static,\n{\n    /// Returns a handle to the node interface that we can use to request data from our\n    /// node. This struct is thread safe, so we can use it from multiple threads and have\n    /// multiple handles. It also doesn't require a mutable reference to the node, or any\n    /// synchronization mechanism.\n    pub fn get_handle(\u0026self) -\u003e Arc\u003cNodeInterface\u003e {\n        self.1.user_requests.clone()\n    }\n\n    #[allow(clippy::result_large_err)]\n    fn check_request_timeout(\u0026mut self) -\u003e Result\u003c(), SendError\u003cNodeResponse\u003e\u003e {\n        let mutex = self.1.user_requests.requests.lock().unwrap();\n        let mut to_remove = Vec::new();\n        for req in mutex.iter() {\n            if req.time.elapsed() \u003e Duration::from_secs(10) {\n                to_remove.push(req.req);\n            }\n        }\n        drop(mutex);\n        for request in to_remove {\n            self.1.user_requests.send_answer(request, None);\n        }\n\n        Ok(())\n    }\n\n    async fn handle_user_request(\u0026mut self) {\n        let mut requests = Vec::new();\n\n        for request in self.1.user_requests.requests.lock().unwrap().iter() {\n            if !self\n                .inflight\n                .contains_key(\u0026InflightRequests::UserRequest(request.req))\n            {\n                requests.push(request.req);\n            }\n        }\n        self.perform_user_request(requests).await;\n    }\n\n    fn handle_get_peer_info(\u0026self) {\n        let mut peers = Vec::new();\n        for peer in self.peer_ids.iter() {\n            peers.push(self.get_peer_info(peer));\n        }\n        let peers = peers.into_iter().flatten().collect();\n        self.1.user_requests.send_answer(\n            UserRequest::GetPeerInfo,\n            Some(NodeResponse::GetPeerInfo(peers)),\n        );\n    }\n\n    async fn perform_user_request(\u0026mut self, user_req: Vec\u003cUserRequest\u003e) {\n        for user_req in user_req {\n            let req = match user_req {\n                UserRequest::Block(block) =\u003e NodeRequest::GetBlock((vec![block], false)),\n                UserRequest::UtreexoBlock(block) =\u003e NodeRequest::GetBlock((vec![block], true)),\n                UserRequest::MempoolTransaction(txid) =\u003e NodeRequest::MempoolTransaction(txid),\n                UserRequest::GetPeerInfo =\u003e {\n                    self.handle_get_peer_info();\n                    continue;\n                }\n                UserRequest::Connect((addr, port)) =\u003e {\n                    let addr_v2 = match addr {\n                        IpAddr::V4(addr) =\u003e AddrV2::Ipv4(addr),\n                        IpAddr::V6(addr) =\u003e AddrV2::Ipv6(addr),\n                    };\n                    let id = rand::random::\u003cusize\u003e();\n                    let local_addr =\n                        LocalAddress::new(addr_v2, 0, AddressState::NeverTried, 0.into(), port, id);\n                    self.open_connection(false, 0, local_addr).await;\n                    self.1.user_requests.send_answer(\n                        UserRequest::Connect((addr, port)),\n                        Some(NodeResponse::Connect(true)),\n                    );\n                    continue;\n                }\n            };\n            let peer = self.send_to_random_peer(req, ServiceFlags::NONE).await;\n            if let Ok(peer) = peer {\n                self.inflight.insert(\n                    InflightRequests::UserRequest(user_req),\n                    (peer, Instant::now()),\n                );\n            }\n        }\n    }\n\n    async fn send_addresses(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        let addresses = self\n            .address_man\n            .get_addresses_to_send()\n            .into_iter()\n            .map(|(addr, time, services, port)| AddrV2Message {\n                services,\n                addr,\n                port,\n                time: time as u32,\n            })\n            .collect();\n\n        self.send_to_random_peer(NodeRequest::SendAddresses(addresses), ServiceFlags::NONE)\n            .await?;\n        Ok(())\n    }\n\n    async fn check_for_timeout(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        let mut timed_out = Vec::new();\n        for request in self.inflight.keys() {\n            let (_, time) = self.inflight.get(request).unwrap();\n            if time.elapsed() \u003e Duration::from_secs(RunningNode::REQUEST_TIMEOUT) {\n                timed_out.push(request.clone());\n                debug!(\"Request {:?} timed out\", request);\n            }\n        }\n\n        for request in timed_out {\n            let Some((peer, _)) = self.inflight.remove(\u0026request) else {\n                warn!(\n                    \"POSSIBLE BUG: Request {:?} timed out, but it wasn't in the inflight list\",\n                    request\n                );\n                continue;\n            };\n\n            // Punnishing this peer for taking too long to respond\n            self.increase_banscore(peer, 2).await?;\n\n            match request {\n                InflightRequests::UtreexoState(_) =\u003e {}\n                InflightRequests::Blocks(block) =\u003e {\n                    if !self.has_utreexo_peers() {\n                        continue;\n                    }\n                    let peer = self\n                        .send_to_random_peer(\n                            NodeRequest::GetBlock((vec![block], true)),\n                            ServiceFlags::UTREEXO,\n                        )\n                        .await?;\n                    self.inflight\n                        .insert(InflightRequests::Blocks(block), (peer, Instant::now()));\n                }\n                InflightRequests::RescanBlock(block) =\u003e {\n                    let peer = self\n                        .send_to_random_peer(\n                            NodeRequest::GetBlock((vec![block], false)),\n                            ServiceFlags::NONE,\n                        )\n                        .await?;\n                    self.inflight\n                        .insert(InflightRequests::RescanBlock(block), (peer, Instant::now()));\n                }\n                InflightRequests::Headers =\u003e {\n                    let peer = self\n                        .send_to_random_peer(NodeRequest::GetAddresses, ServiceFlags::NONE)\n                        .await?;\n                    self.last_headers_request = Instant::now();\n                    self.inflight\n                        .insert(InflightRequests::Headers, (peer, Instant::now()));\n                }\n                InflightRequests::UserRequest(req) =\u003e match req {\n                    UserRequest::Block(block) =\u003e {\n                        let peer = self\n                            .send_to_random_peer(\n                                NodeRequest::GetBlock((vec![block], true)),\n                                ServiceFlags::NONE,\n                            )\n                            .await?;\n                        self.inflight\n                            .insert(InflightRequests::UserRequest(req), (peer, Instant::now()));\n                    }\n                    UserRequest::MempoolTransaction(txid) =\u003e {\n                        let peer = self\n                            .send_to_random_peer(\n                                NodeRequest::MempoolTransaction(txid),\n                                ServiceFlags::NONE,\n                            )\n                            .await?;\n                        self.inflight\n                            .insert(InflightRequests::UserRequest(req), (peer, Instant::now()));\n                    }\n                    UserRequest::UtreexoBlock(block) =\u003e {\n                        let peer = self\n                            .send_to_random_peer(\n                                NodeRequest::GetBlock((vec![block], true)),\n                                ServiceFlags::NONE,\n                            )\n                            .await?;\n                        self.inflight\n                            .insert(InflightRequests::UserRequest(req), (peer, Instant::now()));\n                    }\n                    _ =\u003e {}\n                },\n                InflightRequests::Connect(peer) =\u003e {\n                    self.send_to_peer(peer, NodeRequest::Shutdown).await?\n                }\n                InflightRequests::GetFilters =\u003e {\n                    if let Some(ref block_filters) = self.block_filters {\n                        let last_success = block_filters.get_height() + 1;\n                        self.last_filter = self.chain.get_block_hash(last_success)?;\n                        self.download_filters().await?;\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    pub async fn catch_up(self, kill_signal: Arc\u003cRwLock\u003cbool\u003e\u003e) -\u003e Self {\n        let mut sync = UtreexoNode::\u003cSyncNode, Chain\u003e(self.0, SyncNode::default());\n        sync.run(kill_signal, |_| {}).await;\n\n        UtreexoNode(sync.0, self.1)\n    }\n\n    pub async fn run(\n        mut self,\n        kill_signal: Arc\u003cRwLock\u003cbool\u003e\u003e,\n        stop_signal: futures::channel::oneshot::Sender\u003c()\u003e,\n    ) {\n        try_and_log!(self.init_peers().await);\n        let startup_tip = self.chain.get_height().unwrap();\n\n        // Use this node state to Initial Block download\n        let mut ibd = UtreexoNode(self.0, ChainSelector::default());\n        try_and_log!(UtreexoNode::\u003cChainSelector, Chain\u003e::run(\u0026mut ibd, kill_signal.clone()).await);\n\n        if *kill_signal.read().await {\n            self = UtreexoNode(ibd.0, self.1);\n            self.shutdown().await;\n            return;\n        }\n\n        self = UtreexoNode(ibd.0, self.1);\n\n        // download all blocks from the network\n        if self.config.backfill \u0026\u0026 startup_tip == 0 {\n            let end = self.0.chain.get_validation_index().unwrap();\n            let chain = self\n                .chain\n                .get_partial_chain(startup_tip, end, Stump::default())\n                .unwrap();\n\n            let mut backfill = UtreexoNode::\u003cSyncNode, PartialChainState\u003e::new(\n                self.config.clone(),\n                chain,\n                self.mempool.clone(),\n                None,\n            );\n\n            UtreexoNode::\u003cSyncNode, PartialChainState\u003e::run(\n                \u0026mut backfill,\n                kill_signal.clone(),\n                |chain: \u0026PartialChainState| {\n                    if chain.has_invalid_blocks() {\n                        panic!(\n                            \"We assumed a chain with invalid blocks, something went really wrong\"\n                        );\n                    }\n\n                    for block in chain.list_valid_blocks() {\n                        self.chain\n                            .mark_block_as_valid(block.block_hash())\n                            .expect(\"Failed to mark block as valid\");\n                    }\n                },\n            )\n            .await;\n        }\n\n        self = self.catch_up(kill_signal.clone()).await;\n\n        self.last_block_request = self.chain.get_validation_index().unwrap_or(0);\n\n        info!(\"starting running node...\");\n        loop {\n            while let Ok(notification) =\n                timeout(Duration::from_millis(100), self.node_rx.recv()).await\n            {\n                try_and_log!(self.handle_notification(notification).await);\n            }\n\n            if *kill_signal.read().await {\n                self.shutdown().await;\n                break;\n            }\n\n            // Jobs that don't need a connected peer\n\n            // Save our peers db\n            periodic_job!(\n                self.save_peers(),\n                self.last_peer_db_dump,\n                PEER_DB_DUMP_INTERVAL,\n                RunningNode\n            );\n\n            // Rework our address database\n            periodic_job!(\n                self.address_man.rearrange_buckets(),\n                self.1.last_address_rearrange,\n                ADDRESS_REARRANGE_INTERVAL,\n                RunningNode,\n                true\n            );\n\n            // Perhaps we need more connections\n            periodic_job!(\n                self.maybe_open_connection().await,\n                self.last_connection,\n                TRY_NEW_CONNECTION,\n                RunningNode\n            );\n\n            // Requests using the node handle\n            try_and_log!(self.check_request_timeout());\n            self.handle_user_request().await;\n\n            // Check if some of our peers have timed out a request\n            try_and_log!(self.check_for_timeout().await);\n\n            // Those jobs bellow needs a connected peer to work\n            if self.peer_ids.is_empty() {\n                continue;\n            }\n            // Aks our peers for new addresses\n            periodic_job!(\n                self.ask_for_addresses().await,\n                self.last_get_address_request,\n                ASK_FOR_PEERS_INTERVAL,\n                RunningNode\n            );\n            // Open new feeler connection periodically\n            periodic_job!(\n                self.open_feeler_connection().await,\n                self.1.last_feeler,\n                FEELER_INTERVAL,\n                RunningNode\n            );\n            // Try broadcast transactions\n            periodic_job!(\n                self.handle_broadcast().await,\n                self.last_broadcast,\n                BROADCAST_DELAY,\n                RunningNode\n            );\n            // Send our addresses to our peers\n            periodic_job!(\n                self.send_addresses().await,\n                self.last_send_addresses,\n                SEND_ADDRESSES_INTERVAL,\n                RunningNode\n            );\n\n            try_and_log!(self.request_rescan_block().await);\n\n            // Check whether we are in a stale tip\n            periodic_job!(\n                self.check_for_stale_tip().await,\n                self.last_tip_update,\n                ASSUME_STALE,\n                RunningNode\n            );\n            try_and_log!(self.download_filters().await);\n            // requests that need a utreexo peer\n            if self.has_utreexo_peers() {\n                continue;\n            }\n\n            // Check if we haven't missed any block\n            if self.inflight.len() \u003c 10 {\n                try_and_log!(self.ask_missed_block().await);\n            }\n        }\n\n        stop_signal.send(()).unwrap();\n    }\n\n    async fn download_filters(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        if self.inflight.contains_key(\u0026InflightRequests::GetFilters) {\n            return Ok(());\n        }\n\n        if !self.has_compact_filters_peer() {\n            // open a feeler connection to find more peers with COMPACT_BLOCK_FILTERS flag\n            self.create_connection(true).await;\n            return Ok(());\n        }\n\n        let Some(ref filters) = self.block_filters else {\n            return Ok(());\n        };\n\n        info!(\"Downloading filters from height {}\", filters.get_height());\n        let height = filters.get_height();\n        let best_height = self.chain.get_height().unwrap();\n\n        let stop = if height + 1000 \u003e best_height {\n            best_height\n        } else {\n            height + 1000\n        };\n\n        let stop_hash = self.chain.get_block_hash(stop)?;\n        self.last_filter = stop_hash;\n\n        let peer = self\n            .send_to_random_peer(\n                NodeRequest::GetFilter((stop_hash, height + 1)),\n                ServiceFlags::COMPACT_FILTERS,\n            )\n            .await?;\n\n        self.inflight\n            .insert(InflightRequests::GetFilters, (peer, Instant::now()));\n        Ok(())\n    }\n\n    async fn ask_missed_block(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        let tip = self.chain.get_height().unwrap();\n        let next = self.chain.get_validation_index().unwrap();\n        if tip == next {\n            return Ok(());\n        }\n\n        let mut blocks = Vec::new();\n        for i in (next + 1)..=tip {\n            let hash = self.chain.get_block_hash(i)?;\n            // already requested\n            if self.inflight.contains_key(\u0026InflightRequests::Blocks(hash)) {\n                continue;\n            }\n\n            // already downloaded\n            if self.blocks.contains_key(\u0026hash) {\n                continue;\n            }\n\n            blocks.push(hash);\n        }\n\n        if blocks.is_empty() {\n            return Ok(());\n        }\n\n        self.request_blocks(blocks).await?;\n        Ok(())\n    }\n\n    async fn request_rescan_block(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        let tip = self.chain.get_height().unwrap();\n        if self.inflight.len() + 10 \u003e RunningNode::MAX_INFLIGHT_REQUESTS {\n            return Ok(());\n        }\n        // We use a grace period to avoid looping at the end of rescan\n        if let RescanStatus::Completed(time) = self.1.last_rescan_request {\n            if time.elapsed() \u003e Duration::from_secs(60) {\n                self.1.last_rescan_request = RescanStatus::None;\n            }\n        }\n        if self.1.last_rescan_request == RescanStatus::None\n            \u0026\u0026 self.chain.get_rescan_index().is_some()\n        {\n            self.1.last_rescan_request =\n                RescanStatus::InProgress(self.chain.get_rescan_index().unwrap());\n        }\n        if let RescanStatus::InProgress(height) = self.1.last_rescan_request {\n            for i in (height + 1)..=(height + 10) {\n                if i \u003e tip {\n                    self.1.last_rescan_request = RescanStatus::Completed(Instant::now());\n                    break;\n                }\n                self.1.last_rescan_request = RescanStatus::InProgress(i);\n                let hash = self.chain.get_block_hash(i)?;\n                let peer = self\n                    .send_to_random_peer(\n                        NodeRequest::GetBlock((vec![hash], false)),\n                        ServiceFlags::NONE,\n                    )\n                    .await?;\n                self.inflight\n                    .insert(InflightRequests::RescanBlock(hash), (peer, Instant::now()));\n            }\n        }\n\n        Ok(())\n    }\n\n    /// This function checks how many time has passed since our last tip update, if it's\n    /// been more than 15 minutes, try to update it.\n    async fn check_for_stale_tip(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        warn!(\"Potential stale tip detected, trying extra peers\");\n\n        // this catches an edge-case where all our utreexo peers are gone, and the GetData\n        // times-out. That yields an error, but doesn't ask the block again. Our last_block_request\n        // will be pointing to a block that will never arrive, so we basically deadlock.\n        self.last_block_request = self.chain.get_validation_index().unwrap();\n        // update this or we'll get this warning every second after 15 minutes without a block,\n        // until we get a new block.\n        self.last_tip_update = Instant::now();\n        self.create_connection(false).await;\n        self.send_to_random_peer(\n            NodeRequest::GetHeaders(self.chain.get_block_locator().unwrap()),\n            ServiceFlags::NONE,\n        )\n        .await?;\n        Ok(())\n    }\n\n    async fn handle_new_block(\u0026mut self) -\u003e Result\u003c(), WireError\u003e {\n        if self.inflight.contains_key(\u0026InflightRequests::Headers) {\n            return Ok(());\n        }\n\n        let locator = self.0.chain.get_block_locator().unwrap();\n\n        let peer = self\n            .send_to_random_peer(NodeRequest::GetHeaders(locator), ServiceFlags::NONE)\n            .await?;\n\n        self.inflight\n            .insert(InflightRequests::Headers, (peer, Instant::now()));\n\n        Ok(())\n    }\n\n    /// This function is called every time we get a Block message from a peer.\n    /// This block may be a rescan block, a user request or a new block that we\n    /// need to process.\n    async fn handle_block_data(\u0026mut self, block: UtreexoBlock, peer: u32) -\u003e Result\u003c(), WireError\u003e {\n        // Rescan block, a block that the wallet is interested in to check if it contains\n        // any transaction that we are interested in.\n        if self\n            .inflight\n            .remove(\u0026InflightRequests::RescanBlock(block.block.block_hash()))\n            .is_some()\n        {\n            self.request_rescan_block().await?;\n            return Ok(self.chain.process_rescan_block(\u0026block.block)?);\n        }\n        // If this block is a request made through the user interface, send it back to the\n        // user.\n        if self\n            .inflight\n            .remove(\u0026InflightRequests::UserRequest(UserRequest::Block(\n                block.block.block_hash(),\n            )))\n            .is_some()\n        {\n            if block.udata.is_some() {\n                self.1.user_requests.send_answer(\n                    UserRequest::UtreexoBlock(block.block.block_hash()),\n                    Some(NodeResponse::UtreexoBlock(block)),\n                );\n                return Ok(());\n            }\n            self.1.user_requests.send_answer(\n                UserRequest::Block(block.block.block_hash()),\n                Some(NodeResponse::Block(block.block)),\n            );\n            return Ok(());\n        }\n\n        // If none of the above, it means that this block is a new block that we need to\n        // process.\n\n        // Check if we actually requested this block. If a peer sends a block we didn't\n        // request, we should disconnect it.\n        if self\n            .inflight\n            .remove(\u0026InflightRequests::Blocks(block.block.block_hash()))\n            .is_none()\n        {\n            // We didn't request this block, so we should disconnect the peer.\n            if let Some(peer) = self.peers.get(\u0026peer).cloned() {\n                self.address_man.update_set_state(\n                    peer.address_id as usize,\n                    AddressState::Banned(RunningNode::BAN_TIME),\n                );\n            }\n            error!(\n                \"Peer {peer} sent us block {} which we didn't request\",\n                block.block.block_hash()\n            );\n            self.increase_banscore(peer, 5).await?;\n            return Ok(());\n        }\n\n        let validation_index = self.chain.get_validation_index()?;\n        let mut next_block = self.chain.get_block_hash(validation_index + 1)?;\n\n        debug!(\n            \"Block {} received, waiting for block {}\",\n            block.block.block_hash(),\n            next_block\n        );\n\n        self.blocks.insert(block.block.block_hash(), (peer, block));\n        while let Some((peer, block)) = self.blocks.remove(\u0026next_block) {\n            debug!(\"processing block {}\", block.block.block_hash(),);\n            let (proof, del_hashes, inputs) = floresta_chain::proof_util::process_proof(\n                \u0026block.udata.unwrap(),\n                \u0026block.block.txdata,\n                \u0026self.chain,\n            )?;\n\n            if let Err(e) = self\n                .chain\n                .connect_block(\u0026block.block, proof, inputs, del_hashes)\n            {\n                error!(\"Invalid block received by peer {} reason: {:?}\", peer, e);\n\n                if let BlockchainError::BlockValidation(e) = e {\n                    // Because the proof isn't committed to the block, we can't invalidate\n                    // it if the proof is invalid. Any other error should cause the block\n                    // to be invalidated.\n                    match e {\n                        BlockValidationErrors::InvalidTx(_)\n                        | BlockValidationErrors::NotEnoughPow\n                        | BlockValidationErrors::BadMerkleRoot\n                        | BlockValidationErrors::BadWitnessCommitment\n                        | BlockValidationErrors::NotEnoughMoney\n                        | BlockValidationErrors::FirstTxIsnNotCoinbase\n                        | BlockValidationErrors::BadCoinbaseOutValue\n                        | BlockValidationErrors::EmptyBlock\n                        | BlockValidationErrors::BlockExtendsAnOrphanChain\n                        | BlockValidationErrors::BadBip34\n                        | BlockValidationErrors::CoinbaseNotMatured =\u003e {\n                            self.send_to_peer(peer, NodeRequest::Shutdown).await?;\n                            try_and_log!(self.chain.invalidate_block(block.block.block_hash()));\n                        }\n                        BlockValidationErrors::InvalidProof =\u003e {}\n                    }\n                }\n\n                // Disconnect the peer and ban it.\n                if let Some(peer) = self.peers.get(\u0026peer).cloned() {\n                    self.address_man.update_set_state(\n                        peer.address_id as usize,\n                        AddressState::Banned(RunningNode::BAN_TIME),\n                    );\n                }\n                self.send_to_peer(peer, NodeRequest::Shutdown).await?;\n                return Err(WireError::PeerMisbehaving);\n            }\n\n            if !self.chain.is_in_idb() {\n                let mempool_delta = self.mempool.write().await.consume_block(\u0026block.block);\n                debug!(\n                    \"Block {} accepted, confirmed transactions: {:?}\",\n                    block.block.block_hash(),\n                    mempool_delta\n                );\n            }\n\n            let next = self.chain.get_validation_index()? + 1;\n\n            match self.chain.get_block_hash(next) {\n                Ok(_next_block) =\u003e next_block = _next_block,\n                Err(_) =\u003e break,\n            }\n            debug!(\"accepted block {}\", block.block.block_hash());\n        }\n\n        // Remove confirmed transactions from the mempool.\n        self.last_tip_update = Instant::now();\n\n        Ok(())\n    }\n\n    pub(crate) async fn handle_notification(\n        \u0026mut self,\n        notification: Result\u003cNodeNotification, async_std::channel::RecvError\u003e,\n    ) -\u003e Result\u003c(), WireError\u003e {\n        match notification? {\n            NodeNotification::FromPeer(peer, message) =\u003e match message {\n                PeerMessages::NewBlock(block) =\u003e {\n                    debug!(\"We got an inv with block {block} requesting it\");\n                    self.handle_new_block().await?;\n                }\n                PeerMessages::Block(block) =\u003e {\n                    debug!(\n                        \"Got data for block {} from peer {peer}\",\n                        block.block.block_hash()\n                    );\n                    self.handle_block_data(block, peer).await?;\n                }\n                PeerMessages::Headers(headers) =\u003e {\n                    debug!(\n                        \"Got headers from peer {peer} with {} headers\",\n                        headers.len()\n                    );\n                    self.inflight.remove(\u0026InflightRequests::Headers);\n                    for header in headers.iter() {\n                        self.chain.accept_header(*header)?;\n                    }\n\n                    if self.chain.is_in_idb() {\n                        let blocks = headers.iter().map(|header| header.block_hash()).collect();\n                        self.request_blocks(blocks).await?;\n                    }\n                }\n                PeerMessages::Ready(version) =\u003e {\n                    debug!(\"handshake with peer={peer} succeeded\");\n                    self.handle_peer_ready(peer, \u0026version).await?;\n                }\n                PeerMessages::Disconnected(idx) =\u003e {\n                    self.handle_disconnection(peer, idx)?;\n                }\n                PeerMessages::Addr(addresses) =\u003e {\n                    debug!(\"Got {} addresses from peer {}\", addresses.len(), peer);\n                    let addresses: Vec\u003c_\u003e =\n                        addresses.iter().cloned().map(|addr| addr.into()).collect();\n                    self.address_man.push_addresses(\u0026addresses);\n                }\n                PeerMessages::BlockFilter((hash, filter)) =\u003e {\n                    debug!(\"Got a block filter from peer {}\", peer);\n                    let height = self.chain.get_block_height(\u0026hash)?.unwrap_or(0);\n                    self.block_filters\n                        .as_ref()\n                        .map(|filters| filters.push_filter(height, filter));\n                    if hash == self.last_filter {\n                        self.download_filters().await?;\n                    }\n                }\n                PeerMessages::NotFound(inv) =\u003e match inv {\n                    Inventory::Error =\u003e {}\n                    Inventory::Block(block)\n                    | Inventory::WitnessBlock(block)\n                    | Inventory::UtreexoBlock(block)\n                    | Inventory::UtreexoWitnessBlock(block)\n                    | Inventory::CompactBlock(block) =\u003e {\n                        self.1\n                            .user_requests\n                            .send_answer(UserRequest::Block(block), None);\n                    }\n\n                    Inventory::WitnessTransaction(tx) | Inventory::Transaction(tx) =\u003e {\n                        self.1\n                            .user_requests\n                            .send_answer(UserRequest::MempoolTransaction(tx), None);\n                    }\n                    _ =\u003e {}\n                },\n                PeerMessages::Transaction(tx) =\u003e {\n                    debug!(\"saw a mempool transaction with txid={}\", tx.txid());\n                    self.1.user_requests.send_answer(\n                        UserRequest::MempoolTransaction(tx.txid()),\n                        Some(NodeResponse::MempoolTransaction(tx)),\n                    );\n                }\n                PeerMessages::UtreexoState(_) =\u003e {\n                    warn!(\n                        \"Utreexo state received from peer {}, but we didn't ask\",\n                        peer\n                    );\n                    self.increase_banscore(peer, 5).await?;\n                }\n            },\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":56,"address":[1526320],"length":1,"stats":{"Line":0},"fn_name":"get_required_services"},{"line":57,"address":[1526325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[6336608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":607,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":612,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":613,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":614,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":619,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":620,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":626,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":627,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":628,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":645,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":647,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":650,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":652,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":655,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":659,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":661,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":671,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":672,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":673,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":676,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":677,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":678,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":680,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":682,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":689,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":690,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":691,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":695,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":698,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":706,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":707,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":709,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":712,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":713,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":716,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":717,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":718,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":727,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":728,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":729,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":731,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":735,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":737,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":740,"address":[6334416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":744,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":745,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":746,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":747,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":748,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":751,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":753,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":755,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":757,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":758,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":762,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":763,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":764,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":767,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":768,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":769,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":772,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":773,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":774,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":776,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":777,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":779,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":780,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":781,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":782,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":783,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":785,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":786,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":787,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":788,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":790,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":791,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":792,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":796,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":797,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":798,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":800,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":802,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":803,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":804,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":807,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":808,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":809,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":810,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":812,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":814,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":815,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":818,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":821,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":822,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":824,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":826,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":830,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":459},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","socks.rs"],"content":"//! A wrapper around a TCP stream that handles the SOCKS5 handshake. This module only\n//! drives the handshake and returns the stream back to the caller. It does not\n//! perform any I/O on the stream after the handshake is complete. The caller is\n//! responsible for performing I/O on the stream.\n//! This module is built on top of the `futures` crate instead of an specific\n//! async runtime. This allows the caller to use this module with any async runtime\n//! they want.\n\nuse std::net::Ipv4Addr;\nuse std::net::Ipv6Addr;\nuse std::net::SocketAddr;\n\nuse futures::AsyncRead;\nuse futures::AsyncReadExt;\nuse futures::AsyncWrite;\nuse futures::AsyncWriteExt;\n\n#[derive(Clone, Debug)]\npub struct Socks5StreamBuilder {\n    pub address: SocketAddr,\n}\n/// The version of the SOCKS protocol we support, only SOCKS5 is supported.\nconst SOCKS_VERSION: u8 = 5;\n/// The SOCKS authentication method we support, only no authentication is supported.\nconst SOCKS_AUTH_METHOD_NONE: u8 = 0;\n/// The cmd value for a SOCKS5 connect request.\nconst SOCKS_CMD_CONNECT: u8 = 1;\n/// Magic value to indicate an IPv4 address.\nconst SOCKS_ADDR_TYPE_IPV4: u8 = 1;\n/// Magic value to indicate a domain address.\nconst SOCKS_ADDR_TYPE_DOMAIN: u8 = 3;\n/// Magic value to indicate an IPv6 address.\nconst SOCKS_ADDR_TYPE_IPV6: u8 = 4;\n\n#[derive(Debug)]\n#[allow(dead_code)]\npub enum Socks5Addr {\n    Ipv4(Ipv4Addr),\n    Ipv6(Ipv6Addr),\n    Domain(Box\u003c[u8]\u003e),\n}\nimpl From\u003cSocks5Addr\u003e for u8 {\n    fn from(val: Socks5Addr) -\u003e Self {\n        match val {\n            Socks5Addr::Ipv4(_) =\u003e SOCKS_ADDR_TYPE_IPV4,\n            Socks5Addr::Ipv6(_) =\u003e SOCKS_ADDR_TYPE_IPV6,\n            Socks5Addr::Domain(_) =\u003e SOCKS_ADDR_TYPE_DOMAIN,\n        }\n    }\n}\nimpl Socks5StreamBuilder {\n    pub fn new(address: SocketAddr) -\u003e Self {\n        Self { address }\n    }\n    pub async fn connect\u003cStream: AsyncRead + AsyncWrite + Clone + Unpin\u003e(\n        mut socket: Stream,\n        address: Socks5Addr,\n        port: u16,\n    ) -\u003e Result\u003cStream, Socks5Error\u003e {\n        socket\n            .write_all(\u0026[SOCKS_VERSION, 1, SOCKS_AUTH_METHOD_NONE])\n            .await\n            .unwrap();\n        let address = match address {\n            Socks5Addr::Ipv4(addr) =\u003e addr.octets().to_vec(),\n            Socks5Addr::Ipv6(addr) =\u003e addr.octets().to_vec(),\n            Socks5Addr::Domain(domain) =\u003e {\n                let mut buf = vec![domain.len() as u8];\n                buf.extend_from_slice(\u0026domain);\n                buf\n            }\n        };\n        let mut buf = [0_u8; 2];\n        socket.read_exact(\u0026mut buf).await?;\n\n        if buf[0] != SOCKS_VERSION {\n            return Err(Socks5Error::InvalidVersion);\n        }\n\n        if buf[1] != SOCKS_AUTH_METHOD_NONE {\n            return Err(Socks5Error::InvalidAuthMethod);\n        }\n\n        socket\n            .write_all(\u0026[SOCKS_VERSION, SOCKS_CMD_CONNECT, 0, SOCKS_ADDR_TYPE_IPV4])\n            .await?;\n        socket.write_all(\u0026address).await?;\n        socket.write_all(\u0026port.to_be_bytes()).await?;\n\n        let mut buf = [0_u8; 4];\n        socket.read_exact(\u0026mut buf).await?;\n\n        if buf[0] != SOCKS_VERSION {\n            return Err(Socks5Error::InvalidVersion);\n        }\n        if buf[1] != 0 {\n            return Err(Socks5Error::ConnectionFailed);\n        }\n\n        match buf[3] {\n            SOCKS_ADDR_TYPE_IPV4 =\u003e {\n                let mut buf = [0_u8; 6];\n                socket.read_exact(\u0026mut buf).await?;\n            }\n            SOCKS_ADDR_TYPE_IPV6 =\u003e {\n                let mut buf = [0_u8; 18];\n                socket.read_exact(\u0026mut buf).await?;\n            }\n            SOCKS_ADDR_TYPE_DOMAIN =\u003e {\n                let mut buf = [0_u8; 1];\n                socket.read_exact(\u0026mut buf).await?;\n                let mut buf = vec![0_u8; buf[0] as usize + 2];\n                socket.read_exact(\u0026mut buf).await?;\n            }\n            _ =\u003e return Err(Socks5Error::ConnectionFailed),\n        }\n        Ok(socket)\n    }\n}\n#[derive(Debug)]\npub enum Socks5Error {\n    InvalidVersion,\n    InvalidAuthMethod,\n    ConnectionFailed,\n    InvalidAddress,\n    ReadError,\n}\n\nimpl From\u003cfutures::io::Error\u003e for Socks5Error {\n    fn from(_error: futures::io::Error) -\u003e Self {\n        Socks5Error::ReadError\n    }\n}\n","traces":[{"line":43,"address":[1635024],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":44,"address":[1635032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[1635064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[1635071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[1635078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[1635104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[3704352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[1635152],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":131,"address":[1635161],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":50},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","stream_reader.rs"],"content":"//! A simple async reader that reads data from a [Source] and builds a [Item] from it, assuming\n//! item is [Decodable]. The main intent of this module is to read [RawNetworkMessages] from [TcpStream], because\n//! we don't know how many bytes to read upfront, so we might read an incomplete message and try\n//! to deserialize it, causing unrelated error. This module first reads the message reader\n//! that has constant size (for RawNetworkMessage is 24). Then we look for payload size inside\n//! this header. With payload size we can finally read the entire message and return a parsed\n//! structure.\n\nuse std::marker::PhantomData;\n\nuse async_std::channel::Sender;\nuse async_std::io::ReadExt;\nuse bitcoin::consensus::deserialize;\nuse bitcoin::consensus::deserialize_partial;\nuse bitcoin::consensus::Decodable;\nuse bitcoin::p2p::Magic;\nuse futures::AsyncRead;\n\nuse super::peer::PeerError;\n\n/// A simple type that wraps a stream and returns T, if T is [Decodable].\npub struct StreamReader\u003cSource: Sync + Send + ReadExt + Unpin + AsyncRead, Item: Decodable + Send\u003e {\n    /// Were we read bytes from, usually a TcpStream\n    source: Source,\n    /// Item is what we return, since we don't actually hold any concrete type, just use a\n    /// phantom data to bind a type.\n    phantom: PhantomData\u003cItem\u003e,\n    /// Magic bits, we expect this at the beginning of all messages\n    magic: Magic,\n    /// Where should we send data\n    sender: Sender\u003cResult\u003cItem, PeerError\u003e\u003e,\n}\nimpl\u003cSource, Item\u003e StreamReader\u003cSource, Item\u003e\nwhere\n    Item: Decodable + Unpin + Send + 'static,\n    Source: Sync + Send + ReadExt + Unpin + AsyncRead,\n{\n    /// Creates a new reader from a given stream\n    pub fn new(stream: Source, magic: Magic, sender: Sender\u003cResult\u003cItem, PeerError\u003e\u003e) -\u003e Self {\n        StreamReader {\n            source: stream,\n            phantom: PhantomData,\n            magic,\n            sender,\n        }\n    }\n    async fn read_loop_inner(\u0026mut self) -\u003e Result\u003c(), PeerError\u003e {\n        loop {\n            let mut data: Vec\u003cu8\u003e = vec![0; 24];\n\n            // Read the reader first, so learn the payload size\n            self.source.read_exact(\u0026mut data).await?;\n            let header: P2PMessageHeader = deserialize_partial(\u0026data)?.0;\n            if header.magic != self.magic {\n                return Err(PeerError::MagicBitsMismatch);\n            }\n            // Network Message too big\n            if header.length \u003e (1024 * 1024 * 32) as u32 {\n                return Err(PeerError::MessageTooBig);\n            }\n\n            data.resize(24 + header.length as usize, 0);\n            // Read everything else\n            self.source.read_exact(\u0026mut data[24..]).await?;\n            let message = deserialize(\u0026data)?;\n            let _ = self.sender.send(Ok(message)).await;\n        }\n    }\n    /// Tries to read from a parsed [Item] from [Source]. Only returns on error or if we have\n    /// a valid Item to return\n    pub async fn read_loop(mut self) {\n        let value = self.read_loop_inner().await;\n        if let Err(e) = value {\n            let _ = self.sender.send(Err(e)).await;\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct P2PMessageHeader {\n    magic: Magic,\n    _command: [u8; 12],\n    length: u32,\n    _checksum: u32,\n}\nimpl Decodable for P2PMessageHeader {\n    fn consensus_decode\u003cR: std::io::Read + ?Sized\u003e(\n        reader: \u0026mut R,\n    ) -\u003e Result\u003cSelf, bitcoin::consensus::encode::Error\u003e {\n        let magic = Magic::consensus_decode(reader)?;\n        let _command = \u003c[u8; 12]\u003e::consensus_decode(reader)?;\n        let length = u32::consensus_decode(reader)?;\n        let _checksum = u32::consensus_decode(reader)?;\n        Ok(Self {\n            _checksum,\n            _command,\n            length,\n            magic,\n        })\n    }\n}\n","traces":[{"line":39,"address":[5056544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[5053520,5054358,5053528,5053810,5053599,5053552,5053698,5053653,5056511],"length":1,"stats":{"Line":0},"fn_name":"{async_fn#0}\u003casync_std::io::buf_reader::BufReader\u003casync_std::net::tcp::stream::TcpStream\u003e, bitcoin::p2p::message::RawNetworkMessage\u003e"},{"line":48,"address":[5053696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[5053777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[5053870,5054534,5056438,5054853,5054407,5053722,5053643],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[5054922,5056436,5055067,5054814],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[5055139,5055027],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[5055187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[5055255,5055145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[3828849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[5056624,5057589,5056758,5056688,5056713,5056909,5056842,5056641,5057866,5057035,5057898],"length":1,"stats":{"Line":0},"fn_name":"{async_fn#0}\u003casync_std::io::buf_reader::BufReader\u003casync_std::net::tcp::stream::TcpStream\u003e, bitcoin::p2p::message::RawNetworkMessage\u003e"},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[3826123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[5052752],"length":1,"stats":{"Line":0},"fn_name":"consensus_decode\u003cstd::io::cursor::Cursor\u003c\u0026[u8]\u003e\u003e"},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":28},{"path":["/","home","dane","Desktop","SOB","Floresta","crates","floresta-wire","src","p2p_wire","sync_node.rs"],"content":"//! A node that downlaods and validates the blockchain.\n\nuse std::sync::Arc;\nuse std::time::Duration;\nuse std::time::Instant;\n\nuse async_std::future::timeout;\nuse async_std::sync::RwLock;\nuse bitcoin::p2p::utreexo::UtreexoBlock;\nuse bitcoin::p2p::ServiceFlags;\nuse floresta_chain::pruned_utreexo::BlockchainInterface;\nuse floresta_chain::pruned_utreexo::UpdatableChainstate;\nuse floresta_chain::BlockValidationErrors;\nuse floresta_chain::BlockchainError;\nuse log::debug;\nuse log::error;\nuse log::info;\n\nuse super::error::WireError;\nuse super::peer::PeerMessages;\nuse crate::address_man::AddressState;\nuse crate::node::periodic_job;\nuse crate::node::try_and_log;\nuse crate::node::InflightRequests;\nuse crate::node::NodeNotification;\nuse crate::node::NodeRequest;\nuse crate::node::UtreexoNode;\nuse crate::node_context::NodeContext;\nuse crate::node_context::PeerId;\n\n#[derive(Clone, Debug, Default)]\npub struct SyncNode {\n    last_block_requested: u32,\n}\n\nimpl NodeContext for SyncNode {\n    fn get_required_services(\u0026self) -\u003e bitcoin::p2p::ServiceFlags {\n        ServiceFlags::WITNESS | ServiceFlags::UTREEXO | ServiceFlags::NETWORK\n    }\n\n    const MAX_OUTGOING_PEERS: usize = 5; // don't need many peers, half the default\n    const TRY_NEW_CONNECTION: u64 = 10; // ten seconds\n    const REQUEST_TIMEOUT: u64 = 30; // 30 seconds\n    const MAX_INFLIGHT_REQUESTS: usize = 100; // double the default\n}\n\nimpl\u003cChain\u003e UtreexoNode\u003cSyncNode, Chain\u003e\nwhere\n    WireError: From\u003c\u003cChain as BlockchainInterface\u003e::Error\u003e,\n    Chain: BlockchainInterface + UpdatableChainstate + 'static,\n{\n    pub async fn run(\u0026mut self, kill_signal: Arc\u003cRwLock\u003cbool\u003e\u003e, done_cb: impl FnOnce(\u0026Chain)) {\n        info!(\"Starting sync node\");\n        self.1.last_block_requested = self.chain.get_validation_index().unwrap();\n        loop {\n            while let Ok(Ok(msg)) = timeout(Duration::from_secs(1), self.node_rx.recv()).await {\n                self.handle_message(msg).await;\n            }\n\n            if *kill_signal.read().await {\n                break;\n            }\n\n            if !self.chain.is_in_idb() {\n                break;\n            }\n\n            periodic_job!(\n                self.maybe_open_connection().await,\n                self.last_connection,\n                TRY_NEW_CONNECTION,\n                SyncNode\n            );\n\n            self.handle_timeout().await;\n\n            if self.has_utreexo_peers() {\n                continue;\n            }\n\n            if self.inflight.len() \u003c SyncNode::MAX_INFLIGHT_REQUESTS {\n                let mut blocks = Vec::with_capacity(100);\n                for _ in 0..100 {\n                    let next_block = self.1.last_block_requested + 1;\n                    let next_block = self.chain.get_block_hash(next_block);\n                    match next_block {\n                        Ok(next_block) =\u003e {\n                            blocks.push(next_block);\n                            self.1.last_block_requested += 1;\n                        }\n                        Err(_) =\u003e {\n                            break;\n                        }\n                    }\n                }\n                try_and_log!(self.request_blocks(blocks).await);\n            }\n        }\n\n        done_cb(\u0026self.chain);\n    }\n\n    async fn handle_timeout(\u0026mut self) {\n        let mut to_remove = Vec::new();\n        for (block, (peer, when)) in self.inflight.iter() {\n            if when.elapsed().as_secs() \u003e SyncNode::REQUEST_TIMEOUT {\n                to_remove.push((*peer, block.clone()));\n            }\n        }\n\n        for (peer, block) in to_remove {\n            self.inflight.remove(\u0026block);\n            try_and_log!(self.increase_banscore(peer, 1).await);\n\n            let InflightRequests::Blocks(block) = block else {\n                continue;\n            };\n            try_and_log!(self.request_blocks(vec![block]).await);\n        }\n    }\n\n    async fn handle_block_data(\n        \u0026mut self,\n        peer: PeerId,\n        block: UtreexoBlock,\n    ) -\u003e Result\u003c(), WireError\u003e {\n        self.inflight\n            .remove(\u0026InflightRequests::Blocks(block.block.block_hash()));\n\n        self.blocks.insert(block.block.block_hash(), (peer, block));\n\n        let next_block = self.chain.get_validation_index()? + 1;\n        let mut next_block = self.chain.get_block_hash(next_block)?;\n\n        while let Some((peer, block)) = self.blocks.remove(\u0026next_block) {\n            if block.udata.is_none() {\n                error!(\"Block without proof received from peer {}\", peer);\n                self.send_to_peer(peer, NodeRequest::Shutdown).await?;\n                self.send_to_random_peer(\n                    NodeRequest::GetBlock((vec![block.block.block_hash()], true)),\n                    ServiceFlags::UTREEXO,\n                )\n                .await?;\n                self.inflight\n                    .insert(InflightRequests::Blocks(next_block), (peer, Instant::now()));\n                return Err(WireError::PeerMisbehaving);\n            }\n\n            debug!(\"processing block {}\", block.block.block_hash(),);\n            let (proof, del_hashes, inputs) = floresta_chain::proof_util::process_proof(\n                \u0026block.udata.unwrap(),\n                \u0026block.block.txdata,\n                \u0026self.chain,\n            )?;\n\n            if let Err(e) = self\n                .chain\n                .connect_block(\u0026block.block, proof, inputs, del_hashes)\n            {\n                error!(\"Invalid block received by peer {} reason: {:?}\", peer, e);\n\n                if let BlockchainError::BlockValidation(e) = e {\n                    // Because the proof isn't committed to the block, we can't invalidate\n                    // it if the proof is invalid. Any other error should cause the block\n                    // to be invalidated.\n                    match e {\n                        BlockValidationErrors::InvalidTx(_)\n                        | BlockValidationErrors::NotEnoughPow\n                        | BlockValidationErrors::BadMerkleRoot\n                        | BlockValidationErrors::BadWitnessCommitment\n                        | BlockValidationErrors::NotEnoughMoney\n                        | BlockValidationErrors::FirstTxIsnNotCoinbase\n                        | BlockValidationErrors::BadCoinbaseOutValue\n                        | BlockValidationErrors::EmptyBlock\n                        | BlockValidationErrors::BlockExtendsAnOrphanChain\n                        | BlockValidationErrors::BadBip34\n                        | BlockValidationErrors::CoinbaseNotMatured =\u003e {\n                            self.send_to_peer(peer, NodeRequest::Shutdown).await?;\n                            try_and_log!(self.chain.invalidate_block(block.block.block_hash()));\n                        }\n                        BlockValidationErrors::InvalidProof =\u003e {}\n                    }\n                }\n\n                // Disconnect the peer and ban it.\n                if let Some(peer) = self.peers.get(\u0026peer).cloned() {\n                    self.address_man.update_set_state(\n                        peer.address_id as usize,\n                        AddressState::Banned(SyncNode::BAN_TIME),\n                    );\n                }\n                self.send_to_peer(peer, NodeRequest::Shutdown).await?;\n                return Err(WireError::PeerMisbehaving);\n            }\n\n            let next = self.chain.get_validation_index()? + 1;\n\n            match self.chain.get_block_hash(next) {\n                Ok(_next_block) =\u003e next_block = _next_block,\n                Err(_) =\u003e break,\n            }\n            debug!(\"accepted block {}\", block.block.block_hash());\n        }\n\n        Ok(())\n    }\n\n    async fn handle_message(\u0026mut self, msg: NodeNotification) {\n        match msg {\n            NodeNotification::FromPeer(peer, notification) =\u003e match notification {\n                PeerMessages::Block(block) =\u003e {\n                    if let Err(e) = self.handle_block_data(peer, block).await {\n                        error!(\"Error processing block: {:?}\", e);\n                    }\n                }\n                PeerMessages::Ready(version) =\u003e {\n                    try_and_log!(self.handle_peer_ready(peer, \u0026version).await);\n                }\n                PeerMessages::Disconnected(idx) =\u003e {\n                    try_and_log!(self.handle_disconnection(peer, idx));\n                }\n                _ =\u003e {}\n            },\n        }\n    }\n}\n","traces":[{"line":37,"address":[1744768],"length":1,"stats":{"Line":0},"fn_name":"get_required_services"},{"line":38,"address":[1744773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[6450736,6450832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":108},{"path":["/","home","dane","Desktop","SOB","Floresta","florestad","src","cli.rs"],"content":"use clap::arg;\nuse clap::command;\nuse clap::Parser;\nuse clap::Subcommand;\nuse clap::ValueEnum;\n\n#[derive(Clone, Debug, ValueEnum, Default)]\npub enum Network {\n    #[default]\n    Bitcoin,\n    Signet,\n    Testnet,\n    Regtest,\n}\n\nimpl std::fmt::Display for Network {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Network::Bitcoin =\u003e write!(f, \"bitcoin\"),\n            Network::Signet =\u003e write!(f, \"signet\"),\n            Network::Testnet =\u003e write!(f, \"testnet\"),\n            Network::Regtest =\u003e write!(f, \"regtest\"),\n        }\n    }\n}\n#[derive(Parser)]\n#[command(author, version, about, long_about = None)]\npub struct Cli {\n    /// Sets a custom config file\n    #[arg(short, long, value_name = \"FILE\")]\n    pub config_file: Option\u003cString\u003e,\n    /// Which network should we use\n    #[arg(short, long, default_value_t=Network::Bitcoin)]\n    pub network: Network,\n    /// Turn debugging information on\n    #[arg(short, long, action = clap::ArgAction::Count)]\n    pub debug: u8,\n\n    /// option for saving log into data_Dir\n    /// if set, log will be saved into dataDir/output.log\n    #[arg(long)]\n    pub log_file: bool,\n\n    #[command(subcommand)]\n    pub command: Option\u003cCommands\u003e,\n}\n\n#[derive(Subcommand)]\npub enum Commands {\n    #[cfg(not(feature = \"experimental-p2p\"))]\n    /// Starts your wallet and server\n    Run {\n        /// Where should we store data\n        #[arg(long)]\n        data_dir: Option\u003cString\u003e,\n        /// Add a xpub to our wallet\n        #[arg(long)]\n        wallet_xpub: Option\u003cVec\u003cString\u003e\u003e,\n        /// Add individual addresses to your wallet\n        #[arg(long)]\n        wallet_addresses: Option\u003cVec\u003cString\u003e\u003e,\n        /// Your rpc user, as set in Utreexod\n        #[arg(long)]\n        rpc_user: Option\u003cString\u003e,\n        /// Your rpc password, as set in Utreexod\n        #[arg(long)]\n        rpc_password: Option\u003cString\u003e,\n        /// The hostname:port of Utreexod\n        #[arg(short, long)]\n        rpc_host: Option\u003cString\u003e,\n        #[arg(long)]\n        rpc_port: Option\u003cu32\u003e,\n        /// Whether or not we want to sync with a external provider\n        #[arg(long, default_value_t = false)]\n        use_batch_sync: bool,\n        /// If use_batch_sync is set, this option provides which server we use\n        #[arg(long)]\n        batch_sync: Option\u003cString\u003e,\n        /// Assume blocks before this one as having valid signatures, same with bitcoin core\n        #[arg(long)]\n        assume_valid: Option\u003cString\u003e,\n    },\n    #[cfg(feature = \"experimental-p2p\")]\n    /// Starts your wallet and server\n    #[command(author, version, about, long_about = None)]\n    Run {\n        /// Where should we store data\n        #[arg(long)]\n        data_dir: Option\u003cString\u003e,\n        /// Whether to build Compact Block Filters\n        ///\n        /// Those filters let you query for chain data after IBD, like wallet rescan,\n        /// finding an utxo, finding specific tx_ids.\n        /// Will cause more disk usage\n        #[arg(long = \"cfilters\", short = 'c', default_value_t = true)]\n        cfilters: bool,\n        #[arg(long, short, default_value = None)]\n        /// The url of a proxy we should open p2p connections through (e.g. 127.0.0.1:9050)\n        proxy: Option\u003cString\u003e,\n        #[arg(long, short, default_value = None)]\n        rescan: Option\u003cu32\u003e,\n        /// Add a xpub to our wallet\n        #[arg(long)]\n        wallet_xpub: Option\u003cVec\u003cString\u003e\u003e,\n        #[arg(long)]\n        wallet_descriptor: Option\u003cVec\u003cString\u003e\u003e,\n        /// Assume blocks before this one as having valid signatures, same with bitcoin core\n        #[arg(long)]\n        assume_valid: Option\u003cString\u003e,\n        #[arg(long, short)]\n        zmq_address: Option\u003cString\u003e,\n        #[arg(long)]\n        connect: Option\u003cString\u003e,\n        #[arg(long)]\n        rpc_address: Option\u003cString\u003e,\n        #[arg(long)]\n        electrum_address: Option\u003cString\u003e,\n    },\n}\n","traces":[{"line":17,"address":[3077648],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":18,"address":[3077675],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[3077706],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[3077754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[3077799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[3077844],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","home","dane","Desktop","SOB","Floresta","florestad","src","config_file.rs"],"content":"use serde::Deserialize;\n\n#[derive(Default, Debug, Deserialize)]\npub struct Wallet {\n    pub xpubs: Option\u003cVec\u003cString\u003e\u003e,\n    pub descriptors: Option\u003cVec\u003cString\u003e\u003e,\n    pub addresses: Option\u003cVec\u003cString\u003e\u003e,\n}\n\n#[derive(Default, Debug, Deserialize)]\npub struct ConfigFile {\n    pub wallet: Wallet,\n}\n\nimpl ConfigFile {\n    pub fn from_file(filename: \u0026str) -\u003e Result\u003cSelf, crate::error::Error\u003e {\n        let file = std::fs::read_to_string(filename)?;\n        Ok(toml::from_str(\u0026file)?)\n    }\n}\n","traces":[{"line":16,"address":[3663600,3664064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[3663758,3663633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[3663737,3663970,3663846],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["/","home","dane","Desktop","SOB","Floresta","florestad","src","error.rs"],"content":"use bitcoin::consensus::encode;\n#[cfg(feature = \"cli-blockchain\")]\nuse btcd_rpc::error::UtreexodError;\nuse floresta_chain::BlockValidationErrors;\nuse floresta_chain::BlockchainError;\n\nuse crate::slip132;\n#[derive(Debug)]\npub enum Error {\n    #[cfg(feature = \"cli-blockchain\")]\n    UtreexodError(UtreexodError),\n    Encode(encode::Error),\n    Db(kv::Error),\n    ParseNum(std::num::ParseIntError),\n    Rustreexo(String),\n    Io(std::io::Error),\n    BlockValidation(BlockValidationErrors),\n    ScriptValidation(bitcoin::blockdata::script::Error),\n    Blockchain(BlockchainError),\n    SerdeJson(serde_json::Error),\n    TomlParsing(toml::de::Error),\n    WalletInput(slip132::Error),\n    AddressParsing(bitcoin::address::ParseError),\n    Address(bitcoin::address::Error),\n    Miniscript(miniscript::Error),\n}\n\nimpl std::fmt::Display for Error {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Error::Encode(err) =\u003e write!(f, \"Encode error: {err}\"),\n            #[cfg(feature = \"cli-blockchain\")]\n            Error::UtreexodError(_) =\u003e write!(f, \"UtreexodError\"),\n            Error::Db(err) =\u003e write!(f, \"Database error {err}\"),\n            Error::ParseNum(err) =\u003e write!(f, \"int parse error: {err}\"),\n            Error::Rustreexo(err) =\u003e write!(f, \"Rustreexo error: {err}\"),\n            Error::Io(err) =\u003e write!(f, \"Io error {err}\"),\n            Error::ScriptValidation(err) =\u003e write!(f, \"Error during script evaluation: {err}\"),\n            Error::Blockchain(err) =\u003e write!(f, \"Error with our blockchain backend: {:?}\", err),\n            Error::SerdeJson(err) =\u003e write!(f, \"Error serializing object {err}\"),\n            Error::WalletInput(err) =\u003e write!(f, \"Error while parsing user input {:?}\", err),\n            Error::TomlParsing(err) =\u003e write!(f, \"Error deserializing toml file {err}\"),\n            Error::AddressParsing(err) =\u003e write!(f, \"Invalid address {err}\"),\n            Error::Miniscript(err) =\u003e write!(f, \"Miniscript error: {err}\"),\n            Error::BlockValidation(err) =\u003e write!(f, \"Error while validating block: {err:?}\"),\n            Error::Address(err) =\u003e write!(f, \"Error while validating address: {err}\"),\n        }\n    }\n}\n/// Implements `From\u003cT\u003e` where `T` is a possible error outcome in this crate, this macro only\n/// takes [T] and builds [Error] with the right variant.\nmacro_rules! impl_from_error {\n    ($field:ident, $error:ty) =\u003e {\n        impl From\u003c$error\u003e for Error {\n            fn from(err: $error) -\u003e Self {\n                Error::$field(err)\n            }\n        }\n    };\n}\n// impl_from_error!(Parsing, bitcoin::hashes::hex::Error);\n#[cfg(feature = \"cli-blockchain\")]\nimpl_from_error!(UtreexodError, UtreexodError);\nimpl_from_error!(Encode, encode::Error);\nimpl_from_error!(Db, kv::Error);\nimpl_from_error!(ParseNum, std::num::ParseIntError);\nimpl_from_error!(Rustreexo, String);\nimpl_from_error!(Io, std::io::Error);\nimpl_from_error!(ScriptValidation, bitcoin::blockdata::script::Error);\nimpl_from_error!(Blockchain, BlockchainError);\nimpl_from_error!(SerdeJson, serde_json::Error);\nimpl_from_error!(WalletInput, slip132::Error);\nimpl_from_error!(TomlParsing, toml::de::Error);\nimpl_from_error!(BlockValidation, BlockValidationErrors);\nimpl_from_error!(AddressParsing, bitcoin::address::ParseError);\nimpl_from_error!(Miniscript, miniscript::Error);\nimpl_from_error!(Address, bitcoin::address::Error);\n\nimpl std::error::Error for Error {}\n","traces":[{"line":29,"address":[3018000],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":30,"address":[5348945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[3018084,3018153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[3018291,3018226],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[5349285,5349359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[3346722,3346647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[3346885,3346810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[3347211,3347136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[3347299,3347374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[5350337,5350262],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[3019751,3019676],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[5350500,5350425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[3019914,3019839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[3348277,3348352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[3346973,3347048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[3348114,3348189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[3349392,3349456,3349488,3349808,3349680,3349776,3349600,3349872,3349424,3349664,3349712,3349536,3349728,3349520],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":56,"address":[3349491,3349825,3349395,3349672,3349889,3349731,3349553,3349617,3349432,3349683,3349466,3349779,3349720,3349528],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":18},{"path":["/","home","dane","Desktop","SOB","Floresta","florestad","src","florestad.rs"],"content":"use std::fmt::Arguments;\nuse std::path::PathBuf;\nuse std::process::exit;\nuse std::str::FromStr;\nuse std::sync::Arc;\nuse std::sync::Mutex;\nuse std::sync::OnceLock;\n\nuse async_std::sync::RwLock;\nuse async_std::task;\nuse async_std::task::block_on;\npub use bitcoin::Network;\nuse fern::colors::Color;\nuse fern::colors::ColoredLevelConfig;\nuse fern::FormatCallback;\nuse floresta_chain::pruned_utreexo::BlockchainInterface;\nuse floresta_chain::AssumeValidArg;\nuse floresta_chain::BlockchainError;\nuse floresta_chain::ChainState;\nuse floresta_chain::KvChainStore;\nuse floresta_common::constants::DIR_NAME;\nuse floresta_compact_filters::kv_filter_database::KvFilterStore;\nuse floresta_compact_filters::network_filters::NetworkFilters;\nuse floresta_electrum::electrum_protocol::client_accept_loop;\nuse floresta_electrum::electrum_protocol::ElectrumServer;\nuse floresta_watch_only::kv_database::KvDatabase;\nuse floresta_watch_only::AddressCache;\nuse floresta_watch_only::AddressCacheDatabase;\nuse floresta_wire::address_man::LocalAddress;\nuse floresta_wire::mempool::Mempool;\nuse floresta_wire::node::UtreexoNode;\nuse floresta_wire::UtreexoNodeConfig;\nuse futures::channel::oneshot;\nuse log::debug;\nuse log::error;\nuse log::info;\nuse log::Record;\n#[cfg(feature = \"zmq-server\")]\nuse zmq::ZMQServer;\n\nuse crate::cli;\nuse crate::config_file::ConfigFile;\nuse crate::json_rpc;\nuse crate::wallet_input::InitialWalletSetup;\n\n#[derive(Default, Clone)]\n/// General configuration for the floresta daemon.\n///\n/// Those configs should be passed in by anyone that wants to start a floresta instance. Some of\n/// these are also exposed through the config file.\npub struct Config {\n    /// Where we should place our data\n    ///\n    /// This directory must be readable and writable by our proccess. We'll use this dir to store\n    /// both chain and wallet data, so this should be kept in a non-volatile medium. We are not\n    /// particurly aggressive in disk usage, so we don't need a fast disk to work.\n    ///\n    /// If not set, it defaults to $HOME/.floresta\n    pub data_dir: Option\u003cString\u003e,\n    /// We consider blocks prior to this one to have a valid signature\n    ///\n    /// This is a optimization mirrowed from Core, where blocks before this one are considered to\n    /// have valid signatures. The idea here is that if a block is burried under a lot of PoW, it's\n    /// very unlikely that it is invalid. We still validate everything else and build the\n    /// accumulator until this point (unless running on PoW-fraud proof or assumeutreexo mode) so\n    /// there's still some work to do.\n    pub assume_valid: Option\u003cString\u003e,\n    /// A vector of xpubs to cache\n    ///\n    /// This is a list of SLIP-132-encoded extended public key that we should add to our Watch-only\n    /// wallet. A descriptor may be only passed one time, if you call florestad with an already\n    /// cached address, that will be a no-op. After a xpub is cached, we derive multiple addresses\n    /// from it and try to find transactions involving it.\n    pub wallet_xpub: Option\u003cVec\u003cString\u003e\u003e,\n    /// A output descriptor to cache\n    ///\n    /// This should be a list of ouptut descriptors that we should add to our watch-only wallet.\n    /// This works just like wallet_xpub, but with a descriptor.\n    pub wallet_descriptor: Option\u003cVec\u003cString\u003e\u003e,\n    /// Whether we should rescan for wallet transactions\n    ///\n    /// If your wallet is missing some transaction (e.g. you've just added a new address), you can\n    /// set this value to some height, and we'll rescan from this block to the tip.\n    pub rescan: Option\u003cu32\u003e,\n    /// Where should we read from a config file\n    ///\n    /// This is a toml-encoded file with floresta's configs. For a sample of how this file looks\n    /// like, see config.toml.sample inside floresta's codebase.\n    ///\n    /// If a setting is modified by the config file and this config struct, the following logic is\n    /// used:\n    ///     - For vectors, we use the combination of both vectors\n    ///     - for mutually exclusive options, this struct has precedense over the config file\n    pub config_file: Option\u003cString\u003e,\n    /// A proxy that we should use to connect with others\n    ///\n    /// This should be a socks5 proxy, like Tor's socks. If provided, all our outgoing connections\n    /// will be made through this one, except dns seed connections.\n    pub proxy: Option\u003cString\u003e,\n    /// The network we are running in, it may be one of: bitcoin, signet, regtest or testnet.\n    pub network: cli::Network,\n    /// Whther we should build and store compact block filters\n    ///\n    /// Those filters are used for rescanning our wallet for historical transactions. If you don't\n    /// have this on, the only way to find historical transactions is to download all blocks, which\n    /// is very inefficient and resource/time consuming. But keep in mind that filters will take\n    /// up disk space.\n    pub cfilters: bool,\n    #[cfg(feature = \"zmq-server\")]\n    /// The address to listen to for our ZMQ server\n    ///\n    /// We have an (optional) ZMQ server, that pushes new blocks over a PUSH/PULL ZMQ queue, this\n    /// is the address that we'll listen for incomming connections.\n    pub zmq_address: Option\u003cString\u003e,\n    pub connect: Option\u003cString\u003e,\n    #[cfg(feature = \"json-rpc\")]\n    /// The address our json-rpc should listen to\n    pub json_rpc_address: Option\u003cString\u003e,\n    /// The address our electrum server should listen to\n    pub electrum_address: Option\u003cString\u003e,\n    /// Whether we should write logs to the stdio\n    pub log_to_stdout: bool,\n    //// Whether we should log to a fs file\n    pub log_to_file: bool,\n}\n\npub struct Florestad {\n    /// The config used by this node, see [Config] for more details\n    config: Config,\n    /// A channel that tells others to stop what they are doing because we\n    /// are about to die\n    stop_signal: Arc\u003cRwLock\u003cbool\u003e\u003e,\n    /// A channel that notifies we are done, and it's safe to die now\n    stop_notify: Arc\u003cMutex\u003cOption\u003coneshot::Receiver\u003c()\u003e\u003e\u003e\u003e,\n    /// A handle to our json-rpc server\n    json_rpc: OnceLock\u003cjsonrpc_http_server::Server\u003e,\n}\n\nimpl Florestad {\n    /// Kills a running florestad, this will return as soon as the main node stops.\n    ///\n    /// It's not safe to stop you program before this thread returns because some\n    /// information may not be fully flushed to disk yet, and killing the process\n    /// before flushing everything is equivalent to an unclean shutdown.\n    #[allow(unused)]\n    pub fn stop(\u0026self) {\n        async_std::task::block_on(async move {\n            *self.stop_signal.write().await = true;\n            let chan = {\n                let mut guard = self.stop_notify.lock().unwrap();\n                std::mem::take(\u0026mut *guard)\n            };\n            if let Some(chan) = chan {\n                if let Err(e) = chan.await {\n                    error!(\"POSSIBLE BUG: unexpected error while shutting down {e:?}\");\n                }\n            }\n        });\n    }\n\n    pub fn get_stop_signal(\u0026self) -\u003e Arc\u003cRwLock\u003cbool\u003e\u003e {\n        self.stop_signal.clone()\n    }\n\n    pub async fn wait_shutdown(\u0026self) {\n        let chan = {\n            let mut guard = self.stop_notify.lock().unwrap();\n            std::mem::take(\u0026mut *guard)\n        };\n        if let Some(chan) = chan {\n            if let Err(e) = chan.await {\n                error!(\"POSSIBLE BUG: unexpected error while shutting down {e:?}\");\n            }\n        }\n    }\n\n    /// Actually runs florestad, spawning all modules and waiting util\n    /// someone asks to stop.\n    pub fn start(\u0026self) {\n        // Setup global logger\n        let data_dir = self\n            .config\n            .data_dir\n            .clone()\n            .or_else(|| {\n                dirs::home_dir().map(|x: PathBuf| {\n                    format!(\n                        \"{}/{}/\",\n                        x.to_str().unwrap_or_default().to_owned(),\n                        DIR_NAME,\n                    )\n                })\n            })\n            .unwrap_or(\"floresta\".into());\n\n        if self.config.log_to_stdout || self.config.log_to_file {\n            Self::setup_logger(\u0026data_dir, self.config.log_to_file)\n                .expect(\"failure to setup logger\");\n        }\n\n        let data_dir = match self.config.network {\n            cli::Network::Bitcoin =\u003e data_dir,\n            cli::Network::Signet =\u003e data_dir + \"/signet/\",\n            cli::Network::Testnet =\u003e data_dir + \"/testnet3/\",\n            cli::Network::Regtest =\u003e data_dir + \"/regtest/\",\n        };\n\n        // The config file inside our datadir directory. Any datadir\n        // passed as argument will be used instead\n        let system_config_file = format!(\"{data_dir}/config.toml\");\n        let config_file = match \u0026self.config.config_file {\n            Some(path) =\u003e Self::get_config_file(path),\n            None =\u003e Self::get_config_file(\u0026system_config_file),\n        };\n\n        // Load the watch-only wallet\n        debug!(\"Loading wallet\");\n        let mut wallet = Self::load_wallet(\u0026data_dir);\n        wallet.setup().expect(\"Could not initialize wallet\");\n        debug!(\"Done loading wallet\");\n\n        // Try to add more wallets to watch if needed\n        let result = Self::setup_wallet(\n            Self::get_both_vec(self.config.wallet_xpub.clone(), config_file.wallet.xpubs),\n            Self::get_both_vec(\n                self.config.wallet_descriptor.clone(),\n                config_file.wallet.descriptors,\n            ),\n            Self::get_both_vec(config_file.wallet.addresses.clone(), None),\n            \u0026mut wallet,\n            self.config.network.clone(),\n        );\n\n        if let Err(e) = result {\n            log::error!(\"Something went wrong while setting wallet up: {e}\");\n            return;\n        }\n\n        info!(\"loading blockchain database\");\n\n        let blockchain_state = Arc::new(Self::load_chain_state(\n            \u0026data_dir,\n            Self::get_net(\u0026self.config.network),\n            self.config\n                .assume_valid\n                .as_ref()\n                .map(|value| value.parse().expect(\"invalid assumevalid\")),\n        ));\n\n        if let Some(height) = self.config.rescan {\n            blockchain_state\n                .rescan(height)\n                .expect(\"Fail while setting rescan\");\n        }\n\n        #[cfg(feature = \"compact-filters\")]\n        let cfilters = if self.config.cfilters {\n            // Block Filters\n            let filter_store = KvFilterStore::new(\u0026(data_dir.clone() + \"/cfilters\").into());\n            Some(Arc::new(NetworkFilters::new(filter_store, 0)))\n        } else {\n            None\n        };\n        #[cfg(not(feature = \"compact-filters\"))]\n        let cfilters = None;\n\n        // Handle the `-connect` cli option\n        let connect = match self\n            .config\n            .clone()\n            .connect\n            .map(|host| LocalAddress::from_str(\u0026host))\n        {\n            Some(Ok(host)) =\u003e {\n                debug!(\"Connecting to {:?}\", host);\n                Some(host)\n            }\n            Some(Err(e)) =\u003e {\n                error!(\"Invalid host: {}\", e);\n                exit(-1);\n            }\n            None =\u003e None,\n        };\n\n        // For now we only have compatible bridges on signet\n        let pow_fraud_proofs = match self.config.network {\n            cli::Network::Bitcoin =\u003e false,\n            cli::Network::Signet =\u003e true,\n            cli::Network::Testnet =\u003e false,\n            cli::Network::Regtest =\u003e false,\n        };\n\n        let config = UtreexoNodeConfig {\n            network: Self::get_net(\u0026self.config.network),\n            pow_fraud_proofs,\n            proxy: self\n                .config\n                .proxy\n                .as_ref()\n                .map(|address| address.parse().expect(\"Invalid address\")),\n            datadir: data_dir,\n            fixed_peer: connect,\n            max_banscore: 50,\n            compact_filters: self.config.cfilters,\n            max_outbound: 10,\n            max_inflight: 20,\n            assume_utreexo: None,\n            backfill: false,\n        };\n\n        // Chain Provider (p2p)\n        let chain_provider = UtreexoNode::new(\n            config,\n            blockchain_state.clone(),\n            Arc::new(async_std::sync::RwLock::new(Mempool::new())),\n            cfilters.clone(),\n        );\n\n        // ZMQ\n        #[cfg(feature = \"zmq-server\")]\n        {\n            info!(\"Starting ZMQ server\");\n            if let Ok(zserver) =\n                ZMQServer::new(\u0026ctx.zmq_address.unwrap_or(\"tcp://127.0.0.1:5150\".into()))\n            {\n                blockchain_state.subscribe(Arc::new(zserver));\n                info!(\"Done!\");\n            } else {\n                error!(\"Could not create zmq server, skipping\");\n            };\n        }\n\n        info!(\"Starting server\");\n        let wallet = Arc::new(RwLock::new(wallet));\n\n        // JSON-RPC\n        #[cfg(feature = \"json-rpc\")]\n        {\n            let server = json_rpc::server::RpcImpl::create(\n                blockchain_state.clone(),\n                wallet.clone(),\n                chain_provider.get_handle(),\n                self.stop_signal.clone(),\n                Self::get_net(\u0026self.config.network),\n                cfilters.clone(),\n                self.config\n                    .json_rpc_address\n                    .as_ref()\n                    .map(|x| x.parse().expect(\"Invalid json rpc address\")),\n            );\n\n            if self.json_rpc.set(server).is_err() {\n                panic!(\"we should be the first one setting this\");\n            }\n        }\n\n        // Electrum\n        let electrum_address = self\n            .config\n            .electrum_address\n            .clone()\n            .unwrap_or(\"0.0.0.0:50001\".into());\n\n        let electrum_server = block_on(ElectrumServer::new(\n            electrum_address,\n            wallet,\n            blockchain_state,\n            cfilters,\n            chain_provider.get_handle(),\n        ))\n        .expect(\"Could not create an Electrum Server\");\n\n        // Spawn all services\n\n        // Electrum accept loop\n        task::spawn(client_accept_loop(\n            electrum_server.tcp_listener.clone(),\n            electrum_server.message_transmitter.clone(),\n        ));\n        // Electrum main loop\n        task::spawn(electrum_server.main_loop());\n        info!(\"Server running on: 0.0.0.0:50001\");\n\n        // Chain provider\n        let kill_signal = self.stop_signal.clone();\n        let (sender, receiver) = oneshot::channel();\n\n        let mut recv = self.stop_notify.lock().unwrap();\n        *recv = Some(receiver);\n\n        task::spawn(chain_provider.run(kill_signal, sender));\n    }\n\n    fn setup_logger(data_dir: \u0026String, log_file: bool) -\u003e Result\u003c(), fern::InitError\u003e {\n        let colors = ColoredLevelConfig::new()\n            .error(Color::Red)\n            .warn(Color::Yellow)\n            .info(Color::Green)\n            .debug(Color::Blue)\n            .trace(Color::BrightBlack);\n\n        let formatter = |use_colors: bool| {\n            move |out: FormatCallback, message: \u0026Arguments, record: \u0026Record| {\n                out.finish(format_args!(\n                    \"[{} {} {}] {}\",\n                    chrono::Local::now().format(\"%Y-%m-%d %H:%M:%S\"),\n                    match use_colors {\n                        true =\u003e colors.color(record.level()).to_string(),\n                        false =\u003e record.level().to_string(),\n                    },\n                    record.target(),\n                    message\n                ))\n            }\n        };\n        let stdout_dispatcher = fern::Dispatch::new()\n            .format(formatter(true))\n            .level(log::LevelFilter::Info)\n            .chain(std::io::stdout());\n\n        match log_file {\n            true =\u003e {\n                let file_dispatcher = fern::Dispatch::new()\n                    .format(formatter(false))\n                    .level(log::LevelFilter::Info)\n                    .chain(fern::log_file(format!(\"{}/output.log\", data_dir))?);\n                fern::Dispatch::new()\n                    .chain(stdout_dispatcher)\n                    .chain(file_dispatcher)\n                    .apply()?;\n            }\n            false =\u003e {\n                fern::Dispatch::new().chain(stdout_dispatcher).apply()?;\n            }\n        }\n\n        Ok(())\n    }\n\n    pub fn from_config(config: Config) -\u003e Self {\n        Self {\n            config,\n            stop_signal: Arc::new(RwLock::new(false)),\n            stop_notify: Arc::new(Mutex::new(None)),\n            json_rpc: OnceLock::new(),\n        }\n    }\n\n    pub fn new() -\u003e Self {\n        Self::from_config(Config::default())\n    }\n\n    /// Loads a config file from disk, returns default if some error happens\n    fn get_config_file(path: \u0026str) -\u003e ConfigFile {\n        let data = ConfigFile::from_file(path);\n\n        if let Ok(data) = data {\n            data\n        } else {\n            match data.unwrap_err() {\n                crate::error::Error::TomlParsing(e) =\u003e {\n                    error!(\"Error while parsing config file, ignoring it\");\n                    debug!(\"{e}\");\n                    ConfigFile::default()\n                }\n                crate::error::Error::Io(e) =\u003e {\n                    error!(\"Error reading config file, ignoring it\");\n                    debug!(\"{e}\");\n                    ConfigFile::default()\n                }\n                // Shouldn't be any other error\n                _ =\u003e unreachable!(),\n            }\n        }\n    }\n\n    fn get_key_from_env() -\u003e Option\u003cString\u003e {\n        let xpub = std::env::var(\"WALLET_XPUB\");\n        match xpub {\n            Ok(key) =\u003e return Some(key),\n            Err(e) =\u003e match e {\n                std::env::VarError::NotPresent =\u003e {}\n                std::env::VarError::NotUnicode(xpub) =\u003e error!(\"Invalid xpub {xpub:?}\"),\n            },\n        }\n        None\n    }\n\n    fn load_chain_state(\n        data_dir: \u0026String,\n        network: Network,\n        assume_valid: Option\u003cbitcoin::BlockHash\u003e,\n    ) -\u003e ChainState\u003cKvChainStore\u003e {\n        let db = KvChainStore::new(data_dir.to_string()).expect(\"Could not read db\");\n        let assume_valid =\n            assume_valid.map_or(AssumeValidArg::Hardcoded, AssumeValidArg::UserInput);\n\n        match ChainState::\u003cKvChainStore\u003e::load_chain_state(db, network.into(), assume_valid) {\n            Ok(chainstate) =\u003e chainstate,\n            Err(err) =\u003e match err {\n                BlockchainError::ChainNotInitialized =\u003e {\n                    let db = KvChainStore::new(data_dir.to_string()).expect(\"Could not read db\");\n\n                    ChainState::\u003cKvChainStore\u003e::new(db, network.into(), assume_valid)\n                }\n                _ =\u003e unreachable!(),\n            },\n        }\n    }\n\n    fn load_wallet(data_dir: \u0026String) -\u003e AddressCache\u003cKvDatabase\u003e {\n        let database = KvDatabase::new(data_dir.to_owned()).expect(\"Could not create a database\");\n        AddressCache::new(database)\n    }\n\n    fn get_net(net: \u0026cli::Network) -\u003e bitcoin::Network {\n        match net {\n            cli::Network::Bitcoin =\u003e bitcoin::Network::Bitcoin,\n            cli::Network::Signet =\u003e bitcoin::Network::Signet,\n            cli::Network::Testnet =\u003e bitcoin::Network::Testnet,\n            cli::Network::Regtest =\u003e bitcoin::Network::Regtest,\n        }\n    }\n\n    fn setup_wallet\u003cD: AddressCacheDatabase\u003e(\n        mut xpubs: Vec\u003cString\u003e,\n        descriptors: Vec\u003cString\u003e,\n        addresses: Vec\u003cString\u003e,\n        wallet: \u0026mut AddressCache\u003cD\u003e,\n        network: cli::Network,\n    ) -\u003e anyhow::Result\u003c()\u003e {\n        if let Some(key) = Self::get_key_from_env() {\n            xpubs.push(key);\n        }\n        let setup = InitialWalletSetup::build(\n            \u0026xpubs,\n            \u0026descriptors,\n            \u0026addresses,\n            Self::get_net(\u0026network),\n            100,\n        )?;\n        for descriptor in setup.descriptors {\n            let descriptor = descriptor.to_string();\n            if !wallet.is_cached(\u0026descriptor)? {\n                wallet.push_descriptor(\u0026descriptor)?;\n            }\n        }\n        for addresses in setup.addresses {\n            wallet.cache_address(addresses.script_pubkey());\n        }\n        info!(\"Wallet setup completed!\");\n        anyhow::Ok(())\n    }\n\n    fn get_both_vec\u003cT\u003e(a: Option\u003cVec\u003cT\u003e\u003e, b: Option\u003cVec\u003cT\u003e\u003e) -\u003e Vec\u003cT\u003e {\n        let mut result: Vec\u003cT\u003e = Vec::new();\n        if let Some(a) = a {\n            result.extend(a);\n        }\n        if let Some(b) = b {\n            result.extend(b);\n        }\n        result\n    }\n}\n\nimpl Default for Florestad {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl From\u003cConfig\u003e for Florestad {\n    fn from(config: Config) -\u003e Self {\n        Self {\n            config,\n            stop_signal: Arc::new(RwLock::new(false)),\n            stop_notify: Arc::new(Mutex::new(None)),\n            json_rpc: OnceLock::new(),\n        }\n    }\n}\n","traces":[{"line":146,"address":[2952400],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[5242538,5242421,5242474,5243560,5242367,5242336,5242709],"length":1,"stats":{"Line":0},"fn_name":"{async_block#0}"},{"line":148,"address":[5242411,5242429,5242504,5242603,5242769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[5243097,5243179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[5243249,5243306],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[5243456,5243375],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[5242525,5243440,5243463,5243571,5243820,5243835],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[5244014,5243829,5243882,5243778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[2952448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[2952453],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[2952488,2952480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[3458737,3458866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[3458944,3459017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[3459090,3459169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[3381776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[3459553,3459657,3459604,3459789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[2956061,2963971,2952512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[2952598,2953008],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[5244208],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":186,"address":[5244897,5244272,5244222],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":187,"address":[5244518,5244674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[5244370,5244302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[2953059,2964005,2952936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[2953075],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[2953251,2953109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[2953282,2953155],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[2953284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[2953353,2953665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[2953431,2953675],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[2953685,2953509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[2953752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[2953888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[2954161,2953967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[2953936,2954069],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[2954092,2954234,2954314],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[2954256,2954443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[2954467,2954515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[2954549,2954685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[2954814,2954615],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[2955025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[2954901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[2954961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[2955040,2955104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[2955163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[2955355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[2955552,2955628,2955408,2955778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[2956165,2955453,2956079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[2956355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[2956093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[2956302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[5244928,5244960],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":250,"address":[2956444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[2956553,2956486],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[2956501,2956609,2956969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[2956611,2956664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[2956881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[2956589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[2957015,2957162,2957114,2956654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[5245051,5245024],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":274,"address":[2957228],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[2957482,2957601,2957754,2957324],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[2957488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[2957369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[2963285,2963484,2963352,2957383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[2963291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[2957140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[2958327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[2958366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[2958376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[2958386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[2958396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[2958412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[2958455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[2958667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[2958990],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[2959036,2959100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[2959116,2959189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[2959251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[2959503,2959410,2959629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[2959509,2959766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[2959877,2959813],"length":1,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[2959901,2959962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[2959986,2960055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[2960147,2960071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[2960163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[2960230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[2960360,2960277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[5245310,5245280],"length":1,"stats":{"Line":0},"fn_name":"{closure#4}"},{"line":352,"address":[2960539],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[2962986],"length":1,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[2960749,2960855],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[2960783,2962964,2960898],"length":1,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[2961114,2961241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[2960906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[2960946],"length":1,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[2960978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[2961010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[2961050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[2961455,2961514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[2961298,2961370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[2961386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[2961540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[2961647,2961780],"length":1,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[2961908,2961713],"length":1,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[2961924,2962004],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[2962109,2962036],"length":1,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[2962171,2962726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[2962360,2962511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[2966653,2966792,2964032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[2964363,2964266,2964557,2964169,2964060,2964460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[2964161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[2964258],"length":1,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[2964355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[2964452],"length":1,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[2964549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[2964654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[5245440,5246447,5245391],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":404,"address":[5246277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[5245495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[5245690],"length":1,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[5245734,5245880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[5245703,5245762],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[5246024],"length":1,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[2964662,2964816,2964990,2964891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[2966845,2964871,2964683],"length":1,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[2964920,2964879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[2964928,2965025,2966826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[2965041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[2965068,2965643,2965997,2965568],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[2966770,2965427,2965623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[2965631,2965674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[2966674,2965754,2966028,2966748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[2966602,2966312,2966546,2966136,2966447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[2966184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[2966319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[2965358,2965119,2965053,2964046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[2965333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[2967235,2966864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[2966962,2966910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[2966987,2967067],"length":1,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[2967098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[2967264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[2967280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[2968598,2967328,2969339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[2967367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[2967412,2969223,2967493],"length":1,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[2967475],"length":1,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[2967498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[2967803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[2968657,2968750,2967827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[2969073,2968877,2968663,2968943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[2968891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[2967737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[2968013,2967920,2967761],"length":1,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[2968206,2968140,2967926,2968338],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[2968154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[2970011,2969392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[2969409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[2969432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[2969445],"length":1,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[2969503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[2969594,2969912,2969780],"length":1,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[2969585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[2971266,2970048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[2970096],"length":1,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[2970212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[2970329,2971294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[2970627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[2970682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[2970780,2970864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[2971244,2970937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[2971344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[2971368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[2971441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[2971504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[2971509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[2971540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[2971547],"length":1,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[2971554],"length":1,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[2971561],"length":1,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[5246480,5249338,5248527],"length":1,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":558,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[2971584],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":569,"address":[2971592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[2971987,2971616],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":577,"address":[2971662,2971714],"length":1,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[2971739,2971819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[2971850],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":208},{"path":["/","home","dane","Desktop","SOB","Floresta","florestad","src","json_rpc","mod.rs"],"content":"pub mod res;\npub mod server;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dane","Desktop","SOB","Floresta","florestad","src","json_rpc","res.rs"],"content":"use std::fmt::Display;\n\nuse jsonrpc_core::ErrorCode;\nuse serde::Deserialize;\nuse serde::Serialize;\n\n#[derive(Deserialize, Serialize)]\npub struct GetBlockchainInfoRes {\n    pub best_block: String,\n    pub height: u32,\n    pub ibd: bool,\n    pub validated: u32,\n    pub latest_work: String,\n    pub latest_block_time: u32,\n    pub leaf_count: u32,\n    pub root_count: u32,\n    pub root_hashes: Vec\u003cString\u003e,\n    pub chain: String,\n    pub progress: f32,\n    pub difficulty: u64,\n}\n\n#[derive(Deserialize, Serialize)]\npub struct RawTxJson {\n    pub in_active_chain: bool,\n    pub hex: String,\n    pub txid: String,\n    pub hash: String,\n    pub size: u32,\n    pub vsize: u32,\n    pub weight: u32,\n    pub version: u32,\n    pub locktime: u32,\n    pub vin: Vec\u003cTxInJson\u003e,\n    pub vout: Vec\u003cTxOutJson\u003e,\n    pub blockhash: String,\n    pub confirmations: u32,\n    pub blocktime: u32,\n    pub time: u32,\n}\n\n#[derive(Deserialize, Serialize)]\npub struct TxOutJson {\n    pub value: u64,\n    pub n: u32,\n    pub script_pub_key: ScriptPubKeyJson,\n}\n\n#[derive(Deserialize, Serialize)]\npub struct ScriptPubKeyJson {\n    pub asm: String,\n    pub hex: String,\n    pub req_sigs: u32,\n    #[serde(rename = \"type\")]\n    pub type_: String,\n    pub address: String,\n}\n\n#[derive(Deserialize, Serialize)]\npub struct TxInJson {\n    pub txid: String,\n    pub vout: u32,\n    pub script_sig: ScriptSigJson,\n    pub sequence: u32,\n    pub witness: Vec\u003cString\u003e,\n}\n\n#[derive(Deserialize, Serialize)]\npub struct ScriptSigJson {\n    pub asm: String,\n    pub hex: String,\n}\n\n#[derive(Deserialize, Serialize)]\npub struct BlockJson {\n    pub hash: String,\n    pub confirmations: u32,\n    pub strippedsize: usize,\n    pub size: usize,\n    pub weight: usize,\n    pub height: u32,\n    pub version: i32,\n    #[serde(rename = \"versionHex\")]\n    pub version_hex: String,\n    pub merkleroot: String,\n    pub tx: Vec\u003cString\u003e,\n    pub time: u32,\n    pub mediantime: u32,\n    pub nonce: u32,\n    pub bits: String,\n    pub difficulty: u128,\n    pub chainwork: String,\n    pub n_tx: usize,\n    pub previousblockhash: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub nextblockhash: Option\u003cString\u003e,\n}\n\n#[derive(Debug)]\npub enum Error {\n    TxNotFound,\n    InvalidDescriptor,\n    BlockNotFound,\n    Chain,\n    InvalidPort,\n    InvalidAddress,\n    Node,\n    NoBlockFilters,\n    InvalidNetwork,\n}\n\nimpl Display for Error {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let msg = match self {\n            Error::TxNotFound =\u003e \"Transaction not found\",\n            Error::InvalidDescriptor =\u003e \"Invalid descriptor\",\n            Error::BlockNotFound =\u003e \"Block not found\",\n            Error::Chain =\u003e \"Chain error\",\n            Error::InvalidPort =\u003e \"Invalid port\",\n            Error::InvalidAddress =\u003e \"Invalid address\",\n            Error::Node =\u003e \"Node returned an error\",\n            Error::NoBlockFilters =\u003e \"You don't have block filters enabled, please start florestad with --cfilters to run this RPC\",\n            Error::InvalidNetwork =\u003e \"Invalid network\"\n        };\n        write!(f, \"{}\", msg)\n    }\n}\n\nimpl From\u003cError\u003e for i64 {\n    fn from(val: Error) -\u003e Self {\n        match val {\n            Error::BlockNotFound =\u003e 1,\n            Error::Chain =\u003e 2,\n            Error::TxNotFound =\u003e 3,\n            Error::InvalidDescriptor =\u003e 4,\n            Error::InvalidPort =\u003e 5,\n            Error::InvalidAddress =\u003e 6,\n            Error::Node =\u003e 7,\n            Error::NoBlockFilters =\u003e 8,\n            Error::InvalidNetwork =\u003e 9,\n        }\n    }\n}\n\nimpl From\u003cError\u003e for ErrorCode {\n    fn from(val: Error) -\u003e Self {\n        let code = val.into();\n        ErrorCode::ServerError(code)\n    }\n}\n\nimpl From\u003cError\u003e for jsonrpc_core::Error {\n    fn from(value: Error) -\u003e Self {\n        jsonrpc_core::Error {\n            message: value.to_string(),\n            code: value.into(),\n            data: None,\n        }\n    }\n}\n","traces":[{"line":113,"address":[3143552],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":114,"address":[3143574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[3143605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[3072207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[6657705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[6657731],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[6657754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[3143729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[6657800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[6657823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[3072374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[3072449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[3072528],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":131,"address":[3072535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[3072590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[3072601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[3072568],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[3072579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[3072612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[3072623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[3072634],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[3072645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[3072656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[6272752],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":147,"address":[6272763],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[6272776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[6273006,6272816],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":155,"address":[6272847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[6272852],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":29},{"path":["/","home","dane","Desktop","SOB","Floresta","florestad","src","json_rpc","server.rs"],"content":"use std::net::SocketAddr;\nuse std::sync::Arc;\n\nuse async_std::sync::RwLock;\nuse bitcoin::block::Header as BlockHeader;\nuse bitcoin::consensus::deserialize;\nuse bitcoin::consensus::encode::serialize_hex;\nuse bitcoin::consensus::serialize;\nuse bitcoin::constants::genesis_block;\nuse bitcoin::hashes::hex::FromHex;\nuse bitcoin::hashes::Hash;\nuse bitcoin::hex::DisplayHex;\nuse bitcoin::Address;\nuse bitcoin::Block;\nuse bitcoin::BlockHash;\nuse bitcoin::Network;\nuse bitcoin::OutPoint;\nuse bitcoin::ScriptBuf;\nuse bitcoin::TxIn;\nuse bitcoin::TxOut;\nuse bitcoin::Txid;\nuse floresta_chain::pruned_utreexo::BlockchainInterface;\nuse floresta_chain::pruned_utreexo::UpdatableChainstate;\nuse floresta_chain::ChainState;\nuse floresta_chain::KvChainStore;\nuse floresta_compact_filters::kv_filter_database::KvFilterStore;\nuse floresta_compact_filters::network_filters::NetworkFilters;\nuse floresta_watch_only::kv_database::KvDatabase;\nuse floresta_watch_only::AddressCache;\nuse floresta_watch_only::CachedTransaction;\nuse floresta_wire::node_interface::NodeInterface;\nuse floresta_wire::node_interface::NodeMethods;\nuse floresta_wire::node_interface::PeerInfo;\nuse futures::executor::block_on;\nuse jsonrpc_core::Result;\nuse jsonrpc_derive::rpc;\nuse jsonrpc_http_server::ServerBuilder;\nuse log::info;\nuse serde_json::json;\nuse serde_json::Value;\n\nuse super::res::BlockJson;\nuse super::res::Error;\nuse super::res::GetBlockchainInfoRes;\nuse super::res::RawTxJson;\nuse super::res::ScriptPubKeyJson;\nuse super::res::ScriptSigJson;\nuse super::res::TxInJson;\nuse super::res::TxOutJson;\n\n#[rpc]\npub trait Rpc {\n    #[rpc(name = \"getblockfilter\")]\n    fn get_block_filter(\u0026self, heigth: u32) -\u003e Result\u003cString\u003e;\n    #[rpc(name = \"getblockchaininfo\")]\n    fn get_blockchain_info(\u0026self) -\u003e Result\u003cGetBlockchainInfoRes\u003e;\n    #[rpc(name = \"getblockhash\")]\n    fn get_block_hash(\u0026self, height: u32) -\u003e Result\u003cBlockHash\u003e;\n    #[rpc(name = \"getblockheader\")]\n    fn get_block_header(\u0026self, hash: BlockHash) -\u003e Result\u003cBlockHeader\u003e;\n    #[rpc(name = \"gettransaction\")]\n    fn get_transaction(\u0026self, tx_id: Txid, verbosity: Option\u003cbool\u003e) -\u003e Result\u003cValue\u003e;\n    #[rpc(name = \"gettxproof\")]\n    fn get_tx_proof(\u0026self, tx_id: Txid) -\u003e Result\u003cVec\u003cString\u003e\u003e;\n    #[rpc(name = \"loaddescriptor\")]\n    fn load_descriptor(\u0026self, descriptor: String, rescan: Option\u003cu32\u003e) -\u003e Result\u003cbool\u003e;\n    #[rpc(name = \"rescan\")]\n    fn rescan(\u0026self, rescan: u32) -\u003e Result\u003cbool\u003e;\n    #[rpc(name = \"getheight\")]\n    fn get_height(\u0026self) -\u003e Result\u003cu32\u003e;\n    #[rpc(name = \"sendrawtransaction\")]\n    fn send_raw_transaction(\u0026self, tx: String) -\u003e Result\u003cTxid\u003e;\n    #[rpc(name = \"getroots\")]\n    fn get_roots(\u0026self) -\u003e Result\u003cVec\u003cString\u003e\u003e;\n    #[rpc(name = \"getpeerinfo\")]\n    fn get_peer_info(\u0026self) -\u003e Result\u003cVec\u003cPeerInfo\u003e\u003e;\n    #[rpc(name = \"getblock\")]\n    fn get_block(\u0026self, hash: BlockHash, verbosity: Option\u003cu8\u003e) -\u003e Result\u003cValue\u003e;\n    #[rpc(name = \"gettxout\", returns = \"TxOut\")]\n    fn get_tx_out(\u0026self, tx_id: Txid, outpoint: u32) -\u003e Result\u003cValue\u003e;\n    #[rpc(name = \"stop\")]\n    fn stop(\u0026self) -\u003e Result\u003cbool\u003e;\n    #[rpc(name = \"addnode\")]\n    fn add_node(\u0026self, node: String) -\u003e Result\u003cbool\u003e;\n}\n\npub struct RpcImpl {\n    block_filter_storage: Option\u003cArc\u003cNetworkFilters\u003cKvFilterStore\u003e\u003e\u003e,\n    network: Network,\n    chain: Arc\u003cChainState\u003cKvChainStore\u003e\u003e,\n    wallet: Arc\u003cRwLock\u003cAddressCache\u003cKvDatabase\u003e\u003e\u003e,\n    node: Arc\u003cNodeInterface\u003e,\n    kill_signal: Arc\u003cRwLock\u003cbool\u003e\u003e,\n}\n\nimpl Rpc for RpcImpl {\n    fn get_tx_out(\u0026self, tx_id: Txid, outpoint: u32) -\u003e Result\u003cValue\u003e {\n        fn has_input(block: \u0026Block, expected_input: OutPoint) -\u003e bool {\n            block.txdata.iter().any(|tx| {\n                tx.input\n                    .iter()\n                    .any(|input| input.previous_output == expected_input)\n            })\n        }\n        // can't proceed without block filters\n        if self.block_filter_storage.is_none() {\n            return Err(jsonrpc_core::Error {\n                code: Error::NoBlockFilters.into(),\n                message: Error::NoBlockFilters.to_string(),\n                data: None,\n            });\n        }\n        // this variable will be set to the UTXO iff (i) it have been created\n        // (ii) it haven't been spent\n        let mut txout = None;\n        let tip = self.chain.get_height().unwrap();\n\n        if let Some(ref cfilters) = self.block_filter_storage {\n            let vout = OutPoint {\n                txid: tx_id,\n                vout: outpoint,\n            };\n\n            let filter_outpoint = bitcoin::consensus::serialize(\u0026vout);\n            let filter_txid = bitcoin::consensus::serialize(\u0026tx_id);\n\n            let candidates = cfilters.match_any(\n                vec![filter_outpoint.as_slice(), filter_txid.as_slice()],\n                1,\n                tip,\n                self.chain.clone(),\n            );\n\n            let candidates = candidates.into_iter().map(|hash| self.node.get_block(hash));\n\n            for candidate in candidates {\n                let candidate = match candidate {\n                    Err(e) =\u003e {\n                        return Err(jsonrpc_core::Error {\n                            code: Error::Node.into(),\n                            message: format!(\"error while downloading block {candidate:?}\"),\n                            data: Some(jsonrpc_core::Value::String(e.to_string())),\n                        });\n                    }\n                    Ok(None) =\u003e {\n                        return Err(jsonrpc_core::Error {\n                            code: Error::Node.into(),\n                            message: format!(\"BUG: block {candidate:?} is a match in our filters, but we can't get it?\"),\n                            data: None,\n                        });\n                    }\n                    Ok(Some(candidate)) =\u003e candidate,\n                };\n\n                if let Some(tx) = candidate.txdata.iter().position(|tx| tx.txid() == tx_id) {\n                    txout = candidate.txdata[tx].output.get(outpoint as usize).cloned();\n                }\n\n                if has_input(\u0026candidate, vout) {\n                    txout = None;\n                }\n            }\n        }\n        match txout {\n            Some(txout) =\u003e Ok(json!({ \"txout\": txout })),\n            None =\u003e Ok(json!({})),\n        }\n    }\n    fn get_height(\u0026self) -\u003e Result\u003cu32\u003e {\n        Ok(self.chain.get_best_block().unwrap().0)\n    }\n\n    fn get_block_filter(\u0026self, heigth: u32) -\u003e Result\u003cString\u003e {\n        if let Some(ref cfilters) = self.block_filter_storage {\n            return Ok(serialize_hex(\n                \u0026cfilters\n                    .get_filter(heigth)\n                    .ok_or(Error::BlockNotFound)?\n                    .content,\n            ));\n        }\n        Err(jsonrpc_core::Error {\n            code: Error::NoBlockFilters.into(),\n            message: Error::NoBlockFilters.to_string(),\n            data: None,\n        })\n    }\n    fn add_node(\u0026self, node: String) -\u003e Result\u003cbool\u003e {\n        let node = node.split(':').collect::\u003cVec\u003c\u0026str\u003e\u003e();\n        let (ip, port) = if node.len() == 2 {\n            (node[0], node[1].parse().map_err(|_| Error::InvalidPort)?)\n        } else {\n            match self.network {\n                Network::Bitcoin =\u003e (node[0], 8333),\n                Network::Testnet =\u003e (node[0], 18333),\n                Network::Regtest =\u003e (node[0], 18444),\n                Network::Signet =\u003e (node[0], 38333),\n                _ =\u003e return Err(Error::InvalidNetwork.into()),\n            }\n        };\n        let node = ip.parse().map_err(|_| Error::InvalidAddress)?;\n        self.node.connect(node, port).unwrap();\n        Ok(true)\n    }\n\n    fn get_blockchain_info(\u0026self) -\u003e Result\u003cGetBlockchainInfoRes\u003e {\n        let (height, hash) = self.chain.get_best_block().unwrap();\n        let validated = self.chain.get_validation_index().unwrap();\n        let ibd = self.chain.is_in_idb();\n        let latest_header = self.chain.get_block_header(\u0026hash).unwrap();\n        let latest_work = latest_header.work();\n        let latest_block_time = latest_header.time;\n        let leaf_count = self.chain.acc().leaves as u32;\n        let root_count = self.chain.acc().roots.len() as u32;\n        let root_hashes = self\n            .chain\n            .acc()\n            .roots\n            .into_iter()\n            .map(|r| r.to_string())\n            .collect();\n        let validated_blocks = self.chain.get_validation_index().unwrap();\n        Ok(GetBlockchainInfoRes {\n            best_block: hash.to_string(),\n            height,\n            ibd,\n            validated,\n            latest_work: latest_work.to_string(),\n            latest_block_time,\n            leaf_count,\n            root_count,\n            root_hashes,\n            chain: self.network.to_string(),\n            difficulty: latest_header.difficulty() as u64,\n            progress: validated_blocks as f32 / height as f32,\n        })\n    }\n\n    fn get_roots(\u0026self) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        let hashes = self.chain.get_root_hashes();\n        return Ok(hashes.iter().map(|h| h.to_string()).collect());\n    }\n\n    fn get_block_hash(\u0026self, height: u32) -\u003e Result\u003cBlockHash\u003e {\n        if let Ok(hash) = self.chain.get_block_hash(height) {\n            return Ok(hash);\n        }\n        Err(Error::BlockNotFound.into())\n    }\n\n    fn get_block_header(\u0026self, hash: BlockHash) -\u003e Result\u003cBlockHeader\u003e {\n        if let Ok(header) = self.chain.get_block_header(\u0026hash) {\n            return Ok(header);\n        }\n        Err(Error::BlockNotFound.into())\n    }\n\n    fn get_transaction(\u0026self, tx_id: Txid, verbosity: Option\u003cbool\u003e) -\u003e Result\u003cValue\u003e {\n        let wallet = block_on(self.wallet.read());\n        if verbosity == Some(true) {\n            if let Some(tx) = wallet.get_transaction(\u0026tx_id) {\n                return Ok(serde_json::to_value(serialize(\u0026tx.tx)).unwrap());\n            }\n            return Err(Error::TxNotFound.into());\n        }\n        if let Some(tx) = wallet.get_transaction(\u0026tx_id) {\n            return Ok(serde_json::to_value(self.make_raw_transaction(tx)).unwrap());\n        }\n        Err(Error::TxNotFound.into())\n    }\n\n    fn load_descriptor(\u0026self, descriptor: String, rescan: Option\u003cu32\u003e) -\u003e Result\u003cbool\u003e {\n        let wallet = block_on(self.wallet.write());\n        let result = wallet.push_descriptor(\u0026descriptor);\n        if let Some(rescan) = rescan {\n            self.chain\n                .rescan(rescan)\n                .map_err(|_| jsonrpc_core::Error::internal_error())?;\n        }\n        if result.is_err() {\n            return Err(Error::InvalidDescriptor.into());\n        }\n        Ok(true)\n    }\n\n    fn rescan(\u0026self, rescan: u32) -\u003e Result\u003cbool\u003e {\n        let result = self.chain.rescan(rescan);\n        if result.is_err() {\n            return Err(Error::Chain.into());\n        }\n        Ok(true)\n    }\n\n    fn send_raw_transaction(\u0026self, tx: String) -\u003e Result\u003cTxid\u003e {\n        let tx_hex = Vec::from_hex(\u0026tx).map_err(|_| jsonrpc_core::Error {\n            code: 3.into(),\n            message: \"Invalid hex\".into(),\n            data: None,\n        })?;\n        let tx = deserialize(\u0026tx_hex).map_err(|e| jsonrpc_core::Error {\n            code: 2.into(),\n            message: format!(\"{:?}\", e),\n            data: None,\n        })?;\n        if self.chain.broadcast(\u0026tx).is_ok() {\n            return Ok(tx.txid());\n        }\n        Err(Error::Chain.into())\n    }\n\n    fn get_tx_proof(\u0026self, tx_id: Txid) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        if let Some((proof, _)) = block_on(self.wallet.read()).get_merkle_proof(\u0026tx_id) {\n            return Ok(proof);\n        }\n        Err(Error::TxNotFound.into())\n    }\n\n    fn get_block(\u0026self, hash: BlockHash, verbosity: Option\u003cu8\u003e) -\u003e Result\u003cValue\u003e {\n        let verbosity = verbosity.unwrap_or(1);\n\n        let block = if self.chain.get_block_hash(0).unwrap().eq(\u0026hash) {\n            Some(genesis_block(self.network))\n        } else {\n            self.node.get_block(hash).map_err(|_| Error::Chain)?\n        };\n\n        if let Some(block) = block {\n            if verbosity == 1 {\n                let tip = self.chain.get_height().map_err(|_| Error::Chain)?;\n                let height = self\n                    .chain\n                    .get_block_height(\u0026hash)\n                    .map_err(|_| Error::Chain)?\n                    .unwrap();\n\n                let median_time_past = if height \u003e 11 {\n                    let mut last_block_times: Vec\u003c_\u003e = ((height - 11)..height)\n                        .map(|h| {\n                            self.chain\n                                .get_block_header(\u0026self.chain.get_block_hash(h).unwrap())\n                                .unwrap()\n                                .time\n                        })\n                        .collect();\n                    last_block_times.sort();\n                    last_block_times[5]\n                } else {\n                    block.header.time\n                };\n\n                let block = BlockJson {\n                    bits: serialize_hex(\u0026block.header.bits),\n                    chainwork: block.header.work().to_string(),\n                    confirmations: (tip - height) + 1,\n                    difficulty: block.header.difficulty(),\n                    hash: block.header.block_hash().to_string(),\n                    height,\n                    merkleroot: block.header.merkle_root.to_string(),\n                    nonce: block.header.nonce,\n                    previousblockhash: block.header.prev_blockhash.to_string(),\n                    size: block.total_size(),\n                    time: block.header.time,\n                    tx: block\n                        .txdata\n                        .iter()\n                        .map(|tx| tx.txid().to_string())\n                        .collect(),\n                    version: block.header.version.to_consensus(),\n                    version_hex: serialize_hex(\u0026block.header.version),\n                    weight: block.weight().to_wu() as usize,\n                    mediantime: median_time_past,\n                    n_tx: block.txdata.len(),\n                    nextblockhash: self\n                        .chain\n                        .get_block_hash(height + 1)\n                        .ok()\n                        .map(|h| h.to_string()),\n                    strippedsize: block.strippedsize(),\n                };\n\n                return Ok(serde_json::to_value(block).unwrap());\n            }\n            return Ok(json!(serialize(\u0026block).to_vec()));\n        }\n        Err(Error::BlockNotFound.into())\n    }\n\n    fn get_peer_info(\u0026self) -\u003e Result\u003cVec\u003cPeerInfo\u003e\u003e {\n        let peers = self.node.get_peer_info();\n        if let Ok(peers) = peers {\n            return Ok(peers);\n        }\n        Err(Error::TxNotFound.into())\n    }\n\n    fn stop(\u0026self) -\u003e Result\u003cbool\u003e {\n        *async_std::task::block_on(self.kill_signal.write()) = true;\n        Ok(true)\n    }\n}\nimpl RpcImpl {\n    fn make_vin(\u0026self, input: TxIn) -\u003e TxInJson {\n        let txid = serialize_hex(\u0026input.previous_output.txid);\n        let vout = input.previous_output.vout;\n        let sequence = input.sequence.0;\n        TxInJson {\n            txid,\n            vout,\n            script_sig: ScriptSigJson {\n                asm: input.script_sig.to_asm_string(),\n                hex: input.script_sig.to_hex_string(),\n            },\n            witness: input\n                .witness\n                .iter()\n                .map(|w| w.to_hex_string(bitcoin::hex::Case::Upper))\n                .collect(),\n            sequence,\n        }\n    }\n    fn get_script_type(script: ScriptBuf) -\u003e Option\u003c\u0026'static str\u003e {\n        if script.is_p2pkh() {\n            return Some(\"p2pkh\");\n        }\n        if script.is_p2sh() {\n            return Some(\"p2sh\");\n        }\n        if script.is_p2wpkh() {\n            return Some(\"v0_p2wpkh\");\n        }\n        if script.is_p2wsh() {\n            return Some(\"v0_p2wsh\");\n        }\n        None\n    }\n    fn make_vout(\u0026self, output: TxOut, n: u32) -\u003e TxOutJson {\n        let value = output.value;\n        TxOutJson {\n            value: value.to_sat(),\n            n,\n            script_pub_key: ScriptPubKeyJson {\n                asm: output.script_pubkey.to_asm_string(),\n                hex: output.script_pubkey.to_hex_string(),\n                req_sigs: 0, // This field is deprecated\n                address: Address::from_script(\u0026output.script_pubkey, self.network)\n                    .map(|a| a.to_string())\n                    .unwrap(),\n                type_: Self::get_script_type(output.script_pubkey)\n                    .unwrap_or(\"nonstandard\")\n                    .to_string(),\n            },\n        }\n    }\n    fn make_raw_transaction(\u0026self, tx: CachedTransaction) -\u003e RawTxJson {\n        let raw_tx = tx.tx;\n        let in_active_chain = tx.height != 0;\n        let hex = serialize_hex(\u0026raw_tx);\n        let txid = serialize_hex(\u0026raw_tx.txid());\n        let block_hash = self\n            .chain\n            .get_block_hash(tx.height)\n            .unwrap_or(BlockHash::all_zeros());\n        let tip = self.chain.get_height().unwrap();\n        let confirmations = if in_active_chain {\n            tip - tx.height + 1\n        } else {\n            0\n        };\n\n        RawTxJson {\n            in_active_chain,\n            hex,\n            txid,\n            hash: serialize_hex(\u0026raw_tx.wtxid()),\n            size: raw_tx.total_size() as u32,\n            vsize: raw_tx.vsize() as u32,\n            weight: raw_tx.weight().to_wu() as u32,\n            version: raw_tx.version.0 as u32,\n            locktime: raw_tx.lock_time.to_consensus_u32(),\n            vin: raw_tx\n                .input\n                .iter()\n                .map(|input| self.make_vin(input.clone()))\n                .collect(),\n            vout: raw_tx\n                .output\n                .into_iter()\n                .enumerate()\n                .map(|(i, output)| self.make_vout(output, i as u32))\n                .collect(),\n            blockhash: serialize_hex(\u0026block_hash),\n            confirmations,\n            blocktime: self\n                .chain\n                .get_block_header(\u0026block_hash)\n                .map(|h| h.time)\n                .unwrap_or(0),\n            time: self\n                .chain\n                .get_block_header(\u0026block_hash)\n                .map(|h| h.time)\n                .unwrap_or(0),\n        }\n    }\n    fn get_port(net: \u0026Network) -\u003e u16 {\n        match net {\n            Network::Bitcoin =\u003e 8332,\n            Network::Testnet =\u003e 18332,\n            Network::Signet =\u003e 38332,\n            Network::Regtest =\u003e 18442,\n            _ =\u003e 8332,\n        }\n    }\n\n    #[allow(clippy::too_many_arguments)]\n    pub fn create(\n        chain: Arc\u003cChainState\u003cKvChainStore\u003e\u003e,\n        wallet: Arc\u003cRwLock\u003cAddressCache\u003cKvDatabase\u003e\u003e\u003e,\n        node: Arc\u003cNodeInterface\u003e,\n        kill_signal: Arc\u003cRwLock\u003cbool\u003e\u003e,\n        network: Network,\n        block_filter_storage: Option\u003cArc\u003cNetworkFilters\u003cKvFilterStore\u003e\u003e\u003e,\n        address: Option\u003cSocketAddr\u003e,\n    ) -\u003e jsonrpc_http_server::Server {\n        let mut io = jsonrpc_core::IoHandler::new();\n        let rpc_impl = RpcImpl {\n            network,\n            chain,\n            wallet,\n            node,\n            kill_signal,\n            block_filter_storage,\n        };\n        io.extend_with(rpc_impl.to_delegate());\n        let address = address.unwrap_or_else(|| {\n            format!(\"127.0.0.1:{}\", Self::get_port(\u0026network))\n                .parse()\n                .unwrap()\n        });\n        info!(\"Starting JSON-RPC server on {:?}\", address);\n        ServerBuilder::new(io)\n            .threads(1)\n            .start_http(\u0026address)\n            .unwrap()\n    }\n}\n","traces":[{"line":97,"address":[2704622,2703257,2699872],"length":1,"stats":{"Line":0},"fn_name":"get_tx_out"},{"line":98,"address":[2704656],"length":1,"stats":{"Line":0},"fn_name":"has_input"},{"line":99,"address":[2704669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[5427438,5427489],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[5427481,5427520,5427545],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":106,"address":[2699944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[2700116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[2700027],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[2700064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[2700108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[2699989],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[2700327,2700017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[2700378],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[2700528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[2700589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[2701130,2700648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[2700714,2703958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[2701050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[2701174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[2703252,2701276,2703853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[2701557,2701503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[2699929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[2703692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[2701588],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[2703377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[2703503,2703572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[2702236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[2701630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[2702082],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[2702228],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[2701672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[2702462,2702995,2701896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[2702723,2702611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[2703004,2703234,2702642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[2703032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[2700535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[2703978,2704168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[2703971,2704044],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[2704752],"length":1,"stats":{"Line":0},"fn_name":"get_height"},{"line":170,"address":[2704770],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[2704832,2705465],"length":1,"stats":{"Line":0},"fn_name":"get_block_filter"},{"line":174,"address":[2704873],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[2705407,2705324],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[2705347,2704952,2705259,2704919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[2704944,2705336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[2705108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[2705034],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[2705065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[2705100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[2705504,2706897],"length":1,"stats":{"Line":0},"fn_name":"add_node"},{"line":189,"address":[2705559,2705642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[2705701,2706102,2706144,2705762],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[2706112,2705843,2706215,2705768,2706239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[2705808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[2706389,2706241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[2706276,2706432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[2706346,2706518],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[2706475,2706311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[2706876,2706686,2706205,2706572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[2706662,2706731],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[2706816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[2706928,2708392,2708359],"length":1,"stats":{"Line":0},"fn_name":"get_blockchain_info"},{"line":207,"address":[2706958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[2707077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[2707117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[2707161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[2707201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[2707287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[2707305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[2707368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[2707509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[5427836,5427808],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":222,"address":[2707654,2707702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[2708062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[2707755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[2707778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[2707834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[2707874],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[2707937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[2708042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[2708432,2708682],"length":1,"stats":{"Line":0},"fn_name":"get_roots"},{"line":240,"address":[2708467],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[2708549,2708477],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[2708720],"length":1,"stats":{"Line":0},"fn_name":"get_block_hash"},{"line":245,"address":[2708751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[2708827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[2708892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[2708960],"length":1,"stats":{"Line":0},"fn_name":"get_block_header"},{"line":252,"address":[2708985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[2709034],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[2709086],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[2709168,2710062,2709992],"length":1,"stats":{"Line":0},"fn_name":"get_transaction"},{"line":259,"address":[2709217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[2709332,2709264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[2709724,2709360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[2709897,2709796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[2710003],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[2709393,2709343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[2709520,2709478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[2709629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[2710080,2710827],"length":1,"stats":{"Line":0},"fn_name":"load_descriptor"},{"line":273,"address":[2710132,2710202],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[2710313,2710259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[2710360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[2710394,2710624,2710115,2710479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[2710544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[2710670,2710409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[2710707,2710779],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[2710681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[2711078,2710864],"length":1,"stats":{"Line":0},"fn_name":"rescan"},{"line":287,"address":[2710905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[2710915,2710971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[2711005,2711050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[2710981],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[2712310,2712341,2711104],"length":1,"stats":{"Line":0},"fn_name":"send_raw_transaction"},{"line":295,"address":[2711147,2711215,2711463,2712339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[5428046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[5428066],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[5428109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[2712321,2711539,2711355,2711878],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[5428219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[5428377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[5428502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[2711783,2711955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[2712212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[2712058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[2712746,2712368],"length":1,"stats":{"Line":0},"fn_name":"get_tx_proof"},{"line":312,"address":[2712410,2712525],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[2712602],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[2712692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[2712784,2716170,2716595],"length":1,"stats":{"Line":0},"fn_name":"get_block"},{"line":319,"address":[2712861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[2713274,2712914,2713208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[2713156],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[2713284,2713210,2712994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[2713359,2713315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[2713400],"length":1,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[2713541,2713721,2716183,2713456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[2713969,2713764,2716181,2713706],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[2713959],"length":1,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[2714019,2714000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[2714028,2714100,2714122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[2714114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[5428799,5428744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[5428751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[2714222,2714305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[2714312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[2714005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[2714052],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[2714557,2714390],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[2714784,2714626],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[2714749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[2714817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[2714867],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[2714934],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[2714964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[2715012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[2715080],"length":1,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[2715091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[2715203],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[2715269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[2715292,2715362],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[2715389],"length":1,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[2715510,2715454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[2715540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[2716048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[2713479,2716185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[2716544,2713406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[2716905,2716640],"length":1,"stats":{"Line":0},"fn_name":"get_peer_info"},{"line":389,"address":[2716678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[2716701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[2716762],"length":1,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[2716878,2716798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[2717125,2716944],"length":1,"stats":{"Line":0},"fn_name":"stop"},{"line":397,"address":[2716980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[2717106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[2717797,2717152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[2717190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[2717252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[2717266],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[2717492],"length":1,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[2717635,2717556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[2718248,2717824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[2717905,2717836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[2717952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[2717931,2717988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[2718035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[2718071,2718014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[2718118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[2718097,2718151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[2718194],"length":1,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[2718177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[2718272,2719148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[2718318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[2718346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[2718907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[2721423,2719200,2721292],"length":1,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[2719248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[2719335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[2719377,2719428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[2719436,2719517],"length":1,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[2719668,2719562],"length":1,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[2719548,2719607],"length":1,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[2719623,2721333,2719715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[2719731],"length":1,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[2719803,2719788,2720028],"length":1,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[2719820,2720033,2719969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[2719792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[2720123,2719932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[2720138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[2720208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[2720237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[2720279],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[2720290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[2720315,2720401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[2720589,2720566,2720447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[2720659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[2720741,2720805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[2720857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[2721440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[2721445],"length":1,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[2721476],"length":1,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[2721485],"length":1,"stats":{"Line":0},"fn_name":null},{"line":509,"address":[2721494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[2721503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[2721474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[2722670,2721520,2722799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[2721585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[2721880,2721933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[2722042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[5429429,5429510,5429673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[2722104,2722293,2722426],"length":1,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[2722156,2722546],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":233},{"path":["/","home","dane","Desktop","SOB","Floresta","florestad","src","lib.rs"],"content":"mod cli;\nmod config_file;\nmod error;\nmod florestad;\n#[cfg(feature = \"json-rpc\")]\nmod json_rpc;\nmod slip132;\nmod wallet_input;\n\npub use cli::Network;\npub use florestad::Config;\npub use florestad::Florestad;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dane","Desktop","SOB","Floresta","florestad","src","main.rs"],"content":"// Written in 2022 by Davidson Souza.\n// SPDX-License-Identifier: CC0-1.0\n\n//! This is a modular-(ish) utreexo powered wallet backend and fully validating node, it's\n//! developed as an experiment to showcase utreexo. This wallet also comes with an Electrum\n//! server out-of-the-box, for people to try out with their favorite wallet.\n//! This codebase consists of three main parts: a blockchain backend, that gets all information\n//! we need from the network. An Electrum Server that talks full Electrum protocol and can be\n//! used with any wallet that understands this protocol. Finally, it has the `AddressCache`,\n//! a watch-only wallet that keeps track of your wallet's transactions.\n\n// Coding conventions (lexicographically sorted)\n#![deny(arithmetic_overflow)]\n#![deny(clippy::all)]\n#![deny(missing_docs)]\n#![deny(non_camel_case_types)]\n#![deny(non_snake_case)]\n#![deny(non_upper_case_globals)]\n\nmod cli;\nmod config_file;\nmod error;\nmod florestad;\n#[cfg(feature = \"json-rpc\")]\nmod json_rpc;\nmod slip132;\nmod wallet_input;\n#[cfg(feature = \"zmq-server\")]\nmod zmq;\n\nuse std::time::Duration;\n\nuse clap::Parser;\nuse cli::Cli;\nuse cli::Commands;\nuse florestad::Config;\nuse florestad::Florestad;\n#[cfg(feature = \"zmq-server\")]\nuse zmq::ZMQServer;\n\n#[async_std::main]\nasync fn main() {\n    let params = Cli::parse();\n\n    let config = match params.command {\n        #[cfg(feature = \"experimental-p2p\")]\n        Some(Commands::Run {\n            data_dir,\n            assume_valid,\n            wallet_xpub,\n            wallet_descriptor,\n            rescan,\n            proxy,\n            zmq_address: _zmq_address,\n            cfilters,\n            connect,\n            rpc_address,\n            electrum_address,\n        }) =\u003e Config {\n            data_dir,\n            assume_valid,\n            wallet_xpub,\n            wallet_descriptor,\n            rescan,\n            proxy,\n            config_file: params.config_file,\n            network: params.network,\n            cfilters,\n            #[cfg(feature = \"zmq-server\")]\n            zmq_address: _zmq_address,\n            connect,\n            #[cfg(feature = \"json-rpc\")]\n            json_rpc_address: rpc_address,\n            electrum_address,\n            log_to_file: true,\n            log_to_stdout: true,\n        },\n\n        // We may have more commands here, like setup and dump wallet\n        None =\u003e Config {\n            config_file: params.config_file,\n            network: params.network,\n            cfilters: true,\n            log_to_file: false,\n            log_to_stdout: true,\n            ..Default::default()\n        },\n    };\n\n    let florestad = Florestad::from(config);\n    florestad.start();\n\n    let stop_signal = florestad.get_stop_signal();\n    let _stop_signal = stop_signal.clone();\n\n    ctrlc::set_handler(move || {\n        async_std::task::block_on(async {\n            *(stop_signal.write().await) = true;\n        })\n    })\n    .expect(\"Could not setup ctr+c handler\");\n\n    loop {\n        if *_stop_signal.read().await {\n            florestad.wait_shutdown().await;\n            break;\n        }\n        async_std::task::sleep(Duration::from_secs(5)).await;\n    }\n}\n","traces":[{"line":43,"address":[3350240],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[3350455,3350222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[3350701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[3350984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[3351022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[3350502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[3350548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[3351853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[3351978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[3352113,3352030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[3352131,3352234],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[3352237,3353856,3352349],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":97,"address":[3353904,3354198,3354003,3353971,3353865,3354600,3354040,3353929],"length":1,"stats":{"Line":0},"fn_name":"{async_block#0}"},{"line":98,"address":[3354091,3353964,3353979,3354258,3354030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[3352479,3350333,3352385,3352795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[3352527,3353362,3350354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[3350375,3353257,3352620,3352575],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":17},{"path":["/","home","dane","Desktop","SOB","Floresta","florestad","src","slip132.rs"],"content":"// Based on slip132 from LNP/BP Descriptor Wallet library by:\n//     Dr. Maxim Orlovsky \u003corlovsky@lnp-bp.org\u003e\n//\n// Adapted for Floresta by:\n//     Davidson Sousa \u003cme@dlsouza.lol\u003e\n\n//! Bitcoin SLIP-132 standard implementation for parsing custom xpub/xpriv key\n//! formats\n\n#[cfg(feature = \"strict_encoding\")]\n#[macro_use]\nextern crate strict_encoding;\n\n#[cfg(feature = \"serde\")]\n#[macro_use]\nextern crate serde_crate as serde;\n\nuse std::fmt::Debug;\nuse std::str::FromStr;\n\nuse bitcoin::base58;\nuse bitcoin::bip32;\nuse bitcoin::bip32::Xpriv;\nuse bitcoin::bip32::Xpub;\n\n/// Magical version bytes for xpub: bitcoin mainnet public key for P2PKH or P2SH\npub const VERSION_MAGIC_XPUB: [u8; 4] = [0x04, 0x88, 0xB2, 0x1E];\n/// Magical version bytes for xprv: bitcoin mainnet private key for P2PKH or\n/// P2SH\npub const VERSION_MAGIC_XPRV: [u8; 4] = [0x04, 0x88, 0xAD, 0xE4];\n/// Magical version bytes for ypub: bitcoin mainnet public key for P2WPKH in\n/// P2SH\npub const VERSION_MAGIC_YPUB: [u8; 4] = [0x04, 0x9D, 0x7C, 0xB2];\n/// Magical version bytes for yprv: bitcoin mainnet private key for P2WPKH in\n/// P2SH\npub const VERSION_MAGIC_YPRV: [u8; 4] = [0x04, 0x9D, 0x78, 0x78];\n/// Magical version bytes for zpub: bitcoin mainnet public key for P2WPKH\npub const VERSION_MAGIC_ZPUB: [u8; 4] = [0x04, 0xB2, 0x47, 0x46];\n/// Magical version bytes for zprv: bitcoin mainnet private key for P2WPKH\npub const VERSION_MAGIC_ZPRV: [u8; 4] = [0x04, 0xB2, 0x43, 0x0C];\n/// Magical version bytes for Ypub: bitcoin mainnet public key for\n/// multi-signature P2WSH in P2SH\npub const VERSION_MAGIC_YPUB_MULTISIG: [u8; 4] = [0x02, 0x95, 0xb4, 0x3f];\n/// Magical version bytes for Yprv: bitcoin mainnet private key for\n/// multi-signature P2WSH in P2SH\npub const VERSION_MAGIC_YPRV_MULTISIG: [u8; 4] = [0x02, 0x95, 0xb0, 0x05];\n/// Magical version bytes for Zpub: bitcoin mainnet public key for\n/// multi-signature P2WSH\npub const VERSION_MAGIC_ZPUB_MULTISIG: [u8; 4] = [0x02, 0xaa, 0x7e, 0xd3];\n/// Magical version bytes for Zprv: bitcoin mainnet private key for\n/// multi-signature P2WSH\npub const VERSION_MAGIC_ZPRV_MULTISIG: [u8; 4] = [0x02, 0xaa, 0x7a, 0x99];\n\n/// Magical version bytes for tpub: bitcoin testnet/regtest public key for\n/// P2PKH or P2SH\npub const VERSION_MAGIC_TPUB: [u8; 4] = [0x04, 0x35, 0x87, 0xCF];\n/// Magical version bytes for tprv: bitcoin testnet/regtest private key for\n/// P2PKH or P2SH\npub const VERSION_MAGIC_TPRV: [u8; 4] = [0x04, 0x35, 0x83, 0x94];\n/// Magical version bytes for upub: bitcoin testnet/regtest public key for\n/// P2WPKH in P2SH\npub const VERSION_MAGIC_UPUB: [u8; 4] = [0x04, 0x4A, 0x52, 0x62];\n/// Magical version bytes for uprv: bitcoin testnet/regtest private key for\n/// P2WPKH in P2SH\npub const VERSION_MAGIC_UPRV: [u8; 4] = [0x04, 0x4A, 0x4E, 0x28];\n/// Magical version bytes for vpub: bitcoin testnet/regtest public key for\n/// P2WPKH\npub const VERSION_MAGIC_VPUB: [u8; 4] = [0x04, 0x5F, 0x1C, 0xF6];\n/// Magical version bytes for vprv: bitcoin testnet/regtest private key for\n/// P2WPKH\npub const VERSION_MAGIC_VPRV: [u8; 4] = [0x04, 0x5F, 0x18, 0xBC];\n/// Magical version bytes for Upub: bitcoin testnet/regtest public key for\n/// multi-signature P2WSH in P2SH\npub const VERSION_MAGIC_UPUB_MULTISIG: [u8; 4] = [0x02, 0x42, 0x89, 0xef];\n/// Magical version bytes for Uprv: bitcoin testnet/regtest private key for\n/// multi-signature P2WSH in P2SH\npub const VERSION_MAGIC_UPRV_MULTISIG: [u8; 4] = [0x02, 0x42, 0x85, 0xb5];\n/// Magical version bytes for Zpub: bitcoin testnet/regtest public key for\n/// multi-signature P2WSH\npub const VERSION_MAGIC_VPUB_MULTISIG: [u8; 4] = [0x02, 0x57, 0x54, 0x83];\n/// Magical version bytes for Zprv: bitcoin testnet/regtest private key for\n/// multi-signature P2WSH\npub const VERSION_MAGIC_VPRV_MULTISIG: [u8; 4] = [0x02, 0x57, 0x50, 0x48];\n\n/// Extended public and private key processing errors\n#[derive(Clone, PartialEq, Eq, Debug)]\npub enum Error {\n    /// error in BASE58 key encoding. Details: {0}\n    Base58(base58::Error),\n\n    /// error in hex key encoding. Details: {0}\n    Hex(bitcoin::hashes::hex::HexToArrayError),\n\n    /// pk-\u003epk derivation was attempted on a hardened key.\n    CannotDeriveFromHardenedKey,\n\n    /// child number {0} is out of range.\n    InvalidChildNumber(u32),\n\n    /// invalid child number format.\n    InvalidChildNumberFormat,\n\n    /// invalid derivation path format.\n    InvalidDerivationPathFormat,\n\n    /// unknown version magic bytes {0:#06X?}\n    UnknownVersion([u8; 4]),\n\n    /// encoded extended key data has wrong length {0}\n    WrongExtendedKeyLength(usize),\n\n    /// unrecognized or unsupported extended key prefix (please check SLIP 32\n    /// for possible values)\n    UnknownSlip32Prefix,\n\n    /// failure in rust bitcoin library\n    InternalFailure,\n}\n\n#[cfg(feature = \"strict_encoding\")]\nimpl strict_encoding::StrictEncode for Error {\n    fn strict_encode\u003cE: std::io::Write\u003e(\u0026self, _: E) -\u003e Result\u003cusize, strict_encoding::Error\u003e {\n        unreachable!(\"StrictEncode for slip132::Error is a dummy required by miniscript\")\n    }\n}\n\n#[cfg(feature = \"strict_encoding\")]\nimpl strict_encoding::StrictDecode for Error {\n    fn strict_decode\u003cD: std::io::Read\u003e(_: D) -\u003e Result\u003cSelf, strict_encoding::Error\u003e {\n        unreachable!(\"StrictDecode for slip132::Error is a dummy required by miniscript\")\n    }\n}\n\nimpl From\u003cbip32::Error\u003e for Error {\n    fn from(err: bip32::Error) -\u003e Self {\n        match err {\n            bip32::Error::CannotDeriveFromHardenedKey =\u003e Error::CannotDeriveFromHardenedKey,\n            bip32::Error::InvalidChildNumber(no) =\u003e Error::InvalidChildNumber(no),\n            bip32::Error::InvalidChildNumberFormat =\u003e Error::InvalidChildNumberFormat,\n            bip32::Error::InvalidDerivationPathFormat =\u003e Error::InvalidDerivationPathFormat,\n            bip32::Error::Secp256k1(_) =\u003e Error::InternalFailure,\n            bip32::Error::UnknownVersion(ver) =\u003e Error::UnknownVersion(ver),\n            bip32::Error::WrongExtendedKeyLength(len) =\u003e Error::WrongExtendedKeyLength(len),\n            bip32::Error::Base58(err) =\u003e Error::Base58(err),\n            bip32::Error::Hex(err) =\u003e Error::Hex(err),\n            _ =\u003e Error::InternalFailure,\n        }\n    }\n}\n\nimpl From\u003cbase58::Error\u003e for Error {\n    fn from(err: base58::Error) -\u003e Self {\n        Error::Base58(err)\n    }\n}\n\n/// Structure holding 4 version bytes with magical numbers representing\n/// different versions of extended public and private keys according to BIP-32.\n/// Key version stores raw bytes without their check, interpretation or\n/// verification; for these purposes special helpers structures implementing\n/// [`VersionResolver`] are used.\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\npub struct KeyVersion([u8; 4]);\n\n#[cfg(feature = \"strict_encoding\")]\nimpl strict_encoding::StrictEncode for KeyVersion {\n    fn strict_encode\u003cE: std::io::Write\u003e(\u0026self, mut e: E) -\u003e Result\u003cusize, strict_encoding::Error\u003e {\n        e.write_all(\u0026self.0)?;\n        Ok(4)\n    }\n}\n\n#[cfg(feature = \"strict_encoding\")]\nimpl strict_encoding::StrictDecode for KeyVersion {\n    fn strict_decode\u003cD: std::io::Read\u003e(mut d: D) -\u003e Result\u003cSelf, strict_encoding::Error\u003e {\n        let mut bytes = [0u8; 4];\n        d.read_exact(\u0026mut bytes)?;\n        Ok(Self(bytes))\n    }\n}\n\n/// Default resolver knowing native [`bitcoin::network::constants::Network`]\n/// and BIP 32 and SLIP 132-defined key applications with [`KeyApplication`]\n#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\npub struct DefaultResolver;\n\n/// SLIP 132-defined key applications defining types of scriptPubkey descriptors\n/// in which they can be used\n#[cfg_attr(\n    feature = \"serde\",\n    derive(Serialize, Deserialize),\n    serde(crate = \"serde_crate\")\n)]\n#[cfg_attr(feature = \"strict_encoding\", derive(StrictEncode, StrictDecode))]\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]\n#[non_exhaustive]\npub enum KeyApplication {\n    /// xprv/xpub: keys that can be used for P2PKH and multisig P2SH\n    /// scriptPubkey descriptors.\n    #[cfg_attr(feature = \"serde\", serde(rename = \"bip44\"))]\n    Hashed,\n\n    /// zprv/zpub: keys that can be used for P2WPKH scriptPubkey descriptors\n    #[cfg_attr(feature = \"serde\", serde(rename = \"bip84\"))]\n    SegWit,\n\n    /// Zprv/Zpub: keys that can be used for multisig P2WSH scriptPubkey\n    /// descriptors\n    #[cfg_attr(feature = \"serde\", serde(rename = \"bip48-native\"))]\n    SegWitMultisig,\n\n    /// yprv/ypub: keys that can be used for P2WPKH-in-P2SH scriptPubkey\n    /// descriptors\n    #[cfg_attr(feature = \"serde\", serde(rename = \"bip49\"))]\n    Nested,\n\n    /// Yprv/Ypub: keys that can be used for multisig P2WSH-in-P2SH\n    /// scriptPubkey descriptors\n    #[cfg_attr(feature = \"serde\", serde(rename = \"bip48-nested\"))]\n    NestedMultisig,\n}\n\n/// Unknown string representation of [`KeyApplication`] enum\n#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\npub struct UnknownKeyApplicationError;\n\nimpl FromStr for KeyApplication {\n    type Err = UnknownKeyApplicationError;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        Ok(match s.to_lowercase().as_str() {\n            \"bip44\" =\u003e KeyApplication::Hashed,\n            \"bip84\" =\u003e KeyApplication::SegWit,\n            \"bip48-native\" =\u003e KeyApplication::SegWitMultisig,\n            \"bip49\" =\u003e KeyApplication::Nested,\n            \"bip48-nested\" =\u003e KeyApplication::NestedMultisig,\n            _ =\u003e return Err(UnknownKeyApplicationError),\n        })\n    }\n}\n\n/// Trait for building standard BIP32 extended keys from SLIP132 variant.\npub trait FromSlip132 {\n    /// Constructs standard BIP32 extended key from SLIP132 string.\n    fn from_slip132_str(s: \u0026str) -\u003e Result\u003cSelf, Error\u003e\n    where\n        Self: Sized;\n}\n\nimpl FromSlip132 for Xpub {\n    fn from_slip132_str(s: \u0026str) -\u003e Result\u003cSelf, Error\u003e {\n        let mut data = base58::decode_check(s)?;\n\n        let mut prefix = [0u8; 4];\n        prefix.copy_from_slice(\u0026data[0..4]);\n        let slice = match prefix {\n            VERSION_MAGIC_XPUB\n            | VERSION_MAGIC_YPUB\n            | VERSION_MAGIC_ZPUB\n            | VERSION_MAGIC_YPUB_MULTISIG\n            | VERSION_MAGIC_ZPUB_MULTISIG =\u003e VERSION_MAGIC_XPUB,\n\n            VERSION_MAGIC_TPUB\n            | VERSION_MAGIC_UPUB\n            | VERSION_MAGIC_VPUB\n            | VERSION_MAGIC_UPUB_MULTISIG\n            | VERSION_MAGIC_VPUB_MULTISIG =\u003e VERSION_MAGIC_TPUB,\n\n            _ =\u003e return Err(Error::UnknownSlip32Prefix),\n        };\n        data[0..4].copy_from_slice(\u0026slice);\n\n        let xpub = Xpub::decode(\u0026data)?;\n\n        Ok(xpub)\n    }\n}\n\nimpl FromSlip132 for Xpriv {\n    fn from_slip132_str(s: \u0026str) -\u003e Result\u003cSelf, Error\u003e {\n        let mut data = base58::decode_check(s)?;\n\n        let mut prefix = [0u8; 4];\n        prefix.copy_from_slice(\u0026data[0..4]);\n        let slice = match prefix {\n            VERSION_MAGIC_XPRV\n            | VERSION_MAGIC_YPRV\n            | VERSION_MAGIC_ZPRV\n            | VERSION_MAGIC_YPRV_MULTISIG\n            | VERSION_MAGIC_ZPRV_MULTISIG =\u003e VERSION_MAGIC_XPRV,\n\n            VERSION_MAGIC_TPRV\n            | VERSION_MAGIC_UPRV\n            | VERSION_MAGIC_VPRV\n            | VERSION_MAGIC_UPRV_MULTISIG\n            | VERSION_MAGIC_VPRV_MULTISIG =\u003e VERSION_MAGIC_TPRV,\n\n            _ =\u003e return Err(Error::UnknownSlip32Prefix),\n        };\n        data[0..4].copy_from_slice(\u0026slice);\n\n        let xprv = Xpriv::decode(\u0026data)?;\n\n        Ok(xprv)\n    }\n}\n","traces":[{"line":135,"address":[3195744],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":136,"address":[3195759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[3195836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[3195875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[3195902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[3195919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[3195853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[3195941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[3195977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[3196009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[3196064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[3195819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[3196128],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":153,"address":[3196131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[3196576,3196160],"length":1,"stats":{"Line":0},"fn_name":"from_str"},{"line":231,"address":[3196555,3196266,3196180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[3196282,3196348],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[3196401,3196325,3196362],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[3196454,3196378,3196415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[3196431,3196465,3196504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[3196481,3196515,3196539],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[3196521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[4663008,4664367],"length":1,"stats":{"Line":3},"fn_name":"from_slip132_str"},{"line":252,"address":[4663041,4663248],"length":1,"stats":{"Line":3},"fn_name":null},{"line":254,"address":[4663159],"length":1,"stats":{"Line":3},"fn_name":null},{"line":255,"address":[4663353,4663170],"length":1,"stats":{"Line":6},"fn_name":null},{"line":256,"address":[4663761,4663479,4664032,4663384,4663823],"length":1,"stats":{"Line":8},"fn_name":null},{"line":257,"address":[4663743],"length":1,"stats":{"Line":4},"fn_name":null},{"line":263,"address":[4663805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[4663420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[4663959,4664080],"length":1,"stats":{"Line":7},"fn_name":null},{"line":273,"address":[4664352,4664111,4664285],"length":1,"stats":{"Line":3},"fn_name":null},{"line":275,"address":[4664249],"length":1,"stats":{"Line":3},"fn_name":null},{"line":280,"address":[4665755,4664400],"length":1,"stats":{"Line":0},"fn_name":"from_slip132_str"},{"line":281,"address":[4664640,4664433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[4664551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[4664745,4664562],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[4665153,4664776,4665424,4664871,4665215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[4665135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[4665197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[4664812],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[4665351,4665472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[4665740,4665673,4665503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[4665637],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":9,"coverable":51},{"path":["/","home","dane","Desktop","SOB","Floresta","florestad","src","wallet_input.rs"],"content":"//!\n//! Handles different inputs, try to make sense out of it and store a sane descriptor at the end\n\nuse std::str::FromStr;\n\nuse bitcoin::Address;\nuse miniscript::Descriptor;\nuse miniscript::DescriptorPublicKey;\n\npub mod extended_pub_key {\n    use bitcoin::bip32::Xpub;\n\n    use crate::slip132;\n\n    pub fn from_str(s: \u0026str) -\u003e Result\u003cXpub, slip132::Error\u003e {\n        slip132::FromSlip132::from_slip132_str(s)\n    }\n}\n\nfn parse_xpubs(\n    xpubs: \u0026[String],\n) -\u003e Result\u003cVec\u003cDescriptor\u003cDescriptorPublicKey\u003e\u003e, crate::error::Error\u003e {\n    let mut descriptors = Vec::new();\n    for key in xpubs {\n        // Parses the descriptor and get an external and change descriptors\n        let xpub = extended_pub_key::from_str(key.as_str()).map_err(|e| {\n            log::error!(\"Invalid xpub provided: {key} \\nReason: {e:?}\");\n            e\n        })?;\n        let main_desc = format!(\"wpkh({xpub}/0/*)\");\n        let change_desc = format!(\"wpkh({xpub}/1/*)\");\n        descriptors.push(Descriptor::\u003cDescriptorPublicKey\u003e::from_str(\u0026main_desc)?);\n        descriptors.push(Descriptor::\u003cDescriptorPublicKey\u003e::from_str(\u0026change_desc)?);\n    }\n    Ok(descriptors)\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub(crate) struct InitialWalletSetup {\n    pub(crate) descriptors: Vec\u003cDescriptor\u003cDescriptorPublicKey\u003e\u003e,\n    pub(crate) addresses: Vec\u003cAddress\u003e,\n}\n\nimpl InitialWalletSetup {\n    pub(crate) fn build(\n        xpubs: \u0026[String],\n        initial_descriptors: \u0026[String],\n        addresses: \u0026[String],\n        network: bitcoin::Network,\n        addresses_per_descriptor: u32,\n    ) -\u003e Result\u003cSelf, crate::error::Error\u003e {\n        let mut descriptors = parse_xpubs(xpubs)?;\n        descriptors.extend(parse_descriptors(initial_descriptors)?);\n        descriptors.sort();\n        descriptors.dedup();\n        let mut addresses = addresses\n            .iter()\n            .flat_map(|address| match Address::from_str(address) {\n                Ok(address) =\u003e Ok(address.require_network(network)),\n                Err(e) =\u003e {\n                    log::error!(\"Invalid address provided: {address} \\nReason: {e:?}\");\n                    Err(e)\n                }\n            })\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n        addresses.extend(descriptors.iter().flat_map(|descriptor| {\n            (0..addresses_per_descriptor).map(|index| {\n                descriptor\n                    .at_derivation_index(index)\n                    .expect(\"Error while deriving address\")\n                    .address(network)\n                    .expect(\"Error while deriving address. Is this an active descriptor?\")\n            })\n        }));\n        addresses.sort();\n        addresses.dedup();\n        Ok(Self {\n            descriptors,\n            addresses,\n        })\n    }\n}\n\npub fn parse_descriptors(\n    descriptors: \u0026[String],\n) -\u003e Result\u003cVec\u003cDescriptor\u003cDescriptorPublicKey\u003e\u003e, crate::error::Error\u003e {\n    let descriptors = descriptors\n        .iter()\n        .map(|descriptor| {\n            let descriptor = Descriptor::\u003cDescriptorPublicKey\u003e::from_str(descriptor.as_str())?;\n            descriptor.sanity_check()?;\n            descriptor.into_single_descriptors()\n        })\n        .collect::\u003cResult\u003cVec\u003cVec\u003c_\u003e\u003e, _\u003e\u003e()?\n        .into_iter()\n        .flatten()\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    Ok(descriptors)\n}\n\n#[cfg(test)]\npub mod test {\n    use bitcoin::bip32::ChildNumber;\n    use bitcoin::secp256k1::Secp256k1;\n    use bitcoin::Network;\n\n    use super::*;\n\n    #[test]\n    fn test_xpub_parsing() {\n        // Test cases from https://github.com/satoshilabs/slips/blob/master/slip-0132.md\n        const XPUB: \u0026str = \"xpub6BosfCnifzxcFwrSzQiqu2DBVTshkCXacvNsWGYJVVhhawA7d4R5WSWGFNbi8Aw6ZRc1brxMyWMzG3DSSSSoekkudhUd9yLb6qx39T9nMdj\";\n        const YPUB: \u0026str = \"ypub6Ww3ibxVfGzLrAH1PNcjyAWenMTbbAosGNB6VvmSEgytSER9azLDWCxoJwW7Ke7icmizBMXrzBx9979FfaHxHcrArf3zbeJJJUZPf663zsP\";\n        const ZPUB: \u0026str = \"zpub6rFR7y4Q2AijBEqTUquhVz398htDFrtymD9xYYfG1m4wAcvPhXNfE3EfH1r1ADqtfSdVCToUG868RvUUkgDKf31mGDtKsAYz2oz2AGutZYs\";\n\n        let secp = Secp256k1::new();\n\n        let xpub: bitcoin::bip32::Xpub = super::extended_pub_key::from_str(XPUB)\n            .expect(\"Parsing failed\")\n            .ckd_pub(\u0026secp, ChildNumber::Normal { index: 0 })\n            .and_then(|key| key.ckd_pub(\u0026secp, ChildNumber::Normal { index: 0 }))\n            .unwrap();\n        let ypub = super::extended_pub_key::from_str(YPUB)\n            .expect(\"Parsing failed\")\n            .ckd_pub(\u0026secp, ChildNumber::Normal { index: 0 })\n            .and_then(|key| key.ckd_pub(\u0026secp, ChildNumber::Normal { index: 0 }))\n            .unwrap();\n        let zpub = super::extended_pub_key::from_str(ZPUB)\n            .expect(\"Parsing failed\")\n            .ckd_pub(\u0026secp, ChildNumber::Normal { index: 0 })\n            .and_then(|key| key.ckd_pub(\u0026secp, ChildNumber::Normal { index: 0 }))\n            .unwrap();\n        // Old p2pkh\n        assert_eq!(\n            Address::p2pkh(\u0026xpub.to_pub(), bitcoin::Network::Bitcoin)\n                .to_string()\n                .as_str(),\n            \"1LqBGSKuX5yYUonjxT5qGfpUsXKYYWeabA\"\n        );\n        // p2wpkh-p2pkh\n        let script = Address::p2wpkh(\u0026ypub.to_pub(), bitcoin::Network::Bitcoin)\n            .unwrap()\n            .script_pubkey();\n\n        assert_eq!(\n            Address::p2sh(\u0026script, Network::Bitcoin)\n                .unwrap()\n                .to_string()\n                .as_str(),\n            \"37VucYSaXLCAsxYyAPfbSi9eh4iEcbShgf\"\n        );\n\n        // p2wpkh\n        assert_eq!(\n            Address::p2wpkh(\u0026zpub.to_pub(), bitcoin::Network::Bitcoin)\n                .unwrap()\n                .to_string()\n                .as_str(),\n            \"bc1qcr8te4kr609gcawutmrza0j4xv80jy8z306fyu\"\n        )\n    }\n\n    #[test]\n    fn test_descriptor_parsing() {\n        // singlesig\n        assert_eq!(\n            parse_descriptors(\u0026[\n                \"wpkh([a5b13c0e/84h/0h/0h]xpub6CFy3kRXorC3NMTt8qrsY9ucUfxVLXyFQ49JSLm3iEG5gfAmWewYFzjNYFgRiCjoB9WWEuJQiyYGCdZvUTwPEUPL9pPabT8bkbiD9Po47XG/\u003c0;1\u003e/*)#n8sgapuv\".to_owned()\n            ]).unwrap(),\n            parse_descriptors(\u0026[\n                \"wpkh([a5b13c0e/84'/0'/0']xpub6CFy3kRXorC3NMTt8qrsY9ucUfxVLXyFQ49JSLm3iEG5gfAmWewYFzjNYFgRiCjoB9WWEuJQiyYGCdZvUTwPEUPL9pPabT8bkbiD9Po47XG/0/*)#wg8dh3s7\".to_owned(),\n                \"wpkh([a5b13c0e/84'/0'/0']xpub6CFy3kRXorC3NMTt8qrsY9ucUfxVLXyFQ49JSLm3iEG5gfAmWewYFzjNYFgRiCjoB9WWEuJQiyYGCdZvUTwPEUPL9pPabT8bkbiD9Po47XG/1/*)#luzv2yqx\".to_owned()\n            ]).unwrap()\n        );\n        // multisig\n        assert_eq!(\n            parse_descriptors(\u0026[\n                \"wsh(sortedmulti(1,[6f826a6a/48h/0h/0h/2h]xpub6DsY48BAsvEMTRPbeSTu9jZXqEsTKr5T86WbRbXHp2gEVCNR3hALnMorFawVwnnHMMfjbyY8We9B4beh1fxqhcv6kgSeLgQxeXDqv3DaW7m/\u003c0;1\u003e/*,[a5b13c0e/48h/0h/0h/2h]xpub6Eqj1Hj3RezebC6cKiYYN2sAc1Wu33BWoaafnNgAbQwDkJdy7aXCYCmaMzb8rCpmh919UsehyV5Ywjo62hG4R2G2PGv4uqEDTUhYQw26BDJ/\u003c0;1\u003e/*))#nykmcu2v\".to_owned()\n            ]).unwrap(),\n            parse_descriptors(\u0026[\n                \"wsh(sortedmulti(1,[6f826a6a/48'/0'/0'/2']xpub6DsY48BAsvEMTRPbeSTu9jZXqEsTKr5T86WbRbXHp2gEVCNR3hALnMorFawVwnnHMMfjbyY8We9B4beh1fxqhcv6kgSeLgQxeXDqv3DaW7m/0/*,[a5b13c0e/48'/0'/0'/2']xpub6Eqj1Hj3RezebC6cKiYYN2sAc1Wu33BWoaafnNgAbQwDkJdy7aXCYCmaMzb8rCpmh919UsehyV5Ywjo62hG4R2G2PGv4uqEDTUhYQw26BDJ/0/*))#sw68w95x\".to_owned(),\n                \"wsh(sortedmulti(1,[6f826a6a/48'/0'/0'/2']xpub6DsY48BAsvEMTRPbeSTu9jZXqEsTKr5T86WbRbXHp2gEVCNR3hALnMorFawVwnnHMMfjbyY8We9B4beh1fxqhcv6kgSeLgQxeXDqv3DaW7m/1/*,[a5b13c0e/48'/0'/0'/2']xpub6Eqj1Hj3RezebC6cKiYYN2sAc1Wu33BWoaafnNgAbQwDkJdy7aXCYCmaMzb8rCpmh919UsehyV5Ywjo62hG4R2G2PGv4uqEDTUhYQw26BDJ/1/*))#fafrqkpn\".to_owned()\n            ]).unwrap()\n        );\n    }\n\n    #[test]\n    fn test_initial_wallet_build() {\n        use pretty_assertions::assert_eq;\n        let addresses_per_descriptor = 1;\n        let network = Network::Bitcoin;\n        // Build wallet from xpub (in this case a zpub from slip132 standard)\n        let w1_xpub = InitialWalletSetup::build(\u0026[\n            \"zpub6qvVf5mN7DH14wr7oZS7xL6cpcFPDmxFEHBk18YpUF1qnroE1yGfW83eafbbi23dzRk7jrVXeJFMyCo3urmQpwkXtVnRmGmaJ3qVvdwx4mB\".to_owned()\n        ], \u0026[], \u0026[], network, addresses_per_descriptor).unwrap();\n        // Build same wallet from output descriptor\n        let w1_descriptor = InitialWalletSetup::build(\u0026[], \u0026[\n            \"wpkh(xpub6CFy3kRXorC3NMTt8qrsY9ucUfxVLXyFQ49JSLm3iEG5gfAmWewYFzjNYFgRiCjoB9WWEuJQiyYGCdZvUTwPEUPL9pPabT8bkbiD9Po47XG/\u003c0;1\u003e/*)\".to_owned()\n        ], \u0026[], network, addresses_per_descriptor).unwrap();\n        // Using both methods the result should be the same\n        assert_eq!(w1_xpub, w1_descriptor);\n        // Both normal receiving descriptor and change descriptor should be present\n        assert_eq!(\n            w1_descriptor.descriptors\n                .iter()\n                .map(ToString::to_string)\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            vec![\n                \"wpkh(xpub6CFy3kRXorC3NMTt8qrsY9ucUfxVLXyFQ49JSLm3iEG5gfAmWewYFzjNYFgRiCjoB9WWEuJQiyYGCdZvUTwPEUPL9pPabT8bkbiD9Po47XG/0/*)#qua4l7ct\",\n                \"wpkh(xpub6CFy3kRXorC3NMTt8qrsY9ucUfxVLXyFQ49JSLm3iEG5gfAmWewYFzjNYFgRiCjoB9WWEuJQiyYGCdZvUTwPEUPL9pPabT8bkbiD9Po47XG/1/*)#3gc5ztgn\"\n            ]\n        );\n        // Receiving and change addresses\n        let addresses = vec![\n            \"bc1q88guum89mxwszau37m3y4p24renwlwgtkscl6x\".to_owned(),\n            \"bc1q24629yendf7q0dxnw362dqccn52vuz9s0z59hr\".to_owned(),\n        ];\n        assert_eq!(\n            w1_descriptor\n                .addresses\n                .iter()\n                .map(ToString::to_string)\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            addresses\n        );\n        // We can build from these addresses\n        let w1_addresses =\n            InitialWalletSetup::build(\u0026[], \u0026[], \u0026addresses, network, addresses_per_descriptor)\n                .unwrap();\n        // And the result will be the same as from xpub/descriptor\n        assert_eq!(w1_descriptor.addresses, w1_addresses.addresses);\n        // We can also build from xpub, descriptor and addresses, at same time\n        let w1_all =\n            InitialWalletSetup::build(\u0026[\n                \"zpub6qvVf5mN7DH14wr7oZS7xL6cpcFPDmxFEHBk18YpUF1qnroE1yGfW83eafbbi23dzRk7jrVXeJFMyCo3urmQpwkXtVnRmGmaJ3qVvdwx4mB\".to_owned()\n            ], \u0026[\n                \"wpkh(xpub6CFy3kRXorC3NMTt8qrsY9ucUfxVLXyFQ49JSLm3iEG5gfAmWewYFzjNYFgRiCjoB9WWEuJQiyYGCdZvUTwPEUPL9pPabT8bkbiD9Po47XG/\u003c0;1\u003e/*)\".to_owned()\n            ], \u0026addresses, network, addresses_per_descriptor).unwrap();\n        // And the result should be the same, no duplication will happen\n        assert_eq!(w1_descriptor, w1_all);\n    }\n\n    #[test]\n    fn test_initial_wallet_build_multisig_testnet() {\n        use pretty_assertions::assert_eq;\n        let addresses_per_descriptor = 1;\n        let network = Network::Testnet;\n        let w1_descriptor = InitialWalletSetup::build(\u0026[], \u0026[\n            \"wsh(sortedmulti(1,[54ff5a12/48h/1h/0h/2h]tpubDDw6pwZA3hYxcSN32q7a5ynsKmWr4BbkBNHydHPKkM4BZwUfiK7tQ26h7USm8kA1E2FvCy7f7Er7QXKF8RNptATywydARtzgrxuPDwyYv4x/\u003c0;1\u003e/*,[bcf969c0/48h/1h/0h/2h]tpubDEFdgZdCPgQBTNtGj4h6AehK79Jm4LH54JrYBJjAtHMLEAth7LuY87awx9ZMiCURFzFWhxToRJK6xp39aqeJWrG5nuW3eBnXeMJcvDeDxfp/\u003c0;1\u003e/*))#fuw35j0q\".to_owned()\n        ], \u0026[], network, addresses_per_descriptor).unwrap();\n        let addresses = vec![\n            \"tb1q2eeqw57e7pmrh5w3wkrshctx2qk80vf4mu7l7ek3ne4hg3lmcrnqcwejgj\".to_owned(),\n            \"tb1q6dpyc3jyqelgfwksedef0k2244rcg4gf6wvqm463lk907es2m08qnrfky7\".to_owned(),\n        ];\n        assert_eq!(\n            w1_descriptor\n                .addresses\n                .iter()\n                .map(ToString::to_string)\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            addresses\n        );\n    }\n}\n","traces":[{"line":15,"address":[6877152],"length":1,"stats":{"Line":2},"fn_name":"from_str"},{"line":16,"address":[5768549],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[4244503,4242560,4244490],"length":1,"stats":{"Line":3},"fn_name":"parse_xpubs"},{"line":23,"address":[4242606],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[4242895,4242719,4242636],"length":1,"stats":{"Line":8},"fn_name":null},{"line":26,"address":[3180208],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":27,"address":[3180483,3180234,3180337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[3180279],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[4243444],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[4243685],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[4243876,4243805,4244450],"length":1,"stats":{"Line":4},"fn_name":null},{"line":33,"address":[4244125,4244429],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[4242806],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[4244528,4245933,4245964],"length":1,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[4244783,4244635],"length":1,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[4244776,4244899,4245962],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[4245096],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[4245150],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[4245167,4245450,4245214,4245944],"length":1,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[3180611,3180576],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":59,"address":[3180657],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[3180725],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[3180938,3180764,3181100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[3180821],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[3181216],"length":1,"stats":{"Line":8},"fn_name":"{closure#1}"},{"line":67,"address":[3181238,3181540,3181312],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":68,"address":[3181427,3181349,3181485],"length":1,"stats":{"Line":9},"fn_name":null},{"line":71,"address":[3181423],"length":1,"stats":{"Line":3},"fn_name":null},{"line":75,"address":[4245646],"length":1,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[4245686],"length":1,"stats":{"Line":3},"fn_name":null},{"line":77,"address":[4245794],"length":1,"stats":{"Line":3},"fn_name":null},{"line":78,"address":[4245698],"length":1,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[4245746],"length":1,"stats":{"Line":3},"fn_name":null},{"line":84,"address":[4245984],"length":1,"stats":{"Line":2},"fn_name":"parse_descriptors"},{"line":87,"address":[4246043,4246348],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[3182162,3182193,3181568],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":90,"address":[3181796,3181614],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[3182014,3181898,3181598,3181777],"length":1,"stats":{"Line":6},"fn_name":null},{"line":92,"address":[3181950],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[4246237],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":35,"coverable":40},{"path":["/","home","dane","Desktop","SOB","Floresta","florestad","src","zmq.rs"],"content":"use bitcoin::consensus::serialize;\n/// A small Zero Message Queue (ZMQ) implementation for floresta, that pushes new blocks\n/// as they are found.\n///\n/// # Examples\n/// Creating a server\n/// ```\n/// use florestad::zmq::ZMQServer;\n/// let _ = ZMQServer::new(\"tcp://127.0.0.1:5150\");\n/// ```\n///\n/// Listening for new blocks\n///\n/// ```!\n/// use zmq::{Context, Socket};\n/// let ctx =  Context::new();\n/// // The oposite of PUSH is PULL\n/// let socket = ctx.socket(zmq::SocketType::PULL).unwrap();\n///\n/// socket.connect(addr).unwrap();\n/// let block = socket.recv().unwrap();\n/// ```\nuse floresta_chain::BlockConsumer;\nuse zmq::Context;\nuse zmq::Socket;\n\n/// A 0MQ server that pushes blocks when we receive them\npub struct ZMQServer {\n    /// The ZMQ context that holds our socket. We don't really need it,\n    /// but if _ctx gets dropped, the socket is closed, so we keep it here.\n    _ctx: Context,\n    /// The actual socket where we'll send blocks\n    socket: Socket,\n}\n\n/// # Safety\n/// We only keep one reference of ZMQServer, usually inside an [std::sync::Arc], so it's ok\n/// to assume it can be [Sync].\nunsafe impl Sync for ZMQServer {}\n\nimpl ZMQServer {\n    /// Creates a new ZMQ server that listens on `addr` and pushes blocks\n    /// to connected peers as they are accepted\n    pub fn new(addr: \u0026str) -\u003e Result\u003cZMQServer, zmq::Error\u003e {\n        let ctx = Context::new();\n        let socket = ctx.socket(zmq::SocketType::PUSH)?;\n        socket.bind(addr)?;\n        Ok(ZMQServer { _ctx: ctx, socket })\n    }\n}\n\n// Implement BlockConsumer so we can subscribe on `ChainState`\nimpl BlockConsumer for ZMQServer {\n    fn consume_block(\u0026self, block: \u0026bitcoin::Block, _height: u32) {\n        let block = serialize(\u0026block);\n        if let Err(e) = self.socket.send(block, zmq::DONTWAIT) {\n            log::error!(\"while sending block over zmq: {e}\");\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>